if (!String.prototype.trim) {
    (String.prototype.trim) = function () {
        return this.replace(/^\s+|\s+$/g, '');
    };
}
if (!Array.prototype.indexOf) {
    (Array.prototype.indexOf) = function (searchElement, fromIndex) {
        "use strict";
        if (this == null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
            return -1;
        }
        var n = 0;
        if (arguments.length > 0) {
            n = Number(arguments[1]);
            if (n != n) {
                n = 0;
            } else if (n != 0 && n != Infinity && n != -Infinity) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }
        if (n >= len) {
            return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for(; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }
        return -1;
    };
}
if (!Array.prototype.filter) {
    (Array.prototype.filter) = function (fun, thisp) {
        "use strict";
        if (this == null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun != "function") {
            throw new TypeError();
        }
        var res = [];
        for(var i = 0; i < len; i++) {
            if (i in t) {
                var val = t[i];
                if (fun.call(thisp, val, i, t)) {
                    res.push(val);
                }
            }
        }
        return res;
    };
}
if (!Array.prototype.map) {
    (Array.prototype.map) = function (callback, thisArg) {
        var T = undefined, A, k;
        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }
        var O = Object(this);
        var len = O.length >>> 0;
        if ({}.toString.call(callback) != "[object Function]") {
            throw new TypeError(callback + " is not a function");
        }
        if (thisArg) {
            T = thisArg;
        }
        A = new Array(len);
        k = 0;
        while(k < len) {
            var kValue, mappedValue;
            if (k in O) {
                kValue = O[k];
                mappedValue = callback.call(T, kValue, k, O);
                A[k] = mappedValue;
            }
            k++;
        }
        return A;
    };
}
if (!Array.prototype.reduce) {
    (Array.prototype.reduce) = function reduce(accumulator) {
        if (this === null || this === undefined) {
            throw new TypeError("Object is null or undefined");
        }
        var i = 0, l = this.length >> 0, curr;
        if (typeof accumulator !== "function") {
            throw new TypeError("First argument is not callable");
        }
        if (arguments.length < 2) {
            if (l === 0) {
                throw new TypeError("Array length is 0 and no second argument");
            }
            curr = this[0];
            i = 1;
        } else {
            curr = arguments[1];
        }
        while(i < l) {
            if (i in this) {
                curr = accumulator.call(undefined, curr, this[i], i, this);
            }
            ++i;
        }
        return curr;
    };
}
if (!Array.prototype.forEach) {
    (Array.prototype.forEach) = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }
        var O = Object(this);
        var len = O.length >>> 0;
        if ({}.toString.call(callback) != "[object Function]") {
            throw new TypeError(callback + " is not a function");
        }
        if (thisArg) {
            T = thisArg;
        } else {
            T = undefined;
        }
        k = 0;
        while(k < len) {
            var kValue;
            if (k in O) {
                kValue = O[k];
                callback.call(T, kValue, k, O);
            }
            k++;
        }
    };
}
if (!Date.now) {
    (Date).now = function () {
        return (new Date()).getTime();
    };
}
if (!Array.prototype.some) {
    (Array.prototype.some) = function (fun) {
        "use strict";
        if (this == null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun != "function") {
            throw new TypeError();
        }
        var thisp = arguments[1];
        for(var i = 0; i < len; i++) {
            var idx = i.toString();
            if (idx in t && fun.call(thisp, t[i], i, t)) {
                return true;
            }
        }
        return false;
    };
}
var TypeScript;
(function (TypeScript) {
    (function (CompilerDiagnostics) {
        CompilerDiagnostics.debug = false;
        CompilerDiagnostics.diagnosticWriter = null;
        CompilerDiagnostics.analysisPass = 0;
        function Alert(output) {
            if (CompilerDiagnostics.diagnosticWriter) {
                CompilerDiagnostics.diagnosticWriter.Alert(output);
            }
        }
        CompilerDiagnostics.Alert = Alert;
        function debugPrint(s) {
            if (CompilerDiagnostics.debug) {
                Alert(s);
            }
        }
        CompilerDiagnostics.debugPrint = debugPrint;
        function assert(condition, s) {
            if (CompilerDiagnostics.debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }
        CompilerDiagnostics.assert = assert;
    })(TypeScript.CompilerDiagnostics || (TypeScript.CompilerDiagnostics = {}));
    var CompilerDiagnostics = TypeScript.CompilerDiagnostics;
    var NullLogger = (function () {
        function NullLogger() { }
        NullLogger.prototype.information = function () {
            return false;
        };
        NullLogger.prototype.debug = function () {
            return false;
        };
        NullLogger.prototype.warning = function () {
            return false;
        };
        NullLogger.prototype.error = function () {
            return false;
        };
        NullLogger.prototype.fatal = function () {
            return false;
        };
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;    
    var LoggerAdapter = (function () {
        function LoggerAdapter(logger) {
            this.logger = logger;
            this._information = this.logger.information();
            this._debug = this.logger.debug();
            this._warning = this.logger.warning();
            this._error = this.logger.error();
            this._fatal = this.logger.fatal();
        }
        LoggerAdapter.prototype.information = function () {
            return this._information;
        };
        LoggerAdapter.prototype.debug = function () {
            return this._debug;
        };
        LoggerAdapter.prototype.warning = function () {
            return this._warning;
        };
        LoggerAdapter.prototype.error = function () {
            return this._error;
        };
        LoggerAdapter.prototype.fatal = function () {
            return this._fatal;
        };
        LoggerAdapter.prototype.log = function (s) {
            this.logger.log(s);
        };
        return LoggerAdapter;
    })();
    TypeScript.LoggerAdapter = LoggerAdapter;    
    var BufferedLogger = (function () {
        function BufferedLogger() {
            this.logContents = [];
        }
        BufferedLogger.prototype.information = function () {
            return false;
        };
        BufferedLogger.prototype.debug = function () {
            return false;
        };
        BufferedLogger.prototype.warning = function () {
            return false;
        };
        BufferedLogger.prototype.error = function () {
            return false;
        };
        BufferedLogger.prototype.fatal = function () {
            return false;
        };
        BufferedLogger.prototype.log = function (s) {
            this.logContents.push(s);
        };
        return BufferedLogger;
    })();
    TypeScript.BufferedLogger = BufferedLogger;    
    function timeFunction(logger, funcDescription, func) {
        var start = (new Date()).getTime();
        var result = func();
        var end = (new Date()).getTime();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }
    TypeScript.timeFunction = timeFunction;
    function stringToLiteral(value, length) {
        var result = "";
        var addChar = function (index) {
            var ch = value.charCodeAt(index);
            switch(ch) {
                case 0x09:
                    result += "\\t";
                    break;
                case 0x0a:
                    result += "\\n";
                    break;
                case 0x0b:
                    result += "\\v";
                    break;
                case 0x0c:
                    result += "\\f";
                    break;
                case 0x0d:
                    result += "\\r";
                    break;
                case 0x22:
                    result += "\\\"";
                    break;
                case 0x27:
                    result += "\\\'";
                    break;
                case 0x5c:
                    result += "\\";
                    break;
                default:
                    result += value.charAt(index);
            }
        };
        var tooLong = (value.length > length);
        if (tooLong) {
            var mid = length >> 1;
            for(var i = 0; i < mid; i++) {
                addChar(i);
            }
            result += "(...)";
            for(var i = value.length - mid; i < value.length; i++) {
                addChar(i);
            }
        } else {
            length = value.length;
            for(var i = 0; i < length; i++) {
                addChar(i);
            }
        }
        return result;
    }
    TypeScript.stringToLiteral = stringToLiteral;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function hasFlag(val, flag) {
        return (val & flag) !== 0;
    }
    TypeScript.hasFlag = hasFlag;
    function withoutFlag(val, flag) {
        return val & ~flag;
    }
    TypeScript.withoutFlag = withoutFlag;
    (function (ASTFlags) {
        ASTFlags._map = [];
        ASTFlags.None = 0;
        ASTFlags.StrictMode = 1 << 1;
        ASTFlags.OptionalName = 1 << 2;
        ASTFlags.TypeReference = 1 << 3;
        ASTFlags.EnumInitializer = 1 << 4;
    })(TypeScript.ASTFlags || (TypeScript.ASTFlags = {}));
    var ASTFlags = TypeScript.ASTFlags;
    (function (DeclFlags) {
        DeclFlags._map = [];
        DeclFlags.None = 0;
        DeclFlags.Exported = 1;
        DeclFlags.Private = 1 << 1;
        DeclFlags.Public = 1 << 2;
        DeclFlags.Ambient = 1 << 3;
        DeclFlags.Static = 1 << 4;
    })(TypeScript.DeclFlags || (TypeScript.DeclFlags = {}));
    var DeclFlags = TypeScript.DeclFlags;
    (function (ModuleFlags) {
        ModuleFlags._map = [];
        ModuleFlags.None = 0;
        ModuleFlags.Exported = 1;
        ModuleFlags.Private = 1 << 1;
        ModuleFlags.Public = 1 << 2;
        ModuleFlags.Ambient = 1 << 3;
        ModuleFlags.Static = 1 << 4;
        ModuleFlags.IsEnum = 1 << 7;
        ModuleFlags.IsWholeFile = 1 << 8;
        ModuleFlags.IsDynamic = 1 << 9;
    })(TypeScript.ModuleFlags || (TypeScript.ModuleFlags = {}));
    var ModuleFlags = TypeScript.ModuleFlags;
    (function (SymbolFlags) {
        SymbolFlags._map = [];
        SymbolFlags.None = 0;
        SymbolFlags.Exported = 1;
        SymbolFlags.Private = 1 << 1;
        SymbolFlags.Public = 1 << 2;
        SymbolFlags.Ambient = 1 << 3;
        SymbolFlags.Static = 1 << 4;
        SymbolFlags.Property = 1 << 7;
        SymbolFlags.ModuleMember = 1 << 8;
        SymbolFlags.InterfaceMember = 1 << 9;
        SymbolFlags.ClassMember = 1 << 10;
        SymbolFlags.BuiltIn = 1 << 11;
        SymbolFlags.TypeSetDuringScopeAssignment = 1 << 12;
        SymbolFlags.Constant = 1 << 13;
        SymbolFlags.Optional = 1 << 14;
        SymbolFlags.RecursivelyReferenced = 1 << 15;
        SymbolFlags.Bound = 1 << 16;
        SymbolFlags.CompilerGenerated = 1 << 17;
    })(TypeScript.SymbolFlags || (TypeScript.SymbolFlags = {}));
    var SymbolFlags = TypeScript.SymbolFlags;
    (function (VariableFlags) {
        VariableFlags._map = [];
        VariableFlags.None = 0;
        VariableFlags.Exported = 1;
        VariableFlags.Private = 1 << 1;
        VariableFlags.Public = 1 << 2;
        VariableFlags.Ambient = 1 << 3;
        VariableFlags.Static = 1 << 4;
        VariableFlags.Property = 1 << 8;
        VariableFlags.ClassProperty = 1 << 11;
        VariableFlags.Constant = 1 << 12;
    })(TypeScript.VariableFlags || (TypeScript.VariableFlags = {}));
    var VariableFlags = TypeScript.VariableFlags;
    (function (FunctionFlags) {
        FunctionFlags._map = [];
        FunctionFlags.None = 0;
        FunctionFlags.Exported = 1;
        FunctionFlags.Private = 1 << 1;
        FunctionFlags.Public = 1 << 2;
        FunctionFlags.Ambient = 1 << 3;
        FunctionFlags.Static = 1 << 4;
        FunctionFlags.GetAccessor = 1 << 5;
        FunctionFlags.SetAccessor = 1 << 6;
        FunctionFlags.Signature = 1 << 7;
        FunctionFlags.Method = 1 << 8;
        FunctionFlags.CallMember = 1 << 9;
        FunctionFlags.ConstructMember = 1 << 10;
        FunctionFlags.IsFatArrowFunction = 1 << 11;
        FunctionFlags.IndexerMember = 1 << 12;
        FunctionFlags.IsFunctionExpression = 1 << 13;
        FunctionFlags.ClassMethod = 1 << 14;
        FunctionFlags.ClassPropertyMethodExported = 1 << 15;
    })(TypeScript.FunctionFlags || (TypeScript.FunctionFlags = {}));
    var FunctionFlags = TypeScript.FunctionFlags;
    (function (SignatureFlags) {
        SignatureFlags._map = [];
        SignatureFlags.None = 0;
        SignatureFlags.IsIndexer = 1;
        SignatureFlags.IsStringIndexer = 1 << 1;
        SignatureFlags.IsNumberIndexer = 1 << 2;
    })(TypeScript.SignatureFlags || (TypeScript.SignatureFlags = {}));
    var SignatureFlags = TypeScript.SignatureFlags;
                    function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags) {
        return fncOrVarOrSymbolOrModuleFlags;
    }
    TypeScript.ToDeclFlags = ToDeclFlags;
    (function (TypeFlags) {
        TypeFlags._map = [];
        TypeFlags.None = 0;
        TypeFlags.HasImplementation = 1;
        TypeFlags.HasSelfReference = 1 << 1;
        TypeFlags.MergeResult = 1 << 2;
        TypeFlags.IsEnum = 1 << 3;
        TypeFlags.BuildingName = 1 << 4;
        TypeFlags.HasBaseType = 1 << 5;
        TypeFlags.HasBaseTypeOfObject = 1 << 6;
        TypeFlags.IsClass = 1 << 7;
    })(TypeScript.TypeFlags || (TypeScript.TypeFlags = {}));
    var TypeFlags = TypeScript.TypeFlags;
    (function (TypeRelationshipFlags) {
        TypeRelationshipFlags._map = [];
        TypeRelationshipFlags.SuccessfulComparison = 0;
        TypeRelationshipFlags.SourceIsNullTargetIsVoidOrUndefined = 1;
        TypeRelationshipFlags.RequiredPropertyIsMissing = 1 << 1;
        TypeRelationshipFlags.IncompatibleSignatures = 1 << 2;
        TypeRelationshipFlags.SourceSignatureHasTooManyParameters = 3;
        TypeRelationshipFlags.IncompatibleReturnTypes = 1 << 4;
        TypeRelationshipFlags.IncompatiblePropertyTypes = 1 << 5;
        TypeRelationshipFlags.IncompatibleParameterTypes = 1 << 6;
        TypeRelationshipFlags.InconsistantPropertyAccesibility = 1 << 7;
    })(TypeScript.TypeRelationshipFlags || (TypeScript.TypeRelationshipFlags = {}));
    var TypeRelationshipFlags = TypeScript.TypeRelationshipFlags;
    (function (ModuleGenTarget) {
        ModuleGenTarget._map = [];
        ModuleGenTarget.Synchronous = 0;
        ModuleGenTarget.Asynchronous = 1;
        ModuleGenTarget.Local = 1 << 1;
    })(TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));
    var ModuleGenTarget = TypeScript.ModuleGenTarget;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (NodeType) {
        NodeType._map = [];
        NodeType._map[0] = "None";
        NodeType.None = 0;
        NodeType._map[1] = "List";
        NodeType.List = 1;
        NodeType._map[2] = "Script";
        NodeType.Script = 2;
        NodeType._map[3] = "TrueLiteral";
        NodeType.TrueLiteral = 3;
        NodeType._map[4] = "FalseLiteral";
        NodeType.FalseLiteral = 4;
        NodeType._map[5] = "StringLiteral";
        NodeType.StringLiteral = 5;
        NodeType._map[6] = "RegularExpressionLiteral";
        NodeType.RegularExpressionLiteral = 6;
        NodeType._map[7] = "NumericLiteral";
        NodeType.NumericLiteral = 7;
        NodeType._map[8] = "NullLiteral";
        NodeType.NullLiteral = 8;
        NodeType._map[9] = "TypeParameter";
        NodeType.TypeParameter = 9;
        NodeType._map[10] = "GenericType";
        NodeType.GenericType = 10;
        NodeType._map[11] = "TypeRef";
        NodeType.TypeRef = 11;
        NodeType._map[12] = "FunctionDeclaration";
        NodeType.FunctionDeclaration = 12;
        NodeType._map[13] = "ClassDeclaration";
        NodeType.ClassDeclaration = 13;
        NodeType._map[14] = "InterfaceDeclaration";
        NodeType.InterfaceDeclaration = 14;
        NodeType._map[15] = "ModuleDeclaration";
        NodeType.ModuleDeclaration = 15;
        NodeType._map[16] = "ImportDeclaration";
        NodeType.ImportDeclaration = 16;
        NodeType._map[17] = "VariableDeclarator";
        NodeType.VariableDeclarator = 17;
        NodeType._map[18] = "VariableDeclaration";
        NodeType.VariableDeclaration = 18;
        NodeType._map[19] = "Parameter";
        NodeType.Parameter = 19;
        NodeType._map[20] = "Name";
        NodeType.Name = 20;
        NodeType._map[21] = "ArrayLiteralExpression";
        NodeType.ArrayLiteralExpression = 21;
        NodeType._map[22] = "ObjectLiteralExpression";
        NodeType.ObjectLiteralExpression = 22;
        NodeType._map[23] = "OmittedExpression";
        NodeType.OmittedExpression = 23;
        NodeType._map[24] = "VoidExpression";
        NodeType.VoidExpression = 24;
        NodeType._map[25] = "CommaExpression";
        NodeType.CommaExpression = 25;
        NodeType._map[26] = "PlusExpression";
        NodeType.PlusExpression = 26;
        NodeType._map[27] = "NegateExpression";
        NodeType.NegateExpression = 27;
        NodeType._map[28] = "DeleteExpression";
        NodeType.DeleteExpression = 28;
        NodeType._map[29] = "ThisExpression";
        NodeType.ThisExpression = 29;
        NodeType._map[30] = "SuperExpression";
        NodeType.SuperExpression = 30;
        NodeType._map[31] = "InExpression";
        NodeType.InExpression = 31;
        NodeType._map[32] = "MemberAccessExpression";
        NodeType.MemberAccessExpression = 32;
        NodeType._map[33] = "InstanceOfExpression";
        NodeType.InstanceOfExpression = 33;
        NodeType._map[34] = "TypeOfExpression";
        NodeType.TypeOfExpression = 34;
        NodeType._map[35] = "ElementAccessExpression";
        NodeType.ElementAccessExpression = 35;
        NodeType._map[36] = "InvocationExpression";
        NodeType.InvocationExpression = 36;
        NodeType._map[37] = "ObjectCreationExpression";
        NodeType.ObjectCreationExpression = 37;
        NodeType._map[38] = "AssignmentExpression";
        NodeType.AssignmentExpression = 38;
        NodeType._map[39] = "AddAssignmentExpression";
        NodeType.AddAssignmentExpression = 39;
        NodeType._map[40] = "SubtractAssignmentExpression";
        NodeType.SubtractAssignmentExpression = 40;
        NodeType._map[41] = "DivideAssignmentExpression";
        NodeType.DivideAssignmentExpression = 41;
        NodeType._map[42] = "MultiplyAssignmentExpression";
        NodeType.MultiplyAssignmentExpression = 42;
        NodeType._map[43] = "ModuloAssignmentExpression";
        NodeType.ModuloAssignmentExpression = 43;
        NodeType._map[44] = "AndAssignmentExpression";
        NodeType.AndAssignmentExpression = 44;
        NodeType._map[45] = "ExclusiveOrAssignmentExpression";
        NodeType.ExclusiveOrAssignmentExpression = 45;
        NodeType._map[46] = "OrAssignmentExpression";
        NodeType.OrAssignmentExpression = 46;
        NodeType._map[47] = "LeftShiftAssignmentExpression";
        NodeType.LeftShiftAssignmentExpression = 47;
        NodeType._map[48] = "SignedRightShiftAssignmentExpression";
        NodeType.SignedRightShiftAssignmentExpression = 48;
        NodeType._map[49] = "UnsignedRightShiftAssignmentExpression";
        NodeType.UnsignedRightShiftAssignmentExpression = 49;
        NodeType._map[50] = "ConditionalExpression";
        NodeType.ConditionalExpression = 50;
        NodeType._map[51] = "LogicalOrExpression";
        NodeType.LogicalOrExpression = 51;
        NodeType._map[52] = "LogicalAndExpression";
        NodeType.LogicalAndExpression = 52;
        NodeType._map[53] = "BitwiseOrExpression";
        NodeType.BitwiseOrExpression = 53;
        NodeType._map[54] = "BitwiseExclusiveOrExpression";
        NodeType.BitwiseExclusiveOrExpression = 54;
        NodeType._map[55] = "BitwiseAndExpression";
        NodeType.BitwiseAndExpression = 55;
        NodeType._map[56] = "EqualsWithTypeConversionExpression";
        NodeType.EqualsWithTypeConversionExpression = 56;
        NodeType._map[57] = "NotEqualsWithTypeConversionExpression";
        NodeType.NotEqualsWithTypeConversionExpression = 57;
        NodeType._map[58] = "EqualsExpression";
        NodeType.EqualsExpression = 58;
        NodeType._map[59] = "NotEqualsExpression";
        NodeType.NotEqualsExpression = 59;
        NodeType._map[60] = "LessThanExpression";
        NodeType.LessThanExpression = 60;
        NodeType._map[61] = "LessThanOrEqualExpression";
        NodeType.LessThanOrEqualExpression = 61;
        NodeType._map[62] = "GreaterThanExpression";
        NodeType.GreaterThanExpression = 62;
        NodeType._map[63] = "GreaterThanOrEqualExpression";
        NodeType.GreaterThanOrEqualExpression = 63;
        NodeType._map[64] = "AddExpression";
        NodeType.AddExpression = 64;
        NodeType._map[65] = "SubtractExpression";
        NodeType.SubtractExpression = 65;
        NodeType._map[66] = "MultiplyExpression";
        NodeType.MultiplyExpression = 66;
        NodeType._map[67] = "DivideExpression";
        NodeType.DivideExpression = 67;
        NodeType._map[68] = "ModuloExpression";
        NodeType.ModuloExpression = 68;
        NodeType._map[69] = "LeftShiftExpression";
        NodeType.LeftShiftExpression = 69;
        NodeType._map[70] = "SignedRightShiftExpression";
        NodeType.SignedRightShiftExpression = 70;
        NodeType._map[71] = "UnsignedRightShiftExpression";
        NodeType.UnsignedRightShiftExpression = 71;
        NodeType._map[72] = "BitwiseNotExpression";
        NodeType.BitwiseNotExpression = 72;
        NodeType._map[73] = "LogicalNotExpression";
        NodeType.LogicalNotExpression = 73;
        NodeType._map[74] = "PreIncrementExpression";
        NodeType.PreIncrementExpression = 74;
        NodeType._map[75] = "PreDecrementExpression";
        NodeType.PreDecrementExpression = 75;
        NodeType._map[76] = "PostIncrementExpression";
        NodeType.PostIncrementExpression = 76;
        NodeType._map[77] = "PostDecrementExpression";
        NodeType.PostDecrementExpression = 77;
        NodeType._map[78] = "CastExpression";
        NodeType.CastExpression = 78;
        NodeType._map[79] = "ParenthesizedExpression";
        NodeType.ParenthesizedExpression = 79;
        NodeType._map[80] = "Member";
        NodeType.Member = 80;
        NodeType._map[81] = "Block";
        NodeType.Block = 81;
        NodeType._map[82] = "BreakStatement";
        NodeType.BreakStatement = 82;
        NodeType._map[83] = "ContinueStatement";
        NodeType.ContinueStatement = 83;
        NodeType._map[84] = "DebuggerStatement";
        NodeType.DebuggerStatement = 84;
        NodeType._map[85] = "DoStatement";
        NodeType.DoStatement = 85;
        NodeType._map[86] = "EmptyStatement";
        NodeType.EmptyStatement = 86;
        NodeType._map[87] = "ExportAssignment";
        NodeType.ExportAssignment = 87;
        NodeType._map[88] = "ExpressionStatement";
        NodeType.ExpressionStatement = 88;
        NodeType._map[89] = "ForInStatement";
        NodeType.ForInStatement = 89;
        NodeType._map[90] = "ForStatement";
        NodeType.ForStatement = 90;
        NodeType._map[91] = "IfStatement";
        NodeType.IfStatement = 91;
        NodeType._map[92] = "LabeledStatement";
        NodeType.LabeledStatement = 92;
        NodeType._map[93] = "ReturnStatement";
        NodeType.ReturnStatement = 93;
        NodeType._map[94] = "SwitchStatement";
        NodeType.SwitchStatement = 94;
        NodeType._map[95] = "ThrowStatement";
        NodeType.ThrowStatement = 95;
        NodeType._map[96] = "TryStatement";
        NodeType.TryStatement = 96;
        NodeType._map[97] = "VariableStatement";
        NodeType.VariableStatement = 97;
        NodeType._map[98] = "WhileStatement";
        NodeType.WhileStatement = 98;
        NodeType._map[99] = "WithStatement";
        NodeType.WithStatement = 99;
        NodeType._map[100] = "CaseClause";
        NodeType.CaseClause = 100;
        NodeType._map[101] = "CatchClause";
        NodeType.CatchClause = 101;
        NodeType._map[102] = "Comment";
        NodeType.Comment = 102;
    })(TypeScript.NodeType || (TypeScript.NodeType = {}));
    var NodeType = TypeScript.NodeType;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            this["constructor"] = undefined;
        }
        return BlockIntrinsics;
    })();
    TypeScript.BlockIntrinsics = BlockIntrinsics;    
    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0;
            this.table = new BlockIntrinsics();
        }
        StringHashTable.prototype.getAllKeys = function () {
            var result = [];
            for(var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }
            return result;
        };
        StringHashTable.prototype.add = function (key, data) {
            if (this.table[key] !== undefined) {
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        };
        StringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        };
        StringHashTable.prototype.map = function (fn, context) {
            for(var k in this.table) {
                var data = this.table[k];
                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        };
        StringHashTable.prototype.every = function (fn, context) {
            for(var k in this.table) {
                var data = this.table[k];
                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }
            return true;
        };
        StringHashTable.prototype.some = function (fn, context) {
            for(var k in this.table) {
                var data = this.table[k];
                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }
            return false;
        };
        StringHashTable.prototype.count = function () {
            return this.itemCount;
        };
        StringHashTable.prototype.lookup = function (key) {
            var data = this.table[key];
            return data === undefined ? null : data;
        };
        return StringHashTable;
    })();
    TypeScript.StringHashTable = StringHashTable;    
    var DualStringHashTable = (function () {
        function DualStringHashTable(primaryTable, secondaryTable) {
            this.primaryTable = primaryTable;
            this.secondaryTable = secondaryTable;
            this.insertPrimary = true;
        }
        DualStringHashTable.prototype.getAllKeys = function () {
            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());
        };
        DualStringHashTable.prototype.add = function (key, data) {
            if (this.insertPrimary) {
                return this.primaryTable.add(key, data);
            } else {
                return this.secondaryTable.add(key, data);
            }
        };
        DualStringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.insertPrimary) {
                return this.primaryTable.addOrUpdate(key, data);
            } else {
                return this.secondaryTable.addOrUpdate(key, data);
            }
        };
        DualStringHashTable.prototype.map = function (fn, context) {
            this.primaryTable.map(fn, context);
            this.secondaryTable.map(fn, context);
        };
        DualStringHashTable.prototype.every = function (fn, context) {
            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);
        };
        DualStringHashTable.prototype.some = function (fn, context) {
            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);
        };
        DualStringHashTable.prototype.count = function () {
            return this.primaryTable.count() + this.secondaryTable.count();
        };
        DualStringHashTable.prototype.lookup = function (key) {
            var data = this.primaryTable.lookup(key);
            if (data != undefined) {
                return data;
            } else {
                return this.secondaryTable.lookup(key);
            }
        };
        return DualStringHashTable;
    })();
    TypeScript.DualStringHashTable = DualStringHashTable;    
    function numberHashFn(key) {
        var c2 = 0x27d4eb2d;
        key = (key ^ 61) ^ (key >>> 16);
        key = key + (key << 3);
        key = key ^ (key >>> 4);
        key = key * c2;
        key = key ^ (key >>> 15);
        return key;
    }
    TypeScript.numberHashFn = numberHashFn;
    function combineHashes(key1, key2) {
        return key2 ^ ((key1 >> 5) + key1);
    }
    TypeScript.combineHashes = combineHashes;
    var HashEntry = (function () {
        function HashEntry(key, data) {
            this.key = key;
            this.data = data;
        }
        return HashEntry;
    })();
    TypeScript.HashEntry = HashEntry;    
    var HashTable = (function () {
        function HashTable(size, hashFn, equalsFn) {
            this.size = size;
            this.hashFn = hashFn;
            this.equalsFn = equalsFn;
            this.itemCount = 0;
            this.table = [];
            for(var i = 0; i < this.size; i++) {
                this.table[i] = null;
            }
        }
        HashTable.prototype.add = function (key, data) {
            var entry = new HashEntry(key, data);
            var val = this.hashFn(key);
            val = val % this.size;
            for(var current = this.table[val]; current != null; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return false;
                }
            }
            entry.next = this.table[val];
            this.table[val] = entry;
            this.itemCount++;
            return true;
        };
        HashTable.prototype.remove = function (key) {
            var val = this.hashFn(key);
            val = val % this.size;
            var result = null;
            var prevEntry = null;
            for(var current = this.table[val]; current != null; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    result = current.data;
                    this.itemCount--;
                    if (prevEntry) {
                        prevEntry.next = current.next;
                    } else {
                        this.table[val] = current.next;
                    }
                    break;
                }
                prevEntry = current;
            }
            return result;
        };
        HashTable.prototype.count = function () {
            return this.itemCount;
        };
        HashTable.prototype.lookup = function (key) {
            var val = this.hashFn(key);
            val = val % this.size;
            for(var current = this.table[val]; current != null; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return (current.data);
                }
            }
            return (null);
        };
        return HashTable;
    })();
    TypeScript.HashTable = HashTable;    
})(TypeScript || (TypeScript = {}));
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    var ASTSpan = (function () {
        function ASTSpan() {
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
        }
        return ASTSpan;
    })();
    TypeScript.ASTSpan = ASTSpan;    
    TypeScript.astID = 0;
    function structuralEqualsNotIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, false);
    }
    TypeScript.structuralEqualsNotIncludingPosition = structuralEqualsNotIncludingPosition;
    function structuralEqualsIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, true);
    }
    TypeScript.structuralEqualsIncludingPosition = structuralEqualsIncludingPosition;
    function structuralEquals(ast1, ast2, includingPosition) {
        if (ast1 === ast2) {
            return true;
        }
        return ast1 !== null && ast2 !== null && ast1.nodeType === ast2.nodeType && ast1.structuralEquals(ast2, includingPosition);
    }
    function astArrayStructuralEquals(array1, array2, includingPosition) {
        return TypeScript.ArrayUtilities.sequenceEquals(array1, array2, includingPosition ? structuralEqualsIncludingPosition : structuralEqualsNotIncludingPosition);
    }
    var AST = (function () {
        function AST(nodeType) {
            this.nodeType = nodeType;
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
            this.type = null;
            this._flags = TypeScript.ASTFlags.None;
            this.typeCheckPhase = -1;
            this.astID = TypeScript.astID++;
            this.passCreated = TypeScript.CompilerDiagnostics.analysisPass;
            this.preComments = null;
            this.postComments = null;
            this.docComments = null;
        }
        AST.prototype.isExpression = function () {
            return false;
        };
        AST.prototype.isStatementOrExpression = function () {
            return false;
        };
        AST.prototype.getFlags = function () {
            return this._flags;
        };
        AST.prototype.setFlags = function (flags) {
            this._flags = flags;
        };
        AST.prototype.getLength = function () {
            return this.limChar - this.minChar;
        };
        AST.prototype.getID = function () {
            return this.astID;
        };
        AST.prototype.isDeclaration = function () {
            return false;
        };
        AST.prototype.isStatement = function () {
            return false;
        };
        AST.prototype.typeCheck = function (typeFlow) {
            switch(this.nodeType) {
                case TypeScript.NodeType.OmittedExpression:
                    this.type = typeFlow.anyType;
                    break;
                case TypeScript.NodeType.ThisExpression:
                    return typeFlow.typeCheckThis(this);
                case TypeScript.NodeType.NullLiteral:
                    this.type = typeFlow.nullType;
                    break;
                case TypeScript.NodeType.FalseLiteral:
                case TypeScript.NodeType.TrueLiteral:
                    this.type = typeFlow.booleanType;
                    break;
                case TypeScript.NodeType.SuperExpression:
                    return typeFlow.typeCheckSuper(this);
                case TypeScript.NodeType.EmptyStatement:
                case TypeScript.NodeType.VoidExpression:
                    this.type = typeFlow.voidType;
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        };
        AST.prototype.emit = function (emitter, startLine) {
            throw new Error("please implement in derived class");
        };
        AST.prototype.print = function (context) {
            context.startLine();
            context.writeLine(this.printLabel());
        };
        AST.prototype.printLabel = function () {
            return "";
        };
        AST.prototype.addToControlFlow = function (context) {
            context.walker.options.goChildren = false;
            context.addContent(this);
        };
        AST.prototype.treeViewLabel = function () {
            return (TypeScript.NodeType)._map[this.nodeType];
        };
        AST.prototype.getDocComments = function () {
            if (!this.isDeclaration() || !this.preComments || this.preComments.length === 0) {
                return [];
            }
            if (!this.docComments) {
                var preCommentsLength = this.preComments.length;
                var docComments = [];
                for(var i = preCommentsLength - 1; i >= 0; i--) {
                    if (this.preComments[i].isDocComment()) {
                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;
                        if (prevDocComment === null || (this.preComments[i].limLine === prevDocComment.minLine || this.preComments[i].limLine + 1 === prevDocComment.minLine)) {
                            docComments.push(this.preComments[i]);
                            continue;
                        }
                    }
                    break;
                }
                this.docComments = docComments.reverse();
            }
            return this.docComments;
        };
        AST.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.minChar !== ast.minChar || this.limChar !== ast.limChar) {
                    return false;
                }
            }
            return this._flags === ast._flags && astArrayStructuralEquals(this.preComments, ast.preComments, includingPosition) && astArrayStructuralEquals(this.postComments, ast.postComments, includingPosition);
        };
        return AST;
    })();
    TypeScript.AST = AST;    
    var ASTList = (function (_super) {
        __extends(ASTList, _super);
        function ASTList() {
            _super.call(this, TypeScript.NodeType.List);
            this.members = [];
        }
        ASTList.prototype.addToControlFlow = function (context) {
            var len = this.members.length;
            for(var i = 0; i < len; i++) {
                if (context.noContinuation) {
                    context.addUnreachable(this.members[i]);
                    break;
                } else {
                    this.members[i] = context.walk(this.members[i], this);
                }
            }
            context.walker.options.goChildren = false;
        };
        ASTList.prototype.append = function (ast) {
            this.members[this.members.length] = ast;
            return this;
        };
        ASTList.prototype.emit = function (emitter, startLine) {
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascriptList(this, null, startLine, false, false);
            emitter.recordSourceMappingEnd(this);
        };
        ASTList.prototype.typeCheck = function (typeFlow) {
            var len = this.members.length;
            typeFlow.nestingLevel++;
            for(var i = 0; i < len; i++) {
                if (this.members[i]) {
                    this.members[i] = this.members[i].typeCheck(typeFlow);
                }
            }
            typeFlow.nestingLevel--;
            return this;
        };
        ASTList.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && astArrayStructuralEquals(this.members, ast.members, includingPosition);
        };
        return ASTList;
    })(AST);
    TypeScript.ASTList = ASTList;    
    var Expression = (function (_super) {
        __extends(Expression, _super);
        function Expression(nodeType) {
            _super.call(this, nodeType);
        }
        return Expression;
    })(AST);
    TypeScript.Expression = Expression;    
    var Identifier = (function (_super) {
        __extends(Identifier, _super);
        function Identifier(actualText) {
            _super.call(this, TypeScript.NodeType.Name);
            this.actualText = actualText;
            this.sym = null;
            this.setText(actualText);
        }
        Identifier.prototype.setText = function (actualText) {
            this.actualText = actualText;
            this.text = actualText;
        };
        Identifier.prototype.isMissing = function () {
            return false;
        };
        Identifier.prototype.treeViewLabel = function () {
            return "id: " + this.actualText;
        };
        Identifier.prototype.printLabel = function () {
            if (this.actualText) {
                return "id: " + this.actualText;
            } else {
                return "name node";
            }
        };
        Identifier.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckName(this);
        };
        Identifier.prototype.emit = function (emitter, startLine) {
            emitter.emitJavascriptName(this, true);
        };
        Identifier.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.text === ast.text && this.actualText === ast.actualText && this.isMissing() === ast.isMissing();
        };
        return Identifier;
    })(Expression);
    TypeScript.Identifier = Identifier;    
    var MissingIdentifier = (function (_super) {
        __extends(MissingIdentifier, _super);
        function MissingIdentifier() {
            _super.call(this, "__missing");
        }
        MissingIdentifier.prototype.isMissing = function () {
            return true;
        };
        MissingIdentifier.prototype.emit = function (emitter, startLine) {
        };
        return MissingIdentifier;
    })(Identifier);
    TypeScript.MissingIdentifier = MissingIdentifier;    
    var LiteralExpression = (function (_super) {
        __extends(LiteralExpression, _super);
        function LiteralExpression(nodeType) {
            _super.call(this, nodeType);
        }
        LiteralExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            switch(this.nodeType) {
                case TypeScript.NodeType.NullLiteral:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("null");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case TypeScript.NodeType.FalseLiteral:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("false");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case TypeScript.NodeType.TrueLiteral:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("true");
                    emitter.recordSourceMappingEnd(this);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.emitComments(this, false);
        };
        LiteralExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return LiteralExpression;
    })(Expression);
    TypeScript.LiteralExpression = LiteralExpression;    
    var ThisExpression = (function (_super) {
        __extends(ThisExpression, _super);
        function ThisExpression() {
            _super.call(this, TypeScript.NodeType.ThisExpression);
        }
        ThisExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            if (emitter.thisFnc && (TypeScript.hasFlag(emitter.thisFnc.getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction))) {
                emitter.writeToOutput("_this");
            } else {
                emitter.writeToOutput("this");
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        ThisExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return ThisExpression;
    })(Expression);
    TypeScript.ThisExpression = ThisExpression;    
    var SuperExpression = (function (_super) {
        __extends(SuperExpression, _super);
        function SuperExpression() {
            _super.call(this, TypeScript.NodeType.SuperExpression);
        }
        SuperExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitSuperReference();
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        SuperExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return SuperExpression;
    })(Expression);
    TypeScript.SuperExpression = SuperExpression;    
    var ParenthesizedExpression = (function (_super) {
        __extends(ParenthesizedExpression, _super);
        function ParenthesizedExpression(expression) {
            _super.call(this, TypeScript.NodeType.ParenthesizedExpression);
            this.expression = expression;
        }
        ParenthesizedExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.writeToOutput("(");
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.expression, false);
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(")");
            emitter.emitComments(this, false);
        };
        ParenthesizedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ParenthesizedExpression;
    })(Expression);
    TypeScript.ParenthesizedExpression = ParenthesizedExpression;    
    var UnaryExpression = (function (_super) {
        __extends(UnaryExpression, _super);
        function UnaryExpression(nodeType, operand) {
            _super.call(this, nodeType);
            this.operand = operand;
            this.targetType = null;
            this.castTerm = null;
        }
        UnaryExpression.prototype.addToControlFlow = function (context) {
            _super.prototype.addToControlFlow.call(this, context);
            if (this.nodeType === TypeScript.NodeType.ThrowStatement) {
                context.returnStmt();
            }
        };
        UnaryExpression.prototype.typeCheck = function (typeFlow) {
            switch(this.nodeType) {
                case TypeScript.NodeType.BitwiseNotExpression:
                    return typeFlow.typeCheckBitNot(this);
                case TypeScript.NodeType.LogicalNotExpression:
                    return typeFlow.typeCheckLogNot(this);
                case TypeScript.NodeType.PlusExpression:
                case TypeScript.NodeType.NegateExpression:
                    return typeFlow.typeCheckUnaryNumberOperator(this);
                case TypeScript.NodeType.PostIncrementExpression:
                case TypeScript.NodeType.PreIncrementExpression:
                case TypeScript.NodeType.PostDecrementExpression:
                case TypeScript.NodeType.PreDecrementExpression:
                    return typeFlow.typeCheckIncOrDec(this);
                case TypeScript.NodeType.ArrayLiteralExpression:
                    typeFlow.typeCheckArrayLit(this);
                    return this;
                case TypeScript.NodeType.ObjectLiteralExpression:
                    typeFlow.typeCheckObjectLit(this);
                    return this;
                case TypeScript.NodeType.ThrowStatement:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.voidType;
                    return this;
                case TypeScript.NodeType.TypeOfExpression:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.stringType;
                    return this;
                case TypeScript.NodeType.DeleteExpression:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.booleanType;
                    break;
                case TypeScript.NodeType.CastExpression:
                    this.castTerm = typeFlow.typeCheck(this.castTerm);
                    var applyTargetType = this.operand.nodeType !== TypeScript.NodeType.ParenthesizedExpression;
                    var targetType = applyTargetType ? this.castTerm.type : null;
                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);
                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);
                    this.type = this.castTerm.type;
                    return this;
                case TypeScript.NodeType.VoidExpression:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.checker.undefinedType;
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        };
        UnaryExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            switch(this.nodeType) {
                case TypeScript.NodeType.PostIncrementExpression:
                    emitter.emitJavascript(this.operand, false);
                    emitter.writeToOutput("++");
                    break;
                case TypeScript.NodeType.LogicalNotExpression:
                    emitter.writeToOutput("!");
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.PostDecrementExpression:
                    emitter.emitJavascript(this.operand, false);
                    emitter.writeToOutput("--");
                    break;
                case TypeScript.NodeType.ObjectLiteralExpression:
                    emitter.emitObjectLiteral(this.operand);
                    break;
                case TypeScript.NodeType.ArrayLiteralExpression:
                    emitter.emitArrayLiteral(this.operand);
                    break;
                case TypeScript.NodeType.BitwiseNotExpression:
                    emitter.writeToOutput("~");
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.NegateExpression:
                    emitter.writeToOutput("-");
                    if (this.operand.nodeType === TypeScript.NodeType.NegateExpression || this.operand.nodeType === TypeScript.NodeType.PreDecrementExpression) {
                        emitter.writeToOutput(" ");
                    }
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.PlusExpression:
                    emitter.writeToOutput("+");
                    if (this.operand.nodeType === TypeScript.NodeType.PlusExpression || this.operand.nodeType === TypeScript.NodeType.PreIncrementExpression) {
                        emitter.writeToOutput(" ");
                    }
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.PreIncrementExpression:
                    emitter.writeToOutput("++");
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.PreDecrementExpression:
                    emitter.writeToOutput("--");
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.TypeOfExpression:
                    emitter.writeToOutput("typeof ");
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.DeleteExpression:
                    emitter.writeToOutput("delete ");
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.VoidExpression:
                    emitter.writeToOutput("void ");
                    emitter.emitJavascript(this.operand, false);
                    break;
                case TypeScript.NodeType.CastExpression:
                    emitter.emitJavascript(this.operand, false);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        UnaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.castTerm, ast.castTerm, includingPosition) && structuralEquals(this.operand, ast.operand, includingPosition);
        };
        return UnaryExpression;
    })(Expression);
    TypeScript.UnaryExpression = UnaryExpression;    
    var CallExpression = (function (_super) {
        __extends(CallExpression, _super);
        function CallExpression(nodeType, target, typeArguments, arguments) {
            _super.call(this, nodeType);
            this.target = target;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.signature = null;
        }
        CallExpression.prototype.typeCheck = function (typeFlow) {
            if (this.nodeType === TypeScript.NodeType.ObjectCreationExpression) {
                return typeFlow.typeCheckNew(this);
            } else {
                return typeFlow.typeCheckCall(this);
            }
        };
        CallExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType === TypeScript.NodeType.ObjectCreationExpression) {
                emitter.emitNew(this.target, this.arguments);
            } else {
                emitter.emitCall(this, this.target, this.arguments);
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        CallExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.target, ast.target, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };
        return CallExpression;
    })(Expression);
    TypeScript.CallExpression = CallExpression;    
    var BinaryExpression = (function (_super) {
        __extends(BinaryExpression, _super);
        function BinaryExpression(nodeType, operand1, operand2) {
            _super.call(this, nodeType);
            this.operand1 = operand1;
            this.operand2 = operand2;
        }
        BinaryExpression.prototype.typeCheck = function (typeFlow) {
            switch(this.nodeType) {
                case TypeScript.NodeType.MemberAccessExpression:
                    return typeFlow.typeCheckDotOperator(this);
                case TypeScript.NodeType.AssignmentExpression:
                    return typeFlow.typeCheckAsgOperator(this);
                case TypeScript.NodeType.AddExpression:
                case TypeScript.NodeType.SubtractExpression:
                case TypeScript.NodeType.MultiplyExpression:
                case TypeScript.NodeType.DivideExpression:
                case TypeScript.NodeType.ModuloExpression:
                case TypeScript.NodeType.BitwiseOrExpression:
                case TypeScript.NodeType.BitwiseAndExpression:
                    return typeFlow.typeCheckArithmeticOperator(this, false);
                case TypeScript.NodeType.BitwiseExclusiveOrExpression:
                    return typeFlow.typeCheckBitwiseOperator(this, false);
                case TypeScript.NodeType.NotEqualsWithTypeConversionExpression:
                case TypeScript.NodeType.EqualsWithTypeConversionExpression:
                case TypeScript.NodeType.EqualsExpression:
                case TypeScript.NodeType.NotEqualsExpression:
                case TypeScript.NodeType.LessThanExpression:
                case TypeScript.NodeType.LessThanOrEqualExpression:
                case TypeScript.NodeType.GreaterThanOrEqualExpression:
                case TypeScript.NodeType.GreaterThanExpression:
                    return typeFlow.typeCheckBooleanOperator(this);
                case TypeScript.NodeType.ElementAccessExpression:
                    return typeFlow.typeCheckIndex(this);
                case TypeScript.NodeType.Member:
                    this.type = typeFlow.voidType;
                    return this;
                case TypeScript.NodeType.LogicalOrExpression:
                    return typeFlow.typeCheckLogOr(this);
                case TypeScript.NodeType.LogicalAndExpression:
                    return typeFlow.typeCheckLogAnd(this);
                case TypeScript.NodeType.AddAssignmentExpression:
                case TypeScript.NodeType.SubtractAssignmentExpression:
                case TypeScript.NodeType.MultiplyAssignmentExpression:
                case TypeScript.NodeType.DivideAssignmentExpression:
                case TypeScript.NodeType.ModuloAssignmentExpression:
                case TypeScript.NodeType.OrAssignmentExpression:
                case TypeScript.NodeType.AndAssignmentExpression:
                    return typeFlow.typeCheckArithmeticOperator(this, true);
                case TypeScript.NodeType.ExclusiveOrAssignmentExpression:
                    return typeFlow.typeCheckBitwiseOperator(this, true);
                case TypeScript.NodeType.LeftShiftExpression:
                case TypeScript.NodeType.SignedRightShiftExpression:
                case TypeScript.NodeType.UnsignedRightShiftExpression:
                    return typeFlow.typeCheckShift(this, false);
                case TypeScript.NodeType.LeftShiftAssignmentExpression:
                case TypeScript.NodeType.SignedRightShiftAssignmentExpression:
                case TypeScript.NodeType.UnsignedRightShiftAssignmentExpression:
                    return typeFlow.typeCheckShift(this, true);
                case TypeScript.NodeType.CommaExpression:
                    return typeFlow.typeCheckCommaOperator(this);
                case TypeScript.NodeType.InstanceOfExpression:
                    return typeFlow.typeCheckInstOf(this);
                case TypeScript.NodeType.InExpression:
                    return typeFlow.typeCheckInOperator(this);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        };
        BinaryExpression.prototype.printLabel = function () {
            return BinaryExpression.getTextForBinaryToken(this.nodeType);
        };
        BinaryExpression.getTextForBinaryToken = function getTextForBinaryToken(nodeType) {
            switch(nodeType) {
                case TypeScript.NodeType.CommaExpression:
                    return ",";
                case TypeScript.NodeType.AssignmentExpression:
                    return "=";
                case TypeScript.NodeType.AddAssignmentExpression:
                    return "+=";
                case TypeScript.NodeType.SubtractAssignmentExpression:
                    return "-=";
                case TypeScript.NodeType.MultiplyAssignmentExpression:
                    return "*=";
                case TypeScript.NodeType.DivideAssignmentExpression:
                    return "/=";
                case TypeScript.NodeType.ModuloAssignmentExpression:
                    return "%=";
                case TypeScript.NodeType.AndAssignmentExpression:
                    return "&=";
                case TypeScript.NodeType.ExclusiveOrAssignmentExpression:
                    return "^=";
                case TypeScript.NodeType.OrAssignmentExpression:
                    return "|=";
                case TypeScript.NodeType.LeftShiftAssignmentExpression:
                    return "<<=";
                case TypeScript.NodeType.SignedRightShiftAssignmentExpression:
                    return ">>=";
                case TypeScript.NodeType.UnsignedRightShiftAssignmentExpression:
                    return ">>>=";
                case TypeScript.NodeType.LogicalOrExpression:
                    return "||";
                case TypeScript.NodeType.LogicalAndExpression:
                    return "&&";
                case TypeScript.NodeType.BitwiseOrExpression:
                    return "|";
                case TypeScript.NodeType.BitwiseExclusiveOrExpression:
                    return "^";
                case TypeScript.NodeType.BitwiseAndExpression:
                    return "&";
                case TypeScript.NodeType.EqualsWithTypeConversionExpression:
                    return "==";
                case TypeScript.NodeType.NotEqualsWithTypeConversionExpression:
                    return "!=";
                case TypeScript.NodeType.EqualsExpression:
                    return "===";
                case TypeScript.NodeType.NotEqualsExpression:
                    return "!==";
                case TypeScript.NodeType.LessThanExpression:
                    return "<";
                case TypeScript.NodeType.GreaterThanExpression:
                    return ">";
                case TypeScript.NodeType.LessThanOrEqualExpression:
                    return "<=";
                case TypeScript.NodeType.GreaterThanOrEqualExpression:
                    return ">=";
                case TypeScript.NodeType.InstanceOfExpression:
                    return "instanceof";
                case TypeScript.NodeType.InExpression:
                    return "in";
                case TypeScript.NodeType.LeftShiftExpression:
                    return "<<";
                case TypeScript.NodeType.SignedRightShiftExpression:
                    return ">>";
                case TypeScript.NodeType.UnsignedRightShiftExpression:
                    return ">>>";
                case TypeScript.NodeType.MultiplyExpression:
                    return "*";
                case TypeScript.NodeType.DivideExpression:
                    return "/";
                case TypeScript.NodeType.ModuloExpression:
                    return "%";
                case TypeScript.NodeType.AddExpression:
                    return "+";
                case TypeScript.NodeType.SubtractExpression:
                    return "-";
            }
            throw TypeScript.Errors.invalidOperation();
        };
        BinaryExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            switch(this.nodeType) {
                case TypeScript.NodeType.MemberAccessExpression:
                    if (!emitter.tryEmitConstant(this)) {
                        emitter.emitJavascript(this.operand1, false);
                        emitter.writeToOutput(".");
                        emitter.emitJavascriptName(this.operand2, false);
                    }
                    break;
                case TypeScript.NodeType.ElementAccessExpression:
                    emitter.emitIndex(this.operand1, this.operand2);
                    break;
                case TypeScript.NodeType.Member:
                    if (this.operand2.nodeType === TypeScript.NodeType.FunctionDeclaration && (this.operand2).isAccessor()) {
                        var funcDecl = this.operand2;
                        if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor)) {
                            emitter.writeToOutput("get ");
                        } else {
                            emitter.writeToOutput("set ");
                        }
                        emitter.emitJavascript(this.operand1, false);
                    } else {
                        emitter.emitJavascript(this.operand1, false);
                        emitter.writeToOutputTrimmable(": ");
                    }
                    emitter.emitJavascript(this.operand2, false);
                    break;
                case TypeScript.NodeType.CommaExpression:
                    emitter.emitJavascript(this.operand1, false);
                    if (emitter.emitState.inObjectLiteral) {
                        emitter.writeLineToOutput(", ");
                    } else {
                        emitter.writeToOutput(", ");
                    }
                    emitter.emitJavascript(this.operand2, false);
                    break;
                default: {
                    emitter.emitJavascript(this.operand1, false);
                    var binOp = BinaryExpression.getTextForBinaryToken(this.nodeType);
                    if (binOp === "instanceof") {
                        emitter.writeToOutput(" instanceof ");
                    } else if (binOp === "in") {
                        emitter.writeToOutput(" in ");
                    } else {
                        emitter.writeToOutputTrimmable(" " + binOp + " ");
                    }
                    emitter.emitJavascript(this.operand2, false);
                }
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        BinaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition);
        };
        return BinaryExpression;
    })(Expression);
    TypeScript.BinaryExpression = BinaryExpression;    
    var ConditionalExpression = (function (_super) {
        __extends(ConditionalExpression, _super);
        function ConditionalExpression(operand1, operand2, operand3) {
            _super.call(this, TypeScript.NodeType.ConditionalExpression);
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.operand3 = operand3;
        }
        ConditionalExpression.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckQMark(this);
        };
        ConditionalExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.operand1, false);
            emitter.writeToOutput(" ? ");
            emitter.emitJavascript(this.operand2, false);
            emitter.writeToOutput(" : ");
            emitter.emitJavascript(this.operand3, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        ConditionalExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition) && structuralEquals(this.operand3, ast.operand3, includingPosition);
        };
        return ConditionalExpression;
    })(Expression);
    TypeScript.ConditionalExpression = ConditionalExpression;    
    var NumberLiteral = (function (_super) {
        __extends(NumberLiteral, _super);
        function NumberLiteral(value, text) {
            _super.call(this, TypeScript.NodeType.NumericLiteral);
            this.value = value;
            this.text = text;
        }
        NumberLiteral.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.doubleType;
            return this;
        };
        NumberLiteral.prototype.treeViewLabel = function () {
            return "num: " + this.printLabel();
        };
        NumberLiteral.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        NumberLiteral.prototype.printLabel = function () {
            return this.text;
        };
        NumberLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.value === ast.value && this.text === ast.text;
        };
        return NumberLiteral;
    })(Expression);
    TypeScript.NumberLiteral = NumberLiteral;    
    var RegexLiteral = (function (_super) {
        __extends(RegexLiteral, _super);
        function RegexLiteral(text) {
            _super.call(this, TypeScript.NodeType.RegularExpressionLiteral);
            this.text = text;
        }
        RegexLiteral.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.regexType;
            return this;
        };
        RegexLiteral.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        RegexLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.text === ast.text;
        };
        return RegexLiteral;
    })(Expression);
    TypeScript.RegexLiteral = RegexLiteral;    
    var StringLiteral = (function (_super) {
        __extends(StringLiteral, _super);
        function StringLiteral(text) {
            _super.call(this, TypeScript.NodeType.StringLiteral);
            this.text = text;
        }
        StringLiteral.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitStringLiteral(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        StringLiteral.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.stringType;
            return this;
        };
        StringLiteral.prototype.treeViewLabel = function () {
            return "st: " + this.text;
        };
        StringLiteral.prototype.printLabel = function () {
            return this.text;
        };
        StringLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.text === ast.text;
        };
        return StringLiteral;
    })(Expression);
    TypeScript.StringLiteral = StringLiteral;    
    var ImportDeclaration = (function (_super) {
        __extends(ImportDeclaration, _super);
        function ImportDeclaration(id, alias) {
            _super.call(this, TypeScript.NodeType.ImportDeclaration);
            this.id = id;
            this.alias = alias;
            this.isDynamicImport = false;
        }
        ImportDeclaration.prototype.isStatementOrExpression = function () {
            return true;
        };
        ImportDeclaration.prototype.isDeclaration = function () {
            return true;
        };
        ImportDeclaration.prototype.emit = function (emitter, startLine) {
            if (emitter.importStatementShouldBeEmitted(this)) {
                var prevModAliasId = emitter.modAliasId;
                var prevFirstModAlias = emitter.firstModAlias;
                emitter.recordSourceMappingStart(this);
                emitter.emitComments(this, true);
                emitter.writeToOutput("var " + this.id.actualText + " = ");
                emitter.modAliasId = this.id.actualText;
                emitter.firstModAlias = this.firstAliasedModToString();
                var aliasAST = this.alias.nodeType == TypeScript.NodeType.TypeRef ? (this.alias).term : this.alias;
                emitter.emitJavascript(aliasAST, false);
                emitter.writeToOutput(";");
                emitter.emitComments(this, false);
                emitter.recordSourceMappingEnd(this);
                emitter.modAliasId = prevModAliasId;
                emitter.firstModAlias = prevFirstModAlias;
            }
        };
        ImportDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckImportDecl(this);
        };
        ImportDeclaration.prototype.getAliasName = function (aliasAST) {
            if (typeof aliasAST === "undefined") { aliasAST = this.alias; }
            if (aliasAST.nodeType === TypeScript.NodeType.Name) {
                return (aliasAST).actualText;
            } else {
                var dotExpr = aliasAST;
                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
            }
        };
        ImportDeclaration.prototype.firstAliasedModToString = function () {
            if (this.alias.nodeType === TypeScript.NodeType.Name) {
                return (this.alias).actualText;
            } else {
                var dotExpr = this.alias;
                var firstMod = (dotExpr.term).operand1;
                return firstMod.actualText;
            }
        };
        ImportDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.id, ast.id, includingPosition) && structuralEquals(this.alias, ast.alias, includingPosition);
        };
        return ImportDeclaration;
    })(AST);
    TypeScript.ImportDeclaration = ImportDeclaration;    
    var ExportAssignment = (function (_super) {
        __extends(ExportAssignment, _super);
        function ExportAssignment(id) {
            _super.call(this, TypeScript.NodeType.ExportAssignment);
            this.id = id;
        }
        ExportAssignment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };
        return ExportAssignment;
    })(AST);
    TypeScript.ExportAssignment = ExportAssignment;    
    var BoundDecl = (function (_super) {
        __extends(BoundDecl, _super);
        function BoundDecl(id, nodeType) {
            _super.call(this, nodeType);
            this.id = id;
            this.init = null;
            this.typeExpr = null;
            this._varFlags = TypeScript.VariableFlags.None;
            this.sym = null;
        }
        BoundDecl.prototype.isDeclaration = function () {
            return true;
        };
        BoundDecl.prototype.isStatementOrExpression = function () {
            return true;
        };
        BoundDecl.prototype.getVarFlags = function () {
            return this._varFlags;
        };
        BoundDecl.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };
        BoundDecl.prototype.isProperty = function () {
            return TypeScript.hasFlag(this.getVarFlags(), TypeScript.VariableFlags.Property);
        };
        BoundDecl.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckBoundDecl(this);
        };
        BoundDecl.prototype.printLabel = function () {
            return this.treeViewLabel();
        };
        BoundDecl.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.typeExpr, ast.typeExpr, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };
        return BoundDecl;
    })(AST);
    TypeScript.BoundDecl = BoundDecl;    
    var VariableDeclarator = (function (_super) {
        __extends(VariableDeclarator, _super);
        function VariableDeclarator(id) {
            _super.call(this, id, TypeScript.NodeType.VariableDeclarator);
        }
        VariableDeclarator.prototype.isExported = function () {
            return TypeScript.hasFlag(this.getVarFlags(), TypeScript.VariableFlags.Exported);
        };
        VariableDeclarator.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getVarFlags(), TypeScript.VariableFlags.Static);
        };
        VariableDeclarator.prototype.emit = function (emitter, startLine) {
            emitter.emitJavascriptVariableDeclarator(this);
        };
        VariableDeclarator.prototype.treeViewLabel = function () {
            return "var " + this.id.actualText;
        };
        return VariableDeclarator;
    })(BoundDecl);
    TypeScript.VariableDeclarator = VariableDeclarator;    
    var Parameter = (function (_super) {
        __extends(Parameter, _super);
        function Parameter(id) {
            _super.call(this, id, TypeScript.NodeType.Parameter);
            this.isOptional = false;
            this.parameterPropertySym = null;
        }
        Parameter.prototype.isOptionalArg = function () {
            return this.isOptional || this.init;
        };
        Parameter.prototype.treeViewLabel = function () {
            return "arg: " + this.id.actualText;
        };
        Parameter.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.id.actualText);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        Parameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.isOptional === ast.isOptional;
        };
        return Parameter;
    })(BoundDecl);
    TypeScript.Parameter = Parameter;    
    var FunctionDeclaration = (function (_super) {
        __extends(FunctionDeclaration, _super);
        function FunctionDeclaration(name, block, isConstructor, typeArguments, arguments, nodeType) {
            _super.call(this, nodeType);
            this.name = name;
            this.block = block;
            this.isConstructor = isConstructor;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.hint = null;
            this._functionFlags = TypeScript.FunctionFlags.None;
            this.returnTypeAnnotation = null;
            this.variableArgList = false;
            this.freeVariables = [];
            this.classDecl = null;
            this.accessorSymbol = null;
            this.scopeType = null;
        }
        FunctionDeclaration.prototype.isDeclaration = function () {
            return true;
        };
        FunctionDeclaration.prototype.getFunctionFlags = function () {
            return this._functionFlags;
        };
        FunctionDeclaration.prototype.setFunctionFlags = function (flags) {
            this._functionFlags = flags;
        };
        FunctionDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._functionFlags === ast._functionFlags && this.hint === ast.hint && this.variableArgList === ast.variableArgList && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.block, ast.block, includingPosition) && this.isConstructor === ast.isConstructor && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };
        FunctionDeclaration.prototype.buildControlFlow = function () {
            var entry = new TypeScript.BasicBlock();
            var exit = new TypeScript.BasicBlock();
            var context = new TypeScript.ControlFlowContext(entry, exit);
            var controlFlowPrefix = function (ast, parent, walker) {
                ast.addToControlFlow(walker.state);
                return ast;
            };
            var walker = TypeScript.getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);
            context.walker = walker;
            walker.walk(this.block, this);
            return context;
        };
        FunctionDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckFunction(this);
        };
        FunctionDeclaration.prototype.emit = function (emitter, startLine) {
            emitter.emitJavascriptFunction(this);
        };
        FunctionDeclaration.prototype.getNameText = function () {
            if (this.name) {
                return this.name.actualText;
            } else {
                return this.hint;
            }
        };
        FunctionDeclaration.prototype.isMethod = function () {
            return (this.getFunctionFlags() & TypeScript.FunctionFlags.Method) != TypeScript.FunctionFlags.None;
        };
        FunctionDeclaration.prototype.isCallMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.CallMember);
        };
        FunctionDeclaration.prototype.isConstructMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.ConstructMember);
        };
        FunctionDeclaration.prototype.isIndexerMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.IndexerMember);
        };
        FunctionDeclaration.prototype.isSpecialFn = function () {
            return this.isCallMember() || this.isIndexerMember() || this.isConstructMember();
        };
        FunctionDeclaration.prototype.isAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor) || TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.SetAccessor);
        };
        FunctionDeclaration.prototype.isGetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor);
        };
        FunctionDeclaration.prototype.isSetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.SetAccessor);
        };
        FunctionDeclaration.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), TypeScript.FunctionFlags.Static);
        };
        FunctionDeclaration.prototype.treeViewLabel = function () {
            if (this.name === null) {
                return "funcExpr";
            } else {
                return "func: " + this.name.actualText;
            }
        };
        FunctionDeclaration.prototype.isSignature = function () {
            return (this.getFunctionFlags() & TypeScript.FunctionFlags.Signature) != TypeScript.FunctionFlags.None;
        };
        return FunctionDeclaration;
    })(AST);
    TypeScript.FunctionDeclaration = FunctionDeclaration;    
    var Script = (function (_super) {
        __extends(Script, _super);
        function Script() {
            _super.call(this, TypeScript.NodeType.Script);
            this.moduleElements = null;
            this.referencedFiles = [];
            this.requiresExtendsBlock = false;
            this.isDeclareFile = false;
            this.topLevelMod = null;
            this.containsUnicodeChar = false;
            this.containsUnicodeCharInComment = false;
        }
        Script.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckScript(this);
        };
        Script.prototype.treeViewLabel = function () {
            return "Script";
        };
        Script.prototype.emit = function (emitter, startLine) {
            if (!this.isDeclareFile) {
                emitter.emitJavascriptList(this.moduleElements, null, true, false, false, true, this.requiresExtendsBlock);
            }
        };
        return Script;
    })(AST);
    TypeScript.Script = Script;    
    var NamedDeclaration = (function (_super) {
        __extends(NamedDeclaration, _super);
        function NamedDeclaration(nodeType, name, members) {
            _super.call(this, nodeType);
            this.name = name;
            this.members = members;
        }
        NamedDeclaration.prototype.isDeclaration = function () {
            return true;
        };
        NamedDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.members, ast.members, includingPosition);
        };
        return NamedDeclaration;
    })(AST);
    TypeScript.NamedDeclaration = NamedDeclaration;    
    var ModuleDeclaration = (function (_super) {
        __extends(ModuleDeclaration, _super);
        function ModuleDeclaration(name, members, endingToken) {
            _super.call(this, TypeScript.NodeType.ModuleDeclaration, name, members);
            this.endingToken = endingToken;
            this._moduleFlags = TypeScript.ModuleFlags.None;
            this.mod = null;
            this.amdDependencies = [];
            this.containsUnicodeChar = false;
            this.containsUnicodeCharInComment = false;
            this.prettyName = this.name.actualText;
        }
        ModuleDeclaration.prototype.getModuleFlags = function () {
            return this._moduleFlags;
        };
        ModuleDeclaration.prototype.setModuleFlags = function (flags) {
            this._moduleFlags = flags;
        };
        ModuleDeclaration.prototype.structuralEquals = function (ast, includePosition) {
            if (_super.prototype.structuralEquals.call(this, ast, includePosition)) {
                return this._moduleFlags === ast._moduleFlags;
            }
            return false;
        };
        ModuleDeclaration.prototype.isEnum = function () {
            return TypeScript.hasFlag(this.getModuleFlags(), TypeScript.ModuleFlags.IsEnum);
        };
        ModuleDeclaration.prototype.isWholeFile = function () {
            return TypeScript.hasFlag(this.getModuleFlags(), TypeScript.ModuleFlags.IsWholeFile);
        };
        ModuleDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckModule(this);
        };
        ModuleDeclaration.prototype.shouldEmit = function () {
            for(var i = 0, n = this.members.members.length; i < n; i++) {
                var member = this.members.members[i];
                if (member.nodeType === TypeScript.NodeType.ModuleDeclaration) {
                    if ((member).shouldEmit()) {
                        return true;
                    }
                } else if (member.nodeType !== TypeScript.NodeType.InterfaceDeclaration) {
                    return true;
                }
            }
            return false;
        };
        ModuleDeclaration.prototype.emit = function (emitter, startLine) {
            if (this.shouldEmit()) {
                emitter.emitComments(this, true);
                emitter.emitJavascriptModule(this);
                emitter.emitComments(this, false);
            }
        };
        return ModuleDeclaration;
    })(NamedDeclaration);
    TypeScript.ModuleDeclaration = ModuleDeclaration;    
    var TypeDeclaration = (function (_super) {
        __extends(TypeDeclaration, _super);
        function TypeDeclaration(nodeType, name, typeParameters, extendsList, implementsList, members) {
            _super.call(this, nodeType, name, members);
            this.typeParameters = typeParameters;
            this.extendsList = extendsList;
            this.implementsList = implementsList;
            this._varFlags = TypeScript.VariableFlags.None;
        }
        TypeDeclaration.prototype.getVarFlags = function () {
            return this._varFlags;
        };
        TypeDeclaration.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };
        TypeDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.typeParameters, ast.typeParameters, includingPosition) && structuralEquals(this.extendsList, ast.extendsList, includingPosition) && structuralEquals(this.implementsList, ast.implementsList, includingPosition);
        };
        return TypeDeclaration;
    })(NamedDeclaration);
    TypeScript.TypeDeclaration = TypeDeclaration;    
    var ClassDeclaration = (function (_super) {
        __extends(ClassDeclaration, _super);
        function ClassDeclaration(name, typeParameters, members, extendsList, implementsList) {
            _super.call(this, TypeScript.NodeType.ClassDeclaration, name, typeParameters, extendsList, implementsList, members);
            this.constructorDecl = null;
            this.endingToken = null;
        }
        ClassDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckClass(this);
        };
        ClassDeclaration.prototype.emit = function (emitter, startLine) {
            emitter.emitJavascriptClass(this);
        };
        return ClassDeclaration;
    })(TypeDeclaration);
    TypeScript.ClassDeclaration = ClassDeclaration;    
    var InterfaceDeclaration = (function (_super) {
        __extends(InterfaceDeclaration, _super);
        function InterfaceDeclaration(name, typeParameters, members, extendsList, implementsList) {
            _super.call(this, TypeScript.NodeType.InterfaceDeclaration, name, typeParameters, extendsList, implementsList, members);
        }
        InterfaceDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckInterface(this);
        };
        InterfaceDeclaration.prototype.emit = function (emitter, startLine) {
        };
        return InterfaceDeclaration;
    })(TypeDeclaration);
    TypeScript.InterfaceDeclaration = InterfaceDeclaration;    
    var Statement = (function (_super) {
        __extends(Statement, _super);
        function Statement(nodeType) {
            _super.call(this, nodeType);
        }
        Statement.prototype.isStatement = function () {
            return true;
        };
        Statement.prototype.isStatementOrExpression = function () {
            return true;
        };
        Statement.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.voidType;
            return this;
        };
        return Statement;
    })(AST);
    TypeScript.Statement = Statement;    
    var ThrowStatement = (function (_super) {
        __extends(ThrowStatement, _super);
        function ThrowStatement(expression) {
            _super.call(this, TypeScript.NodeType.ThrowStatement);
            this.expression = expression;
        }
        ThrowStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("throw ");
            emitter.emitJavascript(this.expression, false);
            emitter.writeToOutput(";");
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        ThrowStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ThrowStatement;
    })(Statement);
    TypeScript.ThrowStatement = ThrowStatement;    
    var ExpressionStatement = (function (_super) {
        __extends(ExpressionStatement, _super);
        function ExpressionStatement(expression) {
            _super.call(this, TypeScript.NodeType.ExpressionStatement);
            this.expression = expression;
        }
        ExpressionStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            this.expression.emit(emitter, startLine);
            emitter.writeToOutput(";");
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        ExpressionStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ExpressionStatement;
    })(Statement);
    TypeScript.ExpressionStatement = ExpressionStatement;    
    var LabeledStatement = (function (_super) {
        __extends(LabeledStatement, _super);
        function LabeledStatement(identifier, statement) {
            _super.call(this, TypeScript.NodeType.LabeledStatement);
            this.identifier = identifier;
            this.statement = statement;
        }
        LabeledStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.recordSourceMappingStart(this.identifier);
            emitter.writeToOutput(this.identifier.actualText);
            emitter.recordSourceMappingEnd(this.identifier);
            emitter.writeLineToOutput(":");
            this.statement.emit(emitter, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        LabeledStatement.prototype.typeCheck = function (typeFlow) {
            this.statement = this.statement.typeCheck(typeFlow);
            return this;
        };
        LabeledStatement.prototype.addToControlFlow = function (context) {
            var beforeBB = context.current;
            var bb = new TypeScript.BasicBlock();
            context.current = bb;
            beforeBB.addSuccessor(bb);
        };
        LabeledStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.identifier, ast.identifier, includingPosition) && structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return LabeledStatement;
    })(Statement);
    TypeScript.LabeledStatement = LabeledStatement;    
    var VariableDeclaration = (function (_super) {
        __extends(VariableDeclaration, _super);
        function VariableDeclaration(declarators) {
            _super.call(this, TypeScript.NodeType.VariableDeclaration);
            this.declarators = declarators;
        }
        VariableDeclaration.prototype.emit = function (emitter, startLine) {
            emitter.emitJavascriptVariableDeclaration(this, startLine);
        };
        VariableDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declarators, ast.declarators, includingPosition);
        };
        return VariableDeclaration;
    })(AST);
    TypeScript.VariableDeclaration = VariableDeclaration;    
    var VariableStatement = (function (_super) {
        __extends(VariableStatement, _super);
        function VariableStatement(declaration) {
            _super.call(this, TypeScript.NodeType.VariableStatement);
            this.declaration = declaration;
        }
        VariableStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.emitJavascript(this.declaration, startLine);
            var varDecl = this.declaration.declarators.members[0];
            var isAmbientWithoutInit = TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Ambient) && varDecl.init === null;
            if (!isAmbientWithoutInit) {
                emitter.writeToOutput(";");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        VariableStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declaration, ast.declaration, includingPosition);
        };
        return VariableStatement;
    })(Statement);
    TypeScript.VariableStatement = VariableStatement;    
    var Block = (function (_super) {
        __extends(Block, _super);
        function Block(statements) {
            _super.call(this, TypeScript.NodeType.Block);
            this.statements = statements;
            this.closeBraceSpan = null;
        }
        Block.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();
            var temp = emitter.setInObjectLiteral(false);
            if (this.statements) {
                emitter.emitJavascriptList(this.statements, null, true, false, false);
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        Block.prototype.addToControlFlow = function (context) {
            var afterIfNeeded = new TypeScript.BasicBlock();
            context.pushStatement(this, context.current, afterIfNeeded);
            if (this.statements) {
                context.walk(this.statements, this);
            }
            context.walker.options.goChildren = false;
            context.popStatement();
            if (afterIfNeeded.predecessors.length > 0) {
                context.current.addSuccessor(afterIfNeeded);
                context.current = afterIfNeeded;
            }
        };
        Block.prototype.typeCheck = function (typeFlow) {
            if (!typeFlow.checker.styleSettings.emptyBlocks) {
                if ((this.statements === null) || (this.statements.members.length === 0)) {
                    typeFlow.checker.errorReporter.styleError(this, "empty block");
                }
            }
            typeFlow.typeCheck(this.statements);
            return this;
        };
        Block.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.statements, ast.statements, includingPosition);
        };
        return Block;
    })(Statement);
    TypeScript.Block = Block;    
    var Jump = (function (_super) {
        __extends(Jump, _super);
        function Jump(nodeType) {
            _super.call(this, nodeType);
            this.target = null;
            this.resolvedTarget = null;
        }
        Jump.prototype.hasExplicitTarget = function () {
            return (this.target);
        };
        Jump.prototype.addToControlFlow = function (context) {
            _super.prototype.addToControlFlow.call(this, context);
            context.unconditionalBranch(this.resolvedTarget, (this.nodeType === TypeScript.NodeType.ContinueStatement));
        };
        Jump.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType === TypeScript.NodeType.BreakStatement) {
                emitter.writeToOutput("break");
            } else {
                emitter.writeToOutput("continue");
            }
            if (this.hasExplicitTarget()) {
                emitter.writeToOutput(" " + this.target);
            }
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitComments(this, false);
        };
        Jump.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.target === ast.target;
        };
        return Jump;
    })(Statement);
    TypeScript.Jump = Jump;    
    var WhileStatement = (function (_super) {
        __extends(WhileStatement, _super);
        function WhileStatement(cond, body) {
            _super.call(this, TypeScript.NodeType.WhileStatement);
            this.cond = cond;
            this.body = body;
        }
        WhileStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("while(");
            emitter.emitJavascript(this.cond, false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, false);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        WhileStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckWhile(this);
        };
        WhileStatement.prototype.addToControlFlow = function (context) {
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            context.addContent(this.cond);
            var condBlock = context.current;
            var targetInfo = null;
            if (this.body) {
                context.current = new TypeScript.BasicBlock();
                condBlock.addSuccessor(context.current);
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            condBlock.addSuccessor(afterLoop);
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        };
        WhileStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WhileStatement;
    })(Statement);
    TypeScript.WhileStatement = WhileStatement;    
    var DoStatement = (function (_super) {
        __extends(DoStatement, _super);
        function DoStatement(body, cond) {
            _super.call(this, TypeScript.NodeType.DoStatement);
            this.body = body;
            this.cond = cond;
            this.whileSpan = null;
        }
        DoStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("do");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingStart(this.whileSpan);
            emitter.writeToOutput(" while");
            emitter.recordSourceMappingEnd(this.whileSpan);
            emitter.writeToOutput('(');
            emitter.emitJavascript(this.cond, false);
            emitter.writeToOutput(")");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitComments(this, false);
        };
        DoStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckDo(this);
        };
        DoStatement.prototype.addToControlFlow = function (context) {
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var targetInfo = null;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
                context.addContent(this.cond);
                context.current = afterLoop;
                loopEnd.addSuccessor(afterLoop);
            } else {
                context.addUnreachable(this.cond);
            }
            context.walker.options.goChildren = false;
        };
        DoStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.body, ast.body, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition);
        };
        return DoStatement;
    })(Statement);
    TypeScript.DoStatement = DoStatement;    
    var IfStatement = (function (_super) {
        __extends(IfStatement, _super);
        function IfStatement(cond, thenBod, elseBod) {
            _super.call(this, TypeScript.NodeType.IfStatement);
            this.cond = cond;
            this.thenBod = thenBod;
            this.elseBod = elseBod;
            this.statement = new ASTSpan();
        }
        IfStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("if (");
            emitter.emitJavascript(this.cond, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.thenBod, true);
            if (this.elseBod) {
                if (this.elseBod.nodeType === TypeScript.NodeType.IfStatement) {
                    emitter.writeToOutput(" else ");
                    this.elseBod.emit(emitter, false);
                } else {
                    emitter.writeToOutput(" else");
                    emitter.emitJavascriptStatements(this.elseBod, true);
                }
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        IfStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckIf(this);
        };
        IfStatement.prototype.addToControlFlow = function (context) {
            this.cond.addToControlFlow(context);
            var afterIf = new TypeScript.BasicBlock();
            var beforeIf = context.current;
            context.pushStatement(this, beforeIf, afterIf);
            var hasContinuation = false;
            context.current = new TypeScript.BasicBlock();
            beforeIf.addSuccessor(context.current);
            context.walk(this.thenBod, this);
            if (!context.noContinuation) {
                hasContinuation = true;
                context.current.addSuccessor(afterIf);
            }
            if (this.elseBod) {
                context.current = new TypeScript.BasicBlock();
                context.noContinuation = false;
                beforeIf.addSuccessor(context.current);
                context.walk(this.elseBod, this);
                if (!context.noContinuation) {
                    hasContinuation = true;
                    context.current.addSuccessor(afterIf);
                } else {
                    if (hasContinuation) {
                        context.noContinuation = false;
                    }
                }
            } else {
                beforeIf.addSuccessor(afterIf);
                context.noContinuation = false;
                hasContinuation = true;
            }
            var targetInfo = context.popStatement();
            if (afterIf.predecessors.length > 0) {
                context.noContinuation = false;
                hasContinuation = true;
            }
            if (hasContinuation) {
                context.current = afterIf;
            }
            context.walker.options.goChildren = false;
        };
        IfStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.thenBod, ast.thenBod, includingPosition) && structuralEquals(this.elseBod, ast.elseBod, includingPosition);
        };
        return IfStatement;
    })(Statement);
    TypeScript.IfStatement = IfStatement;    
    var ReturnStatement = (function (_super) {
        __extends(ReturnStatement, _super);
        function ReturnStatement(returnExpression) {
            _super.call(this, TypeScript.NodeType.ReturnStatement);
            this.returnExpression = returnExpression;
        }
        ReturnStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            if (this.returnExpression) {
                emitter.writeToOutput("return ");
                emitter.emitJavascript(this.returnExpression, false);
                emitter.writeToOutput(";");
            } else {
                emitter.writeToOutput("return;");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        ReturnStatement.prototype.addToControlFlow = function (context) {
            _super.prototype.addToControlFlow.call(this, context);
            context.returnStmt();
        };
        ReturnStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckReturn(this);
        };
        ReturnStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.returnExpression, ast.returnExpression, includingPosition);
        };
        return ReturnStatement;
    })(Statement);
    TypeScript.ReturnStatement = ReturnStatement;    
    var ForInStatement = (function (_super) {
        __extends(ForInStatement, _super);
        function ForInStatement(lval, obj, body) {
            _super.call(this, TypeScript.NodeType.ForInStatement);
            this.lval = lval;
            this.obj = obj;
            this.body = body;
            this.statement = new ASTSpan();
        }
        ForInStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("for(");
            emitter.emitJavascript(this.lval, false);
            emitter.writeToOutput(" in ");
            emitter.emitJavascript(this.obj, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        ForInStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckForIn(this);
        };
        ForInStatement.prototype.addToControlFlow = function (context) {
            if (this.lval) {
                context.addContent(this.lval);
            }
            if (this.obj) {
                context.addContent(this.obj);
            }
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            context.noContinuation = false;
            loopHeader.addSuccessor(afterLoop);
            context.walker.options.goChildren = false;
        };
        ForInStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.lval, ast.lval, includingPosition) && structuralEquals(this.obj, ast.obj, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForInStatement;
    })(Statement);
    TypeScript.ForInStatement = ForInStatement;    
    var ForStatement = (function (_super) {
        __extends(ForStatement, _super);
        function ForStatement(init, cond, incr, body) {
            _super.call(this, TypeScript.NodeType.ForStatement);
            this.init = init;
            this.cond = cond;
            this.incr = incr;
            this.body = body;
        }
        ForStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("for(");
            if (this.init) {
                if (this.init.nodeType != TypeScript.NodeType.List) {
                    emitter.emitJavascript(this.init, false);
                } else {
                    emitter.setInVarBlock((this.init).members.length);
                    emitter.emitJavascriptList(this.init, null, false, false, false);
                }
            }
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.cond, false);
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.incr, false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        ForStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckFor(this);
        };
        ForStatement.prototype.addToControlFlow = function (context) {
            if (this.init) {
                context.addContent(this.init);
            }
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var condBlock = null;
            var continueTarget = loopStart;
            var incrBB = null;
            if (this.incr) {
                incrBB = new TypeScript.BasicBlock();
                continueTarget = incrBB;
            }
            if (this.cond) {
                condBlock = context.current;
                context.addContent(this.cond);
                context.current = new TypeScript.BasicBlock();
                condBlock.addSuccessor(context.current);
            }
            var targetInfo = null;
            if (this.body) {
                context.pushStatement(this, continueTarget, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (this.incr) {
                if (context.noContinuation) {
                    if (incrBB.predecessors.length === 0) {
                        context.addUnreachable(this.incr);
                    }
                } else {
                    context.current.addSuccessor(incrBB);
                    context.current = incrBB;
                    context.addContent(this.incr);
                }
            }
            var loopEnd = context.current;
            if (!(context.noContinuation)) {
                loopEnd.addSuccessor(loopStart);
            }
            if (condBlock) {
                condBlock.addSuccessor(afterLoop);
                context.noContinuation = false;
            }
            if (afterLoop.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterLoop;
            }
            context.walker.options.goChildren = false;
        };
        ForStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.incr, ast.incr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForStatement;
    })(Statement);
    TypeScript.ForStatement = ForStatement;    
    var WithStatement = (function (_super) {
        __extends(WithStatement, _super);
        function WithStatement(expr, body) {
            _super.call(this, TypeScript.NodeType.WithStatement);
            this.expr = expr;
            this.body = body;
            this.withSym = null;
        }
        WithStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("with (");
            if (this.expr) {
                emitter.emitJavascript(this.expr, false);
            }
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        WithStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckWith(this);
        };
        WithStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WithStatement;
    })(Statement);
    TypeScript.WithStatement = WithStatement;    
    var SwitchStatement = (function (_super) {
        __extends(SwitchStatement, _super);
        function SwitchStatement(val) {
            _super.call(this, TypeScript.NodeType.SwitchStatement);
            this.val = val;
            this.defaultCase = null;
            this.statement = new ASTSpan();
        }
        SwitchStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("switch(");
            emitter.emitJavascript(this.val, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();
            var casesLen = this.caseList.members.length;
            for(var i = 0; i < casesLen; i++) {
                var caseExpr = this.caseList.members[i];
                emitter.emitJavascript(caseExpr, true);
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        SwitchStatement.prototype.typeCheck = function (typeFlow) {
            var len = this.caseList.members.length;
            this.val = typeFlow.typeCheck(this.val);
            for(var i = 0; i < len; i++) {
                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);
            }
            this.defaultCase = typeFlow.typeCheck(this.defaultCase);
            this.type = typeFlow.voidType;
            return this;
        };
        SwitchStatement.prototype.addToControlFlow = function (context) {
            var condBlock = context.current;
            context.addContent(this.val);
            var execBlock = new TypeScript.BasicBlock();
            var afterSwitch = new TypeScript.BasicBlock();
            condBlock.addSuccessor(execBlock);
            context.pushSwitch(execBlock);
            context.current = execBlock;
            context.pushStatement(this, execBlock, afterSwitch);
            context.walk(this.caseList, this);
            context.popSwitch();
            var targetInfo = context.popStatement();
            var hasCondContinuation = (this.defaultCase === null);
            if (this.defaultCase === null) {
                condBlock.addSuccessor(afterSwitch);
            }
            if (afterSwitch.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterSwitch;
            } else {
                context.noContinuation = true;
            }
            context.walker.options.goChildren = false;
        };
        SwitchStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.caseList, ast.caseList, includingPosition) && structuralEquals(this.val, ast.val, includingPosition);
        };
        return SwitchStatement;
    })(Statement);
    TypeScript.SwitchStatement = SwitchStatement;    
    var CaseClause = (function (_super) {
        __extends(CaseClause, _super);
        function CaseClause() {
            _super.call(this, TypeScript.NodeType.CaseClause);
            this.expr = null;
            this.colonSpan = new ASTSpan();
        }
        CaseClause.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.expr) {
                emitter.writeToOutput("case ");
                emitter.emitJavascript(this.expr, false);
            } else {
                emitter.writeToOutput("default");
            }
            emitter.recordSourceMappingStart(this.colonSpan);
            emitter.writeToOutput(":");
            emitter.recordSourceMappingEnd(this.colonSpan);
            if (this.body.members.length === 1 && this.body.members[0].nodeType === TypeScript.NodeType.Block) {
                emitter.emitJavascriptStatements(this.body, false);
            } else {
                emitter.writeLineToOutput("");
                emitter.indenter.increaseIndent();
                emitter.emitJavascript(this.body, true);
                emitter.indenter.decreaseIndent();
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        CaseClause.prototype.typeCheck = function (typeFlow) {
            this.expr = typeFlow.typeCheck(this.expr);
            typeFlow.typeCheck(this.body);
            this.type = typeFlow.voidType;
            return this;
        };
        CaseClause.prototype.addToControlFlow = function (context) {
            var execBlock = new TypeScript.BasicBlock();
            var sw = context.currentSwitch[context.currentSwitch.length - 1];
            if (this.expr) {
                var exprBlock = new TypeScript.BasicBlock();
                context.current = exprBlock;
                sw.addSuccessor(exprBlock);
                context.addContent(this.expr);
                exprBlock.addSuccessor(execBlock);
            } else {
                sw.addSuccessor(execBlock);
            }
            context.current = execBlock;
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        };
        CaseClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CaseClause;
    })(AST);
    TypeScript.CaseClause = CaseClause;    
    var TypeParameter = (function (_super) {
        __extends(TypeParameter, _super);
        function TypeParameter(name, constraint) {
            _super.call(this, TypeScript.NodeType.TypeParameter);
            this.name = name;
            this.constraint = constraint;
        }
        TypeParameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.constraint, ast.constraint, includingPosition);
        };
        return TypeParameter;
    })(AST);
    TypeScript.TypeParameter = TypeParameter;    
    var GenericType = (function (_super) {
        __extends(GenericType, _super);
        function GenericType(name, typeArguments) {
            _super.call(this, TypeScript.NodeType.GenericType);
            this.name = name;
            this.typeArguments = typeArguments;
        }
        GenericType.prototype.emit = function (emitter, startLine) {
            emitter.emitJavascript(this.name, false);
        };
        GenericType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition);
        };
        return GenericType;
    })(AST);
    TypeScript.GenericType = GenericType;    
    var TypeReference = (function (_super) {
        __extends(TypeReference, _super);
        function TypeReference(term, arrayCount) {
            _super.call(this, TypeScript.NodeType.TypeRef);
            this.term = term;
            this.arrayCount = arrayCount;
        }
        TypeReference.prototype.emit = function (emitter, startLine) {
            throw new Error("should not emit a type ref");
        };
        TypeReference.prototype.typeCheck = function (typeFlow) {
            var prevInTCTR = typeFlow.inTypeRefTypeCheck;
            typeFlow.inTypeRefTypeCheck = true;
            var typeLink = TypeScript.getTypeLink(this, typeFlow.checker, true);
            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);
            if (this.term) {
                typeFlow.typeCheck(this.term);
            }
            typeFlow.checkForVoidConstructor(typeLink.type, this);
            this.type = typeLink.type;
            if (this.term) {
                this.term.type = this.type;
            }
            typeFlow.inTypeRefTypeCheck = prevInTCTR;
            return this;
        };
        TypeReference.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.term, ast.term, includingPosition) && this.arrayCount === ast.arrayCount;
        };
        return TypeReference;
    })(AST);
    TypeScript.TypeReference = TypeReference;    
    var TryStatement = (function (_super) {
        __extends(TryStatement, _super);
        function TryStatement(tryBody, catchClause, finallyBody) {
            _super.call(this, TypeScript.NodeType.TryStatement);
            this.tryBody = tryBody;
            this.catchClause = catchClause;
            this.finallyBody = finallyBody;
        }
        TryStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("try ");
            emitter.emitJavascript(this.tryBody, false);
            emitter.emitJavascript(this.catchClause, false);
            if (this.finallyBody) {
                emitter.writeToOutput(" finally");
                emitter.emitJavascript(this.finallyBody, false);
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        TryStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.tryBody, ast.tryBody, includingPosition) && structuralEquals(this.catchClause, ast.catchClause, includingPosition) && structuralEquals(this.finallyBody, ast.finallyBody, includingPosition);
        };
        return TryStatement;
    })(Statement);
    TypeScript.TryStatement = TryStatement;    
    var CatchClause = (function (_super) {
        __extends(CatchClause, _super);
        function CatchClause(param, body) {
            _super.call(this, TypeScript.NodeType.CatchClause);
            this.param = param;
            this.body = body;
            this.statement = new ASTSpan();
            this.containedScope = null;
        }
        CatchClause.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(" ");
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("catch (");
            emitter.emitJavascript(this.param.id, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascript(this.body, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        CatchClause.prototype.addToControlFlow = function (context) {
            if (this.param) {
                context.addContent(this.param);
                var bodBlock = new TypeScript.BasicBlock();
                context.current.addSuccessor(bodBlock);
                context.current = bodBlock;
            }
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        };
        CatchClause.prototype.typeCheck = function (typeFlow) {
            var prevScope = typeFlow.scope;
            typeFlow.scope = this.containedScope;
            this.param = typeFlow.typeCheck(this.param);
            var exceptVar = new TypeScript.ValueLocation();
            var varSym = new TypeScript.VariableSymbol((this.param).id.text, this.param.minChar, null, exceptVar);
            exceptVar.symbol = varSym;
            exceptVar.typeLink = new TypeScript.TypeLink();
            exceptVar.typeLink.type = typeFlow.anyType;
            var thisFnc = typeFlow.thisFnc;
            if (thisFnc && thisFnc.type) {
                exceptVar.symbol.container = thisFnc.type.symbol;
            } else {
                exceptVar.symbol.container = null;
            }
            this.param.sym = exceptVar.symbol;
            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol, typeFlow.checker.errorReporter, false, false, false);
            this.body = typeFlow.typeCheck(this.body);
            if (typeFlow.checker.inProvisionalTypecheckMode()) {
                var table = typeFlow.scope.getTable();
                (table).secondaryTable.table[exceptVar.symbol.name] = undefined;
            }
            this.type = typeFlow.voidType;
            typeFlow.scope = prevScope;
            return this;
        };
        CatchClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.param, ast.param, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CatchClause;
    })(AST);
    TypeScript.CatchClause = CatchClause;    
    var DebuggerStatement = (function (_super) {
        __extends(DebuggerStatement, _super);
        function DebuggerStatement() {
            _super.call(this, TypeScript.NodeType.DebuggerStatement);
        }
        DebuggerStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("debugger");
            emitter.recordSourceMappingEnd(this);
            emitter.writeLineToOutput(";");
            emitter.emitComments(this, false);
        };
        return DebuggerStatement;
    })(Statement);
    TypeScript.DebuggerStatement = DebuggerStatement;    
    var OmittedExpression = (function (_super) {
        __extends(OmittedExpression, _super);
        function OmittedExpression() {
            _super.call(this, TypeScript.NodeType.OmittedExpression);
        }
        OmittedExpression.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.emitComments(this, false);
        };
        OmittedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return OmittedExpression;
    })(Expression);
    TypeScript.OmittedExpression = OmittedExpression;    
    var EmptyStatement = (function (_super) {
        __extends(EmptyStatement, _super);
        function EmptyStatement() {
            _super.call(this, TypeScript.NodeType.EmptyStatement);
        }
        EmptyStatement.prototype.emit = function (emitter, startLine) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(";");
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };
        EmptyStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return EmptyStatement;
    })(Statement);
    TypeScript.EmptyStatement = EmptyStatement;    
    var Comment = (function (_super) {
        __extends(Comment, _super);
        function Comment(content, isBlockComment, endsLine) {
            _super.call(this, TypeScript.NodeType.Comment);
            this.content = content;
            this.isBlockComment = isBlockComment;
            this.endsLine = endsLine;
            this.text = null;
            this.docCommentText = null;
        }
        Comment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.minLine === ast.minLine && this.content === ast.content && this.isBlockComment === ast.isBlockComment && this.endsLine === ast.endsLine;
        };
        Comment.prototype.getText = function () {
            if (this.text === null) {
                if (this.isBlockComment) {
                    this.text = this.content.split("\n");
                    for(var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
                    }
                } else {
                    this.text = [
                        (this.content.replace(/^\s+|\s+$/g, ''))
                    ];
                }
            }
            return this.text;
        };
        Comment.prototype.isDocComment = function () {
            if (this.isBlockComment) {
                return this.content.charAt(2) === "*" && this.content.charAt(3) != "/";
            }
            return false;
        };
        Comment.prototype.getDocCommentTextValue = function () {
            if (this.docCommentText === null) {
                this.docCommentText = Comment.cleanJSDocComment(this.content);
            }
            return this.docCommentText;
        };
        Comment.consumeLeadingSpace = function consumeLeadingSpace(line, startIndex, maxSpacesToRemove) {
            var endIndex = line.length;
            if (maxSpacesToRemove != undefined) {
                endIndex = TypeScript.min(startIndex + maxSpacesToRemove, endIndex);
            }
            for(; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode !== TypeScript.CharacterCodes.space && charCode !== TypeScript.CharacterCodes.tab) {
                    return startIndex;
                }
            }
            if (endIndex != line.length) {
                return endIndex;
            }
            return -1;
        };
        Comment.isSpaceChar = function isSpaceChar(line, index) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);
                return charCode === TypeScript.CharacterCodes.space || charCode === TypeScript.CharacterCodes.tab;
            }
            return index === length;
        };
        Comment.cleanDocCommentLine = function cleanDocCommentLine(line, jsDocStyleComment, jsDocLineSpaceToRemove) {
            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex != -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') {
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);
                    if (nonSpaceIndex != -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }
                return {
                    minChar: nonSpaceIndex,
                    limChar: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }
            return null;
        };
        Comment.cleanJSDocComment = function cleanJSDocComment(content, spacesToRemove) {
            var docCommentLines = [];
            content = content.replace("/**", "");
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2);
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for(var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    continue;
                }
                var docCommentText = "";
                var prevPos = cleanLinePos.minChar;
                for(var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {
                    var wasInParamtag = inParamTag;
                    if (line.indexOf("param", i + 1) === i + 1 && Comment.isSpaceChar(line, i + 6)) {
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }
                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        prevPos = i;
                        inParamTag = false;
                    }
                }
                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);
                }
                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }
            return docCommentLines.join("\n");
        };
        Comment.getDocCommentText = function getDocCommentText(comments) {
            var docCommentText = [];
            for(var c = 0; c < comments.length; c++) {
                var commentText = comments[c].getDocCommentTextValue();
                if (commentText != "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        };
        Comment.getParameterDocCommentText = function getParameterDocCommentText(param, fncDocComments) {
            if (fncDocComments.length === 0 || !fncDocComments[0].isBlockComment) {
                return "";
            }
            for(var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].content;
                for(var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!Comment.isSpaceChar(commentContents, j)) {
                        continue;
                    }
                    j = Comment.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }
                    if (commentContents.charCodeAt(j) === TypeScript.CharacterCodes.openBrace) {
                        j++;
                        var charCode = 0;
                        for(var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);
                            if (charCode === TypeScript.CharacterCodes.openBrace) {
                                curlies++;
                                continue;
                            }
                            if (charCode === TypeScript.CharacterCodes.closeBrace) {
                                curlies--;
                                if (curlies === 0) {
                                    break;
                                } else {
                                    continue;
                                }
                            }
                            if (charCode === TypeScript.CharacterCodes.at) {
                                break;
                            }
                        }
                        if (j === commentContents.length) {
                            break;
                        }
                        if (charCode === TypeScript.CharacterCodes.at) {
                            continue;
                        }
                        j = Comment.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }
                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {
                        continue;
                    }
                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }
                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);
                    var paramSpacesToRemove = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex != 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }
                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }
            return "";
        };
        Comment.getDocCommentFirstOverloadSignature = function getDocCommentFirstOverloadSignature(signatureGroup) {
            for(var i = 0; i < signatureGroup.signatures.length; i++) {
                var signature = signatureGroup.signatures[i];
                if (signature === signatureGroup.definitionSignature) {
                    continue;
                }
                return TypeScript.Comment.getDocCommentText(signature.declAST.getDocComments());
            }
            return "";
        };
        return Comment;
    })(AST);
    TypeScript.Comment = Comment;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
        }
        return AstWalkOptions;
    })();
    TypeScript.AstWalkOptions = AstWalkOptions;    
    var AstWalker = (function () {
        function AstWalker(childrenWalkers, pre, post, options, state) {
            this.childrenWalkers = childrenWalkers;
            this.pre = pre;
            this.post = post;
            this.options = options;
            this.state = state;
        }
        AstWalker.prototype.walk = function (ast, parent) {
            var preAst = this.pre(ast, parent, this);
            if (preAst === undefined) {
                preAst = ast;
            }
            if (this.options.goChildren) {
                this.childrenWalkers[ast.nodeType](ast, parent, this);
            } else {
                this.options.goChildren = true;
            }
            if (this.post) {
                var postAst = this.post(preAst, parent, this);
                if (postAst === undefined) {
                    postAst = preAst;
                }
                return postAst;
            } else {
                return preAst;
            }
        };
        return AstWalker;
    })();    
    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
            this.childrenWalkers = [];
            this.initChildrenWalkers();
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, options, state) {
            return this.getWalker(pre, post, options, state).walk(ast, null);
        };
        AstWalkerFactory.prototype.getWalker = function (pre, post, options, state) {
            return this.getSlowWalker(pre, post, options, state);
        };
        AstWalkerFactory.prototype.getSlowWalker = function (pre, post, options, state) {
            if (!options) {
                options = new AstWalkOptions();
            }
            return new AstWalker(this.childrenWalkers, pre, post, options, state);
        };
        AstWalkerFactory.prototype.initChildrenWalkers = function () {
            this.childrenWalkers[TypeScript.NodeType.None] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.EmptyStatement] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.OmittedExpression] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.TrueLiteral] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.FalseLiteral] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.ThisExpression] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.SuperExpression] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.StringLiteral] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.RegularExpressionLiteral] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.NullLiteral] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.ArrayLiteralExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.ObjectLiteralExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.VoidExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.CommaExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.PlusExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.NegateExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.DeleteExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.InExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.MemberAccessExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.InstanceOfExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.TypeOfExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.NumericLiteral] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.Name] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.TypeParameter] = ChildrenWalkers.walkTypeParameterChildren;
            this.childrenWalkers[TypeScript.NodeType.GenericType] = ChildrenWalkers.walkGenericTypeChildren;
            this.childrenWalkers[TypeScript.NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;
            this.childrenWalkers[TypeScript.NodeType.ElementAccessExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.InvocationExpression] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.ObjectCreationExpression] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.AssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.AddAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.SubtractAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.DivideAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.MultiplyAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.ModuloAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.AndAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.ExclusiveOrAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.OrAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.LeftShiftAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.SignedRightShiftAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.UnsignedRightShiftAssignmentExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.LogicalOrExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.LogicalAndExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.BitwiseOrExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.BitwiseExclusiveOrExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.BitwiseAndExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.EqualsWithTypeConversionExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.NotEqualsWithTypeConversionExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.EqualsExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.NotEqualsExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.LessThanExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.LessThanOrEqualExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.GreaterThanExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.GreaterThanOrEqualExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.AddExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.SubtractExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.MultiplyExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.DivideExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.ModuloExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.LeftShiftExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.SignedRightShiftExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.UnsignedRightShiftExpression] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.BitwiseNotExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.LogicalNotExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.PreIncrementExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.PreDecrementExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.PostIncrementExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.PostDecrementExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.CastExpression] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.ParenthesizedExpression] = ChildrenWalkers.walkParenthesizedExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.FunctionDeclaration] = ChildrenWalkers.walkFuncDeclChildren;
            this.childrenWalkers[TypeScript.NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[TypeScript.NodeType.VariableDeclarator] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[TypeScript.NodeType.VariableDeclaration] = ChildrenWalkers.walkVariableDeclarationChildren;
            this.childrenWalkers[TypeScript.NodeType.Parameter] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[TypeScript.NodeType.ReturnStatement] = ChildrenWalkers.walkReturnStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.BreakStatement] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.ContinueStatement] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.ThrowStatement] = ChildrenWalkers.walkThrowStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.ForStatement] = ChildrenWalkers.walkForStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.ForInStatement] = ChildrenWalkers.walkForInStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.IfStatement] = ChildrenWalkers.walkIfStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.WhileStatement] = ChildrenWalkers.walkWhileStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.DoStatement] = ChildrenWalkers.walkDoStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.Block] = ChildrenWalkers.walkBlockChildren;
            this.childrenWalkers[TypeScript.NodeType.CaseClause] = ChildrenWalkers.walkCaseClauseChildren;
            this.childrenWalkers[TypeScript.NodeType.SwitchStatement] = ChildrenWalkers.walkSwitchStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.TryStatement] = ChildrenWalkers.walkTryStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.CatchClause] = ChildrenWalkers.walkCatchClauseChildren;
            this.childrenWalkers[TypeScript.NodeType.List] = ChildrenWalkers.walkListChildren;
            this.childrenWalkers[TypeScript.NodeType.Script] = ChildrenWalkers.walkScriptChildren;
            this.childrenWalkers[TypeScript.NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;
            this.childrenWalkers[TypeScript.NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;
            this.childrenWalkers[TypeScript.NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;
            this.childrenWalkers[TypeScript.NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;
            this.childrenWalkers[TypeScript.NodeType.ExportAssignment] = ChildrenWalkers.walkExportAssignmentChildren;
            this.childrenWalkers[TypeScript.NodeType.WithStatement] = ChildrenWalkers.walkWithStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.ExpressionStatement] = ChildrenWalkers.walkExpressionStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.VariableStatement] = ChildrenWalkers.walkVariableStatementChildren;
            this.childrenWalkers[TypeScript.NodeType.Comment] = ChildrenWalkers.walkNone;
            this.childrenWalkers[TypeScript.NodeType.DebuggerStatement] = ChildrenWalkers.walkNone;
            for(var e in (TypeScript.NodeType)._map) {
                if ((this.childrenWalkers)[e] === undefined) {
                    throw new Error("initWalkers function is not up to date with enum content!");
                }
            }
        };
        return AstWalkerFactory;
    })();
    TypeScript.AstWalkerFactory = AstWalkerFactory;    
    var globalAstWalkerFactory;
    function getAstWalkerFactory() {
        if (!globalAstWalkerFactory) {
            globalAstWalkerFactory = new AstWalkerFactory();
        }
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;
    var ChildrenWalkers;
    (function (ChildrenWalkers) {
        function walkNone(preAst, parent, walker) {
        }
        ChildrenWalkers.walkNone = walkNone;
        function walkListChildren(preAst, parent, walker) {
            var len = preAst.members.length;
            for(var i = 0; i < len; i++) {
                preAst.members[i] = walker.walk(preAst.members[i], preAst);
            }
        }
        ChildrenWalkers.walkListChildren = walkListChildren;
        function walkThrowStatementChildren(preAst, parent, walker) {
            if (preAst.expression) {
                preAst.expression = walker.walk(preAst.expression, preAst);
            }
        }
        ChildrenWalkers.walkThrowStatementChildren = walkThrowStatementChildren;
        function walkUnaryExpressionChildren(preAst, parent, walker) {
            if (preAst.castTerm) {
                preAst.castTerm = walker.walk(preAst.castTerm, preAst);
            }
            if (preAst.operand) {
                preAst.operand = walker.walk(preAst.operand, preAst);
            }
        }
        ChildrenWalkers.walkUnaryExpressionChildren = walkUnaryExpressionChildren;
        function walkParenthesizedExpressionChildren(preAst, parent, walker) {
            if (preAst.expression) {
                preAst.expression = walker.walk(preAst.expression, preAst);
            }
        }
        ChildrenWalkers.walkParenthesizedExpressionChildren = walkParenthesizedExpressionChildren;
        function walkBinaryExpressionChildren(preAst, parent, walker) {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
        }
        ChildrenWalkers.walkBinaryExpressionChildren = walkBinaryExpressionChildren;
        function walkTypeParameterChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.constraint) {
                preAst.constraint = walker.walk(preAst.constraint, preAst);
            }
        }
        ChildrenWalkers.walkTypeParameterChildren = walkTypeParameterChildren;
        function walkGenericTypeChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
        }
        ChildrenWalkers.walkGenericTypeChildren = walkGenericTypeChildren;
        function walkTypeReferenceChildren(preAst, parent, walker) {
            if (preAst.term) {
                preAst.term = walker.walk(preAst.term, preAst);
            }
        }
        ChildrenWalkers.walkTypeReferenceChildren = walkTypeReferenceChildren;
        function walkCallExpressionChildren(preAst, parent, walker) {
            preAst.target = walker.walk(preAst.target, preAst);
            if (preAst.arguments) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
        }
        ChildrenWalkers.walkCallExpressionChildren = walkCallExpressionChildren;
        function walkTrinaryExpressionChildren(preAst, parent, walker) {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
            if (preAst.operand3) {
                preAst.operand3 = walker.walk(preAst.operand3, preAst);
            }
        }
        ChildrenWalkers.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;
        function walkFuncDeclChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
            if (preAst.arguments) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
            if (preAst.returnTypeAnnotation) {
                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);
            }
            if (preAst.block) {
                preAst.block = walker.walk(preAst.block, preAst);
            }
        }
        ChildrenWalkers.walkFuncDeclChildren = walkFuncDeclChildren;
        function walkBoundDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if (preAst.typeExpr) {
                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);
            }
        }
        ChildrenWalkers.walkBoundDeclChildren = walkBoundDeclChildren;
        function walkReturnStatementChildren(preAst, parent, walker) {
            if (preAst.returnExpression) {
                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);
            }
        }
        ChildrenWalkers.walkReturnStatementChildren = walkReturnStatementChildren;
        function walkForStatementChildren(preAst, parent, walker) {
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if (preAst.cond) {
                preAst.cond = walker.walk(preAst.cond, preAst);
            }
            if (preAst.incr) {
                preAst.incr = walker.walk(preAst.incr, preAst);
            }
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForStatementChildren = walkForStatementChildren;
        function walkForInStatementChildren(preAst, parent, walker) {
            preAst.lval = walker.walk(preAst.lval, preAst);
            preAst.obj = walker.walk(preAst.obj, preAst);
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForInStatementChildren = walkForInStatementChildren;
        function walkIfStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.thenBod) {
                preAst.thenBod = walker.walk(preAst.thenBod, preAst);
            }
            if (preAst.elseBod) {
                preAst.elseBod = walker.walk(preAst.elseBod, preAst);
            }
        }
        ChildrenWalkers.walkIfStatementChildren = walkIfStatementChildren;
        function walkWhileStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWhileStatementChildren = walkWhileStatementChildren;
        function walkDoStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkDoStatementChildren = walkDoStatementChildren;
        function walkBlockChildren(preAst, parent, walker) {
            if (preAst.statements) {
                preAst.statements = walker.walk(preAst.statements, preAst);
            }
        }
        ChildrenWalkers.walkBlockChildren = walkBlockChildren;
        function walkVariableDeclarationChildren(preAst, parent, walker) {
            if (preAst.declarators) {
                preAst.declarators = walker.walk(preAst.declarators, preAst);
            }
        }
        ChildrenWalkers.walkVariableDeclarationChildren = walkVariableDeclarationChildren;
        function walkCaseClauseChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCaseClauseChildren = walkCaseClauseChildren;
        function walkSwitchStatementChildren(preAst, parent, walker) {
            if (preAst.val) {
                preAst.val = walker.walk(preAst.val, preAst);
            }
            if (preAst.caseList) {
                preAst.caseList = walker.walk(preAst.caseList, preAst);
            }
        }
        ChildrenWalkers.walkSwitchStatementChildren = walkSwitchStatementChildren;
        function walkTryStatementChildren(preAst, parent, walker) {
            if (preAst.tryBody) {
                preAst.tryBody = walker.walk(preAst.tryBody, preAst);
            }
            if (preAst.catchClause) {
                preAst.catchClause = walker.walk(preAst.catchClause, preAst);
            }
            if (preAst.finallyBody) {
                preAst.finallyBody = walker.walk(preAst.finallyBody, preAst);
            }
        }
        ChildrenWalkers.walkTryStatementChildren = walkTryStatementChildren;
        function walkCatchClauseChildren(preAst, parent, walker) {
            if (preAst.param) {
                preAst.param = walker.walk(preAst.param, preAst);
            }
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCatchClauseChildren = walkCatchClauseChildren;
        function walkRecordChildren(preAst, parent, walker) {
            preAst.name = walker.walk(preAst.name, preAst);
            if (preAst.members) {
                preAst.members = walker.walk(preAst.members, preAst);
            }
        }
        ChildrenWalkers.walkRecordChildren = walkRecordChildren;
        function walkNamedTypeChildren(preAst, parent, walker) {
            walkRecordChildren(preAst, parent, walker);
        }
        ChildrenWalkers.walkNamedTypeChildren = walkNamedTypeChildren;
        function walkClassDeclChildren(preAst, parent, walker) {
            walkNamedTypeChildren(preAst, parent, walker);
            if (preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }
            if (preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }
            if (preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkClassDeclChildren = walkClassDeclChildren;
        function walkScriptChildren(preAst, parent, walker) {
            if (preAst.moduleElements) {
                preAst.moduleElements = walker.walk(preAst.moduleElements, preAst);
            }
        }
        ChildrenWalkers.walkScriptChildren = walkScriptChildren;
        function walkTypeDeclChildren(preAst, parent, walker) {
            walkNamedTypeChildren(preAst, parent, walker);
            if (preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }
            if (preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }
            if (preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkTypeDeclChildren = walkTypeDeclChildren;
        function walkModuleDeclChildren(preAst, parent, walker) {
            walkRecordChildren(preAst, parent, walker);
        }
        ChildrenWalkers.walkModuleDeclChildren = walkModuleDeclChildren;
        function walkImportDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.alias) {
                preAst.alias = walker.walk(preAst.alias, preAst);
            }
        }
        ChildrenWalkers.walkImportDeclChildren = walkImportDeclChildren;
        function walkExportAssignmentChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
        }
        ChildrenWalkers.walkExportAssignmentChildren = walkExportAssignmentChildren;
        function walkWithStatementChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWithStatementChildren = walkWithStatementChildren;
        function walkExpressionStatementChildren(preAst, parent, walker) {
            preAst.expression = walker.walk(preAst.expression, preAst);
        }
        ChildrenWalkers.walkExpressionStatementChildren = walkExpressionStatementChildren;
        function walkLabeledStatementChildren(preAst, parent, walker) {
            preAst.identifier = walker.walk(preAst.identifier, preAst);
            preAst.statement = walker.walk(preAst.statement, preAst);
        }
        ChildrenWalkers.walkLabeledStatementChildren = walkLabeledStatementChildren;
        function walkVariableStatementChildren(preAst, parent, walker) {
            preAst.declaration = walker.walk(preAst.declaration, preAst);
        }
        ChildrenWalkers.walkVariableStatementChildren = walkVariableStatementChildren;
    })(ChildrenWalkers || (ChildrenWalkers = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (AstWalkerWithDetailCallback) {
        function walk(script, callback) {
            var pre = function (cur, parent) {
                walker.options.goChildren = AstWalkerCallback(true, cur, callback);
                return cur;
            };
            var post = function (cur, parent) {
                AstWalkerCallback(false, cur, callback);
                return cur;
            };
            var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);
            walker.walk(script, null);
        }
        AstWalkerWithDetailCallback.walk = walk;
        function AstWalkerCallback(pre, ast, callback) {
            var nodeType = ast.nodeType;
            var callbackString = (TypeScript.NodeType)._map[nodeType] + "Callback";
            if (callback[callbackString]) {
                return callback[callbackString](pre, ast);
            }
            if (callback.DefaultCallback) {
                return callback.DefaultCallback(pre, ast);
            }
            return true;
        }
    })(TypeScript.AstWalkerWithDetailCallback || (TypeScript.AstWalkerWithDetailCallback = {}));
    var AstWalkerWithDetailCallback = TypeScript.AstWalkerWithDetailCallback;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function max(a, b) {
        return a >= b ? a : b;
    }
    TypeScript.max = max;
    function min(a, b) {
        return a <= b ? a : b;
    }
    TypeScript.min = min;
    var AstPath = (function () {
        function AstPath() {
            this.asts = [];
            this.top = -1;
        }
        AstPath.reverseIndexOf = function reverseIndexOf(items, index) {
            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
        };
        AstPath.prototype.clone = function () {
            var clone = new AstPath();
            clone.asts = this.asts.map(function (value) {
                return value;
            });
            clone.top = this.top;
            return clone;
        };
        AstPath.prototype.pop = function () {
            var head = this.ast();
            this.up();
            while(this.asts.length > this.count()) {
                this.asts.pop();
            }
            return head;
        };
        AstPath.prototype.push = function (ast) {
            while(this.asts.length > this.count()) {
                this.asts.pop();
            }
            this.top = this.asts.length;
            this.asts.push(ast);
        };
        AstPath.prototype.up = function () {
            if (this.top <= -1) {
                throw new Error("Invalid call to 'up'");
            }
            this.top--;
        };
        AstPath.prototype.down = function () {
            if (this.top === this.ast.length - 1) {
                throw new Error("Invalid call to 'down'");
            }
            this.top++;
        };
        AstPath.prototype.nodeType = function () {
            if (this.ast() === null) {
                return TypeScript.NodeType.None;
            }
            return this.ast().nodeType;
        };
        AstPath.prototype.ast = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
        };
        AstPath.prototype.parent = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
        };
        AstPath.prototype.count = function () {
            return this.top + 1;
        };
        AstPath.prototype.get = function (index) {
            return this.asts[index];
        };
        AstPath.prototype.isNameOfClass = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isNameOfInterface = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isNameOfArgument = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.Parameter) && ((this.parent()).id === this.ast());
        };
        AstPath.prototype.isNameOfVariable = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.VariableDeclarator) && ((this.parent()).id === this.ast());
        };
        AstPath.prototype.isNameOfModule = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.ModuleDeclaration) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isNameOfFunction = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === TypeScript.NodeType.Name) && (this.parent().nodeType === TypeScript.NodeType.FunctionDeclaration) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isBodyOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === TypeScript.NodeType.FunctionDeclaration && (this.asts[this.top - 1]).block === this.asts[this.top - 0];
        };
        AstPath.prototype.isArgumentListOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.FunctionDeclaration && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };
        AstPath.prototype.isArgumentListOfCall = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.InvocationExpression && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };
        AstPath.prototype.isArgumentListOfNew = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === TypeScript.NodeType.List && this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectCreationExpression && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };
        AstPath.prototype.isInClassImplementsList = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) && (this.isMemberOfList((this.parent()).implementsList, this.ast()));
        };
        AstPath.prototype.isInInterfaceExtendsList = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) && (this.isMemberOfList((this.parent()).extendsList, this.ast()));
        };
        AstPath.prototype.isMemberOfMemberAccessExpression = function () {
            if (this.count() > 1 && this.parent().nodeType == TypeScript.NodeType.MemberAccessExpression && (this.parent()).operand2 == this.asts[this.top]) {
                return true;
            }
            return false;
        };
        AstPath.prototype.isCallExpression = function () {
            return this.count() >= 1 && (this.asts[this.top - 0].nodeType === TypeScript.NodeType.InvocationExpression || this.asts[this.top - 0].nodeType === TypeScript.NodeType.ObjectCreationExpression);
        };
        AstPath.prototype.isCallExpressionTarget = function () {
            if (this.count() < 2) {
                return false;
            }
            var current = this.top;
            var nodeType = this.asts[current].nodeType;
            if (nodeType === TypeScript.NodeType.ThisExpression || nodeType === TypeScript.NodeType.SuperExpression || nodeType === TypeScript.NodeType.Name) {
                current--;
            }
            while(current >= 0) {
                if (current < this.top && this.asts[current].nodeType === TypeScript.NodeType.MemberAccessExpression && (this.asts[current]).operand2 === this.asts[current + 1]) {
                    current--;
                    continue;
                }
                break;
            }
            return current < this.top && (this.asts[current].nodeType === TypeScript.NodeType.InvocationExpression || this.asts[current].nodeType === TypeScript.NodeType.ObjectCreationExpression) && this.asts[current + 1] === (this.asts[current]).target;
        };
        AstPath.prototype.isDeclaration = function () {
            if (this.ast() !== null) {
                switch(this.ast().nodeType) {
                    case TypeScript.NodeType.ClassDeclaration:
                    case TypeScript.NodeType.InterfaceDeclaration:
                    case TypeScript.NodeType.ModuleDeclaration:
                    case TypeScript.NodeType.FunctionDeclaration:
                    case TypeScript.NodeType.VariableDeclarator:
                        return true;
                }
            }
            return false;
        };
        AstPath.prototype.isMemberOfList = function (list, item) {
            if (list && list.members) {
                for(var i = 0, n = list.members.length; i < n; i++) {
                    if (list.members[i] === item) {
                        return true;
                    }
                }
            }
            return false;
        };
        return AstPath;
    })();
    TypeScript.AstPath = AstPath;    
    function isValidAstNode(ast) {
        if (ast === null) {
            return false;
        }
        if (ast.minChar === -1 || ast.limChar === -1) {
            return false;
        }
        return true;
    }
    TypeScript.isValidAstNode = isValidAstNode;
    var AstPathContext = (function () {
        function AstPathContext() {
            this.path = new TypeScript.AstPath();
        }
        return AstPathContext;
    })();
    TypeScript.AstPathContext = AstPathContext;    
    (function (GetAstPathOptions) {
        GetAstPathOptions._map = [];
        GetAstPathOptions.Default = 0;
        GetAstPathOptions.EdgeInclusive = 1;
        GetAstPathOptions.DontPruneSearchBasedOnPosition = 1 << 1;
    })(TypeScript.GetAstPathOptions || (TypeScript.GetAstPathOptions = {}));
    var GetAstPathOptions = TypeScript.GetAstPathOptions;
    function getAstPathToPosition(script, pos, useTrailingTriviaAsLimChar, options) {
        if (typeof useTrailingTriviaAsLimChar === "undefined") { useTrailingTriviaAsLimChar = true; }
        if (typeof options === "undefined") { options = GetAstPathOptions.Default; }
        var lookInComments = function (comments) {
            if (comments && comments.length > 0) {
                for(var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar;
                    var limChar = comments[i].limChar + (useTrailingTriviaAsLimChar ? comments[i].trailingTriviaWidth : 0);
                    if (!comments[i].isBlockComment) {
                        limChar++;
                    }
                    if (pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]);
                    }
                }
            }
        };
        var pre = function (cur, parent, walker) {
            if (isValidAstNode(cur)) {
                var inclusive = TypeScript.hasFlag(options, GetAstPathOptions.EdgeInclusive) || cur.nodeType === TypeScript.NodeType.Name || cur.nodeType === TypeScript.NodeType.MemberAccessExpression || cur.nodeType === TypeScript.NodeType.TypeRef || pos === script.limChar + script.trailingTriviaWidth;
                var minChar = cur.minChar;
                var limChar = cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0) + (inclusive ? 1 : 0);
                if (pos >= minChar && pos < limChar) {
                    var previous = ctx.path.ast();
                    if (previous === null || (cur.minChar >= previous.minChar && (cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0)) <= (previous.limChar + (useTrailingTriviaAsLimChar ? previous.trailingTriviaWidth : 0)))) {
                        ctx.path.push(cur);
                    } else {
                    }
                }
                if (pos < limChar) {
                    lookInComments(cur.preComments);
                }
                if (pos >= minChar) {
                    lookInComments(cur.postComments);
                }
                if (!TypeScript.hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
            return cur;
        };
        var ctx = new AstPathContext();
        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
        return ctx.path;
    }
    TypeScript.getAstPathToPosition = getAstPathToPosition;
    function walkAST(ast, callback) {
        var pre = function (cur, parent, walker) {
            var path = walker.state;
            path.push(cur);
            callback(path, walker);
            return cur;
        };
        var post = function (cur, parent, walker) {
            var path = walker.state;
            path.pop();
            return cur;
        };
        var path = new AstPath();
        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);
    }
    TypeScript.walkAST = walkAST;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Binder = (function () {
        function Binder(checker) {
            this.checker = checker;
        }
        Binder.prototype.resolveBaseTypeLinks = function (typeLinks, scope) {
            var extendsList = null;
            if (typeLinks) {
                extendsList = [];
                for(var i = 0, len = typeLinks.length; i < len; i++) {
                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);
                }
            }
            return extendsList;
        };
        Binder.prototype.resolveBases = function (scope, type) {
            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);
            var len = type.extendsList.length;
            var derivedIsClass = type.isClassInstance();
            var baseRef = null;
            for(var i = 0; i < len; i++) {
                var baseIsClass = type.extendsList[i].isClassInstance();
                if (type.extendsList[i] != this.checker.anyType) {
                    baseRef = type.extendsTypeLinks[i].ast;
                    if (derivedIsClass) {
                        if (!baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef, "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");
                        }
                    } else {
                        if (baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef, "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");
                        }
                    }
                }
            }
            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);
            if (type.implementsList) {
                for(var i = 0, len = type.implementsList.length; i < len; i++) {
                    var iface = type.implementsList[i];
                    baseRef = type.implementsTypeLinks[i].ast;
                    if (iface.isClassInstance()) {
                        if (derivedIsClass) {
                            this.checker.errorReporter.simpleError(baseRef, "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");
                        }
                    }
                }
            }
        };
        Binder.prototype.resolveSignatureGroup = function (signatureGroup, scope, instanceType) {
            var supplyVar = !(signatureGroup.hasImplementation);
            for(var i = 0, len = signatureGroup.signatures.length; i < len; i++) {
                var signature = signatureGroup.signatures[i];
                if (instanceType) {
                    signature.returnType.type = instanceType;
                } else {
                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);
                }
                var paramLen = signature.parameters.length;
                for(var j = 0; j < paramLen; j++) {
                    this.bindSymbol(scope, signature.parameters[j]);
                }
                if (signature.hasVariableArgList) {
                    var lastParam = signature.parameters[paramLen - 1];
                    lastParam.argsOffset = paramLen - 1;
                    if (!lastParam.getType().isArray()) {
                        this.checker.errorReporter.simpleErrorFromSym(lastParam, "... parameter must have array type");
                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);
                    }
                }
            }
        };
        Binder.prototype.bindType = function (scope, type, instanceType) {
            if (instanceType) {
                this.bindType(scope, instanceType, null);
            }
            var callAndConstructScope = scope;
            if (type.hasMembers()) {
                var members = type.members;
                var ambientMembers = type.ambientMembers;
                var typeMembers = type.getAllEnclosedTypes();
                var ambientTypeMembers = type.getAllAmbientEnclosedTypes();
                var memberScope = new TypeScript.SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);
                var agg = new TypeScript.SymbolAggregateScope(type.symbol);
                var prevCurrentModDecl = this.checker.currentModDecl;
                var prevBindStatus = this.checker.inBind;
                agg.addParentScope(memberScope);
                agg.addParentScope(scope);
                if (type.isModuleType()) {
                    this.checker.currentModDecl = type.symbol.declAST;
                    this.checker.inBind = true;
                }
                if (members) {
                    this.bind(agg, type.members.allMembers);
                }
                if (typeMembers) {
                    this.bind(agg, typeMembers.allMembers);
                }
                if (ambientMembers) {
                    this.bind(agg, ambientMembers.allMembers);
                }
                if (ambientTypeMembers) {
                    this.bind(agg, ambientTypeMembers.allMembers);
                }
                if (type.isModuleType()) {
                    callAndConstructScope = agg;
                }
                this.checker.currentModDecl = prevCurrentModDecl;
                this.checker.inBind = prevBindStatus;
            }
            if (type.extendsTypeLinks) {
                this.resolveBases(scope, type);
            }
            if (type.construct) {
                this.resolveSignatureGroup(type.construct, callAndConstructScope, instanceType);
            }
            if (type.call) {
                this.resolveSignatureGroup(type.call, callAndConstructScope, null);
            }
            if (type.index) {
                this.resolveSignatureGroup(type.index, scope, null);
            }
            if (type.elementType) {
                this.bindType(scope, type.elementType, null);
            }
        };
        Binder.prototype.bindSymbol = function (scope, symbol) {
            if (!symbol.bound) {
                if (this.checker.fileNameToLocationInfo && this.checker.fileNameToLocationInfo.lookup(symbol.fileName)) {
                }
                switch(symbol.kind()) {
                    case TypeScript.SymbolKind.Type:
                        if (symbol.flags & TypeScript.SymbolFlags.Bound) {
                            break;
                        }
                        var typeSymbol = symbol;
                        typeSymbol.flags |= TypeScript.SymbolFlags.Bound;
                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == TypeScript.NodeType.Name) {
                            var modPath = (typeSymbol.aliasLink.alias).text;
                            var modSym = this.checker.findSymbolForDynamicModule(modPath, null, function (id) {
                                return scope.find(id, false, true);
                            });
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }
                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {
                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);
                            if (typeSymbol.type.isModuleType()) {
                                for(var i = 0; i < typeSymbol.expansions.length; i++) {
                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);
                                }
                            }
                        }
                        break;
                    case TypeScript.SymbolKind.Field:
                        this.checker.resolveTypeLink(scope, (symbol).field.typeLink, false);
                        break;
                    case TypeScript.SymbolKind.Parameter:
                        this.checker.resolveTypeLink(scope, (symbol).parameter.typeLink, true);
                        break;
                }
            }
            symbol.bound = true;
        };
        Binder.prototype.bind = function (scope, table) {
            table.map(function (key, sym, binder) {
                return binder.bindSymbol(scope, sym);
            }, this);
        };
        return Binder;
    })();
    TypeScript.Binder = Binder;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Base64Format = (function () {
        function Base64Format() { }
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        Base64Format.encode = function encode(inValue) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        };
        Base64Format.decodeChar = function decodeChar(inChar) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        };
        return Base64Format;
    })();    
    var Base64VLQFormat = (function () {
        function Base64VLQFormat() { }
        Base64VLQFormat.encode = function encode(inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            } else {
                inValue = inValue << 1;
            }
            var encodedStr = "";
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while(inValue > 0);
            return encodedStr;
        };
        Base64VLQFormat.decode = function decode(inString) {
            var result = 0;
            var negative = false;
            var shift = 0;
            for(var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15;
                } else {
                    result = result | ((byte & 31) << shift);
                }
                shift += (i == 0) ? 4 : 5;
                if ((byte & 32) === 32) {
                } else {
                    return {
                        value: negative ? -(result) : result,
                        rest: inString.substr(i + 1)
                    };
                }
            }
            throw new Error('Base64 value "' + inString + '" finished with a continuation bit');
        };
        return Base64VLQFormat;
    })();
    TypeScript.Base64VLQFormat = Base64VLQFormat;    
})(TypeScript || (TypeScript = {}));
var JSON2 = {};
((function () {
    'use strict';
    function f(n) {
        return n < 10 ? '0' + n : n;
    }
    if (typeof Date.prototype.toJSON !== 'function') {
        (Date.prototype.toJSON) = function (key) {
            return isFinite(this.valueOf()) ? this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z' : null;
        };
        var strProto = String.prototype;
        var numProto = Number.prototype;
        numProto.JSON = strProto.JSON = (Boolean).prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '\\': '\\\\'
    }, rep;
    function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
        var i, k = null, v, length, mind = gap, partial, value = holder[key];
        if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }
        switch(typeof value) {
            case 'string':
                return quote(value);
            case 'number':
                return isFinite(value) ? String(value) : 'null';
            case 'boolean':
            case 'null':
                return String(value);
            case 'object':
                if (!value) {
                    return 'null';
                }
                gap += indent;
                partial = [];
                if (Object.prototype.toString.apply(value, []) === '[object Array]') {
                    length = value.length;
                    for(var i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }
                    v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }
                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for(var i = 0; i < length; i += 1) {
                        if (typeof rep[i] === 'string') {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {
                    for(k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                }
                v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }
    if (typeof JSON2.stringify !== 'function') {
        JSON2.stringify = function (value, replacer, space) {
            var i;
            gap = '';
            indent = '';
            if (typeof space === 'number') {
                for(var i = 0; i < space; i += 1) {
                    indent += ' ';
                }
            } else if (typeof space === 'string') {
                indent = space;
            }
            rep = replacer;
            if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }
            return str('', {
                '': value
            });
        };
    }
})());
var TypeScript;
(function (TypeScript) {
    var SourceMapPosition = (function () {
        function SourceMapPosition() { }
        return SourceMapPosition;
    })();
    TypeScript.SourceMapPosition = SourceMapPosition;    
    var SourceMapping = (function () {
        function SourceMapping() {
            this.start = new SourceMapPosition();
            this.end = new SourceMapPosition();
            this.nameIndex = -1;
            this.childMappings = [];
        }
        return SourceMapping;
    })();
    TypeScript.SourceMapping = SourceMapping;    
    var SourceMapper = (function () {
        function SourceMapper(tsFileName, jsFileName, sourceMapFileName, jsFile, sourceMapOut, emitFullPathOfSourceMap) {
            this.sourceMapFileName = sourceMapFileName;
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;
            this.sourceMappings = [];
            this.currentMappings = [];
            this.names = [];
            this.currentNameIndex = [];
            this.currentMappings.push(this.sourceMappings);
            jsFileName = TypeScript.switchToForwardSlashes(jsFileName);
            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);
            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);
            var fixedPath = jsFileName.substring(0, removalIndex);
            if (emitFullPathOfSourceMap) {
                if (jsFileName.indexOf("://") == -1) {
                    jsFileName = "file:///" + jsFileName;
                }
                this.jsFileName = jsFileName;
            }
            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);
        }
        SourceMapper.MapFileExtension = ".map";
        SourceMapper.emitSourceMapping = function emitSourceMapping(allSourceMappers) {
            var sourceMapper = allSourceMappers[0];
            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);
            var sourceMapOut = sourceMapper.sourceMapOut;
            var mappingsString = "";
            var tsFiles = [];
            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var namesList = [];
            var namesCount = 0;
            var emitComma = false;
            var recordedPosition = null;
            for(var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {
                sourceMapper = allSourceMappers[sourceMapperIndex];
                var currentSourceIndex = tsFiles.length;
                tsFiles.push(sourceMapper.tsFileName);
                if (sourceMapper.names.length > 0) {
                    namesList.push.apply(namesList, sourceMapper.names);
                }
                var recordSourceMapping = function (mappedPosition, nameIndex) {
                    if (recordedPosition != null && recordedPosition.emittedColumn == mappedPosition.emittedColumn && recordedPosition.emittedLine == mappedPosition.emittedLine) {
                        return;
                    }
                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while(prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    } else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);
                    prevSourceIndex = currentSourceIndex;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;
                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);
                        prevNameIndex = namesCount + nameIndex;
                    }
                    emitComma = true;
                    recordedPosition = mappedPosition;
                };
                var recordSourceMappingSiblings = function (sourceMappings) {
                    for(var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };
                recordSourceMappingSiblings(sourceMapper.sourceMappings);
                namesCount = namesCount + sourceMapper.names.length;
            }
            sourceMapOut.Write(JSON2.stringify({
                version: 3,
                file: sourceMapper.jsFileName,
                sources: tsFiles,
                names: namesList,
                mappings: mappingsString
            }));
            sourceMapOut.Close();
        };
        return SourceMapper;
    })();
    TypeScript.SourceMapper = SourceMapper;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (EmitContainer) {
        EmitContainer._map = [];
        EmitContainer._map[0] = "Prog";
        EmitContainer.Prog = 0;
        EmitContainer._map[1] = "Module";
        EmitContainer.Module = 1;
        EmitContainer._map[2] = "DynamicModule";
        EmitContainer.DynamicModule = 2;
        EmitContainer._map[3] = "Class";
        EmitContainer.Class = 3;
        EmitContainer._map[4] = "Constructor";
        EmitContainer.Constructor = 4;
        EmitContainer._map[5] = "Function";
        EmitContainer.Function = 5;
        EmitContainer._map[6] = "Args";
        EmitContainer.Args = 6;
        EmitContainer._map[7] = "Interface";
        EmitContainer.Interface = 7;
    })(TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));
    var EmitContainer = TypeScript.EmitContainer;
    var EmitState = (function () {
        function EmitState() {
            this.column = 0;
            this.line = 0;
            this.pretty = false;
            this.inObjectLiteral = false;
            this.container = EmitContainer.Prog;
        }
        return EmitState;
    })();
    TypeScript.EmitState = EmitState;    
    var EmitOptions = (function () {
        function EmitOptions(compilationSettings) {
            this.compilationSettings = compilationSettings;
            this.ioHost = null;
            this.outputMany = true;
            this.commonDirectoryPath = "";
        }
        EmitOptions.prototype.mapOutputFileName = function (fileName, extensionChanger) {
            if (this.outputMany) {
                var updatedFileName = fileName;
                if (this.compilationSettings.outputOption != "") {
                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");
                    updatedFileName = this.compilationSettings.outputOption + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(this.compilationSettings.outputOption, true);
            }
        };
        return EmitOptions;
    })();
    TypeScript.EmitOptions = EmitOptions;    
    var Indenter = (function () {
        function Indenter() {
            this.indentAmt = 0;
        }
        Indenter.indentStep = 4;
        Indenter.indentStepString = "    ";
        Indenter.indentStrings = [];
        Indenter.prototype.increaseIndent = function () {
            this.indentAmt += Indenter.indentStep;
        };
        Indenter.prototype.decreaseIndent = function () {
            this.indentAmt -= Indenter.indentStep;
        };
        Indenter.prototype.getIndent = function () {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for(var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        };
        return Indenter;
    })();
    TypeScript.Indenter = Indenter;    
    var Emitter = (function () {
        function Emitter(emittingFileName, outfile, emitOptions, semanticInfoChain) {
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.semanticInfoChain = semanticInfoChain;
            this.globalThisCapturePrologueEmitted = false;
            this.extendsPrologueEmitted = false;
            this.thisClassNode = null;
            this.thisFnc = null;
            this.moduleDeclList = [];
            this.moduleName = "";
            this.emitState = new EmitState();
            this.indenter = new Indenter();
            this.modAliasId = null;
            this.firstModAlias = null;
            this.allSourceMappers = [];
            this.sourceMapper = null;
            this.captureThisStmtString = "var _this = this;";
            this.varListCountStack = [
                0
            ];
            this.pullTypeChecker = null;
            this.declStack = [];
            this.resolvingContext = new TypeScript.PullTypeResolutionContext();
            this.document = null;
            this.pullTypeChecker = new TypeScript.PullTypeChecker(emitOptions.compilationSettings, semanticInfoChain);
        }
        Emitter.prototype.pushDecl = function (decl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        };
        Emitter.prototype.popDecl = function (decl) {
            if (decl) {
                this.declStack.length--;
            }
        };
        Emitter.prototype.getEnclosingDecl = function () {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        };
        Emitter.prototype.setTypeCheckerUnit = function (fileName) {
            if (!this.pullTypeChecker.resolver) {
                this.pullTypeChecker.setUnit(fileName);
                return;
            }
            this.pullTypeChecker.resolver.setUnitPath(fileName);
        };
        Emitter.prototype.setDocument = function (document) {
            this.document = document;
        };
        Emitter.prototype.importStatementShouldBeEmitted = function (importDeclAST, unitPath) {
            if (!importDeclAST.isDynamicImport) {
                return true;
            }
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
            var pullSymbol = importDecl.getSymbol();
            return pullSymbol.getIsUsedAsValue();
        };
        Emitter.prototype.setSourceMappings = function (mapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        };
        Emitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);
            this.emitState.column += s.length;
        };
        Emitter.prototype.writeToOutputTrimmable = function (s) {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                s = s.replace(/[\s]*/g, '');
            }
            this.writeToOutput(s);
        };
        Emitter.prototype.writeLineToOutput = function (s) {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                this.writeToOutput(s);
                var c = s.charCodeAt(s.length - 1);
                if (!((c === TypeScript.CharacterCodes.space) || (c === TypeScript.CharacterCodes.semicolon) || (c === TypeScript.CharacterCodes.openBracket))) {
                    this.writeToOutput(' ');
                }
            } else {
                this.outfile.WriteLine(s);
                this.emitState.column = 0;
                this.emitState.line++;
            }
        };
        Emitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        };
        Emitter.prototype.setInVarBlock = function (count) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        };
        Emitter.prototype.setInObjectLiteral = function (val) {
            var temp = this.emitState.inObjectLiteral;
            this.emitState.inObjectLiteral = val;
            return temp;
        };
        Emitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };
        Emitter.prototype.getIndentString = function () {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                return "";
            } else {
                return this.indenter.getIndent();
            }
        };
        Emitter.prototype.emitIndent = function () {
            this.writeToOutput(this.getIndentString());
        };
        Emitter.prototype.emitCommentInPlace = function (comment) {
            var text = comment.getText();
            var hadNewLine = false;
            if (comment.isBlockComment) {
                if (this.emitState.column === 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                if (text.length > 1 || comment.endsLine) {
                    for(var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                    hadNewLine = true;
                } else {
                    this.recordSourceMappingEnd(comment);
                }
            } else {
                if (this.emitState.column === 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
                hadNewLine = true;
            }
            if (hadNewLine) {
                this.emitIndent();
            } else {
                this.writeToOutput(" ");
            }
        };
        Emitter.prototype.emitComments = function (ast, pre) {
            var comments = pre ? ast.preComments : ast.postComments;
            if (this.emitOptions.compilationSettings.emitComments && comments && comments.length != 0) {
                for(var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]);
                }
            }
        };
        Emitter.prototype.emitObjectLiteral = function (content) {
            if (content.members.length === 0) {
                this.writeToOutput("{}");
                return;
            }
            this.writeLineToOutput("{");
            this.indenter.increaseIndent();
            var inObjectLiteral = this.setInObjectLiteral(true);
            this.emitJavascriptList(content, ",", true, false, false);
            this.setInObjectLiteral(inObjectLiteral);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
        };
        Emitter.prototype.emitArrayLiteral = function (content) {
            this.writeToOutput("[");
            if (content && content.members.length > 0) {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascriptList(content, ", ", true, false, false);
                this.indenter.decreaseIndent();
                this.emitIndent();
            }
            this.writeToOutput("]");
        };
        Emitter.prototype.emitNew = function (target, args) {
            this.writeToOutput("new ");
            if (target.nodeType === TypeScript.NodeType.TypeRef) {
                var typeRef = target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                } else {
                    this.emitJavascript(typeRef.term, false);
                    this.writeToOutput("()");
                }
            } else {
                this.emitJavascript(target, false);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitJavascriptList(args, ", ", false, false, false);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        };
        Emitter.prototype.getVarDeclFromIdentifier = function (boundDeclInfo) {
            TypeScript.CompilerDiagnostics.assert(boundDeclInfo.boundDecl && boundDeclInfo.boundDecl.init && boundDeclInfo.boundDecl.init.nodeType == TypeScript.NodeType.Name, "The init expression of bound declaration when emitting as constant has to be indentifier");
            var init = boundDeclInfo.boundDecl.init;
            var ident = init;
            this.setTypeCheckerUnit(this.document.fileName);
            var pullSymbol = this.resolvingContext.resolvingTypeReference ? this.pullTypeChecker.resolver.resolveTypeNameExpression(ident, boundDeclInfo.pullDecl.getParentDecl(), this.resolvingContext) : this.pullTypeChecker.resolver.resolveNameExpression(ident, boundDeclInfo.pullDecl.getParentDecl(), this.resolvingContext);
            if (pullSymbol) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length == 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl);
                    if (ast && ast.nodeType == TypeScript.NodeType.VariableDeclarator) {
                        return {
                            boundDecl: ast,
                            pullDecl: pullDecl
                        };
                    }
                }
            }
            return null;
        };
        Emitter.prototype.getConstantValue = function (boundDeclInfo) {
            var init = boundDeclInfo.boundDecl.init;
            if (init) {
                if (init.nodeType === TypeScript.NodeType.NumericLiteral) {
                    var numLit = init;
                    return numLit.value;
                } else if (init.nodeType === TypeScript.NodeType.LeftShiftExpression) {
                    var binop = init;
                    if (binop.operand1.nodeType === TypeScript.NodeType.NumericLiteral && binop.operand2.nodeType === TypeScript.NodeType.NumericLiteral) {
                        return (binop.operand1).value << (binop.operand2).value;
                    }
                } else if (init.nodeType === TypeScript.NodeType.Name) {
                    var varDeclInfo = this.getVarDeclFromIdentifier(boundDeclInfo);
                    if (varDeclInfo) {
                        return this.getConstantValue(varDeclInfo);
                    }
                }
            }
            return null;
        };
        Emitter.prototype.getConstantDecl = function (dotExpr) {
            this.setTypeCheckerUnit(this.document.fileName);
            var pullSymbol = this.pullTypeChecker.resolver.resolveDottedNameExpression(dotExpr, this.getEnclosingDecl(), this.resolvingContext);
            if (pullSymbol && pullSymbol.hasFlag(TypeScript.PullElementFlags.Constant)) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length == 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl);
                    if (ast && ast.nodeType == TypeScript.NodeType.VariableDeclarator) {
                        return {
                            boundDecl: ast,
                            pullDecl: pullDecl
                        };
                    }
                }
            }
            return null;
        };
        Emitter.prototype.tryEmitConstant = function (dotExpr) {
            if (!this.emitOptions.compilationSettings.propagateConstants) {
                return false;
            }
            var propertyName = dotExpr.operand2;
            var boundDeclInfo = this.getConstantDecl(dotExpr);
            if (boundDeclInfo) {
                var value = this.getConstantValue(boundDeclInfo);
                if (value !== null) {
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.actualText;
                    comment += " */ ";
                    this.writeToOutput(comment);
                    return true;
                }
            }
            return false;
        };
        Emitter.prototype.emitCall = function (callNode, target, args) {
            if (!this.emitSuperCall(callNode)) {
                if (target.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    this.writeToOutput("(");
                }
                if (callNode.target.nodeType === TypeScript.NodeType.SuperExpression && this.emitState.container === EmitContainer.Constructor) {
                    this.writeToOutput("_super.call");
                } else {
                    this.emitJavascript(target, false);
                }
                if (target.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    this.writeToOutput(")");
                }
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                if (callNode.target.nodeType === TypeScript.NodeType.SuperExpression && this.emitState.container === EmitContainer.Constructor) {
                    this.writeToOutput("this");
                    if (args && args.members.length) {
                        this.writeToOutput(", ");
                    }
                }
                this.emitJavascriptList(args, ", ", false, false, false);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        };
        Emitter.prototype.emitInnerFunction = function (funcDecl, printName, isMember, hasSelfRef, classDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            this.pushDecl(pullDecl);
            var isClassConstructor = funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod);
            var hasNonObjectBaseType = isClassConstructor && classDecl.extendsList && classDecl.extendsList.members.length > 0;
            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType;
            var shouldParenthesize = false;
            this.emitComments(funcDecl, true);
            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            var accessorSymbol = funcDecl.isAccessor() ? TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName) : null;
            var container = accessorSymbol ? accessorSymbol.getContainer() : null;
            var containerKind = container ? container.getKind() : TypeScript.PullElementKind.None;
            if (!(funcDecl.isAccessor() && containerKind != TypeScript.PullElementKind.Class && containerKind != TypeScript.PullElementKind.ConstructorType)) {
                this.writeToOutput("function ");
            }
            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }
            this.writeToOutput("(");
            var argsLen = 0;
            var arg;
            var defaultArgs = [];
            if (funcDecl.arguments) {
                var tempContainer = this.setContainer(EmitContainer.Args);
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for(var i = 0; i < printLen; i++) {
                    arg = funcDecl.arguments.members[i];
                    if (arg.init) {
                        defaultArgs.push(arg);
                    }
                    this.emitJavascript(arg, false);
                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);
            }
            this.writeLineToOutput(") {");
            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();
            for(var i = 0; i < defaultArgs.length; i++) {
                arg = defaultArgs[i];
                this.emitIndent();
                this.recordSourceMappingStart(arg);
                this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");
                this.recordSourceMappingStart(arg.id);
                this.writeToOutput(arg.id.actualText);
                this.recordSourceMappingEnd(arg.id);
                this.writeToOutput(" = ");
                this.emitJavascript(arg.init, false);
                this.writeLineToOutput("; }");
                this.recordSourceMappingEnd(arg);
            }
            if (funcDecl.isConstructor && this.shouldCaptureThis(funcDecl.classDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {
                if (funcDecl.arguments) {
                    argsLen = funcDecl.arguments.members.length;
                    for(var i = 0; i < argsLen; i++) {
                        arg = funcDecl.arguments.members[i];
                        if ((arg.getVarFlags() & TypeScript.VariableFlags.Property) != TypeScript.VariableFlags.None) {
                            this.emitIndent();
                            this.recordSourceMappingStart(arg);
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput("this." + arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeToOutput(" = ");
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput(arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeLineToOutput(";");
                            this.recordSourceMappingEnd(arg);
                        }
                    }
                }
            }
            if (hasSelfRef) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.variableArgList) {
                argsLen = funcDecl.arguments.members.length;
                var lastArg = funcDecl.arguments.members[argsLen - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
            if (funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {
                var nProps = this.thisClassNode.members.members.length;
                for(var i = 0; i < nProps; i++) {
                    if (this.thisClassNode.members.members[i].nodeType === TypeScript.NodeType.VariableDeclarator) {
                        var varDecl = this.thisClassNode.members.members[i];
                        if (!TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Static) && varDecl.init) {
                            this.emitIndent();
                            this.emitJavascriptVariableDeclarator(varDecl);
                            this.writeLineToOutput("");
                        }
                    }
                }
            }
            this.emitJavascriptList(funcDecl.block.statements, null, true, false, classPropertiesMustComeAfterSuperCall);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.block.closeBraceSpan);
            this.writeToOutput("}");
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.block.closeBraceSpan);
            this.recordSourceMappingEnd(funcDecl);
            if (shouldParenthesize) {
                this.writeToOutput(")");
            }
            this.recordSourceMappingEnd(funcDecl);
            this.emitComments(funcDecl, false);
            if (!isMember && !funcDecl.isAccessor() && !TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.IsFunctionExpression) && (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Signature) || funcDecl.isConstructor)) {
                this.writeLineToOutput("");
            }
            this.popDecl(pullDecl);
        };
        Emitter.prototype.getModuleImportAndDepencyList = function (moduleDecl) {
            var importList = "";
            var dependencyList = "";
            var semanticInfo = this.semanticInfoChain.getUnit(this.document.fileName);
            var imports = semanticInfo.getDynamicModuleImports();
            if (imports.length) {
                for(var i = 0; i < imports.length; i++) {
                    var importStatement = imports[i];
                    var importStatementAST = semanticInfo.getASTForDecl(importStatement.getDeclarations()[0]);
                    if (importStatement.getIsUsedAsValue()) {
                        if (i <= imports.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }
                        importList += "__" + importStatement.getName() + "__";
                        dependencyList += importStatementAST.firstAliasedModToString();
                    }
                }
            }
            for(var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
            }
            return {
                importList: importList,
                dependencyList: dependencyList
            };
        };
        Emitter.prototype.shouldCaptureThis = function (ast) {
            if (ast == null) {
                var scriptDecl = this.semanticInfoChain.getUnit(this.document.fileName).getTopLevelDecls()[0];
                return (scriptDecl.getFlags() & TypeScript.PullElementFlags.MustCaptureThis) == TypeScript.PullElementFlags.MustCaptureThis;
            }
            var decl = this.semanticInfoChain.getDeclForAST(ast, this.document.fileName);
            if (decl) {
                return (decl.getFlags() & TypeScript.PullElementFlags.MustCaptureThis) == TypeScript.PullElementFlags.MustCaptureThis;
            }
            return false;
        };
        Emitter.prototype.emitJavascriptModule = function (moduleDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
            this.pushDecl(pullDecl);
            var modName = moduleDecl.name.actualText;
            if (TypeScript.isTSFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 3));
            }
            if (!TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.Ambient)) {
                var isDynamicMod = TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.IsDynamic);
                var prevOutFile = this.outfile;
                var prevOutFileName = this.emittingFileName;
                var prevAllSourceMappers = this.allSourceMappers;
                var prevSourceMapper = this.sourceMapper;
                var prevColumn = this.emitState.column;
                var prevLine = this.emitState.line;
                var temp = this.setContainer(EmitContainer.Module);
                var svModuleName = this.moduleName;
                var isExported = TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.Exported);
                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;
                var isWholeFile = TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.IsWholeFile);
                this.moduleName = moduleDecl.name.actualText;
                if (isDynamicMod) {
                    var tsModFileName = TypeScript.stripQuotes(moduleDecl.name.actualText);
                    var modFilePath = TypeScript.trimModName(tsModFileName) + ".js";
                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScript.TypeScriptCompiler.mapToJSFileName);
                    if (this.emitOptions.ioHost) {
                        if (TypeScript.switchToForwardSlashes(modFilePath) != TypeScript.switchToForwardSlashes(this.emittingFileName)) {
                            this.emittingFileName = modFilePath;
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.compilationSettings.emitComments && moduleDecl.containsUnicodeCharInComment);
                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);
                            if (prevSourceMapper != null) {
                                this.allSourceMappers = [];
                                var sourceMapFile = this.emittingFileName + TypeScript.SourceMapper.MapFileExtension;
                                var sourceMappingFile = this.createFile(sourceMapFile, false);
                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, sourceMapFile, this.outfile, sourceMappingFile, this.emitOptions.compilationSettings.emitFullSourceMapPath));
                                this.emitState.column = 0;
                                this.emitState.line = 0;
                            }
                        } else {
                            TypeScript.CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");
                        }
                    }
                    this.setContainer(EmitContainer.DynamicModule);
                    this.recordSourceMappingStart(moduleDecl);
                    if (this.emitOptions.compilationSettings.moduleGenTarget === TypeScript.ModuleGenTarget.Asynchronous) {
                        var dependencyList = "[\"require\", \"exports\"";
                        var importList = "require, exports";
                        var importAndDependencyList = this.getModuleImportAndDepencyList(moduleDecl);
                        importList += importAndDependencyList.importList;
                        dependencyList += importAndDependencyList.dependencyList + "]";
                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                    } else {
                    }
                } else {
                    if (!isExported) {
                        this.recordSourceMappingStart(moduleDecl);
                        this.writeToOutput("var ");
                        this.recordSourceMappingStart(moduleDecl.name);
                        this.writeToOutput(this.moduleName);
                        this.recordSourceMappingEnd(moduleDecl.name);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(moduleDecl);
                        this.emitIndent();
                    }
                    this.writeToOutput("(");
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("function (");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(") {");
                }
                if (!isWholeFile) {
                    this.recordSourceMappingNameStart(this.moduleName);
                }
                if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === TypeScript.ModuleGenTarget.Asynchronous) {
                    this.indenter.increaseIndent();
                }
                if (this.shouldCaptureThis(moduleDecl)) {
                    this.writeCaptureThisStatement(moduleDecl);
                }
                this.emitJavascriptList(moduleDecl.members, null, true, false, false);
                if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === TypeScript.ModuleGenTarget.Asynchronous) {
                    this.indenter.decreaseIndent();
                }
                this.emitIndent();
                if (isDynamicMod) {
                    if (this.emitOptions.compilationSettings.moduleGenTarget === TypeScript.ModuleGenTarget.Asynchronous) {
                        this.writeLineToOutput("})");
                    } else {
                    }
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    if (this.outfile != prevOutFile) {
                        this.emitSourceMapsAndClose();
                        if (prevSourceMapper != null) {
                            this.allSourceMappers = prevAllSourceMappers;
                            this.sourceMapper = prevSourceMapper;
                            this.emitState.column = prevColumn;
                            this.emitState.line = prevLine;
                        }
                        this.outfile = prevOutFile;
                        this.emittingFileName = prevOutFileName;
                    }
                } else {
                    var parentIsDynamic = temp == EmitContainer.DynamicModule;
                    this.recordSourceMappingStart(moduleDecl.endingToken);
                    if (temp === EmitContainer.Prog && isExported) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                    } else if (isExported || temp === EmitContainer.Prog) {
                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                    } else if (!isExported && temp != EmitContainer.Prog) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                    } else {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")();");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    this.writeLineToOutput("");
                    if (temp != EmitContainer.Prog && isExported) {
                        this.emitIndent();
                        this.recordSourceMappingStart(moduleDecl);
                        if (parentIsDynamic) {
                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                        } else {
                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                        }
                        this.recordSourceMappingEnd(moduleDecl);
                    }
                }
                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.moduleDeclList.length--;
            }
            this.popDecl(pullDecl);
        };
        Emitter.prototype.emitIndex = function (operand1, operand2) {
            var temp = this.setInObjectLiteral(false);
            this.emitJavascript(operand1, false);
            this.writeToOutput("[");
            this.emitJavascriptList(operand2, ", ", false, false, false);
            this.writeToOutput("]");
            this.setInObjectLiteral(temp);
        };
        Emitter.prototype.emitStringLiteral = function (text) {
            this.writeToOutput(text);
        };
        Emitter.prototype.emitJavascriptFunction = function (funcDecl) {
            if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Signature)) {
                return;
            }
            var temp;
            var tempFnc = this.thisFnc;
            this.thisFnc = funcDecl;
            if (funcDecl.isConstructor) {
                temp = this.setContainer(EmitContainer.Constructor);
            } else {
                temp = this.setContainer(EmitContainer.Function);
            }
            var hasSelfRef = false;
            var funcName = funcDecl.getNameText();
            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) && ((temp != EmitContainer.Constructor) || ((funcDecl.getFunctionFlags() & TypeScript.FunctionFlags.Method) === TypeScript.FunctionFlags.None))) {
                var tempLit = this.setInObjectLiteral(false);
                hasSelfRef = this.shouldCaptureThis(funcDecl);
                this.recordSourceMappingStart(funcDecl);
                this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, hasSelfRef, this.thisClassNode);
                this.setInObjectLiteral(tempLit);
            }
            this.setContainer(temp);
            this.thisFnc = tempFnc;
            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Signature)) {
                if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Static)) {
                    if (this.thisClassNode) {
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        } else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName + " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                } else if ((this.emitState.container === EmitContainer.Module || this.emitState.container === EmitContainer.DynamicModule) && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Exported | TypeScript.FunctionFlags.ClassPropertyMethodExported)) {
                    this.emitIndent();
                    var modName = this.emitState.container === EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };
        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {
            if (varDecl.init) {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, false);
                this.recordSourceMappingEnd(varDecl);
                this.writeToOutput(";");
                this.emitComments(varDecl, false);
            }
        };
        Emitter.prototype.varListCount = function () {
            return this.varListCountStack[this.varListCountStack.length - 1];
        };
        Emitter.prototype.emitVarDeclVar = function () {
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        };
        Emitter.prototype.onEmitVar = function () {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            } else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        };
        Emitter.prototype.emitJavascriptVariableDeclaration = function (declaration, startLine) {
            var varDecl = declaration.declarators.members[0];
            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.document.fileName);
            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentKind = parentSymbol ? parentSymbol.getKind() : TypeScript.PullElementKind.None;
            var inClass = parentKind === TypeScript.PullElementKind.Class;
            this.emitComments(declaration, true);
            this.recordSourceMappingStart(declaration);
            this.setInVarBlock(declaration.declarators.members.length);
            var temp = this.setInObjectLiteral(false);
            var isAmbientWithoutInit = TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Ambient) && varDecl.init === null;
            if (!isAmbientWithoutInit) {
                for(var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                    var declarator = declaration.declarators.members[i];
                    if (i > 0) {
                        if (inClass) {
                            this.writeToOutputTrimmable(";");
                        } else {
                            this.writeToOutputTrimmable(", ");
                        }
                    }
                    this.emitJavascript(declarator, (startLine && i === 0) || inClass);
                }
            }
            this.setInObjectLiteral(temp);
            this.recordSourceMappingEnd(declaration);
            this.emitComments(declaration, false);
        };
        Emitter.prototype.emitJavascriptVariableDeclarator = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName);
            this.pushDecl(pullDecl);
            if ((varDecl.getVarFlags() & TypeScript.VariableFlags.Ambient) === TypeScript.VariableFlags.Ambient) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            } else {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.document.fileName);
                var parentSymbol = symbol ? symbol.getContainer() : null;
                var parentKind = parentSymbol ? parentSymbol.getKind() : TypeScript.PullElementKind.None;
                var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
                var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.getKind() : TypeScript.PullElementKind.None;
                if (parentKind == TypeScript.PullElementKind.Class) {
                    if (this.emitState.container != EmitContainer.Args) {
                        if (varDecl.isStatic()) {
                            this.writeToOutput(parentSymbol.getName() + ".");
                        } else {
                            this.writeToOutput("this.");
                        }
                    }
                } else if (parentKind == TypeScript.PullElementKind.Enum || parentKind == TypeScript.PullElementKind.DynamicModule || associatedParentSymbolKind == TypeScript.PullElementKind.Container || associatedParentSymbolKind == TypeScript.PullElementKind.DynamicModule || associatedParentSymbolKind == TypeScript.PullElementKind.Enum) {
                    if (!varDecl.isExported() && !varDecl.isProperty()) {
                        this.emitVarDeclVar();
                    } else {
                        if (this.emitState.container === EmitContainer.DynamicModule) {
                            this.writeToOutput("exports.");
                        } else {
                            this.writeToOutput(this.moduleName + ".");
                        }
                    }
                } else {
                    this.emitVarDeclVar();
                }
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                var hasInitializer = (varDecl.init != null);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");
                    this.varListCountStack.push(0);
                    this.emitJavascript(varDecl.init, false);
                    this.varListCountStack.pop();
                }
                if (parentKind == TypeScript.PullElementKind.Class) {
                    if (this.emitState.container != EmitContainer.Args) {
                        this.writeToOutput(";");
                    }
                }
                this.onEmitVar();
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
            this.popDecl(pullDecl);
        };
        Emitter.prototype.symbolIsUsedInItsEnclosingContainer = function (symbol, dynamic) {
            if (typeof dynamic === "undefined") { dynamic = false; }
            var symDecls = symbol.getDeclarations();
            if (symDecls.length) {
                var enclosingDecl = this.getEnclosingDecl();
                if (enclosingDecl) {
                    var parentDecl = symDecls[0].getParentDecl();
                    if (parentDecl) {
                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;
                        while(symbolDeclarationEnclosingContainer) {
                            if (symbolDeclarationEnclosingContainer.getKind() == (dynamic ? TypeScript.PullElementKind.DynamicModule : TypeScript.PullElementKind.Container)) {
                                break;
                            }
                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }
                        if (symbolDeclarationEnclosingContainer) {
                            while(enclosingContainer) {
                                if (enclosingContainer.getKind() == (dynamic ? TypeScript.PullElementKind.DynamicModule : TypeScript.PullElementKind.Container)) {
                                    break;
                                }
                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }
                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer == enclosingContainer;
                            if (!same && symbol.hasFlag(TypeScript.PullElementFlags.InitializedModule)) {
                                same = symbolDeclarationEnclosingContainer == enclosingContainer.getParentDecl();
                            }
                            return same;
                        }
                    }
                }
            }
            return false;
        };
        Emitter.prototype.emitJavascriptName = function (name, addThis) {
            this.emitComments(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                this.setTypeCheckerUnit(this.document.fileName);
                var pullSymbol = this.resolvingContext.resolvingTypeReference ? this.pullTypeChecker.resolver.resolveTypeNameExpression(name, this.getEnclosingDecl(), this.resolvingContext) : this.pullTypeChecker.resolver.resolveNameExpression(name, this.getEnclosingDecl(), this.resolvingContext);
                var pullSymbolKind = pullSymbol.getKind();
                if (addThis && (this.emitState.container != EmitContainer.Args) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();
                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.getKind();
                        if (pullSymbolContainerKind == TypeScript.PullElementKind.Class) {
                            if (pullSymbol.hasFlag(TypeScript.PullElementFlags.Static)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            } else if (pullSymbolKind == TypeScript.PullElementKind.Property) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        } else if (pullSymbolContainerKind == TypeScript.PullElementKind.Container || pullSymbolContainerKind == TypeScript.PullElementKind.Enum || pullSymbolContainer.hasFlag(TypeScript.PullElementFlags.InitializedModule)) {
                            if (pullSymbolKind == TypeScript.PullElementKind.Property || pullSymbolKind == TypeScript.PullElementKind.EnumMember) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            } else if (pullSymbol.hasFlag(TypeScript.PullElementFlags.Exported) && pullSymbolKind == TypeScript.PullElementKind.Variable && !pullSymbol.hasFlag(TypeScript.PullElementFlags.InitializedModule)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            } else if (pullSymbol.hasFlag(TypeScript.PullElementFlags.Exported) && !this.symbolIsUsedInItsEnclosingContainer(pullSymbol)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                        } else if (pullSymbolContainerKind == TypeScript.PullElementKind.DynamicModule) {
                            if (pullSymbolKind == TypeScript.PullElementKind.Property || pullSymbol.hasFlag(TypeScript.PullElementFlags.Exported)) {
                                if (pullSymbolKind == TypeScript.PullElementKind.Property) {
                                    this.writeToOutput("exports.");
                                } else if (pullSymbol.hasFlag(TypeScript.PullElementFlags.Exported) && !this.symbolIsUsedInItsEnclosingContainer(pullSymbol, true)) {
                                    this.writeToOutput("exports.");
                                }
                            }
                        } else if (pullSymbolKind == TypeScript.PullElementKind.Property) {
                            if (pullSymbolContainer.getKind() == TypeScript.PullElementKind.Class) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        } else {
                            var pullDecls = pullSymbol.getDeclarations();
                            var emitContainerName = true;
                            for(var i = 0; i < pullDecls.length; i++) {
                                if (pullDecls[i].getScriptName() == this.document.fileName) {
                                    emitContainerName = false;
                                }
                            }
                            if (emitContainerName) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                        }
                    }
                }
                if (pullSymbol && pullSymbolKind == TypeScript.PullElementKind.DynamicModule) {
                    if (this.emitOptions.compilationSettings.moduleGenTarget == TypeScript.ModuleGenTarget.Asynchronous) {
                        this.writeToOutput("__" + this.modAliasId + "__");
                    } else {
                        var moduleDecl = this.semanticInfoChain.getASTForSymbol(pullSymbol, this.document.fileName);
                        var modPath = name.actualText;
                        var isAmbient = pullSymbol.hasFlag(TypeScript.PullElementFlags.Ambient);
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : TypeScript.quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!TypeScript.isRelative(TypeScript.stripQuotes(modPath)) ? TypeScript.quoteStr("./" + TypeScript.stripQuotes(modPath)) : modPath);
                        this.writeToOutput("require(" + modPath + ")");
                    }
                } else {
                    this.writeToOutput(name.actualText);
                }
            }
            this.recordSourceMappingEnd(name);
            this.emitComments(name, false);
        };
        Emitter.prototype.emitJavascriptStatements = function (stmts, emitEmptyBod) {
            if (stmts) {
                if (stmts.nodeType != TypeScript.NodeType.Block) {
                    var hasContents = (stmts && (stmts.nodeType != TypeScript.NodeType.List || ((stmts).members.length > 0)));
                    if (emitEmptyBod || hasContents) {
                        var hasOnlyBlockStatement = ((stmts.nodeType === TypeScript.NodeType.Block) || ((stmts.nodeType === TypeScript.NodeType.List) && ((stmts).members.length === 1) && ((stmts).members[0].nodeType === TypeScript.NodeType.Block)));
                        this.recordSourceMappingStart(stmts);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput(" {");
                            this.indenter.increaseIndent();
                        }
                        this.emitJavascriptList(stmts, null, true, false, false);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput("");
                            this.indenter.decreaseIndent();
                            this.emitIndent();
                            this.writeToOutput("}");
                        }
                        this.recordSourceMappingEnd(stmts);
                    }
                } else {
                    this.emitJavascript(stmts, true);
                }
            } else if (emitEmptyBod) {
                this.writeToOutput("{ }");
            }
        };
        Emitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }
                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        };
        Emitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };
        Emitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                var lineCol = {
                    line: -1,
                    character: -1
                };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                var lineMap = this.document.lineMap;
                lineMap.fillLineAndCharacterFromPosition(ast.minChar, lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(ast.limChar, lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        };
        Emitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                this.sourceMapper.currentMappings.pop();
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];
                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        };
        Emitter.prototype.emitSourceMapsAndClose = function () {
            if (this.sourceMapper !== null) {
                TypeScript.SourceMapper.emitSourceMapping(this.allSourceMappers);
            }
            try  {
                this.outfile.Close();
            } catch (e) {
                Emitter.throwEmitterError(e);
            }
        };
        Emitter.prototype.emitConstructorPropertyAssignments = function () {
            var constructorDecl = (this.thisClassNode).constructorDecl;
            if (constructorDecl && constructorDecl.arguments) {
                var argsLen = constructorDecl.arguments.members.length;
                for(var iArg = 0; iArg < argsLen; iArg++) {
                    var arg = constructorDecl.arguments.members[iArg];
                    if ((arg.getVarFlags() & TypeScript.VariableFlags.Property) != TypeScript.VariableFlags.None) {
                        this.emitIndent();
                        this.recordSourceMappingStart(arg);
                        this.recordSourceMappingStart(arg.id);
                        this.writeToOutput("this." + arg.id.actualText);
                        this.recordSourceMappingEnd(arg.id);
                        this.writeToOutput(" = ");
                        this.recordSourceMappingStart(arg.id);
                        this.writeToOutput(arg.id.actualText);
                        this.recordSourceMappingEnd(arg.id);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(arg);
                    }
                }
            }
            var nProps = this.thisClassNode.members.members.length;
            for(var iMember = 0; iMember < nProps; iMember++) {
                if (this.thisClassNode.members.members[iMember].nodeType === TypeScript.NodeType.VariableDeclarator) {
                    var varDecl = this.thisClassNode.members.members[iMember];
                    if (!TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Static) && varDecl.init) {
                        this.emitIndent();
                        this.emitJavascriptVariableDeclarator(varDecl);
                        this.writeLineToOutput("");
                    }
                }
            }
        };
        Emitter.prototype.emitJavascriptList = function (ast, delimiter, startLine, onlyStatics, emitClassPropertiesAfterSuperCall, emitPrologue, requiresExtendsBlock) {
            if (typeof emitPrologue === "undefined") { emitPrologue = false; }
            if (ast === null) {
                return;
            } else if (ast.nodeType != TypeScript.NodeType.List) {
                this.emitPrologue(emitPrologue);
                this.emitJavascript(ast, startLine);
            } else {
                var list = ast;
                this.emitComments(ast, true);
                if (list.members.length === 0) {
                    this.emitComments(ast, false);
                    return;
                }
                var len = list.members.length;
                for(var i = 0; i < len; i++) {
                    if (emitPrologue) {
                        if (i === 1 || !TypeScript.hasFlag(list.getFlags(), TypeScript.ASTFlags.StrictMode)) {
                            this.emitPrologue(requiresExtendsBlock);
                            emitPrologue = false;
                        }
                    }
                    if (i === 1 && emitClassPropertiesAfterSuperCall) {
                        this.emitConstructorPropertyAssignments();
                    }
                    var emitNode = list.members[i];
                    var isStaticDecl = (emitNode.nodeType === TypeScript.NodeType.FunctionDeclaration && TypeScript.hasFlag((emitNode).getFunctionFlags(), TypeScript.FunctionFlags.Static)) || (emitNode.nodeType === TypeScript.NodeType.VariableDeclarator && TypeScript.hasFlag((emitNode).getVarFlags(), TypeScript.VariableFlags.Static));
                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {
                        continue;
                    }
                    this.emitJavascript(emitNode, startLine);
                    if (delimiter && (i < (len - 1))) {
                        if (startLine) {
                            this.writeLineToOutput(delimiter);
                        } else {
                            this.writeToOutput(delimiter);
                        }
                    } else if (startLine && (emitNode.nodeType != TypeScript.NodeType.ModuleDeclaration) && (emitNode.nodeType != TypeScript.NodeType.InterfaceDeclaration) && (!((emitNode.nodeType === TypeScript.NodeType.VariableDeclarator) && ((((emitNode).getVarFlags()) & TypeScript.VariableFlags.Ambient) === TypeScript.VariableFlags.Ambient) && (((emitNode).init) === null)) && this.varListCount() >= 0) && (emitNode.nodeType != TypeScript.NodeType.FunctionDeclaration)) {
                        this.writeLineToOutput("");
                    }
                }
                if (i === 1 && emitClassPropertiesAfterSuperCall) {
                    this.emitConstructorPropertyAssignments();
                }
                this.emitComments(ast, false);
            }
        };
        Emitter.prototype.emitJavascript = function (ast, startLine) {
            if (ast === null) {
                return;
            }
            if (startLine && this.indenter.indentAmt > 0 && ast.nodeType !== TypeScript.NodeType.List && ast.nodeType !== TypeScript.NodeType.Block && ast.nodeType !== TypeScript.NodeType.VariableDeclaration && ast.nodeType !== TypeScript.NodeType.VariableStatement) {
                if ((ast.nodeType != TypeScript.NodeType.InterfaceDeclaration) && (!((ast.nodeType === TypeScript.NodeType.VariableDeclarator) && ((((ast).getVarFlags()) & TypeScript.VariableFlags.Ambient) === TypeScript.VariableFlags.Ambient) && (((ast).init) === null)) && this.varListCount() >= 0) && ((ast.nodeType != TypeScript.NodeType.FunctionDeclaration) || (this.emitState.container != EmitContainer.Constructor))) {
                    this.emitIndent();
                }
            }
            ast.emit(this, startLine);
        };
        Emitter.prototype.emitPropertyAccessor = function (funcDecl, className, isProto) {
            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor)) {
                var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName);
                if (accessorSymbol.getGetter()) {
                    return;
                }
            }
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);
            this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
            this.indenter.increaseIndent();
            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.document.fileName);
            if (accessors.getter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.getter);
                this.writeToOutput("get: ");
                this.emitInnerFunction(accessors.getter, false, isProto, this.shouldCaptureThis(accessors.getter), null);
                this.writeLineToOutput(",");
            }
            if (accessors.setter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.setter);
                this.writeToOutput("set: ");
                this.emitInnerFunction(accessors.setter, false, isProto, this.shouldCaptureThis(accessors.setter), null);
                this.writeLineToOutput(",");
            }
            this.emitIndent();
            this.writeLineToOutput("enumerable: true,");
            this.emitIndent();
            this.writeLineToOutput("configurable: true");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("});");
            this.recordSourceMappingEnd(funcDecl);
        };
        Emitter.prototype.emitPrototypeMember = function (member, className) {
            if (member.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                var funcDecl = member;
                if (funcDecl.isAccessor()) {
                    this.emitPropertyAccessor(funcDecl, className, true);
                } else {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                    this.emitInnerFunction(funcDecl, false, true, this.shouldCaptureThis(funcDecl), null);
                    this.writeLineToOutput(";");
                }
            } else if (member.nodeType === TypeScript.NodeType.VariableDeclarator) {
                var varDecl = member;
                if (varDecl.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(varDecl);
                    this.recordSourceMappingStart(varDecl.id);
                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);
                    this.recordSourceMappingEnd(varDecl.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(varDecl.init, false);
                    this.recordSourceMappingEnd(varDecl);
                    this.writeLineToOutput(";");
                }
            }
        };
        Emitter.prototype.emitJavascriptClass = function (classDecl) {
            if (!TypeScript.hasFlag(classDecl.getVarFlags(), TypeScript.VariableFlags.Ambient)) {
                var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl, this.document.fileName);
                this.pushDecl(pullDecl);
                var svClassNode = this.thisClassNode;
                this.thisClassNode = classDecl;
                var className = classDecl.name.actualText;
                this.emitComments(classDecl, true);
                var temp = this.setContainer(EmitContainer.Class);
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput("var " + className);
                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
                var baseNameDecl = null;
                var baseName = null;
                var varDecl = null;
                if (hasBaseClass) {
                    this.writeLineToOutput(" = (function (_super) {");
                } else {
                    this.writeLineToOutput(" = (function () {");
                }
                this.recordSourceMappingNameStart(className);
                this.indenter.increaseIndent();
                if (hasBaseClass) {
                    baseNameDecl = classDecl.extendsList.members[0];
                    baseName = baseNameDecl.nodeType === TypeScript.NodeType.InvocationExpression ? (baseNameDecl).target : baseNameDecl;
                    this.emitIndent();
                    this.writeLineToOutput("__extends(" + className + ", _super);");
                }
                this.emitIndent();
                var constrDecl = classDecl.constructorDecl;
                if (constrDecl) {
                    this.emitJavascript(classDecl.constructorDecl, false);
                } else {
                    var wroteProps = 0;
                    this.recordSourceMappingStart(classDecl);
                    this.indenter.increaseIndent();
                    this.writeToOutput("function " + classDecl.name.actualText + "() {");
                    this.recordSourceMappingNameStart("constructor");
                    if (hasBaseClass) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeLineToOutput("_super.apply(this, arguments);");
                        wroteProps++;
                    }
                    var members = this.thisClassNode.members.members;
                    for(var i = 0; i < members.length; i++) {
                        if (members[i].nodeType === TypeScript.NodeType.VariableDeclarator) {
                            varDecl = members[i];
                            if (!TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Static) && varDecl.init) {
                                this.writeLineToOutput("");
                                this.emitIndent();
                                this.emitJavascriptVariableDeclarator(varDecl);
                                wroteProps++;
                            }
                        }
                    }
                    if (wroteProps) {
                        this.writeLineToOutput("");
                        this.indenter.decreaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("}");
                    } else {
                        this.writeLineToOutput(" }");
                        this.indenter.decreaseIndent();
                    }
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(classDecl);
                }
                var membersLen = classDecl.members.members.length;
                for(var j = 0; j < membersLen; j++) {
                    var memberDecl = classDecl.members.members[j];
                    if (memberDecl.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                        var fn = memberDecl;
                        if (TypeScript.hasFlag(fn.getFunctionFlags(), TypeScript.FunctionFlags.Method) && !fn.isSignature()) {
                            if (!TypeScript.hasFlag(fn.getFunctionFlags(), TypeScript.FunctionFlags.Static)) {
                                this.emitPrototypeMember(fn, className);
                            } else {
                                if (fn.isAccessor()) {
                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                                } else {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(fn);
                                    this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true, this.shouldCaptureThis(fn), null);
                                    this.writeLineToOutput(";");
                                }
                            }
                        }
                    } else if (memberDecl.nodeType === TypeScript.NodeType.VariableDeclarator) {
                        varDecl = memberDecl;
                        if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Static)) {
                            if (varDecl.init) {
                                this.emitIndent();
                                this.recordSourceMappingStart(varDecl);
                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                                this.emitJavascript(varDecl.init, false);
                                this.writeLineToOutput(";");
                                this.recordSourceMappingEnd(varDecl);
                            }
                        }
                    } else {
                        throw Error("We want to catch this");
                    }
                }
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeLineToOutput("return " + className + ";");
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(")(");
                if (hasBaseClass) {
                    this.resolvingContext.resolvingTypeReference = true;
                    this.emitJavascript(baseName, false);
                    this.resolvingContext.resolvingTypeReference = false;
                }
                this.writeToOutput(");");
                this.recordSourceMappingEnd(classDecl);
                if ((temp === EmitContainer.Module || temp === EmitContainer.DynamicModule) && TypeScript.hasFlag(classDecl.getVarFlags(), TypeScript.VariableFlags.Exported)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = temp === EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(classDecl);
                    this.writeToOutput(modName + "." + className + " = " + className + ";");
                    this.recordSourceMappingEnd(classDecl);
                }
                this.emitIndent();
                this.recordSourceMappingEnd(classDecl);
                this.emitComments(classDecl, false);
                this.setContainer(temp);
                this.thisClassNode = svClassNode;
                this.popDecl(pullDecl);
            }
        };
        Emitter.prototype.emitPrologue = function (reqInherits) {
            if (!this.extendsPrologueEmitted) {
                if (reqInherits) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }
            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(null)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };
        Emitter.prototype.emitSuperReference = function () {
            this.writeToOutput("_super.prototype");
        };
        Emitter.prototype.emitSuperCall = function (callEx) {
            if (callEx.target.nodeType === TypeScript.NodeType.MemberAccessExpression) {
                var dotNode = callEx.target;
                if (dotNode.operand1.nodeType === TypeScript.NodeType.SuperExpression) {
                    this.emitJavascript(dotNode, false);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(callEx.arguments, ", ", false, false, false);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        };
        Emitter.prototype.emitThis = function () {
            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };
        Emitter.throwEmitterError = function throwEmitterError(e) {
            var error = new Error(e.message);
            error.isEmitterError = true;
            throw error;
        };
        Emitter.handleEmitterError = function handleEmitterError(fileName, e) {
            if ((e).isEmitterError === true) {
                return [
                    new TypeScript.Diagnostic(0, 0, fileName, e.message)
                ];
            }
            throw e;
        };
        Emitter.prototype.createFile = function (fileName, useUTF8) {
            try  {
                return this.emitOptions.ioHost.createFile(fileName, useUTF8);
            } catch (e) {
                Emitter.throwEmitterError(e);
            }
        };
        return Emitter;
    })();
    TypeScript.Emitter = Emitter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ErrorReporter = (function () {
        function ErrorReporter(outfile) {
            this.outfile = outfile;
            this.errorCallback = null;
            this.lineCol = {
                line: 0,
                character: 0
            };
            this.hasErrors = false;
            this.pushToErrorSink = false;
            this.errorSink = [];
        }
        ErrorReporter.prototype.getCapturedErrors = function () {
            return this.errorSink;
        };
        ErrorReporter.prototype.freeCapturedErrors = function () {
            this.errorSink = [];
        };
        ErrorReporter.prototype.captureError = function (emsg) {
            this.errorSink[this.errorSink.length] = emsg;
        };
        ErrorReporter.prototype.emitPrefix = function () {
            this.outfile.Write("(" + this.lineCol.line + "," + this.lineCol.character + "): ");
        };
        ErrorReporter.prototype.writePrefix = function (ast) {
            if (ast) {
                this.setError(ast);
            } else {
                this.lineCol.line = 0;
                this.lineCol.character = 0;
            }
            this.emitPrefix();
        };
        ErrorReporter.prototype.writePrefixFromSym = function (symbol) {
            if (symbol) {
                if (this.lineCol.line >= 0) {
                    this.lineCol.line++;
                }
            } else {
                this.lineCol.line = -1;
                this.lineCol.character = -1;
            }
            this.emitPrefix();
        };
        ErrorReporter.prototype.setError = function (ast) {
            if (ast) {
            }
        };
        ErrorReporter.prototype.reportError = function (ast, message) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }
            this.hasErrors = true;
            if (ast && this.errorCallback) {
                var len = (ast.limChar - ast.minChar);
                this.errorCallback(ast.minChar, len, message, null, null);
            } else {
                this.writePrefix(ast);
                this.outfile.WriteLine(message);
            }
        };
        ErrorReporter.prototype.reportErrorFromSym = function (symbol, message) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }
            this.hasErrors = true;
            if (this.errorCallback) {
                this.errorCallback(symbol.location, symbol.length, message, null, null);
            } else {
                this.writePrefixFromSym(symbol);
                this.outfile.WriteLine(message);
            }
        };
        ErrorReporter.prototype.duplicateIdentifier = function (ast, name) {
            this.reportError(ast, "Duplicate identifier '" + name + "'");
        };
        ErrorReporter.prototype.unresolvedSymbol = function (ast, name) {
            this.reportError(ast, "The name '" + name + "' does not exist in the current scope");
        };
        ErrorReporter.prototype.symbolDoesNotReferToAValue = function (ast, name) {
            this.reportError(ast, "The name '" + name + "' does not refer to a value");
        };
        ErrorReporter.prototype.styleError = function (ast, msg) {
            var bkThrow = this.pushToErrorSink;
            this.pushToErrorSink = false;
            this.reportError(ast, "STYLE: " + msg);
            this.pushToErrorSink = bkThrow;
        };
        ErrorReporter.prototype.simpleError = function (ast, msg) {
            this.reportError(ast, msg);
        };
        ErrorReporter.prototype.simpleErrorFromSym = function (sym, msg) {
            this.reportErrorFromSym(sym, msg);
        };
        ErrorReporter.prototype.Keyword__super__can_only_be_used_inside_a_class_instance_method = function (ast) {
            this.simpleError(ast, "Keyword 'super' can only be used inside a class instance method");
        };
        ErrorReporter.prototype.The_left_hand_side_of_an_assignment_expression_must_be_a_variable__property_or_indexer = function (ast) {
            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");
        };
        ErrorReporter.prototype.invalidCall = function (ast, nodeType, scope) {
            var targetType = ast.target.type;
            var typeName = targetType.getScopedTypeName(scope);
            if (targetType.construct && (nodeType == TypeScript.NodeType.InvocationExpression)) {
                this.reportError(ast, "Value of type '" + typeName + "' is not callable.  Did you mean to include 'new'?");
            } else {
                var catString = (nodeType == TypeScript.NodeType.InvocationExpression) ? "callable" : "newable";
                this.reportError(ast, "Value of type '" + typeName + "' is not " + catString);
            }
        };
        ErrorReporter.prototype.indexLHS = function (ast, scope) {
            var targetType = ast.operand1.type.getScopedTypeName(scope);
            var indexType = ast.operand2.type.getScopedTypeName(scope);
            this.simpleError(ast, "Value of type '" + targetType + "' is not indexable by type '" + indexType + "'");
        };
        ErrorReporter.prototype.incompatibleTypes = function (ast, t1, t2, op, scope, comparisonInfo) {
            if (!t1) {
            }
            if (!t2) {
            }
            var reason = comparisonInfo ? comparisonInfo.message : "";
            if (op) {
                this.reportError(ast, "Operator '" + op + "' cannot be applied to types '" + t1.getScopedTypeName(scope) + "' and '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            } else {
                this.reportError(ast, "Cannot convert '" + t1.getScopedTypeName(scope) + "' to '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            }
        };
        ErrorReporter.prototype.Expected_var__class__interface__or_module = function (ast) {
            this.simpleError(ast, "Expected var, class, interface, or module");
        };
        ErrorReporter.prototype.unaryOperatorTypeError = function (ast, op, type) {
            this.reportError(ast, "Operator '" + op + "' cannot be applied to type '" + type.getTypeName() + "'");
        };
        return ErrorReporter;
    })();
    TypeScript.ErrorReporter = ErrorReporter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PrintContext = (function () {
        function PrintContext(outfile) {
            this.outfile = outfile;
            this.builder = "";
            this.indent1 = "  ";
            this.indentStrings = [];
            this.indentAmt = 0;
        }
        PrintContext.prototype.increaseIndent = function () {
            this.indentAmt++;
        };
        PrintContext.prototype.decreaseIndent = function () {
            this.indentAmt--;
        };
        PrintContext.prototype.startLine = function () {
            if (this.builder.length > 0) {
                TypeScript.CompilerDiagnostics.Alert(this.builder);
            }
            var indentString = this.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for(var i = 0; i < this.indentAmt; i++) {
                    indentString += this.indent1;
                }
                this.indentStrings[this.indentAmt] = indentString;
            }
            this.builder += indentString;
        };
        PrintContext.prototype.write = function (s) {
            this.builder += s;
        };
        PrintContext.prototype.writeLine = function (s) {
            this.builder += s;
            this.outfile.WriteLine(this.builder);
            this.builder = "";
        };
        return PrintContext;
    })();
    TypeScript.PrintContext = PrintContext;    
    function prePrintAST(ast, parent, walker) {
        var pc = walker.state;
        ast.print(pc);
        pc.increaseIndent();
        return ast;
    }
    TypeScript.prePrintAST = prePrintAST;
    function postPrintAST(ast, parent, walker) {
        var pc = walker.state;
        pc.decreaseIndent();
        return ast;
    }
    TypeScript.postPrintAST = postPrintAST;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AssignScopeContext = (function () {
        function AssignScopeContext(scopeChain, typeFlow, modDeclChain) {
            this.scopeChain = scopeChain;
            this.typeFlow = typeFlow;
            this.modDeclChain = modDeclChain;
        }
        return AssignScopeContext;
    })();
    TypeScript.AssignScopeContext = AssignScopeContext;    
    function pushAssignScope(scope, context, type, classType, fnc) {
        var chain = new TypeScript.ScopeChain(null, context.scopeChain, scope);
        chain.thisType = type;
        chain.classType = classType;
        chain.fnc = fnc;
        context.scopeChain = chain;
    }
    TypeScript.pushAssignScope = pushAssignScope;
    function popAssignScope(context) {
        context.scopeChain = context.scopeChain.previous;
    }
    TypeScript.popAssignScope = popAssignScope;
    function instanceCompare(a, b) {
        if (((a === null) || (!a.isInstanceProperty()))) {
            return b;
        } else {
            return a;
        }
    }
    TypeScript.instanceCompare = instanceCompare;
    function instanceFilterStop(s) {
        return s.isInstanceProperty();
    }
    TypeScript.instanceFilterStop = instanceFilterStop;
    var ScopeSearchFilter = (function () {
        function ScopeSearchFilter(select, stop) {
            this.select = select;
            this.stop = stop;
            this.result = null;
        }
        ScopeSearchFilter.prototype.reset = function () {
            this.result = null;
        };
        ScopeSearchFilter.prototype.update = function (b) {
            this.result = this.select(this.result, b);
            if (this.result) {
                return this.stop(this.result);
            } else {
                return false;
            }
        };
        return ScopeSearchFilter;
    })();
    TypeScript.ScopeSearchFilter = ScopeSearchFilter;    
    TypeScript.instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);
    function preAssignModuleScopes(ast, context) {
        var moduleDecl = ast;
        var memberScope = null;
        var aggScope = null;
        if (moduleDecl.name && moduleDecl.mod) {
            moduleDecl.name.sym = moduleDecl.mod.symbol;
        }
        var mod = moduleDecl.mod;
        if (!mod) {
            return;
        }
        memberScope = new TypeScript.SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);
        mod.memberScope = memberScope;
        context.modDeclChain.push(moduleDecl);
        context.typeFlow.checker.currentModDecl = moduleDecl;
        aggScope = new TypeScript.SymbolAggregateScope(mod.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        mod.containedScope = aggScope;
        if (mod.symbol) {
            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, null, mod.members.privateMembers, true);
        }
    }
    TypeScript.preAssignModuleScopes = preAssignModuleScopes;
    function preAssignClassScopes(ast, context) {
        var classDecl = ast;
        var memberScope = null;
        var aggScope = null;
        if (classDecl.name && classDecl.type) {
            classDecl.name.sym = classDecl.type.symbol;
        }
        var classType = ast.type;
        if (classType) {
            var classSym = classType.symbol;
            memberScope = context.typeFlow.checker.scopeOf(classType);
            aggScope = new TypeScript.SymbolAggregateScope(classType.symbol);
            aggScope.addParentScope(memberScope);
            aggScope.addParentScope(context.scopeChain.scope);
            classType.containedScope = aggScope;
            classType.memberScope = memberScope;
            var instanceType = classType.instanceType;
            memberScope = context.typeFlow.checker.scopeOf(instanceType);
            instanceType.memberScope = memberScope;
            aggScope = new TypeScript.SymbolAggregateScope(instanceType.symbol);
            aggScope.addParentScope(context.scopeChain.scope);
            pushAssignScope(aggScope, context, instanceType, classType, null);
            instanceType.containedScope = aggScope;
        } else {
            ast.type = context.typeFlow.anyType;
        }
    }
    TypeScript.preAssignClassScopes = preAssignClassScopes;
    function preAssignInterfaceScopes(ast, context) {
        var interfaceDecl = ast;
        var memberScope = null;
        var aggScope = null;
        if (interfaceDecl.name && interfaceDecl.type) {
            interfaceDecl.name.sym = interfaceDecl.type.symbol;
        }
        var interfaceType = ast.type;
        memberScope = context.typeFlow.checker.scopeOf(interfaceType);
        interfaceType.memberScope = memberScope;
        aggScope = new TypeScript.SymbolAggregateScope(interfaceType.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        interfaceType.containedScope = aggScope;
    }
    TypeScript.preAssignInterfaceScopes = preAssignInterfaceScopes;
    function preAssignWithScopes(ast, context) {
        var withStmt = ast;
        var withType = withStmt.type;
        var members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
        var ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
        withType = new TypeScript.Type();
        var withSymbol = new TypeScript.WithSymbol(withStmt.minChar, null, withType, context.typeFlow.compilationSettings.optimizeModuleCodeGen);
        withType.members = members;
        withType.ambientMembers = ambientMembers;
        withType.symbol = withSymbol;
        withType.setHasImplementation();
        withStmt.type = withType;
        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);
        pushAssignScope(withScope, context, null, null, null);
        withType.containedScope = withScope;
    }
    TypeScript.preAssignWithScopes = preAssignWithScopes;
    function preAssignFuncDeclScopes(ast, context) {
        var funcDecl = ast;
        var container = null;
        var localContainer = null;
        if (funcDecl.type) {
            localContainer = ast.type.symbol;
        }
        var isStatic = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Static);
        var isInnerStatic = isStatic && context.scopeChain.fnc != null;
        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;
        if (context.scopeChain.thisType && (!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod))) {
            var instType = context.scopeChain.thisType;
            if (!(instType.typeFlags & TypeScript.TypeFlags.IsClass) && !TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod)) {
                if (!funcDecl.isMethod() || isStatic) {
                    parentScope = instType.constructorScope;
                } else {
                    parentScope = instType.containedScope;
                }
            } else {
                if (context.scopeChain.previous.scope.container && context.scopeChain.previous.scope.container.declAST && context.scopeChain.previous.scope.container.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && (context.scopeChain.previous.scope.container.declAST).isConstructor) {
                    parentScope = instType.constructorScope;
                } else if (isStatic && context.scopeChain.classType) {
                    parentScope = context.scopeChain.classType.containedScope;
                } else {
                    parentScope = instType.containedScope;
                }
            }
            container = instType.symbol;
        } else if (funcDecl.isConstructor && context.scopeChain.thisType) {
            container = context.scopeChain.thisType.symbol;
        }
        var fgSym = null;
        if (funcDecl.type === null || TypeScript.hasFlag(funcDecl.type.symbol.flags, TypeScript.SymbolFlags.TypeSetDuringScopeAssignment)) {
            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {
                container = context.scopeChain.fnc.type.symbol;
            }
            var funcScope = null;
            var outerFnc = context.scopeChain.fnc;
            var nameText = funcDecl.name ? funcDecl.name.text : null;
            if (isStatic) {
                if (outerFnc.type.members === null && container.getType().memberScope) {
                    outerFnc.type.members = ((container).type.memberScope).valueMembers;
                }
                funcScope = context.scopeChain.fnc.type.memberScope;
            } else {
                funcScope = context.scopeChain.scope;
            }
            if (nameText && nameText != "__missing" && !funcDecl.isAccessor()) {
                if (isStatic) {
                    fgSym = funcScope.findLocal(nameText, false, false);
                } else {
                    fgSym = funcScope.findLocal(nameText, false, false);
                }
            }
            context.typeFlow.checker.createFunctionSignature(funcDecl, container, funcScope, fgSym, fgSym === null);
            if (!funcDecl.accessorSymbol && (funcDecl.getFunctionFlags() & TypeScript.FunctionFlags.ClassMethod) && container && ((!fgSym || fgSym.declAST.nodeType != TypeScript.NodeType.FunctionDeclaration) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {
                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);
            }
            funcDecl.type.symbol.flags |= TypeScript.SymbolFlags.TypeSetDuringScopeAssignment;
        }
        if (funcDecl.name && funcDecl.type) {
            funcDecl.name.sym = funcDecl.type.symbol;
        }
        funcDecl.scopeType = funcDecl.type;
        var funcTable = new TypeScript.StringHashTable();
        var funcMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(funcTable, new TypeScript.StringHashTable()));
        var ambientFuncTable = new TypeScript.StringHashTable();
        var ambientFuncMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(ambientFuncTable, new TypeScript.StringHashTable()));
        var funcStaticTable = new TypeScript.StringHashTable();
        var funcStaticMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(funcStaticTable, new TypeScript.StringHashTable()));
        var ambientFuncStaticTable = new TypeScript.StringHashTable();
        var ambientFuncStaticMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(ambientFuncStaticTable, new TypeScript.StringHashTable()));
        var locals = new TypeScript.SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);
        var statics = new TypeScript.SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);
        if (funcDecl.isConstructor && context.scopeChain.thisType) {
            context.scopeChain.thisType.constructorScope = locals;
        }
        funcDecl.symbols = funcTable;
        if (!funcDecl.isSpecialFn()) {
            var group = funcDecl.type;
            var signature = funcDecl.signature;
            if (!funcDecl.isConstructor) {
                group.containedScope = locals;
                locals.container = group.symbol;
                group.memberScope = statics;
                statics.container = group.symbol;
            }
            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;
            fgSym = ast.type.symbol;
            if (((funcDecl.getFunctionFlags() & TypeScript.FunctionFlags.Signature) === TypeScript.FunctionFlags.None) && false) {
                context.typeFlow.addLocalsFromScope(locals, fgSym, null, funcTable, false);
                context.typeFlow.addLocalsFromScope(statics, fgSym, null, funcStaticTable, false);
            }
            if (signature.parameters) {
                var len = signature.parameters.length;
                for(var i = 0; i < len; i++) {
                    var paramSym = signature.parameters[i];
                    context.typeFlow.checker.resolveTypeLink(locals, paramSym.parameter.typeLink, true);
                }
            }
            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType, funcDecl.isSignature());
        }
        if (!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod)) {
            var thisType = (funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod)) ? context.scopeChain.thisType : null;
            pushAssignScope(locals, context, thisType, null, funcDecl);
        }
        if (funcDecl.name && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.IsFunctionExpression) && !funcDecl.isAccessor()) {
            if (funcDecl.name.sym) {
                funcTable.add(funcDecl.name.text, funcDecl.name.sym);
            }
        }
    }
    TypeScript.preAssignFuncDeclScopes = preAssignFuncDeclScopes;
    function preAssignCatchScopes(ast, context) {
        var catchBlock = ast;
        if (catchBlock.param) {
            var catchTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            var catchLocals = new TypeScript.SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope, context.scopeChain.scope.container);
            catchBlock.containedScope = catchLocals;
            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);
        }
    }
    TypeScript.preAssignCatchScopes = preAssignCatchScopes;
    function preAssignScopes(ast, parent, walker) {
        var context = walker.state;
        var go = true;
        if (ast) {
            if (ast.nodeType === TypeScript.NodeType.List) {
                var list = ast;
            } else if (ast.nodeType === TypeScript.NodeType.ModuleDeclaration) {
                preAssignModuleScopes(ast, context);
            } else if (ast.nodeType === TypeScript.NodeType.ClassDeclaration) {
                preAssignClassScopes(ast, context);
            } else if (ast.nodeType === TypeScript.NodeType.InterfaceDeclaration) {
                preAssignInterfaceScopes(ast, context);
            } else if (ast.nodeType === TypeScript.NodeType.WithStatement) {
                preAssignWithScopes(ast, context);
            } else if (ast.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                preAssignFuncDeclScopes(ast, context);
            } else if (ast.nodeType === TypeScript.NodeType.CatchClause) {
                preAssignCatchScopes(ast, context);
            } else if (ast.nodeType === TypeScript.NodeType.TypeRef) {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.preAssignScopes = preAssignScopes;
    function postAssignScopes(ast, parent, walker) {
        var context = walker.state;
        var go = true;
        if (ast) {
            if (ast.nodeType === TypeScript.NodeType.ModuleDeclaration) {
                var prevModDecl = ast;
                popAssignScope(context);
                context.modDeclChain.pop();
                if (context.modDeclChain.length >= 1) {
                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];
                }
            } else if (ast.nodeType === TypeScript.NodeType.ClassDeclaration) {
                popAssignScope(context);
            } else if (ast.nodeType === TypeScript.NodeType.InterfaceDeclaration) {
                popAssignScope(context);
            } else if (ast.nodeType === TypeScript.NodeType.WithStatement) {
                popAssignScope(context);
            } else if (ast.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                var funcDecl = ast;
                if ((!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod))) {
                    popAssignScope(context);
                }
            } else if (ast.nodeType === TypeScript.NodeType.CatchClause) {
                var catchBlock = ast;
                if (catchBlock.param) {
                    popAssignScope(context);
                }
            } else {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.postAssignScopes = postAssignScopes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TypeCollectionContext = (function () {
        function TypeCollectionContext(scopeChain, checker) {
            this.scopeChain = scopeChain;
            this.checker = checker;
            this.script = null;
        }
        return TypeCollectionContext;
    })();
    TypeScript.TypeCollectionContext = TypeCollectionContext;    
    function pushTypeCollectionScope(container, valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, context, thisType, classType, moduleDecl) {
        var builder = new TypeScript.SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);
        var chain = new TypeScript.ScopeChain(container, context.scopeChain, builder);
        chain.thisType = thisType;
        chain.classType = classType;
        chain.moduleDecl = moduleDecl;
        context.scopeChain = chain;
    }
    TypeScript.pushTypeCollectionScope = pushTypeCollectionScope;
    function popTypeCollectionScope(context) {
        context.scopeChain = context.scopeChain.previous;
    }
    TypeScript.popTypeCollectionScope = popTypeCollectionScope;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Signature = (function () {
        function Signature() {
            this.hasVariableArgList = false;
            this.parameters = null;
            this.declAST = null;
            this.typeCheckStatus = TypeScript.TypeCheckStatus.NotStarted;
            this.nonOptionalParameterCount = 0;
        }
        Signature.prototype.specializeType = function (pattern, replacement, checker) {
            var result = new Signature();
            if (this.hasVariableArgList) {
                result.hasVariableArgList = true;
            }
            result.returnType = new TypeScript.TypeLink();
            if (this.returnType.type) {
                result.returnType.type = this.returnType.type.specializeType(pattern, replacement, checker, false);
            } else {
                result.returnType.type = checker.anyType;
            }
            if (this.parameters) {
                result.parameters = [];
                for(var i = 0, len = this.parameters.length; i < len; i++) {
                    var oldSym = this.parameters[i];
                    var paramDef = new TypeScript.ValueLocation();
                    var paramSym = new TypeScript.ParameterSymbol(oldSym.name, oldSym.location, null, paramDef);
                    paramSym.declAST = this.declAST;
                    paramDef.symbol = paramSym;
                    paramDef.typeLink = new TypeScript.TypeLink();
                    result.parameters[i] = paramSym;
                    var oldType = oldSym.getType();
                    if (oldType) {
                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);
                    } else {
                        paramDef.typeLink.type = checker.anyType;
                    }
                }
            }
            result.nonOptionalParameterCount = this.nonOptionalParameterCount;
            result.declAST = this.declAST;
            return result;
        };
        Signature.prototype.toString = function () {
            return this.toStringHelper(false, false, null);
        };
        Signature.prototype.toStringHelper = function (shortform, brackets, scope) {
            return this.toStringHelperEx(shortform, brackets, scope).toString();
        };
        Signature.prototype.toStringHelperEx = function (shortform, brackets, scope, prefix) {
            if (typeof prefix === "undefined") { prefix = ""; }
            var builder = new TypeScript.MemberNameArray();
            if (brackets) {
                builder.prefix = prefix + "[";
            } else {
                builder.prefix = prefix + "(";
            }
            var paramLen = this.parameters.length;
            var len = this.hasVariableArgList ? paramLen - 1 : paramLen;
            for(var i = 0; i < len; i++) {
                builder.add(TypeScript.MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }
            if (this.hasVariableArgList) {
                builder.add(TypeScript.MemberName.create("..." + this.parameters[i].name + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
            }
            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                } else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            } else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                } else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }
            if (this.returnType.type) {
                builder.add(this.returnType.type.getScopedTypeNameEx(scope));
            } else {
                builder.add(TypeScript.MemberName.create("any"));
            }
            return builder;
        };
        return Signature;
    })();
    TypeScript.Signature = Signature;    
    var SignatureGroup = (function () {
        function SignatureGroup() {
            this.signatures = [];
            this.hasImplementation = true;
            this.definitionSignature = null;
            this.hasBeenTypechecked = false;
            this.flags = TypeScript.SignatureFlags.None;
        }
        SignatureGroup.prototype.addSignature = function (signature) {
            if (this.signatures == null) {
                this.signatures = [];
            }
            this.signatures[this.signatures.length] = signature;
            if (signature.declAST && !signature.declAST.isSignature() && !TypeScript.hasFlag(signature.declAST.getFunctionFlags(), TypeScript.FunctionFlags.Ambient) && !TypeScript.hasFlag(signature.declAST.getFunctionFlags(), TypeScript.FunctionFlags.Signature)) {
                this.definitionSignature = signature;
            }
        };
        SignatureGroup.prototype.toString = function () {
            return this.signatures.toString();
        };
        SignatureGroup.prototype.toStrings = function (prefix, shortform, scope, getPrettyTypeName, useSignature) {
            var _this = this;
            var result = [];
            var len = this.signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }
            var getMemberNameOfSignature = function (signature) {
                if (_this.flags & TypeScript.SignatureFlags.IsIndexer) {
                    return signature.toStringHelperEx(shortform, true, scope);
                } else {
                    return signature.toStringHelperEx(shortform, false, scope, prefix);
                }
            };
            if (useSignature) {
                result.push(getMemberNameOfSignature(useSignature));
            } else {
                for(var i = 0; i < len; i++) {
                    if (len > 1 && this.signatures[i] == this.definitionSignature) {
                        continue;
                    }
                    result.push(getMemberNameOfSignature(this.signatures[i]));
                    if (getPrettyTypeName) {
                        break;
                    }
                }
            }
            if (getPrettyTypeName && len > 1) {
                var lastMemberName = result[result.length - 1];
                var overloadString = " (+ " + ((this.definitionSignature != null) ? len - 2 : len - 1) + " overload(s))";
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }
            return result;
        };
        SignatureGroup.prototype.specializeType = function (pattern, replacement, checker) {
            var result = new SignatureGroup();
            if (this.signatures) {
                for(var i = 0, len = this.signatures.length; i < len; i++) {
                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));
                }
            }
            return result;
        };
        SignatureGroup.prototype.verifySignatures = function (checker) {
            var len = 0;
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                for(var i = 0; i < len; i++) {
                    for(var j = i + 1; j < len; j++) {
                        if (this.signatures[i].declAST && this.signatures[j].declAST && (TypeScript.hasFlag(this.signatures[i].declAST.getFunctionFlags(), TypeScript.FunctionFlags.Signature) && TypeScript.hasFlag(this.signatures[j].declAST.getFunctionFlags(), TypeScript.FunctionFlags.Signature)) && checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for '" + this.signatures[i].declAST.name.actualText + "' is duplicated" : "Signature is duplicated");
                        }
                    }
                    if (this.definitionSignature) {
                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");
                        }
                    }
                }
            }
        };
        SignatureGroup.prototype.typeCheck = function (checker, ast, hasConstruct) {
            if (this.hasBeenTypechecked) {
                return;
            }
            this.hasBeenTypechecked = true;
            var len = 0;
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                for(var i = 0; i < len; i++) {
                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && !TypeScript.hasFlag(this.signatures[i].declAST.getFunctionFlags(), TypeScript.FunctionFlags.Ambient)) {
                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");
                    }
                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeScript.TypeCheckStatus.NotStarted) {
                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);
                    }
                    checker.typeFlow.typeCheck(this.signatures[i].declAST);
                }
                this.verifySignatures(checker);
            }
        };
        return SignatureGroup;
    })();
    TypeScript.SignatureGroup = SignatureGroup;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TypeCheckStatus) {
        TypeCheckStatus._map = [];
        TypeCheckStatus._map[0] = "NotStarted";
        TypeCheckStatus.NotStarted = 0;
        TypeCheckStatus._map[1] = "Started";
        TypeCheckStatus.Started = 1;
        TypeCheckStatus._map[2] = "Finished";
        TypeCheckStatus.Finished = 2;
    })(TypeScript.TypeCheckStatus || (TypeScript.TypeCheckStatus = {}));
    var TypeCheckStatus = TypeScript.TypeCheckStatus;
    function aLexicallyEnclosesB(a, b) {
        if (a.declAST && b && b.declAST && a.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration) {
            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;
        } else {
            return false;
        }
    }
    TypeScript.aLexicallyEnclosesB = aLexicallyEnclosesB;
    function aEnclosesB(a, b) {
        while(a.container) {
            if (a === b || aLexicallyEnclosesB(a.container, b)) {
                return true;
            }
            a = a.container;
        }
        return false;
    }
    TypeScript.aEnclosesB = aEnclosesB;
    var Symbol = (function () {
        function Symbol(name, location, length, fileName) {
            this.name = name;
            this.location = location;
            this.length = length;
            this.fileName = fileName;
            this.bound = false;
            this.flags = TypeScript.SymbolFlags.None;
            this.isObjectLitField = false;
            this.declAST = null;
            this.declModule = null;
            this.passSymbolCreated = TypeScript.CompilerDiagnostics.analysisPass;
        }
        Symbol.prototype.instanceScope = function () {
            return null;
        };
        Symbol.prototype.isVariable = function () {
            return false;
        };
        Symbol.prototype.isMember = function () {
            return false;
        };
        Symbol.prototype.isInferenceSymbol = function () {
            return false;
        };
        Symbol.prototype.isWith = function () {
            return false;
        };
        Symbol.prototype.writeable = function () {
            return false;
        };
        Symbol.prototype.isType = function () {
            return false;
        };
        Symbol.prototype.getType = function () {
            return null;
        };
        Symbol.prototype.isAccessor = function () {
            return false;
        };
        Symbol.prototype.isInstanceProperty = function () {
            return TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Property) && (!TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.ModuleMember));
        };
        Symbol.prototype.getTypeName = function (scope) {
            return this.getTypeNameEx(scope).toString();
        };
        Symbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.toString());
        };
        Symbol.prototype.getOptionalNameString = function () {
            return TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Optional) ? "?" : "";
        };
        Symbol.prototype.pathToRoot = function () {
            var path = [];
            var node = this;
            while(node && (node.name != TypeScript.globalId)) {
                path[path.length] = node;
                node = node.container;
            }
            return path;
        };
        Symbol.prototype.findCommonAncestorPath = function (b) {
            if (this.container === null) {
                return [];
            }
            var aPath = this.container.pathToRoot();
            var bPath;
            if (b) {
                bPath = b.pathToRoot();
            } else {
                bPath = [];
            }
            var commonNodeIndex = -1;
            for(var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for(var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode === bNode) {
                        commonNodeIndex = i;
                        break;
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }
            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            } else {
                return aPath;
            }
        };
        Symbol.prototype.getPrettyName = function (scopeSymbol) {
            return this.name;
        };
        Symbol.prototype.scopeRelativeName = function (scope) {
            if (scope === null) {
                return this.getPrettyName(null) + this.getOptionalNameString();
            }
            var lca = this.findCommonAncestorPath(scope.container);
            var builder = "";
            for(var i = 0, len = lca.length; i < len; i++) {
                var prettyName = lca[i].getPrettyName(i === len - 1 ? scope.container : lca[i + 1]);
                builder = prettyName + "." + builder;
            }
            builder += this.getPrettyName(len === 0 ? scope.container : lca[0]) + this.getOptionalNameString();
            return builder;
        };
        Symbol.prototype.fullName = function (scope) {
            var scopeSymbol = !scope ? null : scope.container;
            var scopeRootPath = !scopeSymbol ? [] : scopeSymbol.pathToRoot();
            var dynamicModuleRoot = null;
            if (scopeRootPath.length > 0 && scopeRootPath[scopeRootPath.length - 1].declAST && scopeRootPath[scopeRootPath.length - 1].declAST.nodeType === TypeScript.NodeType.ModuleDeclaration && (scopeRootPath[scopeRootPath.length - 1].declAST).isWholeFile()) {
                dynamicModuleRoot = scopeRootPath[scopeRootPath.length - 1];
            }
            var builder = this.getPrettyName(scopeSymbol);
            var ancestor = this.container;
            while(ancestor && (ancestor.name != TypeScript.globalId) && ancestor != dynamicModuleRoot) {
                builder = ancestor.getPrettyName(scopeSymbol) + "." + builder;
                ancestor = ancestor.container;
            }
            return builder;
        };
        Symbol.prototype.isExternallyVisible = function (checker) {
            if (this === checker.gloMod) {
                return true;
            }
            if (TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Private)) {
                return false;
            }
            if (!TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Exported)) {
                return this.container === checker.gloMod;
            }
            return this.container.isExternallyVisible(checker);
        };
        Symbol.prototype.visible = function (scope, checker) {
            if (checker === null || this.container === checker.gloMod) {
                return true;
            }
            if (TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.ModuleMember)) {
                if (TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Exported)) {
                    if (!TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Private)) {
                        return true;
                    } else {
                        return aEnclosesB(this, scope.container);
                    }
                } else {
                    return checker && (checker.currentModDecl === this.declModule) || (checker.currentModDecl && checker.currentModDecl.mod && checker.currentModDecl.mod.symbol && this.declModule && this.declModule.mod && this.declModule.mod.symbol && aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));
                }
            } else {
                var isFunction = this.declAST && this.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration;
                var isMethod = isFunction && (this.declAST).isMethod();
                var isStaticFunction = isFunction && TypeScript.hasFlag((this.declAST).getFunctionFlags(), TypeScript.FunctionFlags.Static);
                var isPrivateMethod = isMethod && TypeScript.hasFlag((this.declAST).getFunctionFlags(), TypeScript.FunctionFlags.Private);
                var isAlias = this.isType() && (this).aliasLink;
                if (this.isMember() || isMethod || isStaticFunction || isAlias) {
                    if (TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Private) || isPrivateMethod) {
                        if (scope.container === null && this.container != scope.container) {
                            return false;
                        } else {
                            return this.container === null ? true : aEnclosesB(scope.container, this.container);
                        }
                    } else {
                        return true;
                    }
                } else if (this.container) {
                    return aEnclosesB(this, scope.container);
                } else {
                    return true;
                }
            }
        };
        Symbol.prototype.addRef = function (identifier) {
            if (!this.refs) {
                this.refs = [];
            }
            this.refs[this.refs.length] = identifier;
        };
        Symbol.prototype.toString = function () {
            if (this.name) {
                return this.name;
            } else {
                return "_anonymous";
            }
        };
        Symbol.prototype.print = function (outfile) {
            outfile.Write(this.toString());
        };
        Symbol.prototype.specializeType = function (pattern, replacement, checker) {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.setType = function (type) {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.kind = function () {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.getInterfaceDeclFromSymbol = function (checker) {
            if (this.declAST != null) {
                if (this.declAST.nodeType === TypeScript.NodeType.InterfaceDeclaration) {
                    return this.declAST;
                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType === TypeScript.NodeType.InterfaceDeclaration) {
                    return this.container.declAST;
                }
            }
            return null;
        };
        Symbol.prototype.getVarDeclFromSymbol = function () {
            if (this.declAST != null && this.declAST.nodeType === TypeScript.NodeType.VariableDeclarator) {
                return this.declAST;
            }
            return null;
        };
        Symbol.prototype.getDocComments = function () {
            if (this.declAST != null) {
                return this.declAST.getDocComments();
            }
            return [];
        };
        Symbol.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.flags, TypeScript.SymbolFlags.Static);
        };
        return Symbol;
    })();
    TypeScript.Symbol = Symbol;    
    var ValueLocation = (function () {
        function ValueLocation() { }
        return ValueLocation;
    })();
    TypeScript.ValueLocation = ValueLocation;    
    var InferenceSymbol = (function (_super) {
        __extends(InferenceSymbol, _super);
        function InferenceSymbol(name, location, length, fileName) {
            _super.call(this, name, location, length, fileName);
            this.typeCheckStatus = TypeCheckStatus.NotStarted;
        }
        InferenceSymbol.prototype.isInferenceSymbol = function () {
            return true;
        };
        InferenceSymbol.prototype.transferVarFlags = function (varFlags) {
            if (TypeScript.hasFlag(varFlags, TypeScript.VariableFlags.Ambient)) {
                this.flags |= TypeScript.SymbolFlags.Ambient;
            }
            if (TypeScript.hasFlag(varFlags, TypeScript.VariableFlags.Constant)) {
                this.flags |= TypeScript.SymbolFlags.Constant;
            }
            if (TypeScript.hasFlag(varFlags, TypeScript.VariableFlags.Static)) {
                this.flags |= TypeScript.SymbolFlags.Static;
            }
            if (TypeScript.hasFlag(varFlags, TypeScript.VariableFlags.Property)) {
                this.flags |= TypeScript.SymbolFlags.Property;
            }
            if (TypeScript.hasFlag(varFlags, TypeScript.VariableFlags.Private)) {
                this.flags |= TypeScript.SymbolFlags.Private;
            }
            if (TypeScript.hasFlag(varFlags, TypeScript.VariableFlags.Public)) {
                this.flags |= TypeScript.SymbolFlags.Public;
            }
            if (TypeScript.hasFlag(varFlags, TypeScript.VariableFlags.Exported)) {
                this.flags |= TypeScript.SymbolFlags.Exported;
            }
        };
        return InferenceSymbol;
    })(Symbol);
    TypeScript.InferenceSymbol = InferenceSymbol;    
    var TypeSymbol = (function (_super) {
        __extends(TypeSymbol, _super);
        function TypeSymbol(locName, location, length, fileName, type, optimizeModuleCodeGen) {
            _super.call(this, locName, location, length, fileName);
            this.type = type;
            this.expansions = [];
            this.expansionsDeclAST = [];
            this.isDynamic = false;
            this.isMethod = false;
            this.aliasLink = null;
            this.prettyName = this.name;
            this.onlyReferencedAsTypeRef = optimizeModuleCodeGen;
        }
        TypeSymbol.prototype.addLocation = function (loc) {
            if (!this.additionalLocations) {
                this.additionalLocations = [];
            }
            this.additionalLocations[this.additionalLocations.length] = loc;
        };
        TypeSymbol.prototype.kind = function () {
            return TypeScript.SymbolKind.Type;
        };
        TypeSymbol.prototype.isType = function () {
            return true;
        };
        TypeSymbol.prototype.getType = function () {
            return this.type;
        };
        TypeSymbol.prototype.getTypeNameEx = function (scope) {
            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);
        };
        TypeSymbol.prototype.instanceScope = function () {
            if (!(this.type.typeFlags & TypeScript.TypeFlags.IsClass) && this.type.isClass()) {
                return this.type.instanceType.constructorScope;
            } else {
                return this.type.containedScope;
            }
        };
        TypeSymbol.prototype.toString = function () {
            var result = this.type.getTypeName();
            if (this.name) {
                result = this.name + ":" + result;
            }
            return result;
        };
        TypeSymbol.prototype.isClass = function () {
            return this.instanceType != null;
        };
        TypeSymbol.prototype.isFunction = function () {
            return this.declAST != null && this.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration;
        };
        TypeSymbol.prototype.specializeType = function (pattern, replacement, checker) {
            if (this.type === pattern) {
                return replacement.symbol;
            } else {
                var replType = this.type.specializeType(pattern, replacement, checker, false);
                if (replType != this.type) {
                    var result = new TypeSymbol(this.name, -1, 0, "", replType, checker.compilationSettings.optimizeModuleCodeGen);
                    return result;
                } else {
                    return this;
                }
            }
        };
        TypeSymbol.prototype.getPrettyName = function (scopeSymbol) {
            if (!!scopeSymbol && TypeScript.isQuoted(this.prettyName) && this.type.isModuleType()) {
                var symbolPath = scopeSymbol.pathToRoot();
                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);
                if (prettyName != null) {
                    return prettyName.name;
                }
            }
            return this.prettyName;
        };
        TypeSymbol.prototype.getPrettyNameOfDynamicModule = function (scopeSymbolPath) {
            var scopeSymbolPathLength = scopeSymbolPath.length;
            var externalSymbol = null;
            var moduleType;
            if (scopeSymbolPath.length > 0 && scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() && (scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {
                if (scopeSymbolPathLength > 1 && scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() && (scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {
                    moduleType = scopeSymbolPath[scopeSymbolPathLength - 2].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);
                }
                if (externalSymbol === null) {
                    moduleType = scopeSymbolPath[scopeSymbolPathLength - 1].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);
                }
            }
            return externalSymbol;
        };
        TypeSymbol.prototype.getDocComments = function () {
            var comments = [];
            if (this.declAST != null) {
                comments = comments.concat(this.declAST.getDocComments());
            }
            for(var i = 0; i < this.expansionsDeclAST.length; i++) {
                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());
            }
            return comments;
        };
        return TypeSymbol;
    })(InferenceSymbol);
    TypeScript.TypeSymbol = TypeSymbol;    
    var WithSymbol = (function (_super) {
        __extends(WithSymbol, _super);
        function WithSymbol(location, fileName, withType, optimizeModuleCodeGen) {
            _super.call(this, "with", location, 4, fileName, withType, optimizeModuleCodeGen);
        }
        WithSymbol.prototype.isWith = function () {
            return true;
        };
        return WithSymbol;
    })(TypeSymbol);
    TypeScript.WithSymbol = WithSymbol;    
    var FieldSymbol = (function (_super) {
        __extends(FieldSymbol, _super);
        function FieldSymbol(name, location, fileName, canWrite, field) {
            _super.call(this, name, location, name.length, fileName);
            this.canWrite = canWrite;
            this.field = field;
            this.getter = null;
            this.setter = null;
            this.hasBeenEmitted = false;
            this.name = name;
            this.location = location;
        }
        FieldSymbol.prototype.kind = function () {
            return TypeScript.SymbolKind.Field;
        };
        FieldSymbol.prototype.writeable = function () {
            return this.isAccessor() ? this.setter != null : this.canWrite;
        };
        FieldSymbol.prototype.getType = function () {
            return this.field.typeLink.type;
        };
        FieldSymbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.field.typeLink.type ? this.field.typeLink.type.getScopedTypeNameEx(scope) : TypeScript.MemberName.create("any"), this.name + this.getOptionalNameString() + ": ", "");
        };
        FieldSymbol.prototype.isMember = function () {
            return true;
        };
        FieldSymbol.prototype.setType = function (type) {
            this.field.typeLink.type = type;
        };
        FieldSymbol.prototype.isAccessor = function () {
            return this.getter != null || this.setter != null;
        };
        FieldSymbol.prototype.isVariable = function () {
            return true;
        };
        FieldSymbol.prototype.toString = function () {
            return this.getTypeNameEx(null).toString();
        };
        FieldSymbol.prototype.specializeType = function (pattern, replacement, checker) {
            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (rType != this.field.typeLink.type) {
                var fieldDef = new ValueLocation();
                var result = new FieldSymbol(this.name, 0, null, this.canWrite, fieldDef);
                result.flags = this.flags;
                fieldDef.symbol = result;
                fieldDef.typeLink = new TypeScript.TypeLink();
                result.setType(rType);
                result.typeCheckStatus = TypeCheckStatus.Finished;
                return result;
            } else {
                return this;
            }
        };
        FieldSymbol.prototype.getDocComments = function () {
            if (this.getter != null || this.setter != null) {
                var comments = [];
                if (this.getter != null) {
                    comments = comments.concat(this.getter.getDocComments());
                }
                if (this.setter != null) {
                    comments = comments.concat(this.setter.getDocComments());
                }
                return comments;
            } else if (this.declAST != null) {
                return this.declAST.getDocComments();
            }
            return [];
        };
        return FieldSymbol;
    })(InferenceSymbol);
    TypeScript.FieldSymbol = FieldSymbol;    
    var ParameterSymbol = (function (_super) {
        __extends(ParameterSymbol, _super);
        function ParameterSymbol(name, location, fileName, parameter) {
            _super.call(this, name, location, name.length, fileName);
            this.parameter = parameter;
            this.paramDocComment = null;
            this.funcDecl = null;
            this.argsOffset = (-1);
            this.name = name;
            this.location = location;
        }
        ParameterSymbol.prototype.kind = function () {
            return TypeScript.SymbolKind.Parameter;
        };
        ParameterSymbol.prototype.writeable = function () {
            return true;
        };
        ParameterSymbol.prototype.getType = function () {
            return this.parameter.typeLink.type;
        };
        ParameterSymbol.prototype.setType = function (type) {
            this.parameter.typeLink.type = type;
        };
        ParameterSymbol.prototype.isVariable = function () {
            return true;
        };
        ParameterSymbol.prototype.isOptional = function () {
            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {
                return (this.parameter.symbol.declAST).isOptional;
            } else {
                return false;
            }
        };
        ParameterSymbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");
        };
        ParameterSymbol.prototype.toString = function () {
            return this.getTypeNameEx(null).toString();
        };
        ParameterSymbol.prototype.specializeType = function (pattern, replacement, checker) {
            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (this.parameter.typeLink.type != rType) {
                var paramDef = new ValueLocation();
                var result = new ParameterSymbol(this.name, 0, null, paramDef);
                paramDef.symbol = result;
                result.setType(rType);
                return result;
            } else {
                return this;
            }
        };
        ParameterSymbol.prototype.getParameterDocComments = function () {
            if (!this.paramDocComment) {
                var parameterComments = [];
                if (this.funcDecl) {
                    var fncDocComments = this.funcDecl.getDocComments();
                    var paramComment = TypeScript.Comment.getParameterDocCommentText(this.name, fncDocComments);
                    if (paramComment != "") {
                        parameterComments.push(paramComment);
                    }
                }
                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());
                if (docComments != "") {
                    parameterComments.push(docComments);
                }
                this.paramDocComment = parameterComments.join("\n");
            }
            return this.paramDocComment;
        };
        ParameterSymbol.prototype.fullName = function () {
            return this.name;
        };
        return ParameterSymbol;
    })(InferenceSymbol);
    TypeScript.ParameterSymbol = ParameterSymbol;    
    var VariableSymbol = (function (_super) {
        __extends(VariableSymbol, _super);
        function VariableSymbol(name, location, fileName, variable) {
            _super.call(this, name, location, name.length, fileName);
            this.variable = variable;
        }
        VariableSymbol.prototype.kind = function () {
            return TypeScript.SymbolKind.Variable;
        };
        VariableSymbol.prototype.writeable = function () {
            return true;
        };
        VariableSymbol.prototype.getType = function () {
            return this.variable.typeLink.type;
        };
        VariableSymbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");
        };
        VariableSymbol.prototype.setType = function (type) {
            this.variable.typeLink.type = type;
        };
        VariableSymbol.prototype.isVariable = function () {
            return true;
        };
        return VariableSymbol;
    })(InferenceSymbol);
    TypeScript.VariableSymbol = VariableSymbol;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScopedMembers = (function () {
        function ScopedMembers(dualMembers) {
            this.dualMembers = dualMembers;
            this.allMembers = this.dualMembers;
            this.publicMembers = this.dualMembers.primaryTable;
            this.privateMembers = this.dualMembers.secondaryTable;
        }
        ScopedMembers.prototype.addPublicMember = function (key, data) {
            return this.dualMembers.primaryTable.add(key, data);
        };
        ScopedMembers.prototype.addPrivateMember = function (key, data) {
            return this.dualMembers.secondaryTable.add(key, data);
        };
        return ScopedMembers;
    })();
    TypeScript.ScopedMembers = ScopedMembers;    
    (function (SymbolKind) {
        SymbolKind._map = [];
        SymbolKind._map[0] = "None";
        SymbolKind.None = 0;
        SymbolKind._map[1] = "Type";
        SymbolKind.Type = 1;
        SymbolKind._map[2] = "Field";
        SymbolKind.Field = 2;
        SymbolKind._map[3] = "Parameter";
        SymbolKind.Parameter = 3;
        SymbolKind._map[4] = "Variable";
        SymbolKind.Variable = 4;
    })(TypeScript.SymbolKind || (TypeScript.SymbolKind = {}));
    var SymbolKind = TypeScript.SymbolKind;
    var SymbolScope = (function () {
        function SymbolScope(container) {
            this.container = container;
        }
        SymbolScope.prototype.printLabel = function () {
            return "base";
        };
        SymbolScope.prototype.getAllSymbolNames = function (members) {
            return [
                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
            ];
        };
        SymbolScope.prototype.getAllTypeSymbolNames = function (members) {
            return [
                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
            ];
        };
        SymbolScope.prototype.getAllValueSymbolNames = function (members) {
            return [
                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
            ];
        };
        SymbolScope.prototype.search = function (filter, name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.findLocal = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.find = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.findImplementation = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.findAmbient = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.print = function (outfile) {
            if (this.container) {
                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");
            } else {
                outfile.WriteLine(this.printLabel() + " scope...");
            }
        };
        SymbolScope.prototype.enter = function (container, ast, symbol, errorReporter, publicOnly, typespace, ambient) {
            throw new Error("please implement in derived class");
        };
        SymbolScope.prototype.getTable = function () {
            throw new Error("please implement in derived class");
        };
        return SymbolScope;
    })();
    TypeScript.SymbolScope = SymbolScope;    
    function symbolCanBeUsed(sym, publicOnly) {
        return publicOnly ? !(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Private) || (sym.declAST && sym.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && TypeScript.hasFlag((sym.declAST).getFunctionFlags(), TypeScript.FunctionFlags.Private))) : true;
    }
    var SymbolAggregateScope = (function (_super) {
        __extends(SymbolAggregateScope, _super);
        function SymbolAggregateScope(container) {
            _super.call(this, container);
            this.valueCache = null;
            this.valueImplCache = null;
            this.valueAmbientCache = null;
            this.typeCache = null;
            this.typeImplCache = null;
            this.typeAmbientCache = null;
            this.parents = null;
            this.container = container;
        }
        SymbolAggregateScope.prototype.printLabel = function () {
            return "agg";
        };
        SymbolAggregateScope.prototype.search = function (filter, name, publicOnly, typespace) {
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);
                    if (sym) {
                        if (filter.update(sym)) {
                            return sym;
                        }
                    }
                }
            }
            return filter.result;
        };
        SymbolAggregateScope.prototype.getAllSymbolNames = function (members) {
            var result = [];
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        };
        SymbolAggregateScope.prototype.getAllTypeSymbolNames = function (members) {
            var result = [];
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        };
        SymbolAggregateScope.prototype.getAllValueSymbolNames = function (members) {
            var result = [];
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllValueSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        };
        SymbolAggregateScope.prototype.print = function (outfile) {
            _super.prototype.print.call(this, outfile);
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    this.parents[i].print(outfile);
                }
            }
        };
        SymbolAggregateScope.prototype.findImplementation = function (name, publicOnly, typespace) {
            var sym = null;
            var implCache = this.valueImplCache;
            if (typespace) {
                implCache = this.typeImplCache;
            }
            if (implCache && ((sym = implCache.lookup(name)) != null) && (publicOnly ? !(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Private) || (sym.declAST && sym.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && TypeScript.hasFlag((sym.declAST).getFunctionFlags(), TypeScript.FunctionFlags.Private))) : true)) {
                return sym;
            }
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (implCache) {
                if (typespace) {
                    this.typeImplCache = new TypeScript.StringHashTable();
                    implCache = this.typeImplCache;
                } else {
                    this.valueImplCache = new TypeScript.StringHashTable();
                    implCache = this.valueImplCache;
                }
            }
            implCache.add(name, sym);
            return sym;
        };
        SymbolAggregateScope.prototype.find = function (name, publicOnly, typespace) {
            var sym = null;
            var cache = this.valueCache;
            if (typespace) {
                cache = this.typeCache;
            }
            if (cache && ((sym = cache.lookup(name)) != null) && (publicOnly ? !(TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.Private) || (sym.declAST && sym.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && TypeScript.hasFlag((sym.declAST).getFunctionFlags(), TypeScript.FunctionFlags.Private))) : true)) {
                return sym;
            }
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].find(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache === null) {
                if (typespace) {
                    this.typeCache = new TypeScript.StringHashTable();
                    cache = this.typeCache;
                } else {
                    this.valueCache = new TypeScript.StringHashTable();
                    cache = this.valueCache;
                }
            }
            cache.add(name, sym);
            return sym;
        };
        SymbolAggregateScope.prototype.findAmbient = function (name, publicOnly, typespace) {
            var sym = null;
            var cache = this.valueAmbientCache;
            if (typespace) {
                cache = this.typeAmbientCache;
            }
            if (cache && ((sym = cache.lookup(name)) != null)) {
                return sym;
            }
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findAmbient(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache === null) {
                if (typespace) {
                    this.typeAmbientCache = new TypeScript.StringHashTable();
                    cache = this.typeAmbientCache;
                } else {
                    this.valueAmbientCache = new TypeScript.StringHashTable();
                    cache = this.valueAmbientCache;
                }
            }
            cache.add(name, sym);
            return sym;
        };
        SymbolAggregateScope.prototype.addParentScope = function (parent) {
            if (this.parents === null) {
                this.parents = [];
            }
            this.parents[this.parents.length] = parent;
        };
        return SymbolAggregateScope;
    })(SymbolScope);
    TypeScript.SymbolAggregateScope = SymbolAggregateScope;    
    var SymbolTableScope = (function (_super) {
        __extends(SymbolTableScope, _super);
        function SymbolTableScope(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, container) {
            _super.call(this, container);
            this.valueMembers = valueMembers;
            this.ambientValueMembers = ambientValueMembers;
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.container = container;
        }
        SymbolTableScope.prototype.printLabel = function () {
            return "table";
        };
        SymbolTableScope.prototype.getAllSymbolNames = function (members) {
            var result = this.getAllTypeSymbolNames(members);
            return result.concat(this.getAllValueSymbolNames(members));
        };
        SymbolTableScope.prototype.getAllTypeSymbolNames = function (members) {
            var result = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            return result;
        };
        SymbolTableScope.prototype.getAllValueSymbolNames = function (members) {
            var result = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            return result;
        };
        SymbolTableScope.prototype.search = function (filter, name, publicOnly, typespace) {
            var sym = this.find(name, publicOnly, typespace);
            filter.update(sym);
            return filter.result;
        };
        SymbolTableScope.prototype.find = function (name, publicOnly, typespace) {
            var table = null;
            var ambientTable = null;
            if (typespace) {
                table = (this.enclosedTypes === null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            } else {
                table = (this.valueMembers === null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
                ambientTable = (this.ambientValueMembers === null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            }
            var s;
            if (ambientTable) {
                s = ambientTable.lookup(name);
                if (s) {
                    return s;
                }
            }
            if (table) {
                s = table.lookup(name);
                if (s) {
                    return s;
                }
            }
            return null;
        };
        SymbolTableScope.prototype.findAmbient = function (name, publicOnly, typespace) {
            var ambientTable = (this.ambientValueMembers === null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes === null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                var s = ambientTable.lookup(name);
                if (s) {
                    return s;
                }
            }
            return null;
        };
        SymbolTableScope.prototype.print = function (outfile) {
            _super.prototype.print.call(this, outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map(function (key, sym, context) {
                    return outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map(function (key, sym, context) {
                    return outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {
                    return outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map(function (key, sym, context) {
                    return outfile.WriteLine("  " + key);
                }, null);
            }
        };
        SymbolTableScope.prototype.findImplementation = function (name, publicOnly, typespace) {
            var sym = this.find(name, publicOnly, typespace);
            if (sym) {
                if (sym.kind() === SymbolKind.Type) {
                    var typeSym = sym;
                    if (!typeSym.type.hasImplementation()) {
                        sym = null;
                    }
                } else if (sym.container) {
                    if (sym.container.kind() === SymbolKind.Type) {
                        var ctypeSym = sym.container;
                        if (!ctypeSym.type.hasImplementation()) {
                            sym = null;
                        }
                    }
                }
            }
            return sym;
        };
        SymbolTableScope.prototype.getTable = function () {
            return this.valueMembers.publicMembers;
        };
        return SymbolTableScope;
    })(SymbolScope);
    TypeScript.SymbolTableScope = SymbolTableScope;    
    var SymbolScopeBuilder = (function (_super) {
        __extends(SymbolScopeBuilder, _super);
        function SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, parent, container) {
            _super.call(this, container);
            this.valueMembers = valueMembers;
            this.ambientValueMembers = ambientValueMembers;
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.parent = parent;
            this.container = container;
        }
        SymbolScopeBuilder.prototype.printLabel = function () {
            return "builder";
        };
        SymbolScopeBuilder.prototype.getAllSymbolNames = function (members) {
            var result = this.getAllTypeSymbolNames(members);
            return result.concat(this.getAllValueSymbolNames(members));
        };
        SymbolScopeBuilder.prototype.getAllTypeSymbolNames = function (members) {
            var result = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllTypeSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        };
        SymbolScopeBuilder.prototype.getAllValueSymbolNames = function (members) {
            var result = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllValueSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        };
        SymbolScopeBuilder.prototype.search = function (filter, name, publicOnly, typespace) {
            var sym = null;
            var table = (this.valueMembers === null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers === null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes === null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (this.parent) {
                sym = this.parent.search(filter, name, publicOnly, typespace);
                if (sym) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            return filter.result;
        };
        SymbolScopeBuilder.prototype.print = function (outfile) {
            _super.prototype.print.call(this, outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.parent) {
                this.parent.print(outfile);
            }
        };
        SymbolScopeBuilder.prototype.find = function (name, publicOnly, typespace) {
            var sym = null;
            var table = (this.valueMembers === null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers === null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes === null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (table && ((sym = table.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.find(name, publicOnly, typespace);
            }
            return null;
        };
        SymbolScopeBuilder.prototype.findAmbient = function (name, publicOnly, typespace) {
            var sym = null;
            var ambientTable = (this.ambientValueMembers === null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes === null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.findAmbient(name, publicOnly, typespace);
            }
            return null;
        };
        SymbolScopeBuilder.prototype.findLocal = function (name, publicOnly, typespace) {
            var sym = null;
            var table = (this.valueMembers === null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers === null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes === null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (sym) {
                        return sym;
                    }
                }
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (sym) {
                        return sym;
                    }
                }
            }
            return null;
        };
        SymbolScopeBuilder.prototype.enter = function (container, ast, symbol, errorReporter, insertAsPublic, typespace, ambient) {
            var table = null;
            if (ambient) {
                if (typespace) {
                    table = (this.ambientEnclosedTypes === null) ? null : insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;
                } else {
                    table = (this.ambientValueMembers === null) ? null : insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;
                }
            } else {
                if (typespace) {
                    table = (this.enclosedTypes === null) ? null : insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;
                } else {
                    table = (this.valueMembers === null) ? null : insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;
                }
            }
            if (table) {
                if (!table.add(symbol.name, symbol)) {
                    errorReporter.duplicateIdentifier(ast, symbol.name);
                }
            } else {
                TypeScript.CompilerDiagnostics.Alert("YYYYY");
            }
            symbol.container = container;
        };
        SymbolScopeBuilder.prototype.getTable = function () {
            return this.valueMembers.allMembers;
        };
        return SymbolScopeBuilder;
    })(SymbolScope);
    TypeScript.SymbolScopeBuilder = SymbolScopeBuilder;    
    var FilteredSymbolScope = (function (_super) {
        __extends(FilteredSymbolScope, _super);
        function FilteredSymbolScope(scope, container, filter) {
            _super.call(this, container);
            this.scope = scope;
            this.filter = filter;
        }
        FilteredSymbolScope.prototype.print = function (outfile) {
            this.scope.print(outfile);
        };
        FilteredSymbolScope.prototype.find = function (name, publicOnly, typespace) {
            this.filter.reset();
            return this.scope.search(this.filter, name, publicOnly, typespace);
        };
        FilteredSymbolScope.prototype.findLocal = function (name, publicOnly, typespace) {
            return this.scope.findLocal(name, publicOnly, typespace);
        };
        return FilteredSymbolScope;
    })(SymbolScope);
    TypeScript.FilteredSymbolScope = FilteredSymbolScope;    
    var FilteredSymbolScopeBuilder = (function (_super) {
        __extends(FilteredSymbolScopeBuilder, _super);
        function FilteredSymbolScopeBuilder(valueMembers, parent, container, filter) {
            _super.call(this, valueMembers, null, null, null, parent, container);
            this.filter = filter;
        }
        FilteredSymbolScopeBuilder.prototype.findLocal = function (name, publicOnly, typespace) {
            var sym = _super.prototype.findLocal.call(this, name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return sym;
        };
        FilteredSymbolScopeBuilder.prototype.search = function (filter, name, publicOnly, typespace) {
            throw new Error("please implement");
        };
        FilteredSymbolScopeBuilder.prototype.find = function (name, publicOnly, typespace) {
            var sym = _super.prototype.findLocal.call(this, name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return _super.prototype.find.call(this, name, publicOnly, typespace);
        };
        return FilteredSymbolScopeBuilder;
    })(SymbolScopeBuilder);
    TypeScript.FilteredSymbolScopeBuilder = FilteredSymbolScopeBuilder;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ArrayCache = (function () {
        function ArrayCache() {
            this.arrayBase = null;
        }
        ArrayCache.prototype.specialize = function (arrInstType, checker) {
            if (this.arrayBase === null) {
                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType, checker, true);
            }
            return this.arrayBase;
        };
        return ArrayCache;
    })();
    TypeScript.ArrayCache = ArrayCache;    
    var TypeComparisonInfo = (function () {
        function TypeComparisonInfo(sourceComparisonInfo) {
            this.onlyCaptureFirstError = false;
            this.flags = TypeScript.TypeRelationshipFlags.SuccessfulComparison;
            this.message = "";
            this.stringConstantVal = null;
            this.indent = 1;
            if (sourceComparisonInfo) {
                this.flags = sourceComparisonInfo.flags;
                this.onlyCaptureFirstError = sourceComparisonInfo.onlyCaptureFirstError;
                this.stringConstantVal = sourceComparisonInfo.stringConstantVal;
                this.indent = sourceComparisonInfo.indent + 1;
            }
        }
        TypeComparisonInfo.prototype.addMessage = function (message) {
            if (!this.onlyCaptureFirstError && this.message) {
                this.message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._0__NL__1_TB__2, [
                    this.message, 
                    this.indent, 
                    message
                ]);
            } else {
                this.message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._0_TB__1, [
                    this.indent, 
                    message
                ]);
            }
        };
        TypeComparisonInfo.prototype.setMessage = function (message) {
            this.message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._0_TB__1, [
                this.indent, 
                message
            ]);
        };
        return TypeComparisonInfo;
    })();
    TypeScript.TypeComparisonInfo = TypeComparisonInfo;    
    (function (TypeCheckCollectionMode) {
        TypeCheckCollectionMode._map = [];
        TypeCheckCollectionMode._map[0] = "Resident";
        TypeCheckCollectionMode.Resident = 0;
        TypeCheckCollectionMode._map[1] = "Transient";
        TypeCheckCollectionMode.Transient = 1;
    })(TypeScript.TypeCheckCollectionMode || (TypeScript.TypeCheckCollectionMode = {}));
    var TypeCheckCollectionMode = TypeScript.TypeCheckCollectionMode;
    var PersistentGlobalTypeState = (function () {
        function PersistentGlobalTypeState(errorReporter, compilationSettings) {
            this.errorReporter = errorReporter;
            this.compilationSettings = compilationSettings;
            this.importedGlobalsTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            this.importedGlobalsTypeTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            this.globals = null;
            this.globalTypes = null;
            this.ambientGlobals = null;
            this.ambientGlobalTypes = null;
            this.residentGlobalValues = new TypeScript.StringHashTable();
            this.residentGlobalTypes = new TypeScript.StringHashTable();
            this.residentGlobalAmbientValues = new TypeScript.StringHashTable();
            this.residentGlobalAmbientTypes = new TypeScript.StringHashTable();
            this.residentTypeCheck = true;
            this.mod = null;
            this.gloMod = null;
            this.wildElm = null;
            this.importedGlobals = new TypeScript.SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);
            this.dualGlobalValues = new TypeScript.DualStringHashTable(this.residentGlobalValues, new TypeScript.StringHashTable());
            this.dualGlobalTypes = new TypeScript.DualStringHashTable(this.residentGlobalTypes, new TypeScript.StringHashTable());
            this.dualAmbientGlobalValues = new TypeScript.DualStringHashTable(this.residentGlobalAmbientValues, new TypeScript.StringHashTable());
            this.dualAmbientGlobalTypes = new TypeScript.DualStringHashTable(this.residentGlobalAmbientTypes, new TypeScript.StringHashTable());
            var dualGlobalScopedMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualGlobalValues, new TypeScript.StringHashTable()));
            var dualGlobalScopedAmbientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualAmbientGlobalValues, new TypeScript.StringHashTable()));
            var dualGlobalScopedEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualGlobalTypes, new TypeScript.StringHashTable()));
            var dualGlobalScopedAmbientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualAmbientGlobalTypes, new TypeScript.StringHashTable()));
            this.globalScope = new TypeScript.SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);
            this.voidType = this.enterPrimitive(TypeScript.Primitive.Void, "void");
            this.booleanType = this.enterPrimitive(TypeScript.Primitive.Boolean, "bool");
            this.doubleType = this.enterPrimitive(TypeScript.Primitive.Double, "number");
            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);
            this.stringType = this.enterPrimitive(TypeScript.Primitive.String, "string");
            this.anyType = this.enterPrimitive(TypeScript.Primitive.Any, "any");
            this.nullType = this.enterPrimitive(TypeScript.Primitive.Null, "null");
            this.undefinedType = this.enterPrimitive(TypeScript.Primitive.Undefined, "undefined");
            this.setCollectionMode(TypeCheckCollectionMode.Resident);
            this.wildElm = new TypeScript.TypeSymbol("_element", -1, 0, "", new TypeScript.Type(), this.compilationSettings.optimizeModuleCodeGen);
            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);
            this.mod = new TypeScript.ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);
            this.mod.members = dualGlobalScopedMembers;
            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;
            this.mod.containedScope = this.globalScope;
            this.gloMod = new TypeScript.TypeSymbol(TypeScript.globalId, -1, 0, "", this.mod, this.compilationSettings.optimizeModuleCodeGen);
            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);
            this.defineGlobalValue("undefined", this.undefinedType);
        }
        PersistentGlobalTypeState.prototype.enterPrimitive = function (flags, name) {
            var primitive = new TypeScript.Type();
            primitive.primitiveTypeClass = flags;
            var symbol = new TypeScript.TypeSymbol(name, -1, name.length, "", primitive, this.compilationSettings.optimizeModuleCodeGen);
            symbol.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;
            primitive.symbol = symbol;
            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);
            return primitive;
        };
        PersistentGlobalTypeState.prototype.setCollectionMode = function (mode) {
            this.residentTypeCheck = this.dualGlobalValues.insertPrimary = this.dualGlobalTypes.insertPrimary = this.dualAmbientGlobalValues.insertPrimary = this.dualAmbientGlobalTypes.insertPrimary = mode === TypeCheckCollectionMode.Resident;
        };
        PersistentGlobalTypeState.prototype.refreshPersistentState = function () {
            this.globals = new TypeScript.StringHashTable();
            this.globalTypes = new TypeScript.StringHashTable();
            this.ambientGlobals = new TypeScript.StringHashTable();
            this.ambientGlobalTypes = new TypeScript.StringHashTable();
            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);
            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);
            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);
            this.globalTypes.add("number", this.doubleType.symbol);
            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);
            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);
            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);
            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);
            this.dualGlobalValues.secondaryTable = this.globals;
            this.dualGlobalTypes.secondaryTable = this.globalTypes;
            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;
            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;
        };
        PersistentGlobalTypeState.prototype.defineGlobalValue = function (name, type) {
            var valueLocation = new TypeScript.ValueLocation();
            valueLocation.typeLink = new TypeScript.TypeLink();
            var sym = new TypeScript.VariableSymbol(name, 0, "", valueLocation);
            sym.setType(type);
            sym.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;
            sym.container = this.gloMod;
            this.importedGlobalsTable.addPublicMember(name, sym);
        };
        return PersistentGlobalTypeState;
    })();
    TypeScript.PersistentGlobalTypeState = PersistentGlobalTypeState;    
    var ContextualTypeContext = (function () {
        function ContextualTypeContext(contextualType, provisional, contextID) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.contextID = contextID;
            this.targetSig = null;
            this.targetThis = null;
            this.targetAccessorType = null;
        }
        return ContextualTypeContext;
    })();
    TypeScript.ContextualTypeContext = ContextualTypeContext;    
    var ContextualTypingContextStack = (function () {
        function ContextualTypingContextStack(checker) {
            this.checker = checker;
            this.contextStack = [];
            this.hadProvisionalErrors = false;
        }
        ContextualTypingContextStack.contextID = TypeScript.TypeCheckStatus.Finished + 1;
        ContextualTypingContextStack.prototype.pushContextualType = function (type, provisional) {
            this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++));
            this.checker.errorReporter.pushToErrorSink = provisional;
        };
        ContextualTypingContextStack.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();
            this.checker.errorReporter.pushToErrorSink = this.isProvisional();
            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));
            this.checker.errorReporter.freeCapturedErrors();
            return tc;
        };
        ContextualTypingContextStack.prototype.getContextualType = function () {
            return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]);
        };
        ContextualTypingContextStack.prototype.getContextID = function () {
            return (!this.contextStack.length ? TypeScript.TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID);
        };
        ContextualTypingContextStack.prototype.isProvisional = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };
        return ContextualTypingContextStack;
    })();
    TypeScript.ContextualTypingContextStack = ContextualTypingContextStack;    
    var TypeChecker = (function () {
        function TypeChecker(persistentState, compilationSettings) {
            this.persistentState = persistentState;
            this.compilationSettings = compilationSettings;
            this.errorReporter = null;
            this.checkControlFlow = false;
            this.printControlFlowGraph = false;
            this.checkControlFlowUseDef = false;
            this.styleSettings = null;
            this.fileNameToLocationInfo = null;
            this.anon = "_anonymous";
            this.typeFlow = null;
            this.currentCompareA = null;
            this.currentCompareB = null;
            this.currentModDecl = null;
            this.inBind = false;
            this.inWith = false;
            this.errorsOnWith = true;
            this.currentContextualTypeContext = null;
            this.resolvingBases = false;
            this.canCallDefinitionSignature = false;
            this.assignableCache = {};
            this.subtypeCache = {};
            this.identicalCache = {};
            this.provisionalStartedTypecheckObjects = [];
            this.mustCaptureGlobalThis = false;
            this.voidType = this.persistentState.voidType;
            this.booleanType = this.persistentState.booleanType;
            this.numberType = this.persistentState.doubleType;
            this.stringType = this.persistentState.stringType;
            this.anyType = this.persistentState.anyType;
            this.nullType = this.persistentState.nullType;
            this.undefinedType = this.persistentState.undefinedType;
            this.globals = this.persistentState.dualGlobalValues;
            this.globalTypes = this.persistentState.dualGlobalTypes;
            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;
            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;
            this.gloModType = this.persistentState.mod;
            this.gloMod = this.persistentState.gloMod;
            this.wildElm = this.persistentState.wildElm;
            this.globalScope = this.persistentState.globalScope;
            this.typingContextStack = new ContextualTypingContextStack(this);
        }
        TypeChecker.prototype.setStyleOptions = function (style) {
            this.styleSettings = style;
        };
        TypeChecker.prototype.setContextualType = function (type, provisional) {
            this.typingContextStack.pushContextualType(type, provisional);
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        };
        TypeChecker.prototype.unsetContextualType = function () {
            var lastTC = this.typingContextStack.popContextualType();
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
            return lastTC;
        };
        TypeChecker.prototype.hadProvisionalErrors = function () {
            return this.typingContextStack.hadProvisionalErrors;
        };
        TypeChecker.prototype.resetProvisionalErrors = function () {
            if (!this.typingContextStack.getContextualType()) {
                this.typingContextStack.hadProvisionalErrors = false;
            }
        };
        TypeChecker.prototype.typeCheckWithContextualType = function (contextType, provisional, condition, ast) {
            if (condition) {
                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);
            }
            this.typeFlow.typeCheck(ast);
            if (condition) {
                this.unsetContextualType();
            }
        };
        TypeChecker.prototype.resetTargetType = function () {
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        };
        TypeChecker.prototype.killCurrentContextualType = function () {
            this.currentContextualTypeContext = null;
            this.errorReporter.pushToErrorSink = false;
        };
        TypeChecker.prototype.hasTargetType = function () {
            return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType;
        };
        TypeChecker.prototype.getTargetTypeContext = function () {
            return this.currentContextualTypeContext;
        };
        TypeChecker.prototype.inProvisionalTypecheckMode = function () {
            return this.typingContextStack.isProvisional();
        };
        TypeChecker.prototype.getTypeCheckFinishedStatus = function () {
            if (this.inProvisionalTypecheckMode()) {
                return this.typingContextStack.getContextID();
            }
            return TypeScript.TypeCheckStatus.Finished;
        };
        TypeChecker.prototype.typeStatusIsFinished = function (status) {
            return status === TypeScript.TypeCheckStatus.Finished || (this.inProvisionalTypecheckMode() && status === this.typingContextStack.getContextID());
        };
        TypeChecker.prototype.addStartedPTO = function (pto) {
            if (this.inProvisionalTypecheckMode()) {
                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;
            }
        };
        TypeChecker.prototype.cleanStartedPTO = function () {
            for(var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {
                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {
                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeScript.TypeCheckStatus.NotStarted;
                }
            }
            this.provisionalStartedTypecheckObjects = [];
        };
        TypeChecker.prototype.collectTypes = function (ast) {
            if (ast.nodeType === TypeScript.NodeType.Script) {
                var script = ast;
            }
            var globalChain = new TypeScript.ScopeChain(this.gloMod, null, this.globalScope);
            var context = new TypeScript.TypeCollectionContext(globalChain, this);
            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.preCollectTypes, TypeScript.postCollectTypes, null, context);
        };
        TypeChecker.prototype.makeArrayType = function (type) {
            if (!type.arrayCache) {
                type.arrayCache = new ArrayCache();
                type.arrayCache.arrayType = new TypeScript.Type();
                type.arrayCache.arrayType.elementType = type;
                type.arrayCache.arrayType.symbol = type.symbol;
            }
            return type.arrayCache.arrayType;
        };
        TypeChecker.prototype.getParameterList = function (funcDecl, container) {
            var args = funcDecl.arguments;
            var parameterTable = null;
            var parameterBuilder = null;
            var len = args.members.length;
            var nonOptionalParams = 0;
            var result = [];
            if (len > 0) {
                parameterTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                parameterBuilder = new TypeScript.SymbolScopeBuilder(parameterTable, null, null, null, null, container);
                for(var i = 0; i < len; i++) {
                    var parameter = args.members[i];
                    var paramDef = new TypeScript.ValueLocation();
                    var parameterSymbol = new TypeScript.ParameterSymbol(parameter.id.text, parameter.minChar, null, paramDef);
                    parameterSymbol.declAST = parameter;
                    parameterSymbol.funcDecl = funcDecl;
                    parameter.id.sym = parameterSymbol;
                    parameter.sym = parameterSymbol;
                    paramDef.symbol = parameterSymbol;
                    paramDef.typeLink = TypeScript.getTypeLink(parameter.typeExpr, this, false);
                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false);
                    result[result.length] = parameterSymbol;
                    if (!parameter.isOptionalArg()) {
                        nonOptionalParams++;
                    }
                }
            }
            return {
                parameters: result,
                nonOptionalParameterCount: nonOptionalParams
            };
        };
        TypeChecker.prototype.createFunctionSignature = function (funcDecl, container, scope, overloadGroupSym, addToScope) {
            var isExported = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Exported | TypeScript.FunctionFlags.ClassPropertyMethodExported) || container === this.gloMod;
            var isStatic = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Static);
            var isPrivate = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Private);
            var isDefinition = !TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Signature);
            var isAmbient = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Ambient);
            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
            var isGlobal = container === this.gloMod;
            var signature = new TypeScript.Signature();
            var isLambda = funcDecl.getFunctionFlags() & TypeScript.FunctionFlags.IsFunctionExpression;
            if (funcDecl.returnTypeAnnotation || isDefinition) {
                signature.returnType = TypeScript.getTypeLink(funcDecl.returnTypeAnnotation, this, false);
            } else {
                signature.returnType = new TypeScript.TypeLink();
                signature.returnType.type = this.anyType;
            }
            signature.hasVariableArgList = funcDecl.variableArgList;
            var sigData = this.getParameterList(funcDecl, container);
            signature.parameters = sigData.parameters;
            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;
            funcDecl.signature = signature;
            signature.declAST = funcDecl;
            var useOverloadGroupSym = overloadGroupSym && overloadGroupSym.getType() && !overloadGroupSym.isAccessor() && (funcDecl.isSignature() || (isAmbient === TypeScript.hasFlag(overloadGroupSym.flags, TypeScript.SymbolFlags.Ambient)));
            if (useOverloadGroupSym && isPrivate != TypeScript.hasFlag(overloadGroupSym.flags, TypeScript.SymbolFlags.Private)) {
                this.errorReporter.simpleError(funcDecl, "Public/Private visibility of overloads does not agree");
            }
            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new TypeScript.Type();
            if (isConstructor) {
                if (groupType.construct === null) {
                    groupType.construct = new TypeScript.SignatureGroup();
                }
                groupType.construct.addSignature(signature);
                groupType.construct.hasImplementation = !(funcDecl.isSignature());
                if (groupType.construct.hasImplementation) {
                    groupType.setHasImplementation();
                }
            } else if (funcDecl.isIndexerMember()) {
                if (groupType.index === null) {
                    groupType.index = new TypeScript.SignatureGroup();
                    groupType.index.flags |= TypeScript.SignatureFlags.IsIndexer;
                }
                groupType.index.addSignature(signature);
                groupType.index.hasImplementation = !(funcDecl.isSignature());
                if (groupType.index.hasImplementation) {
                    groupType.setHasImplementation();
                }
            } else {
                if (groupType.call === null) {
                    groupType.call = new TypeScript.SignatureGroup();
                }
                groupType.call.addSignature(signature);
                groupType.call.hasImplementation = !(funcDecl.isSignature());
                if (groupType.call.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }
            var instanceType = groupType.instanceType;
            var funcName = null;
            var usedHint = false;
            if (funcDecl.name && !funcDecl.name.isMissing()) {
                funcName = funcDecl.name.text;
            } else if (funcDecl.hint) {
                funcName = funcDecl.hint;
                usedHint = true;
            }
            if (!groupType.symbol) {
                groupType.symbol = new TypeScript.TypeSymbol(funcName ? funcName : this.anon, funcDecl.minChar, funcDecl.limChar - funcDecl.minChar, null, groupType, this.compilationSettings.optimizeModuleCodeGen);
                if (!useOverloadGroupSym) {
                    groupType.symbol.declAST = funcDecl;
                }
            }
            if (isStatic) {
                groupType.symbol.flags |= TypeScript.SymbolFlags.Static;
            }
            if (isAmbient) {
                groupType.symbol.flags |= TypeScript.SymbolFlags.Ambient;
            }
            if (isPrivate) {
                groupType.symbol.flags |= TypeScript.SymbolFlags.Private;
            }
            groupType.symbol.isMethod = funcDecl.isMethod();
            if (groupType.symbol.isMethod) {
                groupType.symbol.flags |= TypeScript.SymbolFlags.Property;
            }
            funcDecl.type = groupType;
            if (!isConstructor) {
                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {
                    if (addToScope) {
                        if (funcDecl.isMethod() && isStatic) {
                            if (!(container).type.members.publicMembers.add(funcName, groupType.symbol)) {
                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);
                            }
                            groupType.symbol.container = container;
                        } else if (overloadGroupSym === null || (overloadGroupSym.declAST && (container.isType()))) {
                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);
                        }
                    } else if (!funcDecl.isSpecialFn()) {
                        groupType.symbol.container = container;
                    }
                } else if (!funcDecl.isSpecialFn()) {
                    groupType.symbol.container = container;
                }
            }
            if (useOverloadGroupSym) {
                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;
                var classType = groupType;
                if (classType != overloadGroupType) {
                    if (classType.construct === null) {
                        if (overloadGroupType && overloadGroupType.construct) {
                            classType.construct = overloadGroupType.construct;
                        } else {
                            classType.construct = new TypeScript.SignatureGroup();
                        }
                    } else if (overloadGroupType) {
                        if (overloadGroupType.construct) {
                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);
                        }
                    }
                    if (overloadGroupType) {
                        if (classType.call === null) {
                            classType.call = overloadGroupType.call;
                        } else if (overloadGroupType.call) {
                            classType.call.signatures.concat(overloadGroupType.call.signatures);
                        }
                        if (!isStatic) {
                            if (classType.instanceType === null) {
                                classType.instanceType = overloadGroupType.instanceType;
                            }
                            instanceType = classType.instanceType;
                            if (instanceType) {
                                if (instanceType.call === null) {
                                    instanceType.call = overloadGroupType.call;
                                } else if (overloadGroupType.call) {
                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);
                                }
                            }
                        }
                        if (classType.index === null) {
                            classType.index = overloadGroupType.index;
                        } else if (overloadGroupType.index) {
                            classType.index.signatures.concat(overloadGroupType.index.signatures);
                        }
                    }
                }
            }
            return signature;
        };
        TypeChecker.prototype.createAccessorSymbol = function (funcDecl, fgSym, enclosingClass, addToMembers, isClassProperty, scope, container) {
            var accessorSym = null;
            var sig = funcDecl.signature;
            var nameText = funcDecl.name.text;
            var isStatic = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Static);
            var isPrivate = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Private);
            if (fgSym === null) {
                var field = new TypeScript.ValueLocation();
                accessorSym = new TypeScript.FieldSymbol(nameText, funcDecl.minChar, null, false, field);
                field.symbol = accessorSym;
                accessorSym.declAST = funcDecl;
                if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor)) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = sig.declAST.type.symbol;
                } else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = sig.declAST.type.symbol;
                }
                field.typeLink = TypeScript.getTypeLink(null, this, false);
                if (addToMembers) {
                    if (enclosingClass) {
                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {
                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);
                        }
                        accessorSym.container = enclosingClass.symbol;
                    } else {
                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");
                    }
                } else {
                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);
                }
                if (isClassProperty) {
                    accessorSym.flags |= TypeScript.SymbolFlags.Property;
                }
                if (isStatic) {
                    accessorSym.flags |= TypeScript.SymbolFlags.Static;
                }
                if (isPrivate) {
                    accessorSym.flags |= TypeScript.SymbolFlags.Private;
                } else {
                    accessorSym.flags |= TypeScript.SymbolFlags.Public;
                }
            } else {
                accessorSym = (fgSym);
                if (isPrivate != TypeScript.hasFlag(accessorSym.flags, TypeScript.SymbolFlags.Private)) {
                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");
                }
                if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor)) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = funcDecl.type.symbol;
                } else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = funcDecl.type.symbol;
                }
            }
            return accessorSym;
        };
        TypeChecker.prototype.addBases = function (resultScope, type, baseContext) {
            resultScope.addParentScope(new TypeScript.SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));
            var parent;
            if (type.extendsList) {
                for(var i = 0, n = type.extendsList.length; i < n; i++) {
                    parent = type.extendsList[i];
                    if (baseContext.baseId === parent.typeID) {
                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type '" + baseContext.base + "' is recursively referenced as a base class of itself");
                        parent.symbol.flags |= TypeScript.SymbolFlags.RecursivelyReferenced;
                        break;
                    }
                    this.addBases(resultScope, parent, baseContext);
                }
            }
        };
        TypeChecker.prototype.scopeOf = function (type) {
            var resultScope = new TypeScript.SymbolAggregateScope(type.symbol);
            var baseContext = {
                base: type.symbol && type.symbol.name ? type.symbol.name : "{}",
                baseId: type.typeID
            };
            this.addBases(resultScope, type, baseContext);
            return resultScope;
        };
        TypeChecker.prototype.lookupMemberTypeSymbol = function (containingType, name) {
            var symbol = null;
            if (containingType.containedScope) {
                symbol = containingType.containedScope.find(name, false, true);
            } else if (containingType.members) {
                symbol = containingType.members.allMembers.lookup(name);
                if (symbol === null && containingType.ambientMembers) {
                    symbol = containingType.ambientMembers.allMembers.lookup(name);
                }
            }
            if (symbol === null || !symbol.isType()) {
                var typeMembers = containingType.getAllEnclosedTypes();
                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();
                if (typeMembers) {
                    symbol = typeMembers.allMembers.lookup(name);
                    if (symbol === null && ambientTypeMembers) {
                        symbol = ambientTypeMembers.allMembers.lookup(name);
                    }
                }
            }
            if (symbol && symbol.isType()) {
                return symbol;
            } else {
                return null;
            }
        };
        TypeChecker.prototype.findSymbolForDynamicModule = function (idText, currentFileName, search) {
            var originalIdText = idText;
            var symbol = search(idText);
            if (symbol === null) {
                if (!symbol) {
                    idText = TypeScript.swapQuotes(originalIdText);
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }
                if (!symbol && !TypeScript.isRelative(originalIdText)) {
                    idText = originalIdText;
                    var strippedIdText = TypeScript.stripQuotes(idText);
                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));
                    while(symbol === null && path != "") {
                        idText = TypeScript.normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);
                        if (symbol === null) {
                            idText = TypeScript.changePathToDTS(idText);
                            symbol = search(idText);
                        }
                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            } else {
                                path = TypeScript.normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }
            return symbol;
        };
        TypeChecker.prototype.resolveTypeMember = function (scope, dotNode) {
            var lhs = dotNode.operand1;
            var rhs = dotNode.operand2;
            var resultType = this.anyType;
            var lhsType = this.anyType;
            if (lhs && rhs && (rhs.nodeType === TypeScript.NodeType.Name)) {
                if (lhs.nodeType === TypeScript.NodeType.MemberAccessExpression) {
                    lhsType = this.resolveTypeMember(scope, lhs);
                } else if (lhs.nodeType === TypeScript.NodeType.Name) {
                    var identifier = lhs;
                    var symbol = scope.find(identifier.text, false, true);
                    if (symbol === null) {
                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                    } else if (symbol.isType()) {
                        var typeSymbol = symbol;
                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType === TypeScript.NodeType.Name) {
                            var modPath = (typeSymbol.aliasLink.alias).text;
                            var modSym = this.findSymbolForDynamicModule(modPath, null, function (id) {
                                return scope.find(id, false, true);
                            });
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }
                        if (this.compilationSettings.optimizeModuleCodeGen && symbol) {
                            var symType = symbol.getType();
                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {
                                var modDecl = symType.symbol.declAST;
                                if (modDecl && TypeScript.hasFlag(modDecl.getModuleFlags(), TypeScript.ModuleFlags.IsDynamic)) {
                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;
                                }
                            }
                        }
                        if (!symbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + identifier.actualText + "' is not visible at this point");
                        }
                        lhsType = symbol.getType();
                        identifier.sym = symbol;
                    } else {
                        this.errorReporter.simpleError(lhs, "Expected type");
                    }
                }
                if (!lhsType) {
                    lhsType = this.anyType;
                }
                if (lhsType != this.anyType) {
                    var rhsIdentifier = rhs;
                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);
                    if (resultSymbol === null) {
                        resultType = this.anyType;
                        this.errorReporter.simpleError(dotNode, "Expected type");
                    } else {
                        resultType = resultSymbol.getType();
                        if (!resultSymbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + (rhs).actualText + "' is not visible at this point");
                        }
                    }
                    rhsIdentifier.sym = resultType.symbol;
                }
            }
            if (resultType.isClass()) {
                resultType = resultType.instanceType;
            }
            return resultType;
        };
        TypeChecker.prototype.resolveFuncDecl = function (funcDecl, scope, fgSym) {
            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;
            var signatures;
            if (funcDecl.isConstructMember()) {
                signatures = functionGroupSymbol.type.construct.signatures;
            } else if (funcDecl.isIndexerMember()) {
                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;
            } else {
                signatures = functionGroupSymbol.type.call.signatures;
            }
            var signature = signatures[signatures.length - 1];
            var len = signature.parameters.length;
            for(var i = 0; i < len; i++) {
                var paramSym = signature.parameters[i];
                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);
            }
            if (len && funcDecl.variableArgList) {
                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {
                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");
                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);
                }
            }
            this.resolveTypeLink(scope, signature.returnType, funcDecl.isSignature());
            return functionGroupSymbol;
        };
        TypeChecker.prototype.resolveVarDecl = function (varDecl, scope) {
            var field = new TypeScript.ValueLocation();
            var fieldSymbol = new TypeScript.FieldSymbol(varDecl.id.text, varDecl.minChar, null, true, field);
            fieldSymbol.transferVarFlags(varDecl.getVarFlags());
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = varDecl;
            field.typeLink = TypeScript.getTypeLink(varDecl.typeExpr, this, varDecl.init === null);
            this.resolveTypeLink(scope, field.typeLink, true);
            varDecl.sym = fieldSymbol;
            varDecl.type = field.typeLink.type;
            return fieldSymbol;
        };
        TypeChecker.prototype.resolveTypeLink = function (scope, typeLink, supplyVar) {
            var arrayCount = 0;
            if (typeLink.type === null) {
                var ast = typeLink.ast;
                if (ast) {
                    while(typeLink.type === null) {
                        switch(ast.nodeType) {
                            case TypeScript.NodeType.Name:
                                var identifier = ast;
                                var symbol = scope.find(identifier.text, false, true);
                                if (symbol === null) {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                                } else if (symbol.isType()) {
                                    if (!symbol.visible(scope, this)) {
                                        this.errorReporter.simpleError(ast, "The symbol '" + identifier.actualText + "' is not visible at this point");
                                    }
                                    identifier.sym = symbol;
                                    typeLink.type = symbol.getType();
                                    if (typeLink.type) {
                                        if (typeLink.type.isClass()) {
                                            typeLink.type = typeLink.type.instanceType;
                                        }
                                    } else {
                                        typeLink.type = this.anyType;
                                    }
                                } else {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.simpleError(ast, "Expected type");
                                }
                                break;
                            case TypeScript.NodeType.MemberAccessExpression:
                                typeLink.type = this.resolveTypeMember(scope, ast);
                                break;
                            case TypeScript.NodeType.TypeRef:
                                var typeRef = ast;
                                arrayCount = typeRef.arrayCount;
                                ast = typeRef.term;
                                if (ast === null) {
                                    typeLink.type = this.anyType;
                                }
                                break;
                            case TypeScript.NodeType.InterfaceDeclaration:
                                var interfaceDecl = ast;
                                var interfaceType = new TypeScript.Type();
                                var interfaceSymbol = new TypeScript.TypeSymbol((interfaceDecl.name).text, ast.minChar, ast.limChar - ast.minChar, null, interfaceType, this.compilationSettings.optimizeModuleCodeGen);
                                interfaceType.symbol = interfaceSymbol;
                                interfaceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                                interfaceType.containedScope = new TypeScript.SymbolTableScope(interfaceType.members, null, null, null, interfaceSymbol);
                                interfaceType.containedScope.container = interfaceSymbol;
                                interfaceType.memberScope = interfaceType.containedScope;
                                var memberList = interfaceDecl.members;
                                var props = memberList.members;
                                var propsLen = props.length;
                                for(var j = 0; j < propsLen; j++) {
                                    var propDecl = props[j];
                                    var propSym = null;
                                    var addMember = true;
                                    var id = null;
                                    if (propDecl.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                                        var funcDecl = propDecl;
                                        id = funcDecl.name;
                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());
                                        addMember = (propSym === null);
                                        if (funcDecl.isSpecialFn()) {
                                            addMember = false;
                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);
                                        } else {
                                            propSym = this.resolveFuncDecl(funcDecl, scope, propSym);
                                        }
                                        funcDecl.type = (propSym).type;
                                    } else {
                                        id = (propDecl).id;
                                        propSym = this.resolveVarDecl(propDecl, scope);
                                        addMember = !id.isMissing();
                                    }
                                    if (addMember) {
                                        if (id && TypeScript.hasFlag(id.getFlags(), TypeScript.ASTFlags.OptionalName)) {
                                            propSym.flags |= TypeScript.SymbolFlags.Optional;
                                        }
                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {
                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);
                                        }
                                    }
                                }
                                ast.type = interfaceType;
                                typeLink.type = interfaceType;
                                break;
                            case TypeScript.NodeType.FunctionDeclaration:
                                var tsym = this.resolveFuncDecl(ast, scope, null);
                                typeLink.type = tsym.type;
                                break;
                            default:
                                typeLink.type = this.anyType;
                                this.errorReporter.simpleError(ast, "Expected type");
                                break;
                        }
                    }
                }
                for(var count = arrayCount; count > 0; count--) {
                    typeLink.type = this.makeArrayType(typeLink.type);
                }
                if (supplyVar && (typeLink.type === null)) {
                    typeLink.type = this.anyType;
                }
                if (typeLink.ast) {
                    typeLink.ast.type = typeLink.type;
                }
            }
        };
        TypeChecker.prototype.resolveBaseTypeLink = function (typeLink, scope) {
            this.resolvingBases = true;
            this.resolveTypeLink(scope, typeLink, true);
            this.resolvingBases = false;
            var extendsType = null;
            if (typeLink.type.isClass()) {
                extendsType = typeLink.type.instanceType;
            } else {
                extendsType = typeLink.type;
            }
            return extendsType;
        };
        TypeChecker.prototype.findMostApplicableSignature = function (signatures, args) {
            if (signatures.length === 1) {
                return {
                    sig: signatures[0].signature,
                    ambiguous: false
                };
            }
            var best = signatures[0];
            var Q = null;
            var AType = null;
            var PType = null;
            var QType = null;
            var ambiguous = false;
            for(var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                for(var i = 0; args && i < args.members.length; i++) {
                    AType = args.members[i].type;
                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;
                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;
                    if (this.typesAreIdentical(PType, QType)) {
                        continue;
                    } else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    } else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(PType, QType)) {
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(QType, PType)) {
                        best = Q;
                        break;
                    } else if (Q.hadProvisionalErrors) {
                        break;
                    } else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }
                if (!args || i === args.members.length) {
                    var collection = {
                        getLength: function () {
                            return 2;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return index ? Q.signature.returnType.type : best.signature.returnType.type;
                        }
                    };
                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);
                    ambiguous = !bct;
                } else {
                    ambiguous = false;
                }
            }
            return {
                sig: best.signature,
                ambiguous: ambiguous
            };
        };
        TypeChecker.prototype.getApplicableSignatures = function (signatures, args, comparisonInfo) {
            var applicableSigs = [];
            var memberType = null;
            var miss = false;
            var cxt = null;
            var hadProvisionalErrors = false;
            for(var i = 0; i < signatures.length; i++) {
                miss = false;
                for(var j = 0; j < args.members.length; j++) {
                    if (j >= signatures[i].parameters.length) {
                        continue;
                    }
                    memberType = signatures[i].parameters[j].getType();
                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {
                        memberType = memberType.elementType;
                    }
                    if (memberType === this.anyType) {
                        continue;
                    } else if (args.members[j].nodeType === TypeScript.NodeType.FunctionDeclaration) {
                        if (this.typeFlow.functionInterfaceType && memberType === this.typeFlow.functionInterfaceType) {
                            continue;
                        }
                        if (!this.canContextuallyTypeFunction(memberType, args.members[j], true)) {
                            if (this.canContextuallyTypeFunction(memberType, args.members[j], false)) {
                                this.typeFlow.typeCheck(args.members[j]);
                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else {
                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                            this.cleanStartedPTO();
                            hadProvisionalErrors = this.hadProvisionalErrors();
                            this.resetProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    } else if (args.members[j].nodeType === TypeScript.NodeType.ObjectLiteralExpression) {
                        if (this.typeFlow.objectInterfaceType && memberType === this.typeFlow.objectInterfaceType) {
                            continue;
                        }
                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors();
                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    } else if (args.members[j].nodeType === TypeScript.NodeType.ArrayLiteralExpression) {
                        if (this.typeFlow.arrayInterfaceType && memberType === this.typeFlow.arrayInterfaceType) {
                            continue;
                        }
                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors();
                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                }
                if (j === args.members.length) {
                    applicableSigs[applicableSigs.length] = {
                        signature: signatures[i],
                        hadProvisionalErrors: hadProvisionalErrors
                    };
                }
                hadProvisionalErrors = false;
            }
            return applicableSigs;
        };
        TypeChecker.prototype.canContextuallyTypeFunction = function (candidateType, funcDecl, beStringent) {
            if (funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation) {
                return false;
            }
            beStringent = beStringent || (this.typeFlow.functionInterfaceType === candidateType);
            if (!beStringent) {
                return true;
            }
            if (!funcDecl.signature) {
                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);
                this.typeFlow.typeCheck(funcDecl);
            }
            var signature = funcDecl.signature;
            var paramLen = signature.parameters.length;
            for(var i = 0; i < paramLen; i++) {
                var param = signature.parameters[i];
                var symbol = param;
                var argDecl = symbol.declAST;
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }
            if (candidateType.construct && candidateType.call) {
                return false;
            }
            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;
            if (!candidateSigs || candidateSigs.signatures.length > 1) {
                return false;
            }
            return true;
        };
        TypeChecker.prototype.canContextuallyTypeObjectLiteral = function (targetType, objectLit) {
            if (targetType === this.typeFlow.objectInterfaceType) {
                return true;
            }
            var memberDecls = objectLit.operand;
            if (!(memberDecls && targetType.memberScope)) {
                return false;
            }
            var id = null;
            var targetMember = null;
            var text = "";
            var foundSyms = {};
            for(var i = 0; i < memberDecls.members.length; i++) {
                id = (memberDecls.members[i]).operand1;
                if (id.nodeType === TypeScript.NodeType.Name) {
                    text = (id).text;
                } else if (id.nodeType === TypeScript.NodeType.StringLiteral) {
                    var idText = (id).text;
                    text = idText.substring(1, idText.length - 1);
                } else {
                    return false;
                }
                targetMember = targetType.memberScope.find(text, true, false);
                if (!targetMember) {
                    return false;
                }
                foundSyms[text] = true;
            }
            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);
            for(var i = 0; i < targetMembers.length; i++) {
                var memberName = targetMembers[i];
                var memberSym = targetType.memberScope.find(memberName, true, false);
                if (!foundSyms[targetMembers[i]] && !TypeScript.hasFlag(memberSym.flags, TypeScript.SymbolFlags.Optional)) {
                    return false;
                }
            }
            return true;
        };
        TypeChecker.prototype.widenType = function (t) {
            if (t === this.undefinedType || t === this.nullType) {
                return this.anyType;
            }
            return t;
        };
        TypeChecker.prototype.isNullOrUndefinedType = function (t) {
            return t === this.undefinedType || t === this.nullType;
        };
        TypeChecker.prototype.findBestCommonType = function (initialType, targetType, collection, acceptVoid, comparisonInfo) {
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;
            if (targetType) {
                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;
            }
            var convergenceType = bestCommonType;
            while(nlastChecked < len) {
                for(var i = 0; i < len; i++) {
                    if (i === nlastChecked) {
                        continue;
                    }
                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }
                    if (bestCommonType === this.anyType || bestCommonType === null) {
                        break;
                    } else if (targetType) {
                        collection.setTypeAtIndex(i, targetType);
                    }
                }
                if (convergenceType && bestCommonType) {
                    break;
                }
                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }
            return acceptVoid ? bestCommonType : (bestCommonType === this.voidType ? null : bestCommonType);
        };
        TypeChecker.prototype.typesAreIdentical = function (t1, t2) {
            if (t1 === t2) {
                return true;
            }
            if (!t1 || !t2) {
                return false;
            }
            if (t1.isClass() || t1.isClassInstance()) {
                return false;
            }
            var comboId = (t2.typeID << 16) | t1.typeID;
            if (this.identicalCache[comboId]) {
                return true;
            }
            if ((t1.typeFlags & TypeScript.TypeFlags.IsEnum) || (t2.typeFlags & TypeScript.TypeFlags.IsEnum)) {
                return false;
            }
            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);
                if (ret) {
                    this.subtypeCache[comboId] = true;
                } else {
                    this.subtypeCache[comboId] = undefined;
                }
                return ret;
            }
            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {
                return false;
            }
            this.identicalCache[comboId] = false;
            if (t1.memberScope && t2.memberScope) {
                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();
                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();
                if (t1MemberKeys.length != t2MemberKeys.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }
                var t1MemberSymbol = null;
                var t2MemberSymbol = null;
                var t1MemberType = null;
                var t2MemberType = null;
                for(var iMember = 0; iMember < t1MemberKeys.length; iMember++) {
                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                    t1MemberSymbol = t1.memberScope.find(t1MemberKeys[iMember], false, false);
                    t2MemberSymbol = t2.memberScope.find(t2MemberKeys[iMember], false, false);
                    if ((t1MemberSymbol.flags & TypeScript.SymbolFlags.Optional) != (t2MemberSymbol.flags & TypeScript.SymbolFlags.Optional)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {
                        continue;
                    }
                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            } else if (t1.memberScope || t2.memberScope) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            this.identicalCache[comboId] = true;
            return true;
        };
        TypeChecker.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 === sg2) {
                return true;
            }
            if (!sg1 || !sg2) {
                return false;
            }
            if (sg1.signatures.length != sg2.signatures.length) {
                return false;
            }
            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;
            for(var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {
                sig1 = sg1.signatures[iSig1];
                for(var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {
                    sig2 = sg2.signatures[iSig2];
                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }
                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        TypeChecker.prototype.signaturesAreIdentical = function (s1, s2) {
            if (s1.hasVariableArgList != s2.hasVariableArgList) {
                return false;
            }
            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {
                return false;
            }
            if (s1.parameters.length != s2.parameters.length) {
                return false;
            }
            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {
                return false;
            }
            for(var iParam = 0; iParam < s1.parameters.length; iParam++) {
                if (!this.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {
                    return false;
                }
            }
            return true;
        };
        TypeChecker.prototype.sourceIsSubtypeOfTarget = function (source, target, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureIsSubtypeOfTarget = function (s1, s2, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo);
        };
        TypeChecker.prototype.sourceIsAssignableToTarget = function (source, target, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureIsAssignableToTarget = function (s1, s2, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo);
        };
        TypeChecker.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, comparisonInfo) {
            if (source === target) {
                return true;
            }
            if (!(source && target)) {
                return true;
            }
            var comboId = (source.typeID << 16) | target.typeID;
            if (comparisonCache[comboId] != undefined) {
                return true;
            }
            if (assignableTo) {
                if (source === this.anyType || target === this.anyType) {
                    return true;
                }
            } else {
                if (target === this.anyType) {
                    return true;
                }
            }
            if (source === this.undefinedType) {
                return true;
            }
            if ((source === this.nullType) && (target != this.undefinedType && target != this.voidType)) {
                return true;
            }
            if (target === this.numberType && (source.typeFlags & TypeScript.TypeFlags.IsEnum)) {
                return true;
            }
            if (source === this.numberType && (target.typeFlags & TypeScript.TypeFlags.IsEnum)) {
                return true;
            }
            if ((source.typeFlags & TypeScript.TypeFlags.IsEnum) || (target.typeFlags & TypeScript.TypeFlags.IsEnum)) {
                return false;
            }
            if (source.isArray() || target.isArray()) {
                if (!(source.isArray() && target.isArray())) {
                    return false;
                }
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                } else {
                    comparisonCache[comboId] = undefined;
                }
                return ret;
            }
            if (source.primitiveTypeClass != target.primitiveTypeClass) {
                if (target.primitiveTypeClass === TypeScript.Primitive.None) {
                    if (source === this.numberType && this.typeFlow.numberInterfaceType) {
                        source = this.typeFlow.numberInterfaceType;
                    } else if (source === this.stringType && this.typeFlow.stringInterfaceType) {
                        source = this.typeFlow.stringInterfaceType;
                    } else if (source === this.booleanType && this.typeFlow.booleanInterfaceType) {
                        source = this.typeFlow.booleanInterfaceType;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            comparisonCache[comboId] = false;
            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }
            if (this.typeFlow.objectInterfaceType && target === this.typeFlow.objectInterfaceType) {
                return true;
            }
            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target === this.typeFlow.functionInterfaceType) {
                return true;
            }
            if (target.isClass() || target.isClassInstance()) {
                comparisonCache[comboId] = undefined;
                return false;
            }
            if (target.memberScope && source.memberScope) {
                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);
                var mProp = null;
                var nProp = null;
                var mPropType = null;
                var nPropType = null;
                var inferenceSymbol = null;
                for(var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {
                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);
                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);
                    if (mProp.name === "arguments" && this.typeFlow.iargumentsInterfaceType && (this.typeFlow.iargumentsInterfaceType.symbol.flags & TypeScript.SymbolFlags.CompilerGenerated) && mProp.kind() === TypeScript.SymbolKind.Variable && (mProp).variable.typeLink.type === this.typeFlow.iargumentsInterfaceType) {
                        continue;
                    }
                    if (mProp.isInferenceSymbol()) {
                        inferenceSymbol = mProp;
                        if (inferenceSymbol.typeCheckStatus === TypeScript.TypeCheckStatus.NotStarted) {
                            this.typeFlow.typeCheck(mProp.declAST);
                        }
                    }
                    mPropType = mProp.getType();
                    if (!nProp) {
                        if (this.typeFlow.objectInterfaceType) {
                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                        }
                        if (!nProp) {
                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {
                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                            }
                            if (!nProp) {
                                if (!(mProp.flags & TypeScript.SymbolFlags.Optional)) {
                                    comparisonCache[comboId] = undefined;
                                    if (comparisonInfo) {
                                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.RequiredPropertyIsMissing;
                                        comparisonInfo.addMessage("Type '" + source.getTypeName() + "' is missing property '" + mPropKeys[iMProp] + "' from type '" + target.getTypeName() + "'");
                                    }
                                    return false;
                                } else {
                                    continue;
                                }
                            }
                        }
                    }
                    if (nProp.isInferenceSymbol()) {
                        inferenceSymbol = nProp;
                        if (inferenceSymbol.typeCheckStatus === TypeScript.TypeCheckStatus.NotStarted) {
                            this.typeFlow.typeCheck(nProp.declAST);
                        }
                    }
                    nPropType = nProp.getType();
                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {
                        continue;
                    }
                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {
                        comparisonCache[comboId] = undefined;
                        if (comparisonInfo) {
                            comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatiblePropertyTypes;
                            comparisonInfo.addMessage("Types of property '" + mProp.name + "' of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        return false;
                    }
                }
            }
            var hasSig;
            var lacksSig;
            if (source.call || target.call) {
                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.call && target.call) {
                            comparisonInfo.addMessage("Call signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        } else {
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            if (source.construct || target.construct) {
                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.construct && target.construct) {
                            comparisonInfo.addMessage("Construct signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        } else {
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            if (target.index) {
                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;
                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;
                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.addMessage("Index signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            comparisonCache[comboId] = true;
            return true;
        };
        TypeChecker.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, comparisonInfo) {
            if (sourceSG === targetSG) {
                return true;
            }
            if (!(sourceSG && targetSG)) {
                return false;
            }
            var mSig = null;
            var nSig = null;
            var foundMatch = false;
            for(var iMSig = 0; iMSig < targetSG.signatures.length; iMSig++) {
                mSig = targetSG.signatures[iMSig];
                for(var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {
                    nSig = sourceSG.signatures[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }
                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        TypeChecker.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, comparisonInfo) {
            if (!sourceSig.parameters || !targetSig.parameters) {
                return false;
            }
            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;
            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;
            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
                    comparisonInfo.addMessage("Call signature expects " + targetVarArgCount + " or fewer parameters");
                }
                return false;
            }
            var sourceReturnType = sourceSig.returnType.type;
            var targetReturnType = targetSig.returnType.type;
            if (targetReturnType != this.voidType) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleReturnTypes;
                    }
                    return false;
                }
            }
            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";
            for(var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {
                    sourceParamType = (sourceSig.parameters[iSource]).parameter.typeLink.type;
                    sourceParamName = (sourceSig.parameters[iSource]).parameter.symbol.name;
                } else if (iSource === sourceVarArgCount) {
                    sourceParamType = (sourceSig.parameters[iSource]).parameter.typeLink.type;
                    if (sourceParamType.elementType) {
                        sourceParamType = sourceParamType.elementType;
                    }
                    sourceParamName = (sourceSig.parameters[iSource]).parameter.symbol.name;
                }
                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {
                    targetParamType = (targetSig.parameters[iTarget]).parameter.typeLink.type;
                    targetParamName = (targetSig.parameters[iTarget]).parameter.symbol.name;
                } else if (targetSig.hasVariableArgList && iTarget === targetVarArgCount) {
                    targetParamType = (targetSig.parameters[iTarget]).parameter.typeLink.type;
                    if (targetParamType.elementType) {
                        targetParamType = targetParamType.elementType;
                    }
                    targetParamName = (targetSig.parameters[iTarget]).parameter.symbol.name;
                }
                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleParameterTypes;
                    }
                    return false;
                }
            }
            return true;
        };
        return TypeChecker;
    })();
    TypeScript.TypeChecker = TypeChecker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Continuation = (function () {
        function Continuation(normalBlock) {
            this.normalBlock = normalBlock;
            this.exceptionBlock = -1;
        }
        return Continuation;
    })();
    TypeScript.Continuation = Continuation;    
    function getBaseTypeLinks(bases, baseTypeLinks) {
        if (bases) {
            var len = bases.members.length;
            if (!baseTypeLinks) {
                baseTypeLinks = [];
            }
            for(var i = 0; i < len; i++) {
                var baseExpr = bases.members[i];
                var name = baseExpr;
                var typeLink = new TypeScript.TypeLink();
                typeLink.ast = name;
                baseTypeLinks[baseTypeLinks.length] = typeLink;
            }
        }
        return baseTypeLinks;
    }
    function getBases(type, typeDecl) {
        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);
        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);
    }
    function addPrototypeField(classType, ast, context) {
        var field = new TypeScript.ValueLocation();
        field.typeLink = new TypeScript.TypeLink();
        field.typeLink.ast = ast;
        field.typeLink.type = classType.instanceType;
        var fieldSymbol = new TypeScript.FieldSymbol("prototype", ast.minChar, null, true, field);
        fieldSymbol.flags |= (TypeScript.SymbolFlags.Property | TypeScript.SymbolFlags.BuiltIn);
        field.symbol = fieldSymbol;
        fieldSymbol.declAST = ast;
        classType.members.addPublicMember("prototype", fieldSymbol);
    }
    function createNewConstructGroupForType(type) {
        var signature = new TypeScript.Signature();
        signature.returnType = new TypeScript.TypeLink();
        signature.returnType.type = type.instanceType;
        signature.parameters = [];
        type.construct = new TypeScript.SignatureGroup();
        type.construct.addSignature(signature);
    }
    TypeScript.createNewConstructGroupForType = createNewConstructGroupForType;
    function cloneParentConstructGroupForChildType(child, parent) {
        child.construct = new TypeScript.SignatureGroup();
        var sig = null;
        if (!parent.construct) {
            createNewConstructGroupForType(parent);
        }
        for(var i = 0; i < parent.construct.signatures.length; i++) {
            sig = new TypeScript.Signature();
            sig.parameters = parent.construct.signatures[i].parameters;
            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;
            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;
            sig.declAST = parent.construct.signatures[i].declAST;
            sig.returnType = new TypeScript.TypeLink();
            sig.returnType.type = child.instanceType;
            child.construct.addSignature(sig);
        }
    }
    TypeScript.cloneParentConstructGroupForChildType = cloneParentConstructGroupForChildType;
    TypeScript.globalId = "__GLO";
    function findTypeSymbolInScopeChain(name, scopeChain) {
        var symbol = scopeChain.scope.find(name, false, true);
        if (symbol === null && scopeChain.previous) {
            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);
        }
        return symbol;
    }
    function findSymbolFromAlias(alias, context) {
        var symbol = null;
        switch(alias.nodeType) {
            case TypeScript.NodeType.Name:
                var name = (alias).text;
                var isDynamic = TypeScript.isQuoted(name);
                var findSym = function (id) {
                    if (context.members) {
                        return context.members.lookup(name);
                    } else {
                        return findTypeSymbolInScopeChain(name, context.topLevelScope);
                    }
                };
                if (isDynamic) {
                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, null, findSym);
                } else {
                    symbol = findSym(name);
                }
                break;
            case TypeScript.NodeType.MemberAccessExpression:
                var dottedExpr = alias;
                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);
                if (op1Sym && op1Sym.getType()) {
                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);
                }
                break;
            default:
                break;
        }
        if (symbol) {
            var symType = symbol.getType();
            if (symType) {
                var members = symType.members;
                if (members) {
                    context.members = members.publicMembers;
                }
            }
        }
        return symbol;
    }
    function preCollectImportTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var typeSymbol = null;
        var modType = null;
        var importDecl = ast;
        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, {
            topLevelScope: scopeChain,
            members: null,
            tcContext: context
        });
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        if (aliasedModSymbol) {
            var aliasedModType = aliasedModSymbol.getType();
            if (aliasedModType) {
                modType = aliasedModType;
            }
        }
        typeSymbol = new TypeScript.TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar, null, modType, context.checker.compilationSettings.optimizeModuleCodeGen);
        typeSymbol.aliasLink = importDecl;
        if (context.scopeChain.moduleDecl) {
            typeSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;
            typeSymbol.declModule = context.scopeChain.moduleDecl;
        }
        typeSymbol.declAST = importDecl;
        importDecl.id.sym = typeSymbol;
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isGlobal, true, false);
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isGlobal, false, false);
        return true;
    }
    TypeScript.preCollectImportTypes = preCollectImportTypes;
    function preCollectModuleTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var moduleDecl = ast;
        var isAmbient = TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.Ambient);
        var isEnum = TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.IsEnum);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var isExported = TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.Exported);
        var modName = (moduleDecl.name).text;
        var isDynamic = TypeScript.isQuoted(modName);
        var symbol = scopeChain.scope.findLocal(modName, false, false);
        var typeSymbol = null;
        var modType = null;
        if (symbol && symbol.declAST && symbol.declAST.nodeType != TypeScript.NodeType.ModuleDeclaration) {
            context.checker.errorReporter.simpleError(moduleDecl, "Conflicting symbol name for module '" + modName + "'");
            symbol = null;
            modName = "";
        }
        if (symbol) {
            var modDeclAST = symbol.declAST;
            var modDeclASTIsExported = TypeScript.hasFlag(modDeclAST.getModuleFlags(), TypeScript.ModuleFlags.Exported);
            if ((modDeclASTIsExported && !isExported) || (!modDeclASTIsExported && isExported)) {
                context.checker.errorReporter.simpleError(moduleDecl, 'All contributions to a module must be "export" or none');
            }
        }
        var enclosedTypes = null;
        var ambientEnclosedTypes = null;
        if ((symbol === null) || (symbol.kind() != TypeScript.SymbolKind.Type)) {
            if (modType === null) {
                enclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                ambientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                modType = new TypeScript.ModuleType(enclosedTypes, ambientEnclosedTypes);
                if (isEnum) {
                    modType.typeFlags |= TypeScript.TypeFlags.IsEnum;
                }
                modType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                modType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                modType.setHasImplementation();
            }
            typeSymbol = new TypeScript.TypeSymbol(modName, moduleDecl.name.minChar, modName.length, null, modType, context.checker.compilationSettings.optimizeModuleCodeGen);
            typeSymbol.isDynamic = TypeScript.isQuoted(moduleDecl.prettyName);
            if (context.scopeChain.moduleDecl) {
                typeSymbol.declModule = context.scopeChain.moduleDecl;
            }
            typeSymbol.declAST = moduleDecl;
            typeSymbol.prettyName = moduleDecl.prettyName;
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            modType.symbol = typeSymbol;
        } else {
            typeSymbol = symbol;
            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;
            var publicEnclosedTypesTable = (publicEnclosedTypes === null) ? new TypeScript.StringHashTable() : publicEnclosedTypes;
            enclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicEnclosedTypesTable, new TypeScript.StringHashTable()));
            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;
            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes === null) ? new TypeScript.StringHashTable() : publicEnclosedAmbientTypes;
            ambientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicAmbientEnclosedTypesTable, new TypeScript.StringHashTable()));
            var publicMembers = typeSymbol.type.members.publicMembers;
            var publicMembersTable = (publicMembers === null) ? new TypeScript.StringHashTable() : publicMembers;
            var members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicMembersTable, new TypeScript.StringHashTable()));
            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;
            var publicAmbientMembersTable = (publicAmbientMembers === null) ? new TypeScript.StringHashTable() : publicAmbientMembers;
            var ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicAmbientMembersTable, new TypeScript.StringHashTable()));
            modType = new TypeScript.ModuleType(enclosedTypes, ambientEnclosedTypes);
            if (isEnum) {
                modType.typeFlags |= TypeScript.TypeFlags.IsEnum;
            }
            modType.members = members;
            modType.ambientMembers = ambientMembers;
            modType.setHasImplementation();
            modType.symbol = typeSymbol;
            typeSymbol.addLocation(moduleDecl.minChar);
            typeSymbol.expansions.push(modType);
            typeSymbol.expansionsDeclAST.push(moduleDecl);
        }
        if (context.scopeChain.moduleDecl) {
        }
        if (isExported) {
            typeSymbol.flags |= TypeScript.SymbolFlags.Exported;
        }
        if ((context.scopeChain.moduleDecl) || (context.scopeChain.container === context.checker.gloMod)) {
            typeSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;
        }
        moduleDecl.mod = modType;
        TypeScript.pushTypeCollectionScope(typeSymbol, modType.members, modType.ambientMembers, modType.enclosedTypes, modType.ambientEnclosedTypes, context, null, null, moduleDecl);
        return true;
    }
    TypeScript.preCollectModuleTypes = preCollectModuleTypes;
    function preCollectClassTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var classDecl = ast;
        var classType;
        var instanceType;
        var typeSymbol = null;
        var className = (classDecl.name).text;
        var alreadyInScope = false;
        var isAmbient = TypeScript.hasFlag(classDecl.getVarFlags(), TypeScript.VariableFlags.Ambient);
        var isExported = TypeScript.hasFlag(classDecl.getVarFlags(), TypeScript.VariableFlags.Exported);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var containerMod = scopeChain.container;
        var foundValSymbol = false;
        typeSymbol = scopeChain.scope.findLocal(className, false, true);
        if (!typeSymbol) {
            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);
            if (valTypeSymbol && valTypeSymbol.isType() && valTypeSymbol.declAST && valTypeSymbol.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && (valTypeSymbol.declAST).isSignature()) {
                typeSymbol = valTypeSymbol;
                foundValSymbol = true;
                if (isExported) {
                    typeSymbol.flags |= TypeScript.SymbolFlags.Exported;
                }
                if (isAmbient) {
                    typeSymbol.flags |= TypeScript.SymbolFlags.Ambient;
                }
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            }
        }
        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {
            typeSymbol = null;
        }
        if (typeSymbol === null) {
            var valueSymbol = scopeChain.scope.findLocal(className, false, false);
            classType = new TypeScript.Type();
            classType.setHasImplementation();
            instanceType = new TypeScript.Type();
            instanceType.setHasImplementation();
            classType.instanceType = instanceType;
            classType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            classType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            addPrototypeField(classType, classDecl, context);
            instanceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            instanceType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            typeSymbol = new TypeScript.TypeSymbol(className, classDecl.name.minChar, className.length, null, classType, context.checker.compilationSettings.optimizeModuleCodeGen);
            typeSymbol.declAST = classDecl;
            typeSymbol.instanceType = instanceType;
            classType.symbol = typeSymbol;
            instanceType.symbol = typeSymbol;
            if (context.scopeChain.moduleDecl) {
                typeSymbol.declModule = context.scopeChain.moduleDecl;
                typeSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;
            }
            if (isExported) {
                typeSymbol.flags |= TypeScript.SymbolFlags.Exported;
            }
            if (isAmbient) {
                typeSymbol.flags |= TypeScript.SymbolFlags.Ambient;
            }
            ast.type = classType;
            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            if (valueSymbol === null) {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            }
        } else {
            classType = typeSymbol.type;
            if (classType.instanceType === null) {
                classType.instanceType = new TypeScript.Type();
                classType.instanceType.setHasImplementation();
                classType.instanceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                classType.instanceType.symbol = classType.symbol;
                classType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                classType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            }
            instanceType = classType.instanceType;
            ast.type = classType;
        }
        if (!classDecl.constructorDecl) {
            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call) {
                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);
            }
            createNewConstructGroupForType(classDecl.type);
        }
        classType.typeFlags |= TypeScript.TypeFlags.IsClass;
        instanceType.typeFlags |= TypeScript.TypeFlags.IsClass;
        getBases(instanceType, classDecl);
        TypeScript.pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null, context, instanceType, classType, null);
        return true;
    }
    TypeScript.preCollectClassTypes = preCollectClassTypes;
    function preCollectInterfaceTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var interfaceDecl = ast;
        var interfaceSymbol = null;
        var interfaceType = null;
        var isExported = TypeScript.hasFlag(interfaceDecl.getVarFlags(), TypeScript.VariableFlags.Exported);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var alreadyInScope = true;
        alreadyInScope = false;
        var interfaceName = (interfaceDecl.name).text;
        interfaceSymbol = scopeChain.scope.findLocal(interfaceName, false, true);
        if (interfaceSymbol === null) {
            interfaceType = new TypeScript.Type();
            interfaceSymbol = new TypeScript.TypeSymbol(interfaceName, interfaceDecl.name.minChar, interfaceName.length, null, interfaceType, context.checker.compilationSettings.optimizeModuleCodeGen);
            interfaceType.symbol = interfaceSymbol;
            interfaceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            interfaceType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            interfaceSymbol.declAST = interfaceDecl;
            interfaceSymbol.declModule = context.scopeChain.moduleDecl;
        } else {
            alreadyInScope = true;
            interfaceType = interfaceSymbol.type;
        }
        if (!interfaceType) {
            interfaceType = context.checker.anyType;
        }
        ast.type = interfaceType;
        getBases(interfaceType, interfaceDecl);
        if (isExported) {
            interfaceSymbol.flags |= TypeScript.SymbolFlags.Exported;
        }
        if (context.scopeChain.moduleDecl) {
            interfaceSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;
        }
        if (!alreadyInScope) {
            context.scopeChain.scope.enter(context.scopeChain.container, ast, interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false);
        }
        TypeScript.pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null, context, interfaceType, null, null);
        return true;
    }
    TypeScript.preCollectInterfaceTypes = preCollectInterfaceTypes;
    function preCollectArgDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var argDecl = ast;
        if (TypeScript.hasFlag(argDecl.getVarFlags(), TypeScript.VariableFlags.Public | TypeScript.VariableFlags.Private)) {
            var field = new TypeScript.ValueLocation();
            var isPrivate = TypeScript.hasFlag(argDecl.getVarFlags(), TypeScript.VariableFlags.Private);
            var fieldSymbol = new TypeScript.FieldSymbol(argDecl.id.text, argDecl.id.minChar, null, true, field);
            fieldSymbol.transferVarFlags(argDecl.getVarFlags());
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            argDecl.parameterPropertySym = fieldSymbol;
            context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);
            field.typeLink = TypeScript.getTypeLink(argDecl.typeExpr, context.checker, argDecl.init === null);
            argDecl.sym = fieldSymbol;
        }
        return false;
    }
    TypeScript.preCollectArgDeclTypes = preCollectArgDeclTypes;
    function preCollectVarDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var varDecl = ast;
        var isAmbient = TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Ambient);
        var isExported = TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Exported);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var isProperty = TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Property);
        var isStatic = TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Static);
        var isPrivate = TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Private);
        var isOptional = TypeScript.hasFlag(varDecl.id.getFlags(), TypeScript.ASTFlags.OptionalName);
        if (context.scopeChain.moduleDecl) {
        }
        if (isProperty || isExported || (context.scopeChain.container === context.checker.gloMod) || context.scopeChain.moduleDecl) {
            if (isAmbient) {
                var existingSym = scopeChain.scope.findLocal(varDecl.id.text, false, false);
                if (existingSym) {
                    varDecl.sym = existingSym;
                    return false;
                }
            }
            if (varDecl.id === null) {
                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");
                return false;
            }
            var field = new TypeScript.ValueLocation();
            var fieldSymbol = new TypeScript.FieldSymbol(varDecl.id.text, varDecl.id.minChar, null, true, field);
            fieldSymbol.transferVarFlags(varDecl.getVarFlags());
            if (isOptional) {
                fieldSymbol.flags |= TypeScript.SymbolFlags.Optional;
            }
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            if ((context.scopeChain.moduleDecl) || (context.scopeChain.container === context.checker.gloMod)) {
                fieldSymbol.flags |= TypeScript.SymbolFlags.ModuleMember;
                fieldSymbol.declModule = context.scopeChain.moduleDecl;
            }
            if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Property) && isStatic && context.scopeChain.classType) {
                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {
                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);
                }
                fieldSymbol.container = context.scopeChain.classType.symbol;
            } else {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate && (isProperty || isExported || isGlobal || isStatic), false, isAmbient);
            }
            if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Exported)) {
                fieldSymbol.flags |= TypeScript.SymbolFlags.Exported;
            }
            field.typeLink = TypeScript.getTypeLink(varDecl.typeExpr, context.checker, varDecl.init === null);
            varDecl.sym = fieldSymbol;
        }
        return false;
    }
    TypeScript.preCollectVarDeclTypes = preCollectVarDeclTypes;
    function preCollectFuncDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        if (context.scopeChain.moduleDecl) {
        }
        var funcDecl = ast;
        var fgSym = null;
        var nameText = funcDecl.getNameText();
        var isExported = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Exported | TypeScript.FunctionFlags.ClassPropertyMethodExported);
        var isStatic = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Static);
        var isPrivate = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Private);
        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
        var containerSym = (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);
        var containerScope = context.scopeChain.scope;
        var isGlobal = containerSym === context.checker.gloMod;
        var isOptional = funcDecl.name && TypeScript.hasFlag(funcDecl.name.getFlags(), TypeScript.ASTFlags.OptionalName);
        var go = false;
        var foundSymbol = false;
        if (isConstructor && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod)) {
            containerSym = containerSym.container;
            containerScope = scopeChain.previous.scope;
        }
        if (!funcDecl.isConstructor && containerSym && containerSym.declAST && containerSym.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && (containerSym.declAST).isConstructor && !funcDecl.isMethod()) {
            return go;
        }
        if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Signature)) {
            var instType = context.scopeChain.thisType;
            if (nameText && nameText != "__missing") {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                } else {
                    fgSym = containerScope.findLocal(nameText, false, false);
                    if (fgSym === null) {
                        fgSym = containerScope.findLocal(nameText, false, true);
                    }
                }
                if (fgSym) {
                    foundSymbol = true;
                    if (!funcDecl.isSignature() && (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Ambient) != TypeScript.hasFlag(fgSym.flags, TypeScript.SymbolFlags.Ambient))) {
                        fgSym = null;
                    }
                }
            }
            if (fgSym === null) {
                if (!(funcDecl.isSpecialFn())) {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;
                } else {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;
                }
                if (fgSym.declAST === null || !funcDecl.isSpecialFn()) {
                    fgSym.declAST = ast;
                }
            } else {
                if ((fgSym.kind() === TypeScript.SymbolKind.Type)) {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;
                } else {
                    context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                }
            }
            if (funcDecl.isSpecialFn() && !isStatic) {
                funcDecl.type = instType ? instType : fgSym.type;
            } else {
                funcDecl.type = fgSym.type;
            }
        } else {
            if (nameText) {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                } else {
                    if (funcDecl.isConstructor && context.scopeChain.previous) {
                        fgSym = context.scopeChain.previous.scope.findLocal(nameText, false, false);
                    }
                    if (fgSym === null) {
                        fgSym = containerScope.findLocal(nameText, false, false);
                    }
                }
                if (fgSym) {
                    foundSymbol = true;
                    if (!isConstructor && fgSym.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && !(fgSym.declAST).isAccessor() && !(fgSym.declAST).isSignature()) {
                        fgSym = null;
                        foundSymbol = false;
                    }
                }
            }
            if (fgSym && !fgSym.isAccessor() && fgSym.type && fgSym.type.construct && fgSym.type.construct.signatures != [] && (fgSym.type.construct.signatures[0].declAST === null || !TypeScript.hasFlag(fgSym.type.construct.signatures[0].declAST.getFunctionFlags(), TypeScript.FunctionFlags.Ambient)) && !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Functions may not have class overloads");
            }
            if (fgSym && !(fgSym.kind() === TypeScript.SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                fgSym.type = context.checker.anyType;
            }
            if (fgSym && !fgSym.isAccessor() && funcDecl.isAccessor()) {
                fgSym = null;
            }
            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);
            if (((!fgSym || fgSym.declAST.nodeType != TypeScript.NodeType.FunctionDeclaration) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {
                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);
            }
            funcDecl.type.symbol.declAST = ast;
            if (funcDecl.isConstructor) {
                go = true;
            }
            ;
        }
        if (isExported) {
            if (funcDecl.type.call) {
                funcDecl.type.symbol.flags |= TypeScript.SymbolFlags.Exported;
            }
            if (fgSym && !fgSym.isAccessor() && fgSym.kind() === TypeScript.SymbolKind.Type && fgSym.type.call) {
                fgSym.flags |= TypeScript.SymbolFlags.Exported;
            }
        }
        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {
            funcDecl.type.symbol.flags |= TypeScript.SymbolFlags.ModuleMember;
            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;
        }
        if (fgSym && isOptional) {
            fgSym.flags |= TypeScript.SymbolFlags.Optional;
        }
        return go;
    }
    TypeScript.preCollectFuncDeclTypes = preCollectFuncDeclTypes;
    function preCollectTypes(ast, parent, walker) {
        var context = walker.state;
        var go = false;
        var scopeChain = context.scopeChain;
        if (ast.nodeType === TypeScript.NodeType.Script) {
            var script = ast;
            context.script = script;
            go = true;
        } else if (ast.nodeType === TypeScript.NodeType.List) {
            go = true;
        } else if (ast.nodeType === TypeScript.NodeType.ImportDeclaration) {
            go = preCollectImportTypes(ast, parent, context);
        } else if (ast.nodeType === TypeScript.NodeType.WithStatement) {
            go = false;
        } else if (ast.nodeType === TypeScript.NodeType.ModuleDeclaration) {
            go = preCollectModuleTypes(ast, parent, context);
        } else if (ast.nodeType === TypeScript.NodeType.ClassDeclaration) {
            go = preCollectClassTypes(ast, parent, context);
        } else if (ast.nodeType === TypeScript.NodeType.Block) {
            go = true;
        } else if (ast.nodeType === TypeScript.NodeType.InterfaceDeclaration) {
            go = preCollectInterfaceTypes(ast, parent, context);
        } else if (ast.nodeType === TypeScript.NodeType.Parameter) {
            go = preCollectArgDeclTypes(ast, parent, context);
        } else if (ast.nodeType === TypeScript.NodeType.VariableDeclarator) {
            go = preCollectVarDeclTypes(ast, parent, context);
        } else if (ast.nodeType === TypeScript.NodeType.FunctionDeclaration) {
            go = preCollectFuncDeclTypes(ast, parent, context);
        } else {
            if (context.scopeChain.moduleDecl) {
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.preCollectTypes = preCollectTypes;
    function postCollectTypes(ast, parent, walker) {
        var context = walker.state;
        if (ast.nodeType === TypeScript.NodeType.ModuleDeclaration) {
            TypeScript.popTypeCollectionScope(context);
        } else if (ast.nodeType === TypeScript.NodeType.ClassDeclaration) {
            TypeScript.popTypeCollectionScope(context);
        } else if (ast.nodeType === TypeScript.NodeType.InterfaceDeclaration) {
            TypeScript.popTypeCollectionScope(context);
        }
        return ast;
    }
    TypeScript.postCollectTypes = postCollectTypes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScopeChain = (function () {
        function ScopeChain(container, previous, scope) {
            this.container = container;
            this.previous = previous;
            this.scope = scope;
        }
        return ScopeChain;
    })();
    TypeScript.ScopeChain = ScopeChain;    
    var BBUseDefInfo = (function () {
        function BBUseDefInfo(bb) {
            this.bb = bb;
            this.defsBySymbol = [];
            this.useIndexBySymbol = [];
        }
        BBUseDefInfo.prototype.updateTop = function () {
            var temp = new BitVector(this.top.bitCount);
            for(var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {
                var succ = this.bb.successors[i];
                if (succ.useDef) {
                    temp.union(succ.useDef.top);
                }
            }
            temp.difference(this.kill);
            temp.union(this.gen);
            var changed = temp.notEq(this.top);
            this.top = temp;
            return changed;
        };
        BBUseDefInfo.prototype.initialize = function (useDefContext) {
            var _this = this;
            var defSym = function (sym, context) {
                if (context.isLocalSym(sym)) {
                    var index = context.getSymbolIndex(sym);
                    _this.useIndexBySymbol[index] = [];
                    _this.defsBySymbol[index] = true;
                }
            };
            var useSym = function (sym, context, ast) {
                if (context.isLocalSym(sym)) {
                    var symIndex = context.getSymbolIndex(sym);
                    if (_this.useIndexBySymbol[symIndex] === undefined) {
                        _this.useIndexBySymbol[symIndex] = [];
                    }
                    var symUses = _this.useIndexBySymbol[symIndex];
                    var astIndex = context.getUseIndex(ast);
                    context.addUse(symIndex, astIndex);
                    symUses.push(astIndex);
                }
            };
            function initUseDefPre(cur, parent, walker) {
                var context = walker.state;
                var asg;
                var id;
                if (cur === null) {
                    cur = null;
                }
                if (cur.nodeType === TypeScript.NodeType.VariableDeclarator) {
                    var varDecl = cur;
                    if (varDecl.init) {
                        defSym(varDecl.sym, context);
                    }
                } else if (cur.nodeType === TypeScript.NodeType.Name) {
                    if (parent) {
                        if (parent.nodeType === TypeScript.NodeType.AssignmentExpression) {
                            asg = parent;
                            if (asg.operand1 === cur) {
                                return cur;
                            }
                        } else if (parent.nodeType === TypeScript.NodeType.VariableDeclarator) {
                            var parentDecl = parent;
                            if (parentDecl.id === cur) {
                                return cur;
                            }
                        }
                    }
                    id = cur;
                    useSym(id.sym, context, cur);
                } else if ((cur.nodeType >= TypeScript.NodeType.AssignmentExpression) && (cur.nodeType <= TypeScript.NodeType.UnsignedRightShiftAssignmentExpression)) {
                    asg = cur;
                    if (asg.operand1 && (asg.operand1.nodeType === TypeScript.NodeType.Name)) {
                        id = asg.operand1;
                        defSym(id.sym, context);
                    }
                } else if (cur.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    walker.options.goChildren = false;
                }
                return cur;
            }
            var options = new TypeScript.AstWalkOptions();
            TypeScript.getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);
        };
        BBUseDefInfo.prototype.initializeGen = function (useDefContext) {
            var symbolLen = this.useIndexBySymbol.length;
            var bitCount = useDefContext.uses.length;
            this.gen = new BitVector(bitCount);
            for(var s = 0; s < symbolLen; s++) {
                var symUses = this.useIndexBySymbol[s];
                if ((symUses !== undefined) && (symUses.length > 0)) {
                    for(var u = 0, uLen = symUses.length; u < uLen; u++) {
                        this.gen.set(symUses[u], true);
                    }
                }
            }
            this.top = this.gen;
        };
        BBUseDefInfo.prototype.initializeKill = function (useDefContext) {
            this.kill = new BitVector(this.gen.bitCount);
            for(var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {
                if (this.defsBySymbol[s]) {
                    var globalSymUses = useDefContext.useIndexBySymbol[s];
                    if (globalSymUses) {
                        for(var u = 0, useLen = globalSymUses.length; u < useLen; u++) {
                            this.kill.set(globalSymUses[u], true);
                        }
                    }
                }
            }
        };
        return BBUseDefInfo;
    })();
    TypeScript.BBUseDefInfo = BBUseDefInfo;    
    var UseDefContext = (function () {
        function UseDefContext() {
            this.useIndexBySymbol = [];
            this.uses = [];
            this.symbols = [];
            this.symbolMap = new TypeScript.StringHashTable();
            this.symbolCount = 0;
        }
        UseDefContext.prototype.getSymbolIndex = function (sym) {
            var name = sym.name;
            var index = (this.symbolMap.lookup(name));
            if (index === null) {
                index = this.symbolCount++;
                this.symbols[index] = sym;
                this.symbolMap.add(name, index);
            }
            return index;
        };
        UseDefContext.prototype.addUse = function (symIndex, astIndex) {
            var useBySym = this.useIndexBySymbol[symIndex];
            if (useBySym === undefined) {
                useBySym = [];
                this.useIndexBySymbol[symIndex] = useBySym;
            }
            useBySym[useBySym.length] = astIndex;
        };
        UseDefContext.prototype.getUseIndex = function (ast) {
            this.uses[this.uses.length] = ast;
            return this.uses.length - 1;
        };
        UseDefContext.prototype.isLocalSym = function (sym) {
            return (sym && (sym.container === this.func) && (sym.kind() === TypeScript.SymbolKind.Variable));
        };
        UseDefContext.prototype.killSymbol = function (sym, bbUses) {
            var index = this.symbolMap.lookup(sym.name);
            var usesOfSym = this.useIndexBySymbol[index];
            for(var k = 0, len = usesOfSym.length; k < len; k++) {
                bbUses.set(usesOfSym[k], true);
            }
        };
        return UseDefContext;
    })();
    TypeScript.UseDefContext = UseDefContext;    
    var BitVector = (function () {
        function BitVector(bitCount) {
            this.bitCount = bitCount;
            this.firstBits = 0;
            this.restOfBits = null;
            if (this.bitCount > BitVector.packBits) {
                this.restOfBits = [];
                var len = Math.floor(this.bitCount / BitVector.packBits);
                for(var i = 0; i < len; i++) {
                    this.restOfBits[i] = 0;
                }
            }
        }
        BitVector.packBits = 30;
        BitVector.prototype.set = function (bitIndex, value) {
            if (bitIndex < BitVector.packBits) {
                if (value) {
                    this.firstBits |= (1 << bitIndex);
                } else {
                    this.firstBits &= (~(1 << bitIndex));
                }
            } else {
                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;
                var localIndex = bitIndex % BitVector.packBits;
                if (value) {
                    this.restOfBits[offset] |= (1 << localIndex);
                } else {
                    this.restOfBits[offset] &= (~(1 << localIndex));
                }
            }
        };
        BitVector.prototype.map = function (fn) {
            for(var k = 0; k < BitVector.packBits; k++) {
                if (k === this.bitCount) {
                    return;
                }
                if (((1 << k) & this.firstBits) !== 0) {
                    fn(k);
                }
            }
            if (this.restOfBits) {
                var len;
                var cumu = BitVector.packBits;
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    for(var j = 0; j < BitVector.packBits; j++) {
                        if (((1 << j) & myBits) !== 0) {
                            fn(cumu);
                        }
                        cumu++;
                        if (cumu === this.bitCount) {
                            return;
                        }
                    }
                }
            }
        };
        BitVector.prototype.union = function (b) {
            this.firstBits |= b.firstBits;
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits | bBits;
                }
            }
        };
        BitVector.prototype.intersection = function (b) {
            this.firstBits &= b.firstBits;
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits & bBits;
                }
            }
        };
        BitVector.prototype.notEq = function (b) {
            if (this.firstBits !== b.firstBits) {
                return true;
            }
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    if (myBits !== bBits) {
                        return true;
                    }
                }
            }
            return false;
        };
        BitVector.prototype.difference = function (b) {
            var oldFirstBits = this.firstBits;
            this.firstBits &= (~b.firstBits);
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] &= (~bBits);
                }
            }
        };
        return BitVector;
    })();
    TypeScript.BitVector = BitVector;    
    var BasicBlock = (function () {
        function BasicBlock() {
            this.predecessors = [];
            this.index = -1;
            this.markValue = 0;
            this.successors = [];
            this.useDef = null;
            this.content = new TypeScript.ASTList();
        }
        BasicBlock.prototype.marked = function (markBase) {
            return this.markValue > markBase;
        };
        BasicBlock.prototype.mark = function () {
            this.markValue++;
        };
        BasicBlock.prototype.addSuccessor = function (successor) {
            this.successors[this.successors.length] = successor;
            successor.predecessors[successor.predecessors.length] = this;
        };
        return BasicBlock;
    })();
    TypeScript.BasicBlock = BasicBlock;    
    var ControlFlowContext = (function () {
        function ControlFlowContext(current, exit) {
            this.current = current;
            this.exit = exit;
            this.entry = null;
            this.unreachable = null;
            this.noContinuation = false;
            this.statementStack = [];
            this.currentSwitch = [];
            this.markBase = 0;
            this.linearBBs = [];
            this.entry = this.current;
        }
        ControlFlowContext.prototype.walk = function (ast, parent) {
            return this.walker.walk(ast, parent);
        };
        ControlFlowContext.prototype.pushSwitch = function (bb) {
            this.currentSwitch.push(bb);
        };
        ControlFlowContext.prototype.popSwitch = function () {
            return this.currentSwitch.pop();
        };
        ControlFlowContext.prototype.reportUnreachable = function (er) {
            if (this.unreachable && (this.unreachable.length > 0)) {
                var len = this.unreachable.length;
                for(var i = 0; i < len; i++) {
                    var unreachableAST = this.unreachable[i];
                }
            }
        };
        ControlFlowContext.prototype.printAST = function (ast, outfile) {
            var printContext = new TypeScript.PrintContext(outfile);
            printContext.increaseIndent();
            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.prePrintAST, TypeScript.postPrintAST, null, printContext);
            printContext.decreaseIndent();
        };
        ControlFlowContext.prototype.printBlockContent = function (bb, outfile) {
            var content = bb.content;
            for(var i = 0, len = content.members.length; i < len; i++) {
                var ast = content.members[i];
                this.printAST(ast, outfile);
            }
        };
        ControlFlowContext.prototype.bfs = function (nodeFunc, edgeFunc, preEdges, postEdges) {
            var markValue = this.markBase++;
            var q = [];
            q[q.length] = this.entry;
            while(q.length > 0) {
                var bb = q.pop();
                if (!(bb.marked(markValue))) {
                    bb.mark();
                    if (nodeFunc) {
                        nodeFunc(bb);
                    }
                    var succLen = bb.successors.length;
                    if (succLen > 0) {
                        if (preEdges) {
                            preEdges();
                        }
                        for(var j = succLen - 1; j >= 0; j--) {
                            var successor = bb.successors[j];
                            if (!(successor.marked(this.markBase))) {
                                if (edgeFunc) {
                                    edgeFunc(bb, successor);
                                }
                                q[q.length] = successor;
                            }
                        }
                        if (postEdges) {
                            postEdges();
                        }
                    }
                }
            }
        };
        ControlFlowContext.prototype.useDef = function (er, funcSym) {
            var _this = this;
            var useDefContext = new UseDefContext();
            useDefContext.func = funcSym;
            var useDefInit = function (bb) {
                bb.useDef = new BBUseDefInfo(bb);
                bb.useDef.initialize(useDefContext);
                _this.linearBBs[_this.linearBBs.length] = bb;
            };
            this.bfs(useDefInit, null, null, null);
            var i, bbLen;
            for(var i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {
                this.linearBBs[i].useDef.initializeGen(useDefContext);
                this.linearBBs[i].useDef.initializeKill(useDefContext);
            }
            var changed = true;
            while(changed) {
                changed = false;
                for(var i = 0; i < bbLen; i++) {
                    changed = this.linearBBs[i].useDef.updateTop() || changed;
                }
            }
            var top = this.entry.useDef.top;
            top.map(function (index) {
                var ast = useDefContext.uses[index];
                er.simpleError(ast, "use of variable '" + ast.actualText + "' that is not definitely assigned");
            });
        };
        ControlFlowContext.prototype.print = function (outfile) {
            var _this = this;
            var index = 0;
            var node = function (bb) {
                if (bb.index < 0) {
                    bb.index = index++;
                }
                if (bb === _this.exit) {
                    outfile.WriteLine("Exit block with index " + bb.index);
                } else {
                    outfile.WriteLine("Basic block with index " + bb.index);
                    _this.printBlockContent(bb, outfile);
                }
            };
            function preEdges() {
                outfile.Write("  Branches to ");
            }
            function postEdges() {
                outfile.WriteLine("");
            }
            function edge(node1, node2) {
                if (node2.index < 0) {
                    node2.index = index++;
                }
                outfile.Write(node2.index + " ");
            }
            this.bfs(node, edge, preEdges, postEdges);
            if (this.unreachable !== null) {
                for(var i = 0, len = this.unreachable.length; i < len; i++) {
                    outfile.WriteLine("Unreachable basic block ...");
                    this.printAST(this.unreachable[i], outfile);
                }
            }
        };
        ControlFlowContext.prototype.pushStatement = function (stmt, continueBB, breakBB) {
            this.statementStack.push({
                stmt: stmt,
                continueBB: continueBB,
                breakBB: breakBB
            });
        };
        ControlFlowContext.prototype.popStatement = function () {
            return this.statementStack.pop();
        };
        ControlFlowContext.prototype.returnStmt = function () {
            this.current.addSuccessor(this.exit);
            this.setUnreachable();
        };
        ControlFlowContext.prototype.setUnreachable = function () {
            this.current = null;
            this.noContinuation = true;
        };
        ControlFlowContext.prototype.addUnreachable = function (ast) {
            if (this.unreachable === null) {
                this.unreachable = [];
            }
            this.unreachable[this.unreachable.length] = ast;
        };
        ControlFlowContext.prototype.unconditionalBranch = function (target, isContinue) {
            var targetBB = null;
            for(var i = 0, len = this.statementStack.length; i < len; i++) {
                var targetInfo = this.statementStack[i];
                if (targetInfo.stmt === target) {
                    if (isContinue) {
                        targetBB = targetInfo.continueBB;
                    } else {
                        targetBB = targetInfo.breakBB;
                    }
                    break;
                }
            }
            if (targetBB) {
                this.current.addSuccessor(targetBB);
            }
            this.setUnreachable();
        };
        ControlFlowContext.prototype.addContent = function (ast) {
            if (this.current) {
                this.current.content.append(ast);
            }
        };
        return ControlFlowContext;
    })();
    TypeScript.ControlFlowContext = ControlFlowContext;    
    var ResolutionDataCache = (function () {
        function ResolutionDataCache() {
            this.cacheSize = 16;
            this.rdCache = [];
            this.nextUp = 0;
            for(var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: i
                };
            }
        }
        ResolutionDataCache.prototype.getResolutionData = function () {
            var rd = null;
            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }
            if (rd === null) {
                this.cacheSize++;
                rd = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }
            this.nextUp++;
            return rd;
        };
        ResolutionDataCache.prototype.returnResolutionData = function (rd) {
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;
            this.nextUp = rd.id;
        };
        return ResolutionDataCache;
    })();
    TypeScript.ResolutionDataCache = ResolutionDataCache;    
    var TypeFlow = (function () {
        function TypeFlow(logger, initScope, checker, compilationSettings) {
            this.logger = logger;
            this.initScope = initScope;
            this.checker = checker;
            this.compilationSettings = compilationSettings;
            this.thisFnc = null;
            this.thisClassNode = null;
            this.enclosingFncIsMethod = false;
            this.arrayInterfaceType = null;
            this.stringInterfaceType = null;
            this.objectInterfaceType = null;
            this.functionInterfaceType = null;
            this.numberInterfaceType = null;
            this.booleanInterfaceType = null;
            this.iargumentsInterfaceType = null;
            this.currentScript = null;
            this.inImportTypeCheck = false;
            this.inTypeRefTypeCheck = false;
            this.inArrayElementTypeCheck = false;
            this.resolutionDataCache = new ResolutionDataCache();
            this.nestingLevel = 0;
            this.inSuperCall = false;
            this.checker.typeFlow = this;
            this.scope = this.initScope;
            this.globalScope = this.initScope;
            this.doubleType = this.checker.numberType;
            this.booleanType = this.checker.booleanType;
            this.stringType = this.checker.stringType;
            this.anyType = this.checker.anyType;
            this.regexType = this.anyType;
            this.nullType = this.checker.nullType;
            this.voidType = this.checker.voidType;
            this.arrayAnyType = this.checker.makeArrayType(this.anyType);
        }
        TypeFlow.prototype.initLibs = function () {
            var arraySym = this.globalScope.find("Array", false, true);
            if (arraySym && (arraySym.kind() === TypeScript.SymbolKind.Type)) {
                this.arrayInterfaceType = (arraySym).type;
            }
            var stringSym = this.globalScope.find("String", false, true);
            if (stringSym && (stringSym.kind() === TypeScript.SymbolKind.Type)) {
                this.stringInterfaceType = (stringSym).type;
            }
            var objectSym = this.globalScope.find("Object", false, true);
            if (objectSym && (objectSym.kind() === TypeScript.SymbolKind.Type)) {
                this.objectInterfaceType = (objectSym).type;
            }
            var fnSym = this.globalScope.find("Function", false, true);
            if (fnSym && (fnSym.kind() === TypeScript.SymbolKind.Type)) {
                this.functionInterfaceType = (fnSym).type;
            }
            var numberSym = this.globalScope.find("Number", false, true);
            if (numberSym && (numberSym.kind() === TypeScript.SymbolKind.Type)) {
                this.numberInterfaceType = (numberSym).type;
            }
            var booleanSym = this.globalScope.find("Boolean", false, true);
            if (booleanSym && (booleanSym.kind() === TypeScript.SymbolKind.Type)) {
                this.booleanInterfaceType = (booleanSym).type;
            }
            var regexSym = this.globalScope.find("RegExp", false, true);
            if (regexSym && (regexSym.kind() === TypeScript.SymbolKind.Type)) {
                this.regexType = (regexSym).type;
            }
        };
        TypeFlow.prototype.cast = function (ast, type) {
            return this.castWithCoercion(ast, type, true, false);
        };
        TypeFlow.prototype.castWithCoercion = function (ast, type, applyCoercion, typeAssertion) {
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {
                if (applyCoercion) {
                    if (type === null) {
                        ast.type = this.anyType;
                    } else if (type.isClass()) {
                        ast.type = type.instanceType;
                    } else {
                        ast.type = type;
                    }
                }
                return ast;
            } else {
                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);
                return ast;
            }
        };
        TypeFlow.prototype.inScopeTypeCheck = function (ast, enclosingScope) {
            var prevScope = this.scope;
            this.scope = enclosingScope;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var svThisClassNode = this.thisClassNode;
            var svCurrentModDecl = this.checker.currentModDecl;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var container = this.scope.container;
            var fnc = null;
            while(container) {
                if (container.kind() === TypeScript.SymbolKind.Type) {
                    var typeSym = container;
                    var type = typeSym.type;
                    if (type.call) {
                        if (fnc === null) {
                            this.enclosingFncIsMethod = typeSym.isMethod;
                            fnc = container.declAST;
                        }
                    }
                    if (type.isClass()) {
                        this.thisType = type.instanceType;
                        if (typeSym.declAST && (typeSym.declAST.nodeType === TypeScript.NodeType.ClassDeclaration)) {
                            this.thisClassNode = typeSym.declAST;
                        }
                        break;
                    }
                    if (type.isModuleType()) {
                        this.checker.currentModDecl = typeSym.declAST;
                        break;
                    }
                }
                container = container.container;
            }
            this.thisFnc = fnc;
            var updated = this.typeCheck(ast);
            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.thisClassNode = svThisClassNode;
            this.checker.currentModDecl = svCurrentModDecl;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.scope = prevScope;
            return updated;
        };
        TypeFlow.prototype.typeCheck = function (ast) {
            if (ast) {
                return ast.typeCheck(this);
            } else {
                return null;
            }
        };
        TypeFlow.prototype.inScopeTypeCheckDecl = function (ast) {
            if (ast.nodeType === TypeScript.NodeType.VariableDeclarator || ast.nodeType === TypeScript.NodeType.Parameter) {
                this.inScopeTypeCheckBoundDecl(ast);
            } else if (ast.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                var funcDecl = ast;
                if (funcDecl.isAccessor()) {
                    this.typeCheckFunction(funcDecl);
                }
            }
        };
        TypeFlow.prototype.inScopeTypeCheckBoundDecl = function (varDecl) {
            var sym = varDecl.sym;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var prevMethodStatus = this.enclosingFncIsMethod;
            if (sym && sym.container) {
                var instanceScope = sym.container.instanceScope();
                if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Property) && sym.container.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    this.thisFnc = sym.container.declAST;
                }
                if (instanceScope) {
                    var prevScope = this.scope;
                    this.scope = instanceScope;
                    var container = sym.container;
                    var svCurrentModDecl = this.checker.currentModDecl;
                    if (this.checker.fileNameToLocationInfo && this.checker.fileNameToLocationInfo.lookup(sym.fileName)) {
                    } else {
                    }
                    while(container) {
                        if (container.kind() === TypeScript.SymbolKind.Type) {
                            var typeSym = container;
                            var type = typeSym.type;
                            if (type.call) {
                                this.enclosingFncIsMethod = typeSym.isMethod;
                            }
                            if (type.isClass()) {
                                this.thisType = type.instanceType;
                            }
                            if (type.isModuleType()) {
                                this.checker.currentModDecl = container.declAST;
                                break;
                            }
                        }
                        container = container.container;
                    }
                    this.typeCheckBoundDecl(varDecl);
                    this.checker.currentModDecl = svCurrentModDecl;
                    this.scope = prevScope;
                }
            }
            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.enclosingFncIsMethod = prevMethodStatus;
        };
        TypeFlow.prototype.resolveBoundDecl = function (varDecl) {
            if (varDecl.typeExpr) {
                if (varDecl.typeExpr.type === null || (varDecl.typeExpr.type && varDecl.typeExpr.type === this.anyType && this.scope) || (!varDecl.typeExpr.type.symbol) || !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {
                    this.typeCheck(varDecl.typeExpr);
                }
                varDecl.type = varDecl.typeExpr.type;
                if (varDecl.sym) {
                    varDecl.sym.setType(varDecl.type);
                }
            } else if (varDecl.init === null) {
                if (this.checker.styleSettings.implicitAny) {
                    this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                }
                varDecl.type = this.anyType;
                if (varDecl.sym) {
                    if (varDecl.sym.isType()) {
                        var tsym = varDecl.sym;
                        if (tsym.isMethod) {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)");
                            return;
                        } else {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind type to variable");
                            return;
                        }
                    }
                    varDecl.sym.setType(varDecl.type);
                }
            }
        };
        TypeFlow.prototype.typeCheckBoundDecl = function (varDecl) {
            var _this = this;
            var infSym = varDecl.sym;
            if (infSym === null) {
                if (varDecl.init) {
                    varDecl.init = this.typeCheck(varDecl.init);
                    varDecl.type = this.checker.widenType(varDecl.init.type);
                } else {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                }
            } else {
                if (infSym.typeCheckStatus === TypeScript.TypeCheckStatus.Started) {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                    infSym.setType(this.anyType);
                } else if (infSym.typeCheckStatus === TypeScript.TypeCheckStatus.NotStarted) {
                    infSym.typeCheckStatus = TypeScript.TypeCheckStatus.Started;
                    this.checker.addStartedPTO(infSym);
                    var resolved = false;
                    if (varDecl.type === null) {
                        if (varDecl.typeExpr) {
                            this.resolveBoundDecl(varDecl);
                            resolved = true;
                            varDecl.type = varDecl.typeExpr.type;
                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        }
                    }
                    if (varDecl.init) {
                        var prevScope = this.scope;
                        var applyTargetType = varDecl.init.nodeType !== TypeScript.NodeType.ParenthesizedExpression;
                        if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Property) && this.thisClassNode) {
                            TypeScript.getAstWalkerFactory().walk(varDecl.init, function (ast, parent, walker) {
                                if (ast && ast.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                                    if (TypeScript.hasFlag((ast).getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction)) {
                                    }
                                    walker.options.goChildren = false;
                                }
                                return ast;
                            });
                        }
                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);
                        this.scope = prevScope;
                        if (varDecl.type) {
                            var preserveScope = false;
                            var preservedContainedScope = null;
                            if (varDecl.init.type) {
                                preservedContainedScope = varDecl.init.type.containedScope;
                                preserveScope = true;
                                if (varDecl.init.type === this.voidType) {
                                    this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                }
                            }
                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);
                            if (preserveScope && varDecl.init.type.containedScope === null) {
                                varDecl.init.type.containedScope = preservedContainedScope;
                            }
                        } else {
                            varDecl.type = this.checker.widenType(varDecl.init.type);
                            if (varDecl.type === this.voidType) {
                                this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                varDecl.type = this.anyType;
                            }
                        }
                        infSym.setType(varDecl.type);
                    } else {
                        if (!resolved) {
                            this.resolveBoundDecl(varDecl);
                        }
                    }
                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                } else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) && (infSym.declAST !== varDecl)) {
                    if (varDecl.init) {
                        varDecl.init = this.typeCheck(varDecl.init);
                        varDecl.type = infSym.getType();
                        varDecl.init = this.cast(varDecl.init, varDecl.type);
                    }
                }
            }
            if (varDecl.id && varDecl.sym) {
                varDecl.id.sym = varDecl.sym;
            }
            if (varDecl.sym && varDecl.sym.container) {
                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, function (typeName, isModuleName) {
                    return _this.varPrivacyErrorReporter(varDecl, typeName, isModuleName);
                });
            }
            return varDecl;
        };
        TypeFlow.prototype.varPrivacyErrorReporter = function (varDecl, typeName, isModuleName) {
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Public)) {
                if (varDecl.sym.container.declAST.nodeType === TypeScript.NodeType.InterfaceDeclaration) {
                    this.checker.errorReporter.simpleError(varDecl, "property '" + varDecl.sym.name + "' of exported interface" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(varDecl, "public member '" + varDecl.sym.name + "' of exported class" + typestring);
                }
            } else {
                this.checker.errorReporter.simpleError(varDecl, "exported variable '" + varDecl.sym.name + "'" + typestring);
            }
        };
        TypeFlow.prototype.typeCheckSuper = function (ast) {
            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {
                ast.type = this.thisType.baseClass();
            } else {
                if (!this.enclosingFncIsMethod && this.thisType && this.thisType.baseClass() && this.thisFnc && TypeScript.hasFlag(this.thisFnc.getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction)) {
                    var enclosingFnc = null;
                    while(TypeScript.hasFlag(enclosingFnc.getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction)) {
                        enclosingFnc = enclosingFnc.enclosingFnc;
                    }
                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {
                        ast.type = this.thisType.baseClass();
                        return ast;
                    }
                }
                ast.type = this.anyType;
                this.checker.errorReporter.Keyword__super__can_only_be_used_inside_a_class_instance_method(ast);
            }
            return ast;
        };
        TypeFlow.prototype.typeCheckThis = function (ast) {
            ast.type = this.anyType;
            var illegalThisRef = false;
            if (this.thisFnc === null) {
                if (this.thisType) {
                    if (this.thisClassNode && this.thisClassNode.nodeType === TypeScript.NodeType.ClassDeclaration) {
                        illegalThisRef = true;
                    } else {
                        ast.type = this.thisType;
                    }
                } else if (this.checker.currentModDecl) {
                    this.checker.errorReporter.simpleError(ast, "'this' may not be referenced within module bodies");
                }
            } else {
                if (this.thisClassNode || (this.inSuperCall)) {
                    illegalThisRef = true;
                }
                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor) {
                    if (this.thisType && !(this.thisFnc.getFunctionFlags() & TypeScript.FunctionFlags.Static)) {
                        ast.type = this.thisType;
                    }
                }
            }
            if (!this.enclosingFncIsMethod && this.thisFnc && TypeScript.hasFlag(this.thisFnc.getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction)) {
                if (false) {
                    var container = null;
                    if (container.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    }
                } else {
                    var encFnc = null;
                    var firstEncFnc = encFnc;
                    while(encFnc) {
                        if (this.thisClassNode) {
                            illegalThisRef = true;
                        }
                        if (!TypeScript.hasFlag(encFnc.getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction) || encFnc.hasSelfReference()) {
                            encFnc.setHasSelfReference();
                            break;
                        }
                        encFnc = encFnc.enclosingFnc;
                    }
                    if (!encFnc && firstEncFnc) {
                        encFnc = firstEncFnc;
                        encFnc.setHasSelfReference();
                    } else if (!encFnc) {
                        if (this.thisClassNode) {
                        } else if (this.checker.currentModDecl) {
                        } else {
                            this.checker.mustCaptureGlobalThis = true;
                        }
                    }
                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !TypeScript.hasFlag(encFnc.getFunctionFlags(), TypeScript.FunctionFlags.Static)) {
                        ast.type = this.thisType;
                    }
                }
            }
            if (illegalThisRef) {
                this.checker.errorReporter.simpleError(ast, "Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls");
            }
            return ast;
        };
        TypeFlow.prototype.setTypeFromSymbol = function (ast, symbol) {
            if (symbol.isVariable()) {
                if (symbol.isInferenceSymbol()) {
                    var infSym = symbol;
                    if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                        if (infSym.typeCheckStatus === TypeScript.TypeCheckStatus.Started) {
                            infSym.declAST.type = this.anyType;
                            infSym.setType(this.anyType);
                        } else {
                            this.inScopeTypeCheckDecl(infSym.declAST);
                        }
                    }
                    if (!this.checker.styleSettings.innerScopeDeclEscape) {
                        if (infSym.declAST && (infSym.declAST.nodeType === TypeScript.NodeType.VariableDeclarator)) {
                        }
                    }
                }
                ast.type = symbol.getType();
                if (!symbol.writeable()) {
                }
            } else if (symbol.isType()) {
                ast.type = symbol.getType();
            } else {
                ast.type = this.anyType;
                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);
            }
        };
        TypeFlow.prototype.typeCheckName = function (ast) {
            var _this = this;
            var identifier = ast;
            if (this.checker.inWith) {
                identifier.type = this.anyType;
            } else {
                var typespace = this.inTypeRefTypeCheck;
                var idText = identifier.text;
                var originalIdText = idText;
                var isDynamicModuleName = TypeScript.isQuoted(identifier.text);
                var symbol = this.scope.find(idText, false, typespace);
                if (symbol === null && isDynamicModuleName) {
                    symbol = this.checker.findSymbolForDynamicModule(idText, null, function (id) {
                        return _this.scope.find(id, false, typespace);
                    });
                }
                if (!symbol) {
                    if (!identifier.isMissing()) {
                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);
                    }
                    identifier.type = this.anyType;
                } else {
                    if (this.compilationSettings.optimizeModuleCodeGen && symbol && symbol.isType()) {
                        var symType = symbol.getType();
                        if (symType && (symbol).aliasLink && (symbol).onlyReferencedAsTypeRef) {
                            var modDecl = symType.symbol.declAST;
                            if (modDecl && TypeScript.hasFlag(modDecl.getModuleFlags(), TypeScript.ModuleFlags.IsDynamic)) {
                                (symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;
                            }
                        }
                    }
                    if (symbol.declAST && symbol.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration && !(symbol.declAST).returnTypeAnnotation && (symbol.declAST).signature.typeCheckStatus === TypeScript.TypeCheckStatus.Started) {
                        (symbol.declAST).type.symbol.flags |= TypeScript.SymbolFlags.RecursivelyReferenced;
                        (symbol.declAST).signature.returnType.type = this.anyType;
                    }
                    this.setTypeFromSymbol(ast, symbol);
                    identifier.sym = symbol;
                    if (this.thisFnc) {
                        if (this.thisFnc.type && symbol.container !== this.thisFnc.type.symbol) {
                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;
                        }
                    }
                }
            }
            return ast;
        };
        TypeFlow.prototype.typeCheckScript = function (script) {
            this.scope = this.checker.globalScope;
            if (!script.topLevelMod) {
                this.addLocalsFromScope(this.scope, this.checker.gloMod, null, this.checker.globals, true);
            }
            this.currentScript = script;
            script.moduleElements = this.typeCheck(script.moduleElements);
            this.currentScript = null;
            return script;
        };
        TypeFlow.prototype.typeCheckBitNot = function (ast) {
            var unex = ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return unex;
        };
        TypeFlow.prototype.typeCheckUnaryNumberOperator = function (ast) {
            var unex = ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return ast;
        };
        TypeFlow.prototype.typeCheckLogNot = function (ast) {
            var unex = ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.booleanType;
            return unex;
        };
        TypeFlow.prototype.typeCheckIncOrDec = function (ast) {
            var unex = ast;
            var lval = unex.operand;
            unex = this.typeCheckUnaryNumberOperator(ast);
            if (unex.operand.type !== this.checker.numberType && unex.operand.type !== this.checker.anyType && !(unex.operand.type.typeFlags & TypeScript.TypeFlags.IsEnum)) {
                this.checker.errorReporter.simpleError(ast, "'++' and '--' may only be applied to operands of type 'number' or 'any'");
            }
            return unex;
        };
        TypeFlow.prototype.typeCheckBitwiseOperator = function (ast, assignment) {
            var binex = ast;
            var resultType = null;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {
                resultType = this.doubleType;
            } else if ((leftType === this.booleanType) && (rightType === this.booleanType)) {
                resultType = this.booleanType;
            } else if (leftType === this.anyType) {
                if ((rightType === this.anyType) || (rightType === this.doubleType) || (rightType === this.booleanType)) {
                    resultType = this.anyType;
                }
            } else if (rightType === this.anyType) {
                if ((leftType === this.anyType) || (leftType === this.doubleType) || (leftType === this.booleanType)) {
                    resultType = this.anyType;
                }
            }
            if (resultType === null) {
                resultType = this.anyType;
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
            }
            binex.type = resultType;
            return binex;
        };
        TypeFlow.prototype.typeCheckArithmeticOperator = function (ast, assignment) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            var nodeType = binex.nodeType;
            if (this.checker.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.checker.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }
            leftType = this.checker.widenType(leftType);
            rightType = this.checker.widenType(rightType);
            if (nodeType === TypeScript.NodeType.AddExpression || nodeType === TypeScript.NodeType.AddAssignmentExpression) {
                if (leftType === this.checker.stringType || rightType === this.checker.stringType) {
                    binex.type = this.checker.stringType;
                } else if (leftType === this.checker.numberType && rightType === this.checker.numberType) {
                    binex.type = this.checker.numberType;
                } else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                } else if (leftType === this.checker.anyType || rightType === this.checker.anyType) {
                    binex.type = this.checker.anyType;
                } else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
                }
            } else {
                if (leftType === this.checker.numberType && rightType === this.checker.numberType) {
                    binex.type = this.checker.numberType;
                } else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                } else if (leftType === this.checker.anyType || rightType === this.checker.anyType) {
                    binex.type = this.checker.numberType;
                } else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
                }
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckDotOperator = function (ast) {
            var binex = ast;
            var leftIsFnc = false;
            binex.operand1 = this.typeCheck(binex.operand1);
            var leftType = binex.operand1.type;
            var leftScope = null;
            if (leftType) {
                if (leftType === this.anyType) {
                    binex.type = this.anyType;
                    return binex;
                } else if (leftType === this.stringType) {
                    if (this.stringInterfaceType) {
                        leftScope = this.stringInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if (leftType === this.doubleType) {
                    if (this.numberInterfaceType) {
                        leftScope = this.numberInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if (leftType === this.booleanType) {
                    if (this.booleanInterfaceType) {
                        leftScope = this.booleanInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if ((leftType.call || leftType.construct) && !leftType.members) {
                    if (this.functionInterfaceType) {
                        leftScope = this.functionInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if (leftType.elementType) {
                    if (this.arrayInterfaceType) {
                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);
                        leftScope = arrInstType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else {
                    leftScope = leftType.memberScope;
                }
            }
            if (!leftScope) {
                this.checker.errorReporter.Expected_var__class__interface__or_module(binex);
                binex.type = this.anyType;
            } else {
                var propertyName = binex.operand2;
                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type === this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;
                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck);
                if (!symbol) {
                    if (this.objectInterfaceType && leftType) {
                        if (leftType.isReferenceType()) {
                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                        }
                        if (!symbol) {
                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {
                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                            }
                        }
                    }
                }
                if (!symbol || (!symbol.visible(leftScope, this.checker))) {
                    binex.type = this.anyType;
                    if (symbol === null) {
                        this.checker.errorReporter.simpleError(propertyName, "The property '" + propertyName.actualText + "' does not exist on value of type '" + leftType.getScopedTypeName(this.scope) + "'");
                    } else if (!this.inTypeRefTypeCheck) {
                        this.checker.errorReporter.simpleError(binex, "The property '" + propertyName.actualText + " on type '" + leftType.getScopedTypeName(this.scope) + "' is not visible");
                    }
                } else {
                    if (symbol.isVariable()) {
                        if (symbol.isInferenceSymbol()) {
                            var infSym = symbol;
                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                                this.inScopeTypeCheckDecl(infSym.declAST);
                            }
                        }
                    }
                    propertyName.sym = symbol;
                    binex.type = symbol.getType();
                }
            }
            if (binex.type === null) {
                binex.type = this.anyType;
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckBooleanOperator = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if ((!(this.checker.sourceIsAssignableToTarget(leftType, rightType))) && (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
            }
            binex.type = this.booleanType;
            return binex;
        };
        TypeFlow.prototype.typeCheckAsgOperator = function (ast) {
            var binex = ast;
            var applyTargetType = binex.operand2.nodeType !== TypeScript.NodeType.ParenthesizedExpression;
            binex.operand1 = this.typeCheck(binex.operand1);
            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if (binex.operand1.nodeType === TypeScript.NodeType.InvocationExpression) {
                var callEx = binex.operand1;
            }
            var preserveScope = false;
            var preservedContainedScope = null;
            if (binex.operand2.type) {
                preservedContainedScope = binex.operand2.type.containedScope;
                preserveScope = true;
            }
            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);
            if (preserveScope && binex.operand2.type.containedScope === null) {
                binex.operand2.type.containedScope = preservedContainedScope;
            }
            binex.type = rightType;
            return binex;
        };
        TypeFlow.prototype.typeCheckIndex = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            if (!this.checker.styleSettings.literalSubscript) {
                if (binex.operand2.nodeType === TypeScript.NodeType.StringLiteral) {
                    this.checker.errorReporter.styleError(ast, "use literal subscript ('.') notation instead)");
                }
            }
            var objExprType = binex.operand1.type;
            var indexExprType = binex.operand2.type;
            if (objExprType.elementType) {
                if (indexExprType === this.checker.anyType || indexExprType === this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, TypeScript.TypeFlags.IsEnum)) {
                    binex.type = objExprType.elementType;
                } else if (indexExprType === this.checker.stringType) {
                    binex.type = this.checker.anyType;
                } else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            } else if (objExprType.index) {
                if (indexExprType === this.checker.anyType || !((objExprType.index.flags & TypeScript.SignatureFlags.IsStringIndexer) || (objExprType.index.flags & TypeScript.SignatureFlags.IsNumberIndexer)) || ((objExprType.index.flags & TypeScript.SignatureFlags.IsStringIndexer) && indexExprType === this.checker.stringType) || ((objExprType.index.flags & TypeScript.SignatureFlags.IsNumberIndexer) && (indexExprType === this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, TypeScript.TypeFlags.IsEnum)))) {
                    var sig = this.resolveOverload(ast, objExprType.index);
                    if (sig) {
                        binex.type = sig.returnType.type;
                    } else {
                        binex.type = this.checker.anyType;
                    }
                } else if (indexExprType === this.checker.stringType) {
                    binex.type = this.checker.anyType;
                } else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            } else if ((objExprType === this.checker.anyType || objExprType === this.checker.stringType || objExprType === this.checker.numberType || objExprType === this.checker.booleanType || objExprType.isReferenceType()) && (indexExprType === this.checker.anyType || indexExprType === this.checker.stringType || (indexExprType === this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, TypeScript.TypeFlags.IsEnum)))) {
                binex.type = this.checker.anyType;
            } else {
                this.checker.errorReporter.simpleError(binex, "Illegal property access");
                binex.type = this.checker.anyType;
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckInOperator = function (binex) {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);
            binex.operand2 = this.typeCheck(binex.operand2);
            if (!((binex.operand1.type === this.checker.anyType || binex.operand1.type === this.checker.stringType) && (binex.operand2.type === this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {
                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");
            }
            binex.type = this.booleanType;
            return binex;
        };
        TypeFlow.prototype.typeCheckShift = function (binex, assignment) {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);
            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);
            binex.type = this.doubleType;
            return binex;
        };
        TypeFlow.prototype.typeCheckQMark = function (trinex) {
            trinex.operand1 = this.typeCheck(trinex.operand1);
            trinex.operand2 = this.typeCheck(trinex.operand2);
            trinex.operand3 = this.typeCheck(trinex.operand3);
            var leftType = trinex.operand2.type;
            var rightType = trinex.operand3.type;
            if (leftType === rightType) {
                trinex.type = leftType;
            } else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    trinex.type = rightType;
                } else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    trinex.type = leftType;
                } else {
                    trinex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);
                }
            }
            return trinex;
        };
        TypeFlow.prototype.addFormals = function (container, signature, table) {
            var len = signature.parameters.length;
            for(var i = 0; i < len; i++) {
                var symbol = signature.parameters[i];
                symbol.container = container;
                table.add(symbol.name, symbol);
            }
        };
        TypeFlow.prototype.addLocalsFromScope = function (scope, container, vars, table, isModContainer) {
            var len = vars.members.length;
            var hasArgsDef = false;
            for(var i = 0; i < len; i++) {
                var local = vars.members[i];
                if (((local.sym === null) || (local.sym.kind() !== TypeScript.SymbolKind.Field))) {
                    var result = null;
                    if ((result = table.lookup(local.id.text)) === null) {
                        var localVar = new TypeScript.ValueLocation();
                        localVar.typeLink = new TypeScript.TypeLink();
                        var varSym = null;
                        if (TypeScript.hasFlag(local.getVarFlags(), TypeScript.VariableFlags.Static)) {
                            varSym = new TypeScript.FieldSymbol(local.id.text, local.minChar, null, true, localVar);
                        } else {
                            varSym = new TypeScript.VariableSymbol(local.id.text, local.minChar, null, localVar);
                        }
                        varSym.transferVarFlags(local.getVarFlags());
                        localVar.symbol = varSym;
                        varSym.declAST = local;
                        localVar.typeLink.ast = local.typeExpr;
                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);
                        if ((local.type === null) && (local.init === null)) {
                            local.type = this.anyType;
                        }
                        localVar.typeLink.type = local.type;
                        localVar.symbol.container = container;
                        local.sym = localVar.symbol;
                        table.add(local.id.text, varSym);
                        if (local.id.text === "arguments") {
                            hasArgsDef = true;
                        }
                    } else {
                        local.type = result.getType();
                        local.sym = result;
                    }
                }
            }
            if (!isModContainer) {
                if (!hasArgsDef) {
                    var argLoc = new TypeScript.ValueLocation();
                    argLoc.typeLink = new TypeScript.TypeLink();
                    var theArgSym = new TypeScript.VariableSymbol("arguments", vars.minChar, null, argLoc);
                    if (!this.iargumentsInterfaceType) {
                        var argumentsSym = scope.find("IArguments", false, true);
                        if (argumentsSym) {
                            argumentsSym.flags |= TypeScript.SymbolFlags.CompilerGenerated;
                            this.iargumentsInterfaceType = argumentsSym.getType();
                        } else {
                            this.iargumentsInterfaceType = this.anyType;
                        }
                    }
                    argLoc.typeLink.type = this.iargumentsInterfaceType;
                    table.add("arguments", theArgSym);
                }
            }
        };
        TypeFlow.prototype.addConstructorLocalArgs = function (constructorDecl, table, isClass) {
            var container = constructorDecl.type.symbol;
            var args = constructorDecl.arguments;
            if (args) {
                var len = args.members.length;
                for(var i = 0; i < len; i++) {
                    var local = args.members[i];
                    if ((local.sym === null) || (isClass || (local.sym.kind() !== TypeScript.SymbolKind.Field))) {
                        var result = null;
                        if ((result = table.lookup(local.id.text)) === null) {
                            this.resolveBoundDecl(local);
                            var localVar = new TypeScript.ValueLocation();
                            localVar.typeLink = new TypeScript.TypeLink();
                            var varSym = new TypeScript.ParameterSymbol(local.id.text, local.minChar, null, localVar);
                            varSym.funcDecl = constructorDecl;
                            varSym.declAST = local;
                            localVar.symbol = varSym;
                            localVar.typeLink.type = local.type;
                            localVar.symbol.container = container;
                            local.sym = localVar.symbol;
                            table.add(local.id.text, varSym);
                        } else {
                            local.type = result.getType();
                            local.sym = result;
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.checkInitSelf = function (funcDecl) {
            if (!funcDecl.isMethod()) {
                var freeVars = funcDecl.freeVariables;
                for(var k = 0, len = freeVars.length; k < len; k++) {
                    var sym = freeVars[k];
                    if (sym.isInstanceProperty()) {
                        return true;
                    }
                }
            }
            return false;
        };
        TypeFlow.prototype.checkPromoteFreeVars = function (funcDecl, constructorSym) {
            var freeVars = funcDecl.freeVariables;
            for(var k = 0, len = freeVars.length; k < len; k++) {
                var sym = freeVars[k];
                if ((!sym.isInstanceProperty()) && (sym.container === constructorSym)) {
                    TypeScript.instanceFilter.reset();
                    if (this.scope.search(TypeScript.instanceFilter, sym.name, false, false)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property '" + sym.name + "'. To access the class property, use 'self." + sym.name + "'");
                    }
                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '" + sym.name + "' to a class property");
                }
            }
        };
        TypeFlow.prototype.allReturnsAreVoid = function (funcDecl) {
            var allReturnsAreVoid = true;
            if (funcDecl.signature.returnType.type === null) {
                var preFindReturnExpressionTypes = function (ast, parent, walker) {
                    var go = true;
                    switch(ast.nodeType) {
                        case TypeScript.NodeType.FunctionDeclaration:
                            go = false;
                            break;
                        case TypeScript.NodeType.ReturnStatement:
                            var returnStmt = ast;
                            if (returnStmt.returnExpression) {
                                allReturnsAreVoid = false;
                                go = false;
                            }
                        default:
                            break;
                    }
                    walker.options.goChildren = go;
                    return ast;
                };
                TypeScript.getAstWalkerFactory().walk(funcDecl.block, preFindReturnExpressionTypes);
            }
            return allReturnsAreVoid;
        };
        TypeFlow.prototype.classConstructorHasSuperCall = function (funcDecl) {
            var foundSuper = false;
            var preFindSuperCall = function (ast, parent, walker) {
                var go = true;
                switch(ast.nodeType) {
                    case TypeScript.NodeType.FunctionDeclaration:
                        go = false;
                        break;
                    case TypeScript.NodeType.InvocationExpression:
                        var call = ast;
                        if (call.target.nodeType === TypeScript.NodeType.SuperExpression) {
                            go = false;
                            foundSuper = true;
                            break;
                        }
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = go;
                return ast;
            };
            TypeScript.getAstWalkerFactory().walk(funcDecl.block, preFindSuperCall);
            return foundSuper;
        };
        TypeFlow.prototype.baseListPrivacyErrorReporter = function (bases, i, declSymbol, extendsList, typeName, isModuleName) {
            var baseSymbol = bases.members[i].type.symbol;
            var declTypeString = (declSymbol.declAST.nodeType === TypeScript.NodeType.InterfaceDeclaration) ? "interface" : "class";
            var baseListTypeString = extendsList ? "extends" : "implements";
            var baseTypeString = (baseSymbol.declAST.nodeType === TypeScript.NodeType.InterfaceDeclaration) ? "interface" : "class";
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module ";
                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;
            } else {
                baseTypeString = " private " + baseTypeString + " '" + typeName + "'";
            }
            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " '" + declSymbol.name + "' " + baseListTypeString + baseTypeString);
        };
        TypeFlow.prototype.typeCheckBaseListPrivacy = function (bases, declSymbol, extendsList) {
            var _this = this;
            if (bases) {
                var basesLen = bases.members.length;
                for(var i = 0; i < basesLen; i++) {
                    if (!bases.members[i].type || bases.members[i].type === this.checker.anyType) {
                        continue;
                    }
                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, function (typeName, isModuleName) {
                        return _this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName);
                    });
                }
            }
        };
        TypeFlow.prototype.checkSymbolPrivacy = function (typeSymbol, declSymbol, errorCallback) {
            var externalModuleSymbol = null;
            var declSymbolPath = null;
            if (typeSymbol.isExternallyVisible(this.checker)) {
                var typeSymbolPath = typeSymbol.pathToRoot();
                declSymbolPath = declSymbol.pathToRoot();
                var typeSymbolLength = typeSymbolPath.length;
                var declSymbolPathLength = declSymbolPath.length;
                if (typeSymbolLength > 0) {
                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() && (typeSymbolPath[typeSymbolLength - 1]).isDynamic && typeSymbolPath[typeSymbolLength - 1] !== declSymbolPath[declSymbolPathLength - 1]) {
                        externalModuleSymbol = typeSymbolPath[typeSymbolLength - 1];
                    } else if (typeSymbolLength > 1) {
                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() && (typeSymbolPath[typeSymbolLength - 2]).isDynamic && (declSymbolPathLength === 1 || typeSymbolPath[typeSymbolLength - 2] !== declSymbolPath[declSymbolPathLength - 2])) {
                            externalModuleSymbol = typeSymbolPath[typeSymbolLength - 2];
                        }
                    }
                }
                if (externalModuleSymbol === null) {
                    return;
                }
            }
            var interfaceDecl = declSymbol.getInterfaceDeclFromSymbol(this.checker);
            if (interfaceDecl && !TypeScript.hasFlag(interfaceDecl.getVarFlags(), TypeScript.VariableFlags.Exported)) {
                return;
            }
            var checkVisibilitySymbol = declSymbol;
            var varDecl = declSymbol.getVarDeclFromSymbol();
            if (varDecl) {
                if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Private)) {
                    return;
                } else if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Public)) {
                    checkVisibilitySymbol = declSymbol.container;
                }
            }
            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {
                var privateSymbolName = typeSymbol.name;
                if (externalModuleSymbol !== null) {
                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);
                    if (prettyName !== null) {
                        return;
                    } else {
                        privateSymbolName = externalModuleSymbol.prettyName;
                    }
                }
                errorCallback(privateSymbolName, typeSymbol.name !== privateSymbolName);
            }
        };
        TypeFlow.prototype.checkTypePrivacy = function (type, declSymbol, errorCallback) {
            var _this = this;
            if (!(type && type.primitiveTypeClass === TypeScript.Primitive.None)) {
                return;
            }
            if (type.isArray()) {
                return this.checkTypePrivacy(type.elementType, declSymbol, errorCallback);
            }
            if (type.symbol && type.symbol.name && type.symbol.name !== "_anonymous" && (((type.call === null) && (type.construct === null) && (type.index === null)) || (type.members && (!type.isClass())))) {
                return this.checkSymbolPrivacy(type.symbol, declSymbol, errorCallback);
            }
            if (type.members) {
                type.members.allMembers.map(function (key, s, unused) {
                    var sym = s;
                    if (!TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.BuiltIn)) {
                        _this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);
                    }
                }, null);
            }
            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);
        };
        TypeFlow.prototype.checkSignatureGroupPrivacy = function (sgroup, declSymbol, errorCallback) {
            if (sgroup) {
                var len = sgroup.signatures.length;
                for(var i = 0; i < sgroup.signatures.length; i++) {
                    var signature = sgroup.signatures[i];
                    if (len > 1 && signature === sgroup.definitionSignature) {
                        continue;
                    }
                    if (signature.returnType) {
                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);
                    }
                    var paramLen = signature.parameters.length;
                    for(var j = 0; j < paramLen; j++) {
                        var param = signature.parameters[j];
                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);
                    }
                }
            }
        };
        TypeFlow.prototype.functionArgumentPrivacyErrorReporter = function (funcDecl, p, paramSymbol, typeName, isModuleName) {
            var isGetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.SetAccessor);
            var isPublicFunc = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Public);
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) !== null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (!isContainerInterface) {
                if (funcDecl.isConstructor) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (isSetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!isGetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter '" + paramSymbol.name + "'" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's call parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's function parameter '" + paramSymbol.name + "'" + typestring);
                }
            }
        };
        TypeFlow.prototype.returnTypePrivacyError = function (astError, funcDecl, typeName, isModuleName) {
            var isGetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.SetAccessor);
            var isPublicFunc = TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Public);
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) !== null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (!isContainerInterface) {
                if (isGetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);
                } else if (!isSetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's constructor return type" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's call return type" + typestring);
                } else if (funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's indexer return type" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(astError, "exported interface's function return type" + typestring);
                }
            }
        };
        TypeFlow.prototype.functionReturnTypePrivacyErrorReporter = function (funcDecl, signature, typeName, isModuleName) {
            var reportOnFuncDecl = false;
            if (funcDecl.returnTypeAnnotation !== null && funcDecl.returnTypeAnnotation.type === signature.returnType.type) {
                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);
            }
            for(var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                if (funcDecl.returnStatementsWithExpressions[i].type === signature.returnType.type) {
                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);
                } else {
                    reportOnFuncDecl = true;
                }
            }
            if (reportOnFuncDecl) {
                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);
            }
        };
        TypeFlow.prototype.typeCheckFunction = function (funcDecl) {
            var _this = this;
            this.nestingLevel = 0;
            var fnType = funcDecl.type;
            var fgSym = fnType.symbol;
            var signature = funcDecl.signature;
            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {
                return funcDecl;
            } else if (signature.typeCheckStatus === TypeScript.TypeCheckStatus.Started) {
                if (!funcDecl.returnTypeAnnotation && funcDecl.block && !funcDecl.isSignature() && !(funcDecl.isConstructor) && this.allReturnsAreVoid(funcDecl)) {
                    signature.returnType.type = this.voidType;
                    return funcDecl;
                } else {
                    if (funcDecl.returnTypeAnnotation === null) {
                        if (this.checker.styleSettings.implicitAny) {
                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'");
                        }
                        signature.returnType.type = this.anyType;
                        fgSym.flags |= TypeScript.SymbolFlags.RecursivelyReferenced;
                    }
                    return funcDecl;
                }
            }
            signature.typeCheckStatus = TypeScript.TypeCheckStatus.Started;
            this.checker.addStartedPTO(signature);
            var prevScope = this.scope;
            var prevFnc = this.thisFnc;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var prevClassNode = this.thisClassNode;
            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;
            this.thisFnc = funcDecl;
            var container = funcDecl.type.symbol;
            var prevThisType = this.thisType;
            var funcTable = null;
            var acceptedContextualType = false;
            var targetParams = null;
            var targetReturnType = null;
            var isGetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.SetAccessor);
            var accessorType = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;
            var prevModDecl = this.checker.currentModDecl;
            var ssb;
            if (funcDecl.isConstructor) {
                if (fnType.instanceType === null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed function body (is this a class named the same as an existing interface?)");
                    return funcDecl;
                }
                if (funcDecl.classDecl.type.construct === null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed constructor (is this a class named the same as an existing class?)");
                    return funcDecl;
                }
                this.scope = fnType.instanceType.constructorScope;
                ssb = this.scope;
                funcTable = ssb.valueMembers.allMembers;
            } else if ((funcDecl.isSpecialFn() && !(funcDecl.getFunctionFlags() & TypeScript.FunctionFlags.Signature))) {
                funcTable = funcDecl.symbols;
                if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Static) && fnType.containedScope) {
                    this.scope = fnType.containedScope;
                }
            } else {
                if (funcDecl.block) {
                    this.scope = fnType.containedScope;
                }
                ssb = this.scope;
                if (ssb && ssb.valueMembers) {
                    funcTable = ssb.valueMembers.allMembers;
                }
            }
            if (funcDecl.isConstructor && funcDecl.block && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod)) {
                var hasBaseType = TypeScript.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeScript.TypeFlags.HasBaseType);
                var noSuperCallAllowed = !hasBaseType || TypeScript.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeScript.TypeFlags.HasBaseTypeOfObject);
                var superCallMustBeFirst = false;
                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {
                    this.checker.errorReporter.simpleError(funcDecl, "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class");
                } else if (hasBaseType) {
                    if (superCallMustBeFirst) {
                        if (!funcDecl.block || !funcDecl.block.statements.members.length || !((funcDecl.block.statements.members[0].nodeType === TypeScript.NodeType.InvocationExpression && (funcDecl.block.statements.members[0]).target.nodeType === TypeScript.NodeType.SuperExpression) || (TypeScript.hasFlag(funcDecl.block.getFlags(), TypeScript.ASTFlags.StrictMode) && funcDecl.block.statements.members.length > 1 && funcDecl.block.statements.members[1].nodeType === TypeScript.NodeType.InvocationExpression && (funcDecl.block.statements.members[1]).target.nodeType === TypeScript.NodeType.SuperExpression))) {
                            this.checker.errorReporter.simpleError(funcDecl, "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor");
                        }
                    } else if (!this.classConstructorHasSuperCall(funcDecl)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructors for derived classes must contain a call to the class's 'super' constructor");
                    }
                }
            }
            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {
                var enclosingClassNode = null;
                if (funcDecl.type.enclosingType.symbol.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    enclosingClassNode = (funcDecl.type.enclosingType.symbol.declAST).classDecl;
                } else if (funcDecl.type.enclosingType.symbol.declAST.nodeType === TypeScript.NodeType.ClassDeclaration) {
                    enclosingClassNode = funcDecl.type.enclosingType.symbol.declAST;
                }
                if (enclosingClassNode) {
                    this.thisClassNode = enclosingClassNode;
                }
            }
            if (fnType.enclosingType) {
                ;
                var enclosingSym = fnType.symbol.container;
                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {
                    enclosingSym = enclosingSym.container;
                }
                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType === TypeScript.NodeType.ModuleDeclaration) {
                    this.checker.currentModDecl = enclosingSym.declAST;
                }
            }
            if (fnType.enclosingType) {
                this.thisType = fnType.enclosingType;
            } else {
                this.thisType = prevThisType;
            }
            var paramLen = signature.parameters.length;
            var candidateTypeContext;
            if (!funcDecl.isConstructor && funcDecl.block && !funcDecl.isSignature()) {
                var tmpParamScope = this.scope;
                ssb = this.scope;
                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation === null) {
                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {
                        var considerSym = prevScope.findAmbient(funcDecl.name.text, false, false);
                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {
                            this.checker.setContextualType(considerSym.declAST.type, false);
                        }
                    }
                    if (this.checker.hasTargetType()) {
                        candidateTypeContext = this.checker.getTargetTypeContext();
                        var candidateType = candidateTypeContext.contextualType;
                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {
                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;
                            candidateTypeContext.targetSig = candidateSigs.signatures[0];
                            var candidateParams = candidateTypeContext.targetSig.parameters;
                            targetParams = candidateParams;
                            targetReturnType = candidateTypeContext.targetSig.returnType.type;
                            fgSym.type = candidateTypeContext.contextualType;
                            acceptedContextualType = true;
                        } else if (candidateType && funcDecl.isAccessor()) {
                            accessorType = candidateType;
                            candidateTypeContext.targetAccessorType = accessorType;
                        } else {
                            this.checker.killCurrentContextualType();
                        }
                    }
                }
                var paramTable = ssb.valueMembers;
                this.scope = new TypeScript.SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);
                for(var p = 0; p < paramLen; p++) {
                    var symbol = signature.parameters[p];
                    var ast = symbol.declAST;
                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {
                        candidateTypeContext = this.checker.getTargetTypeContext();
                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;
                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();
                        ast.sym.setType(ast.type);
                        (ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                    } else {
                        this.typeCheck(ast);
                    }
                    if (isSetter && accessorType) {
                        ast = this.cast(ast, accessorType);
                    }
                    symbol.container = container;
                    this.checkTypePrivacy(symbol.getType(), container, function (typeName, isModuleName) {
                        return _this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName);
                    });
                    paramTable.publicMembers.add(symbol.name, symbol);
                }
                this.scope = tmpParamScope;
            } else {
                this.typeCheck(funcDecl.arguments);
                for(var p = 0; p < paramLen; p++) {
                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;
                    this.checkTypePrivacy(signature.parameters[p].getType(), container, function (typeName, isModuleName) {
                        return _this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName);
                    });
                    if ((funcDecl.arguments.members[p]).parameterPropertySym) {
                        (funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);
                    }
                }
                if ((funcDecl.getFunctionFlags() & TypeScript.FunctionFlags.IndexerMember)) {
                    if (!paramLen || paramLen > 1) {
                        this.checker.errorReporter.simpleError(funcDecl, "Index signatures may take one and only one parameter");
                    } else if (funcDecl.arguments.members[0].type === this.checker.numberType) {
                        fnType.index.flags |= TypeScript.SignatureFlags.IsNumberIndexer;
                    } else if (funcDecl.arguments.members[0].type === this.checker.stringType) {
                        fnType.index.flags |= TypeScript.SignatureFlags.IsStringIndexer;
                    } else {
                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], "Index signatures may only take 'string' or 'number' as their parameter");
                    }
                }
            }
            if (funcDecl.block && (!funcDecl.isSignature())) {
                if (!(funcDecl.isConstructor)) {
                    this.addFormals(container, signature, funcTable);
                } else {
                    this.addConstructorLocalArgs(funcDecl, funcTable, TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod));
                    if (this.thisClassNode && this.thisClassNode.extendsList) {
                        var tmpScope = this.scope;
                        var funcMembers = new TypeScript.ScopedMembers(funcTable);
                        this.scope = new TypeScript.FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol, function (sym) {
                            return sym.kind() === TypeScript.SymbolKind.Parameter;
                        });
                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);
                        this.scope = tmpScope;
                    }
                }
                var prevMod = this.checker.currentModDecl;
                if (funcDecl.type && funcDecl.type.symbol && !funcDecl.isMethod() && funcDecl.type.symbol.declModule) {
                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;
                }
                if (acceptedContextualType) {
                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());
                }
                this.typeCheck(funcDecl.block);
                if (acceptedContextualType) {
                    this.checker.unsetContextualType();
                }
                this.checker.currentModDecl = prevMod;
                if (this.checker.checkControlFlow) {
                    var cfg = funcDecl.buildControlFlow();
                    if (this.checker.printControlFlowGraph) {
                        cfg.print(this.checker.errorReporter.outfile);
                    }
                    cfg.reportUnreachable(this.checker.errorReporter);
                    if (this.checker.checkControlFlowUseDef) {
                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);
                    }
                }
                if (funcDecl.isConstructor) {
                }
            }
            this.scope = prevScope;
            this.thisFnc = prevFnc;
            this.thisClassNode = prevClassNode;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.thisType = prevThisType;
            this.checker.currentModDecl = prevModDecl;
            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
            if (funcDecl.returnTypeAnnotation) {
                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);
                if (signature.returnType.type === null) {
                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);
                }
            } else if (targetReturnType) {
                signature.returnType.type = targetReturnType;
            }
            if (!(fgSym.flags & TypeScript.SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {
                var collection = {
                    getLength: function () {
                        return funcDecl.returnStatementsWithExpressions.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        funcDecl.returnStatementsWithExpressions[index].type = type;
                    },
                    getTypeAtIndex: function (index) {
                        return funcDecl.returnStatementsWithExpressions[index].type;
                    }
                };
                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;
                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);
                if (bestCommonReturnType) {
                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);
                } else {
                    for(var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");
                    }
                    signature.returnType.type = this.anyType;
                }
            }
            var onlyHasThrow = false;
            if (signature.returnType.type === null) {
                signature.returnType.type = this.voidType;
            } else if (signature.returnType.type === this.nullType || signature.returnType.type === this.checker.undefinedType) {
                signature.returnType.type = this.anyType;
            } else if ((signature.returnType.type !== this.voidType && signature.returnType.type !== this.checker.undefinedType && signature.returnType.type !== this.anyType)) {
                if (!funcDecl.isSignature() && !funcDecl.isConstructor && !TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction)) {
                    onlyHasThrow = (funcDecl.block.statements.members.length > 0) && (funcDecl.block.statements.members[0].nodeType === TypeScript.NodeType.ThrowStatement);
                    if (!onlyHasThrow) {
                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl, "Function declared a non-void return type, but has no return expression");
                    }
                }
                this.checkTypePrivacy(signature.returnType.type, container, function (typeName, isModuleName) {
                    return _this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName);
                });
            }
            if (funcDecl.accessorSymbol) {
                accessorType = funcDecl.accessorSymbol.getType();
                if (!onlyHasThrow && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor) && true) {
                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");
                }
                if (accessorType) {
                    if ((TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor) && accessorType !== signature.returnType.type) || (funcDecl.arguments.members.length > 0 && accessorType !== funcDecl.arguments.members[0].type)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");
                    }
                } else {
                    if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor)) {
                        funcDecl.accessorSymbol.setType(signature.returnType.type);
                    } else {
                        if (funcDecl.arguments.members.length !== 1) {
                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");
                        } else {
                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);
                        }
                    }
                }
            }
            this.typeCheckOverloadSignatures(fnType, funcDecl);
            return funcDecl;
        };
        TypeFlow.prototype.typeCheckBases = function (type) {
            var seenInterface = false;
            var bases = type.extendsList;
            var baseLinks = type.extendsTypeLinks;
            if (bases) {
                var len = bases.length;
                if (len > 0) {
                    type.typeFlags |= TypeScript.TypeFlags.HasBaseType;
                }
                for(var i = 0; i < len; i++) {
                    if (bases[i] === this.checker.anyType) {
                        baseLinks[i].type = null;
                        var oldErrors = this.checker.errorReporter.getCapturedErrors();
                        TypeScript.CompilerDiagnostics.assert(oldErrors.length === 0, "There shouldnt be any contextual errors when typechecking base type names");
                        this.checker.errorReporter.pushToErrorSink = true;
                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);
                        this.checker.errorReporter.pushToErrorSink = false;
                        this.checker.errorReporter.freeCapturedErrors();
                    }
                    var base = bases[i];
                    var baseRef = baseLinks[i].ast;
                    var baseTypeOfObject = base.symbol && base.symbol.name === "Object" && base.symbol.container === this.checker.gloMod;
                    if (baseTypeOfObject) {
                        type.typeFlags |= TypeScript.TypeFlags.HasBaseTypeOfObject;
                    }
                    if (base.isClassInstance()) {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        } else {
                            if (seenInterface) {
                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");
                            }
                        }
                    } else if (base.isModuleType()) {
                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");
                    } else if (base.members) {
                        if (!seenInterface) {
                            seenInterface = true;
                        }
                    } else {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        } else {
                            this.checker.errorReporter.simpleError(baseRef, "Base type must be interface or class");
                        }
                        break;
                    }
                }
            }
        };
        TypeFlow.prototype.checkMembersImplementInterfaces = function (implementingType) {
            var instanceType = implementingType.getInstanceType();
            if (instanceType.implementsList) {
                var len = instanceType.implementsList.length;
                for(var i = 0; i < len; i++) {
                    var interfaceType = instanceType.implementsList[i];
                    var comparisonInfo = new TypeScript.TypeComparisonInfo();
                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {
                        var emsg = "Class '" + instanceType.getTypeName() + "' declares interface '" + interfaceType.getTypeName() + "' but does not implement it";
                        if (!comparisonInfo.message) {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);
                        } else {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckBaseCalls = function (bases) {
            if (bases === null) {
                return;
            }
            var basesLen = bases.members.length;
            for(var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol = null;
                if (baseExpr.nodeType === TypeScript.NodeType.InvocationExpression) {
                    this.typeCheckNew(baseExpr);
                }
            }
        };
        TypeFlow.prototype.assertUniqueNamesInBaseTypes = function (names, type, classDecl, checkUnique) {
            var _this = this;
            if (type) {
                if (type.members) {
                    type.members.publicMembers.map(function (key, s, c) {
                        var sym = s;
                        var dup = names.lookup(sym.name);
                        if (dup) {
                            if (checkUnique) {
                                _this.checker.errorReporter.simpleError(classDecl, "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);
                            }
                        } else {
                            names.add(sym.name, sym);
                        }
                    }, null);
                }
                if (type.extendsList) {
                    var len = type.extendsList.length;
                    for(var i = 0; i < len; i++) {
                        if (!(type.extendsList[i].symbol.flags & TypeScript.SymbolFlags.RecursivelyReferenced)) {
                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.checkBaseTypeMemberInheritance = function (derivedType, derivedTypeDecl) {
            var _this = this;
            var instanceType = derivedType.getInstanceType();
            if (!instanceType.extendsList) {
                return;
            }
            var len = instanceType.extendsList.length;
            if (len > 0) {
                var names = new TypeScript.StringHashTable();
                if (instanceType.isClassInstance()) {
                    for(var i = 0; i < len; i++) {
                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], derivedTypeDecl, i > 0);
                    }
                }
                if (instanceType.members) {
                    instanceType.members.publicMembers.map(function (key, s, c) {
                        var sym = s;
                        for(var j = 0; j < len; j++) {
                            var base = instanceType.extendsList[j];
                            if (!base.memberScope) {
                                _this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type '" + base.symbol.name + "' lacks an implementation.");
                            } else {
                                var bSym = base.memberScope.find(sym.name, false, false);
                                if (bSym) {
                                    var aType = sym.getType();
                                    var bType = bSym.getType();
                                    if (!(_this.checker.sourceIsSubtypeOfTarget(aType, bType))) {
                                        _this.checker.errorReporter.simpleErrorFromSym(sym, "Type of overridden member '" + sym.name + "' is not subtype of original member defined by type '" + bSym.container.name + "'");
                                    } else if ((sym.kind() === TypeScript.SymbolKind.Type) && (bSym.kind() === TypeScript.SymbolKind.Field)) {
                                        _this.checker.errorReporter.simpleErrorFromSym(sym, "Cannot override field '" + sym.name + "' with method");
                                    }
                                }
                            }
                        }
                    }, null);
                }
            }
        };
        TypeFlow.prototype.typeCheckClass = function (classDecl) {
            var typeSymbol = classDecl.type.symbol;
            if (typeSymbol.typeCheckStatus === TypeScript.TypeCheckStatus.Finished) {
                return classDecl;
            } else if (typeSymbol.typeCheckStatus === TypeScript.TypeCheckStatus.Started) {
                return classDecl;
            } else {
                typeSymbol.typeCheckStatus = TypeScript.TypeCheckStatus.Started;
                this.checker.addStartedPTO(typeSymbol);
            }
            var prevScope = this.scope;
            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var classType = classDecl.type;
            this.typeCheckBases(classType.instanceType);
            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);
            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);
            var prevThisType = this.thisType;
            this.thisType = classType.instanceType;
            this.scope = classType.instanceType.containedScope;
            if (classDecl.constructorDecl) {
                this.scope = classType.instanceType.constructorScope;
                var ssb = this.scope;
                var funcTable = ssb.valueMembers.allMembers;
                this.addConstructorLocalArgs(classDecl.constructorDecl, funcTable, true);
            }
            this.typeCheck(classDecl.members);
            typeSymbol.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;
            this.checkBaseTypeMemberInheritance(classType, classDecl);
            this.checkMembersImplementInterfaces(classType);
            this.typeCheckOverloadSignatures(classType, classDecl);
            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);
            if (!classDecl.constructorDecl) {
                if (classDecl.extendsList && classDecl.extendsList.members.length && classDecl.extendsList.members[0].type && classDecl.extendsList.members[0].type.symbol.type.isClass()) {
                    TypeScript.cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);
                }
            }
            this.thisType = prevThisType;
            this.thisClassNode = svClassNode;
            this.scope = prevScope;
            return classDecl;
        };
        TypeFlow.prototype.typeCheckOverloadSignatures = function (type, ast) {
            if (type.call) {
                type.call.typeCheck(this.checker, ast, type.construct !== null);
            }
            if (type.construct) {
                type.construct.typeCheck(this.checker, ast, false);
            }
            if (type.index) {
                type.index.typeCheck(this.checker, ast, false);
            }
        };
        TypeFlow.prototype.typeCheckInterface = function (interfaceDecl) {
            this.typeCheckBases(interfaceDecl.type);
            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);
            this.typeCheck(interfaceDecl.members);
            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);
            if (interfaceDecl.extendsList) {
                for(var i = 0; i < interfaceDecl.extendsList.members.length; i++) {
                    if (interfaceDecl.extendsList.members[i].type.call) {
                        if (interfaceDecl.type.call) {
                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);
                        } else {
                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.construct) {
                        if (interfaceDecl.type.construct) {
                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);
                        } else {
                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.index) {
                        if (interfaceDecl.type.index) {
                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);
                        } else {
                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;
                        }
                    }
                }
            }
            return interfaceDecl;
        };
        TypeFlow.prototype.typeCheckImportDecl = function (importDecl) {
            var mod = importDecl.alias.type;
            var sym = null;
            var prevInImportTC = this.inImportTypeCheck;
            this.inImportTypeCheck = true;
            this.typeCheck(importDecl.alias);
            mod = importDecl.alias.type;
            if (mod === null) {
                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias '" + importDecl.id.actualText + "'");
                mod = this.checker.anyType;
                (importDecl.id.sym).type = mod;
            }
            importDecl.id.type = mod;
            sym = mod.symbol;
            if (!mod.isModuleType()) {
                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");
            } else {
                sym.type = mod;
                if (this.checker.typeFlow.currentScript && this.checker.typeFlow.currentScript.topLevelMod && this.checker.typeFlow.currentScript.topLevelMod.mod) {
                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);
                }
                (importDecl.id.sym).type = mod;
                if (mod.symbol && mod.symbol.declAST) {
                }
            }
            this.inImportTypeCheck = prevInImportTC;
            return importDecl;
        };
        TypeFlow.prototype.typeCheckModule = function (moduleDecl) {
            if (!moduleDecl.mod) {
                return moduleDecl;
            }
            var mod = moduleDecl.mod;
            var sym = null;
            var prevScope = this.scope;
            var prevThisType = this.thisType;
            var prevCurrentModDecl = this.checker.currentModDecl;
            this.checker.currentModDecl = moduleDecl;
            this.thisType = null;
            this.scope = mod.containedScope;
            this.typeCheck(moduleDecl.members);
            sym = mod.symbol;
            this.checker.currentModDecl = prevCurrentModDecl;
            this.thisType = prevThisType;
            this.scope = prevScope;
            moduleDecl.type = mod;
            if (sym) {
                sym.typeCheckStatus = TypeScript.TypeCheckStatus.Finished;
            }
            return moduleDecl;
        };
        TypeFlow.prototype.typeCheckFor = function (forStmt) {
            forStmt.init = this.typeCheck(forStmt.init);
            this.nestingLevel++;
            forStmt.cond = this.typeCheck(forStmt.cond);
            this.typeCheckCondExpr(forStmt.cond);
            forStmt.incr = this.typeCheck(forStmt.incr);
            this.nestingLevel--;
            forStmt.body = this.typeCheck(forStmt.body);
            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");
            forStmt.type = this.voidType;
            return forStmt;
        };
        TypeFlow.prototype.typeCheckWith = function (withStmt) {
            if (this.checker.errorsOnWith) {
                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a 'with' block will be typed as 'any'");
            }
            withStmt.expr = this.typeCheck(withStmt.expr);
            this.checker.inWith = true;
            withStmt.body = this.typeCheck(withStmt.body);
            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");
            this.checker.inWith = false;
            return withStmt;
        };
        TypeFlow.prototype.typeCheckForIn = function (forInStmt) {
            forInStmt.obj = this.typeCheck(forInStmt.obj);
            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);
            if (forInStmt.lval.nodeType === TypeScript.NodeType.VariableDeclarator) {
                var varDecl = forInStmt.lval;
                if (varDecl.typeExpr) {
                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");
                }
                if (varDecl.sym) {
                    varDecl.sym.setType(this.checker.stringType);
                }
            }
            forInStmt.body = this.typeCheck(forInStmt.body);
            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");
            return forInStmt;
        };
        TypeFlow.prototype.typeCheckWhile = function (whileStmt) {
            whileStmt.cond = this.typeCheck(whileStmt.cond);
            this.typeCheckCondExpr(whileStmt.cond);
            whileStmt.body = this.typeCheck(whileStmt.body);
            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");
            whileStmt.type = this.voidType;
            return whileStmt;
        };
        TypeFlow.prototype.typeCheckDo = function (doStatement) {
            doStatement.cond = this.typeCheck(doStatement.cond);
            this.typeCheckCondExpr(doStatement.cond);
            doStatement.body = this.typeCheck(doStatement.body);
            this.typeCheckCompoundStmtBlock(doStatement.body, "do while statement");
            doStatement.type = this.voidType;
            return doStatement;
        };
        TypeFlow.prototype.typeCheckCondExpr = function (cond) {
            if (this.checker.styleSettings.assignmentInCond) {
                if ((cond !== null) && (cond.nodeType >= TypeScript.NodeType.AssignmentExpression) && (cond.nodeType <= TypeScript.NodeType.UnsignedRightShiftAssignmentExpression)) {
                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");
                }
            }
        };
        TypeFlow.prototype.typeCheckCompoundStmtBlock = function (stmts, stmtType) {
            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {
                if (stmts.nodeType !== TypeScript.NodeType.Block) {
                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");
                }
            }
        };
        TypeFlow.prototype.typeCheckIf = function (ifStmt) {
            ifStmt.cond = this.typeCheck(ifStmt.cond);
            this.typeCheckCondExpr(ifStmt.cond);
            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);
            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);
            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");
            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");
            ifStmt.type = this.voidType;
            return ifStmt;
        };
        TypeFlow.prototype.typeFromAccessorFuncDecl = function (funcDecl) {
            if (!funcDecl.isAccessor()) {
                return null;
            }
            if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor)) {
                return funcDecl.type.call.signatures[0].returnType.type;
            } else {
                return funcDecl.type.call.signatures[0].parameters[0].getType();
            }
        };
        TypeFlow.prototype.typeCheckObjectLit = function (objectLit) {
            var resultType = new TypeScript.Type();
            resultType.symbol = new TypeScript.TypeSymbol(this.checker.anon, objectLit.minChar, objectLit.limChar - objectLit.minChar, null, resultType, this.compilationSettings.optimizeModuleCodeGen);
            resultType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            resultType.memberScope = new TypeScript.SymbolTableScope(resultType.members, null, null, null, null);
            var aggScope = new TypeScript.SymbolAggregateScope(resultType.symbol);
            aggScope.addParentScope(resultType.memberScope);
            aggScope.addParentScope(this.scope);
            resultType.containedScope = aggScope;
            var memberDecls = objectLit.operand;
            var prevThisType = this.thisType;
            var acceptTargetType = false;
            var targetType = null;
            if (this.checker.hasTargetType()) {
                targetType = this.checker.getTargetTypeContext().contextualType;
                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {
                    if (targetType.symbol.declAST) {
                        this.typeCheck(targetType.symbol.declAST);
                    }
                }
                acceptTargetType = true;
            }
            if (memberDecls) {
                for(var i = 0, len = memberDecls.members.length; i < len; i++) {
                    var binex = memberDecls.members[i];
                    var id = binex.operand1;
                    var text;
                    var targetMember = null;
                    var fieldSymbol = null;
                    if (id.nodeType === TypeScript.NodeType.Name) {
                        text = (id).text;
                    } else if (id.nodeType === TypeScript.NodeType.StringLiteral) {
                        var idText = (id).text;
                        text = idText.substring(1, idText.length - 1);
                    } else {
                        this.checker.errorReporter.simpleError(objectLit, "malformed object literal");
                        resultType = this.anyType;
                        break;
                    }
                    if (acceptTargetType && targetType.memberScope) {
                        targetMember = targetType.memberScope.find(text, false, false);
                    }
                    if (binex.operand2.nodeType === TypeScript.NodeType.FunctionDeclaration && (binex.operand2).isAccessor()) {
                        var funcDecl = binex.operand2;
                        var accessorSym = resultType.members.publicMembers.lookup(text);
                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);
                        funcDecl.accessorSymbol = accessorSym;
                        fieldSymbol = accessorSym;
                        if (id.nodeType === TypeScript.NodeType.Name) {
                            (id).sym = accessorSym;
                        }
                    }
                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);
                    if (acceptTargetType && targetMember) {
                        if ((binex.operand2.type === this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) || (binex.operand2.nodeType === TypeScript.NodeType.FunctionDeclaration && (binex.operand2).isAccessor() && this.typeFromAccessorFuncDecl(binex.operand2) === targetMember.getType())) {
                            binex.operand1.type = targetMember.getType();
                        }
                    } else {
                        binex.operand2.type = binex.operand2.type === this.checker.undefinedType ? this.anyType : binex.operand2.type;
                    }
                    if (fieldSymbol === null) {
                        var memberType = binex.operand2.type;
                        var field = new TypeScript.ValueLocation();
                        fieldSymbol = new TypeScript.FieldSymbol(text, id.minChar, null, true, field);
                        fieldSymbol.flags |= TypeScript.SymbolFlags.Property;
                        field.symbol = fieldSymbol;
                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        field.typeLink = new TypeScript.TypeLink();
                        field.typeLink.type = memberType;
                        resultType.members.publicMembers.add(text, fieldSymbol);
                    }
                    fieldSymbol.isObjectLitField = true;
                }
            }
            this.thisType = prevThisType;
            objectLit.type = resultType;
            if (targetType) {
                objectLit.targetType = targetType;
            }
        };
        TypeFlow.prototype.typeCheckArrayLit = function (arrayLit) {
            var elements = arrayLit.operand;
            var elementType = this.anyType;
            var targetElementType = null;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            comparisonInfo.onlyCaptureFirstError = true;
            if (this.checker.hasTargetType()) {
                var targetType = this.checker.getTargetTypeContext().contextualType;
                if (targetType.elementType) {
                    targetElementType = targetType.elementType;
                }
            }
            if (elements) {
                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;
                this.inArrayElementTypeCheck = true;
                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType !== null, elements);
                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;
                elementType = elements.members[0].type;
                var collection = {
                    getLength: function () {
                        return elements.members.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        elements.members[index].type = type;
                    },
                    getTypeAtIndex: function (index) {
                        return elements.members[index].type;
                    }
                };
                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);
                if (elementType === this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType === this.nullType)) {
                    elementType = this.anyType;
                }
            }
            if (!elementType) {
                var emsg = "Incompatible types in array literal expression";
                if (!comparisonInfo.message) {
                    this.checker.errorReporter.simpleError(arrayLit, emsg);
                } else {
                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);
                }
                elementType = this.anyType;
            } else if (targetElementType) {
                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {
                    elementType = targetElementType;
                }
            }
            arrayLit.type = this.checker.makeArrayType(elementType);
        };
        TypeFlow.prototype.checkForVoidConstructor = function (type, ast) {
            if (type && type.construct && type.construct.signatures.length > 0) {
                for(var i = 0; i < type.construct.signatures.length; i++) {
                    if (type.construct.signatures[i].returnType.type === this.checker.voidType) {
                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of 'void'");
                        break;
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckReturn = function (returnStmt) {
            if (this.thisFnc) {
                var targetType = null;
                if (this.checker.hasTargetType()) {
                    var tcContext = this.checker.getTargetTypeContext();
                    var accessorType = tcContext.targetAccessorType;
                    if (accessorType) {
                        targetType = accessorType;
                    } else {
                        var targetSig = this.checker.getTargetTypeContext().targetSig;
                        if (targetSig && targetSig.returnType.type !== this.voidType) {
                            targetType = targetSig.returnType.type;
                        }
                    }
                }
                if (returnStmt.returnExpression) {
                    if (targetType === null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type !== this.voidType) {
                        targetType = this.thisFnc.returnTypeAnnotation.type;
                    }
                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType !== null, returnStmt.returnExpression);
                    var expectedReturnType = (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : targetType;
                    if (expectedReturnType) {
                        if (expectedReturnType === this.voidType && returnStmt.returnExpression.type !== this.voidType) {
                            this.checker.errorReporter.simpleError(returnStmt, "Return with value expression in void function");
                            returnStmt.type = returnStmt.returnExpression.type;
                        } else {
                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);
                            returnStmt.type = expectedReturnType;
                        }
                    } else {
                        if (targetType) {
                            if (returnStmt.returnExpression.type !== this.voidType) {
                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);
                            } else {
                                returnStmt.returnExpression.type = targetType;
                            }
                        }
                        returnStmt.type = returnStmt.returnExpression.type;
                    }
                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;
                } else {
                    returnStmt.type = targetType === null ? this.checker.voidType : targetType;
                }
            }
            return returnStmt;
        };
        TypeFlow.prototype.typeCheckInstOf = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            if (!((binex.operand1.type === this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) && (binex.operand2.type === this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {
                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");
            }
            binex.type = this.booleanType;
            return binex;
        };
        TypeFlow.prototype.typeCheckCommaOperator = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        };
        TypeFlow.prototype.typeCheckLogOr = function (binex) {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if (leftType === this.checker.anyType || rightType === this.checker.anyType) {
                binex.type = this.checker.anyType;
            } else if (leftType === this.checker.booleanType) {
                if (rightType === this.checker.booleanType) {
                    binex.type = this.checker.booleanType;
                } else {
                    binex.type = this.checker.anyType;
                }
            } else if (leftType === this.checker.numberType) {
                if (rightType === this.checker.numberType) {
                    binex.type = this.checker.numberType;
                } else {
                    binex.type = this.checker.anyType;
                }
            } else if (leftType === this.checker.stringType) {
                if (rightType === this.checker.stringType) {
                    binex.type = this.checker.stringType;
                } else {
                    binex.type = this.checker.anyType;
                }
            } else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    binex.type = rightType;
                } else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    binex.type = leftType;
                } else {
                    binex.type = this.checker.anyType;
                }
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckLogAnd = function (binex) {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        };
        TypeFlow.prototype.tryAddCandidates = function (signature, actuals, exactCandidates, conversionCandidates, comparisonInfo) {
            var lowerBound = signature.nonOptionalParameterCount;
            var upperBound = signature.parameters.length;
            var formalLen = lowerBound;
            var acceptable = false;
            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);
                acceptable = true;
            }
            var repeatType = null;
            if (acceptable || signature.hasVariableArgList) {
                if (signature.hasVariableArgList) {
                    formalLen -= 1;
                    repeatType = (signature.parameters[formalLen]).parameter.typeLink.type;
                    repeatType = repeatType.elementType;
                    acceptable = actuals.length >= formalLen;
                }
                var len = actuals.length;
                var exact = acceptable;
                var convert = acceptable;
                for(var i = 0; i < len; i++) {
                    var typeA;
                    if (i < formalLen) {
                        typeA = (signature.parameters[i]).parameter.typeLink.type;
                    } else {
                        typeA = repeatType;
                    }
                    var typeB = actuals[i];
                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {
                        exact = false;
                    }
                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {
                        convert = false;
                    }
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                } else if (convert && (exactCandidates.length === 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        };
        TypeFlow.prototype.resolveOverload = function (application, group) {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate = null;
            var hasOverloads = group.signatures.length > 1;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var args = null;
            var target = null;
            if (application.nodeType === TypeScript.NodeType.InvocationExpression || application.nodeType === TypeScript.NodeType.ObjectCreationExpression) {
                var callEx = application;
                args = callEx.arguments;
                target = callEx.target;
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    for(var i = 0; i < len; i++) {
                        actuals[i] = callEx.arguments.members[i].type;
                    }
                }
            } else if (application.nodeType === TypeScript.NodeType.ElementAccessExpression) {
                var binExp = application;
                target = binExp.operand1;
                args = new TypeScript.ASTList();
                args.members[0] = binExp.operand2;
                actuals[0] = binExp.operand2.type;
            }
            for(var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {
                var signature = group.signatures[j];
                if (hasOverloads && signature === group.definitionSignature && !this.checker.canCallDefinitionSignature) {
                    continue;
                }
                if (!signature.returnType.type && signature.declAST && (signature.typeCheckStatus !== TypeScript.TypeCheckStatus.Finished)) {
                    this.typeCheckFunction(signature.declAST);
                }
                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);
            }
            var apparentTarget = target.nodeType === TypeScript.NodeType.MemberAccessExpression ? (target).operand2 : target;
            if (exactCandidates.length === 0) {
                var candidateInfo;
                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);
                if (applicableCandidates.length > 0) {
                    candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(apparentTarget, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                } else {
                    var emsg = "Supplied parameters do not match any signature of call target";
                    if (comparisonInfo.message) {
                        this.checker.errorReporter.simpleError(apparentTarget, emsg + ":\n\t" + comparisonInfo.message);
                    } else {
                        this.checker.errorReporter.simpleError(apparentTarget, emsg);
                    }
                }
            } else {
                if (exactCandidates.length > 1) {
                    var applicableSigs = [];
                    for(var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = {
                            signature: exactCandidates[i],
                            hadProvisionalErrors: false
                        };
                    }
                    candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(apparentTarget, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                } else {
                    candidate = exactCandidates[0];
                }
            }
            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        };
        TypeFlow.prototype.typeCheckNew = function (ast) {
            var callEx = ast;
            var signature;
            callEx.target = this.typeCheck(callEx.target);
            var target = callEx.target;
            if (target.type.construct || target.type.call) {
                this.preTypeCheckCallArgs(callEx.arguments);
            } else {
                callEx.arguments = this.typeCheck(callEx.arguments);
            }
            if (target.type === this.anyType) {
                callEx.type = this.anyType;
                callEx.arguments = this.typeCheck(callEx.arguments);
            } else {
                if (target.type.construct) {
                    signature = this.resolveOverload(callEx, target.type.construct);
                    if (signature === null) {
                        callEx.type = this.anyType;
                    } else if (signature.returnType.type === this.voidType) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    } else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                } else if (target.type.call) {
                    signature = this.resolveOverload(callEx, target.type.call);
                    if (signature === null) {
                        callEx.type = this.anyType;
                    } else if ((signature.returnType.type === this.voidType) || (signature.returnType.type === this.anyType)) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    } else {
                        this.checker.errorReporter.simpleError(callEx.target, "new expression only valid on constructors");
                    }
                } else if (target.type.elementType) {
                    callEx.type = target.type;
                } else {
                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    callEx.type = this.anyType;
                }
            }
            this.postTypeCheckCallArgs(callEx);
            return callEx;
        };
        TypeFlow.prototype.preTypeCheckCallArgs = function (args) {
            if (!args) {
                return;
            }
            for(var i = 0; i < args.members.length; i++) {
                switch(args.members[i].nodeType) {
                    case TypeScript.NodeType.FunctionDeclaration:
                    case TypeScript.NodeType.ObjectLiteralExpression:
                    case TypeScript.NodeType.ArrayLiteralExpression:
                        continue;
                    default:
                        this.typeCheck(args.members[i]);
                        break;
                }
            }
        };
        TypeFlow.prototype.postTypeCheckCallArgs = function (callEx) {
            var acceptedTargetType = false;
            if (callEx.target && callEx.target.type && callEx.signature && callEx.arguments) {
                var sig = callEx.signature;
                if (sig && callEx.arguments.members.length >= sig.nonOptionalParameterCount) {
                    acceptedTargetType = true;
                    var targetType = null;
                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;
                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength;
                    for(var i = 0; i < nonVarArgActualParamLength; i++) {
                        targetType = sig.parameters[i].getType();
                        switch(callEx.arguments.members[i].nodeType) {
                            case TypeScript.NodeType.FunctionDeclaration:
                            case TypeScript.NodeType.ObjectLiteralExpression:
                            case TypeScript.NodeType.ArrayLiteralExpression:
                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), sig.parameters[i].declAST.nodeType !== TypeScript.NodeType.ParenthesizedExpression, callEx.arguments.members[i]);
                                break;
                        }
                    }
                    if (sig.hasVariableArgList) {
                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;
                        targetType = sig.parameters[varArgParamIndex].getType();
                        if (targetType) {
                            targetType = targetType.elementType;
                        }
                        var isParenthesized = sig.parameters[varArgParamIndex].declAST.nodeType !== TypeScript.NodeType.ParenthesizedExpression;
                        for(var i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {
                            switch(callEx.arguments.members[i].nodeType) {
                                case TypeScript.NodeType.FunctionDeclaration:
                                case TypeScript.NodeType.ObjectLiteralExpression:
                                case TypeScript.NodeType.ArrayLiteralExpression:
                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);
                                    break;
                            }
                        }
                    }
                }
            }
            if (!acceptedTargetType && callEx.arguments) {
                this.checker.killCurrentContextualType();
                for(var i = 0; i < callEx.arguments.members.length; i++) {
                    switch(callEx.arguments.members[i].nodeType) {
                        case TypeScript.NodeType.FunctionDeclaration:
                        case TypeScript.NodeType.ObjectLiteralExpression:
                        case TypeScript.NodeType.ArrayLiteralExpression:
                            this.typeCheck(callEx.arguments.members[i]);
                            break;
                        default:
                            continue;
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckCall = function (ast) {
            var callEx = ast;
            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType === TypeScript.NodeType.ObjectCreationExpression)) {
            } else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType === TypeScript.NodeType.InvocationExpression)) {
                if ((callEx.target.nodeType === TypeScript.NodeType.Name) && ((callEx.target).text === "eval")) {
                    this.checker.errorReporter.styleError(callEx, "eval not permitted");
                }
            }
            var prevInSuperCall = this.inSuperCall;
            if (callEx.target.nodeType === TypeScript.NodeType.SuperExpression) {
                this.inSuperCall = true;
            }
            callEx.target = this.typeCheck(callEx.target);
            this.preTypeCheckCallArgs(callEx.arguments);
            var target = callEx.target;
            var signature;
            if ((target.type === null) || (target.type === this.anyType) || (this.functionInterfaceType && target.type === this.functionInterfaceType)) {
                callEx.type = this.anyType;
            } else {
                var fnType = target.type;
                if (fnType.call) {
                    signature = this.resolveOverload(callEx, fnType.call);
                    if (signature === null) {
                        callEx.type = this.anyType;
                    } else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                } else {
                    if (callEx.target.nodeType === TypeScript.NodeType.SuperExpression && this.thisFnc && this.thisFnc.isConstructor && TypeScript.hasFlag(this.thisFnc.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod)) {
                        signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;
                        if (signature === null) {
                            callEx.type = this.anyType;
                        } else {
                            callEx.type = signature.returnType.type;
                            callEx.signature = signature;
                        }
                    } else {
                        callEx.type = this.anyType;
                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    }
                }
            }
            this.postTypeCheckCallArgs(callEx);
            this.inSuperCall = prevInSuperCall;
            return callEx;
        };
        TypeFlow.prototype.assignScopes = function (ast) {
            var script = ast;
            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);
            var context = new TypeScript.AssignScopeContext(globalChain, this, [
                this.checker.currentModDecl
            ]);
            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.preAssignScopes, TypeScript.postAssignScopes, null, context);
        };
        return TypeFlow;
    })();
    TypeScript.TypeFlow = TypeFlow;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Primitive) {
        Primitive._map = [];
        Primitive.None = 0;
        Primitive.Void = 1;
        Primitive.Double = 2;
        Primitive.String = 4;
        Primitive.Boolean = 8;
        Primitive.Any = 16;
        Primitive.Null = 32;
        Primitive.Undefined = 64;
    })(TypeScript.Primitive || (TypeScript.Primitive = {}));
    var Primitive = TypeScript.Primitive;
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () {
            return false;
        };
        MemberName.prototype.isArray = function () {
            return false;
        };
        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };
        MemberName.memberNameToString = function memberNameToString(memberName) {
            var result = memberName.prefix;
            if (memberName.isString()) {
                result += (memberName).text;
            } else {
                var ar = memberName;
                for(var index = 0; index < ar.entries.length; index++) {
                    result += MemberName.memberNameToString(ar.entries[index]);
                    result += ar.delim;
                }
            }
            result += memberName.suffix;
            return result;
        };
        MemberName.create = function create(arg1, arg2, arg3) {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            } else {
                var result = new MemberNameArray();
                if (arg2) {
                    result.prefix = arg2;
                }
                if (arg3) {
                    result.suffix = arg3;
                }
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    })();
    TypeScript.MemberName = MemberName;    
    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
            _super.call(this);
            this.text = text;
        }
        MemberNameString.prototype.isString = function () {
            return true;
        };
        return MemberNameString;
    })(MemberName);
    TypeScript.MemberNameString = MemberNameString;    
    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            _super.call(this);
            this.delim = "";
            this.entries = [];
        }
        MemberNameArray.prototype.isArray = function () {
            return true;
        };
        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };
        MemberNameArray.prototype.addAll = function (entries) {
            for(var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    })(MemberName);
    TypeScript.MemberNameArray = MemberNameArray;    
    var currentTypeID = -1;
    var Type = (function () {
        function Type() {
            this.typeID = currentTypeID++;
            this.construct = null;
            this.call = null;
            this.index = null;
            this.passTypeCreated = TypeScript.CompilerDiagnostics.analysisPass;
            this.primitiveTypeClass = Primitive.None;
            this.typeFlags = TypeScript.TypeFlags.None;
        }
        Type.prototype.baseClass = function () {
            if (this.extendsList && (this.extendsList.length > 0)) {
                return this.extendsList[0];
            } else {
                return null;
            }
        };
        Type.prototype.getArrayBase = function (arrInstType, checker) {
            return this.arrayCache.specialize(arrInstType, checker);
        };
        Type.prototype.isClass = function () {
            return this.instanceType != null;
        };
        Type.prototype.isArray = function () {
            return this.elementType != null;
        };
        Type.prototype.isClassInstance = function () {
            return this.symbol && !this.elementType && (this.symbol).type.isClass();
        };
        Type.prototype.getInstanceType = function () {
            if (this.isClass()) {
                return this.instanceType;
            } else {
                return this;
            }
        };
        Type.prototype.hasImplementation = function () {
            return TypeScript.hasFlag(this.typeFlags, TypeScript.TypeFlags.HasImplementation);
        };
        Type.prototype.setHasImplementation = function () {
            this.typeFlags |= TypeScript.TypeFlags.HasImplementation;
        };
        Type.prototype.isDouble = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.Double);
        };
        Type.prototype.isString = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.String);
        };
        Type.prototype.isBoolean = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.Boolean);
        };
        Type.prototype.isNull = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, Primitive.Null);
        };
        Type.prototype.getTypeName = function () {
            return this.getMemberTypeName("", true, false, null);
        };
        Type.prototype.getScopedTypeName = function (scope, getPrettyTypeName) {
            return this.getMemberTypeName("", true, false, scope, getPrettyTypeName);
        };
        Type.prototype.getScopedTypeNameEx = function (scope, getPrettyTypeName) {
            return this.getMemberTypeNameEx("", true, false, scope, getPrettyTypeName);
        };
        Type.prototype.callCount = function () {
            var total = 0;
            if (this.call) {
                total += this.call.signatures.length;
            }
            if (this.construct) {
                total += this.construct.signatures.length;
            }
            if (this.index) {
                total += this.index.signatures.length;
            }
            return total;
        };
        Type.prototype.getMemberTypeName = function (prefix, topLevel, isElementType, scope, getPrettyTypeName) {
            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope, getPrettyTypeName);
            return memberName.toString();
        };
        Type.prototype.getMemberTypeNameEx = function (prefix, topLevel, isElementType, scope, getPrettyTypeName) {
            if (this.elementType) {
                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");
            } else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" && (((this.call === null) && (this.construct === null) && (this.index === null)) || (TypeScript.hasFlag(this.typeFlags, TypeScript.TypeFlags.BuildingName)) || (this.members && (!this.isClass())))) {
                var tn = this.symbol.scopeRelativeName(scope);
                return MemberName.create(tn === "null" ? "any" : tn);
            } else {
                if (this.members || this.call || this.construct) {
                    if (TypeScript.hasFlag(this.typeFlags, TypeScript.TypeFlags.BuildingName)) {
                        return MemberName.create("this");
                    }
                    this.typeFlags |= TypeScript.TypeFlags.BuildingName;
                    var builder = "";
                    var allMemberNames = new MemberNameArray();
                    var curlies = isElementType || this.index != null;
                    var memCount = 0;
                    var delim = "; ";
                    if (this.members) {
                        this.members.allMembers.map(function (key, s, unused) {
                            var sym = s;
                            if (!TypeScript.hasFlag(sym.flags, TypeScript.SymbolFlags.BuiltIn)) {
                                var typeNameMember = sym.getTypeNameEx(scope);
                                if (typeNameMember.isArray() && (typeNameMember).delim === delim) {
                                    allMemberNames.addAll((typeNameMember).entries);
                                } else {
                                    allMemberNames.add(typeNameMember);
                                }
                                memCount++;
                                curlies = true;
                            }
                        }, null);
                    }
                    var signatureCount = this.callCount();
                    var j;
                    var len = 0;
                    var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.call && this.call.signatures.length > 1 && !this.members && !this.construct;
                    var shortform = !curlies && (signatureCount === 1 || getPrettyFunctionOverload) && topLevel;
                    if (this.call) {
                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope, getPrettyFunctionOverload));
                    }
                    if (this.construct) {
                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));
                    }
                    if (this.index) {
                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));
                    }
                    if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                        allMemberNames.prefix = "{ ";
                        allMemberNames.suffix = "}";
                        allMemberNames.delim = delim;
                    } else if (allMemberNames.entries.length > 1) {
                        allMemberNames.delim = delim;
                    }
                    this.typeFlags &= (~TypeScript.TypeFlags.BuildingName);
                    if ((signatureCount === 0) && (memCount === 0)) {
                        return MemberName.create("{}");
                    } else {
                        return allMemberNames;
                    }
                } else {
                    return MemberName.create("{}");
                }
            }
        };
        Type.prototype.checkDecl = function (checker) {
            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST) {
                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);
                }
            }
        };
        Type.prototype.getMemberScope = function (flow) {
            if (this === flow.anyType) {
                return null;
            } else if (this.isDouble()) {
                if (flow.numberInterfaceType) {
                    return flow.numberInterfaceType.memberScope;
                } else {
                    return null;
                }
            } else if (this.isBoolean()) {
                if (flow.booleanInterfaceType) {
                    return flow.booleanInterfaceType.memberScope;
                } else {
                    return null;
                }
            } else if (this === flow.stringType) {
                if (flow.stringInterfaceType) {
                    return flow.stringInterfaceType.memberScope;
                } else {
                    return null;
                }
            } else if (this.elementType) {
                if (flow.arrayInterfaceType) {
                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);
                    return arrInstType.memberScope;
                } else {
                    return null;
                }
            } else {
                return this.memberScope;
            }
        };
        Type.prototype.isReferenceType = function () {
            return this.members || this.extendsList || this.construct || this.call || this.index || this.elementType;
        };
        Type.prototype.specializeType = function (pattern, replacement, checker, membersOnly) {
            if (pattern === this) {
                return replacement;
            }
            var result = this;
            if (membersOnly) {
                if (this.isReferenceType()) {
                    result = new Type();
                    if (this.members) {
                        result.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                        this.members.publicMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPublicMember(bSym.name, bSym);
                        }, null);
                        this.members.privateMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    if (this.ambientMembers) {
                        result.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                        this.ambientMembers.publicMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPublicMember(bSym.name, bSym);
                        }, null);
                        this.ambientMembers.privateMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    result.containedScope = checker.scopeOf(result);
                    result.memberScope = result.containedScope;
                }
            } else {
                if (this.elementType) {
                    if (this.elementType === pattern) {
                        result = checker.makeArrayType(replacement);
                    } else {
                        if (this.elementType.elementType === pattern) {
                            result = checker.makeArrayType(checker.makeArrayType(replacement));
                        }
                    }
                } else if (this.call) {
                    result = new Type();
                    result.call = this.call.specializeType(pattern, replacement, checker);
                }
            }
            return result;
        };
        Type.prototype.hasBase = function (baseType) {
            if (baseType === this) {
                return true;
            } else {
                if (this.extendsList) {
                    for(var i = 0, len = this.extendsList.length; i < len; i++) {
                        if (this.extendsList[i].hasBase(baseType)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        Type.prototype.mergeOrdered = function (b, checker, acceptVoid, comparisonInfo) {
            if ((this === checker.anyType) || (b === checker.anyType)) {
                return checker.anyType;
            } else if (this === b) {
                return this;
            } else if ((b === checker.nullType) && this != checker.nullType) {
                return this;
            } else if ((this === checker.nullType) && (b != checker.nullType)) {
                return b;
            } else if (acceptVoid && (b === checker.voidType) && this != checker.voidType) {
                return this;
            } else if (acceptVoid && (this === checker.voidType) && (b != checker.voidType)) {
                return b;
            } else if ((b === checker.undefinedType) && this != checker.undefinedType) {
                return this;
            } else if ((this === checker.undefinedType) && (b != checker.undefinedType)) {
                return b;
            } else if (this.elementType && b.elementType) {
                if (this.elementType === b.elementType) {
                    return this;
                } else {
                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);
                    if (mergedET === null) {
                        return checker.makeArrayType(checker.anyType);
                    } else {
                        return checker.makeArrayType(mergedET);
                    }
                }
            } else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {
                return b;
            } else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {
                return this;
            } else {
                return null;
            }
        };
        Type.prototype.isModuleType = function () {
            return false;
        };
        Type.prototype.hasMembers = function () {
            return this.members != null;
        };
        Type.prototype.getAllEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getAllAmbientEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getPublicEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getpublicAmbientEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getDocComments = function () {
            if (this.elementType || !this.symbol) {
                return [];
            }
            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    return (this.symbol.declAST).classDecl.getDocComments();
                } else {
                    return this.symbol.getDocComments();
                }
            }
            if (this.symbol.name && this.symbol.name != "_anonymous" && (((this.call === null) && (this.construct === null) && (this.index === null)) || this.members)) {
                return this.symbol.getDocComments();
            }
            return [];
        };
        return Type;
    })();
    TypeScript.Type = Type;    
    var ModuleType = (function (_super) {
        __extends(ModuleType, _super);
        function ModuleType(enclosedTypes, ambientEnclosedTypes) {
            _super.call(this);
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.importedModules = [];
        }
        ModuleType.prototype.isModuleType = function () {
            return true;
        };
        ModuleType.prototype.hasMembers = function () {
            return this.members != null || this.enclosedTypes != null;
        };
        ModuleType.prototype.getAllEnclosedTypes = function () {
            return this.enclosedTypes;
        };
        ModuleType.prototype.getAllAmbientEnclosedTypes = function () {
            return this.ambientEnclosedTypes;
        };
        ModuleType.prototype.getPublicEnclosedTypes = function () {
            return null;
        };
        ModuleType.prototype.getpublicAmbientEnclosedTypes = function () {
            return null;
        };
        ModuleType.findDynamicModuleNameInHashTable = function findDynamicModuleNameInHashTable(moduleType, members) {
            var moduleName = null;
            members.map(function (key, s, c) {
                if (moduleName === null && !TypeScript.isQuoted(key)) {
                    var symbol = s;
                    var type = symbol.getType();
                    if (type === moduleType) {
                        moduleName = {
                            name: key,
                            symbol: symbol
                        };
                    }
                }
            }, null);
            return moduleName;
        };
        ModuleType.prototype.findDynamicModuleName = function (moduleType) {
            var moduleName = null;
            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);
            if (moduleName === null) {
                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);
            }
            return moduleName;
        };
        return ModuleType;
    })(Type);
    TypeScript.ModuleType = ModuleType;    
    var TypeLink = (function () {
        function TypeLink() {
            this.type = null;
            this.ast = null;
        }
        return TypeLink;
    })();
    TypeScript.TypeLink = TypeLink;    
    function getTypeLink(ast, checker, autoVar) {
        var result = new TypeLink();
        result.ast = ast;
        if ((ast === null) && (autoVar)) {
            result.type = checker.anyType;
        } else {
            result.type = null;
        }
        return result;
    }
    TypeScript.getTypeLink = getTypeLink;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function stripQuotes(str) {
        return str.replace("\"", "").replace("'", "").replace("'", "").replace("\"", "");
    }
    TypeScript.stripQuotes = stripQuotes;
    function isSingleQuoted(str) {
        return str.indexOf("'") != -1;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;
    function isQuoted(str) {
        return str.indexOf("\"") != -1 || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;
    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;
    function swapQuotes(str) {
        if (str.indexOf("\"") != -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        } else {
            str = str.replace("'", "\"");
            str = str.replace("'", "\"");
        }
        return str;
    }
    TypeScript.swapQuotes = swapQuotes;
    function changeToSingleQuote(str) {
        if (str.indexOf("\"") != -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        }
        return str;
    }
    TypeScript.changeToSingleQuote = changeToSingleQuote;
    function switchToForwardSlashes(path) {
        return path.replace(/\\/g, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;
    function trimModName(modName) {
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {
            return modName.substring(0, modName.length - 3);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {
            return modName.substring(0, modName.length - 3);
        }
        return modName;
    }
    TypeScript.trimModName = trimModName;
    function getDeclareFilePath(fname) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;
    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;
    }
    function isJSFile(fname) {
        return isFileOfExtension(fname, ".js");
    }
    TypeScript.isJSFile = isJSFile;
    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;
    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;
    function getPrettyName(modPath, quote, treatAsFileName) {
        if (typeof quote === "undefined") { quote = true; }
        if (typeof treatAsFileName === "undefined") { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;
    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;
    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath) {
        absoluteModPath = switchToForwardSlashes(absoluteModPath);
        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);
        var joinStartIndex = 0;
        for(; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {
                break;
            }
        }
        if (joinStartIndex != 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for(; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] != "") {
                    relativePath = relativePath + "../";
                }
            }
            return relativePath + relativePathComponents.join("/");
        }
        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;
    function quoteBaseName(modPath) {
        var modName = trimModName(stripQuotes(modPath));
        var path = getRootFilePath(modName);
        if (path == "") {
            return modPath;
        } else {
            var components = modName.split(path);
            var fileIndex = components.length > 1 ? 1 : 0;
            return quoteStr(components[fileIndex]);
        }
    }
    TypeScript.quoteBaseName = quoteBaseName;
    function changePathToTS(modPath) {
        return trimModName(stripQuotes(modPath)) + ".ts";
    }
    TypeScript.changePathToTS = changePathToTS;
    function changePathToDTS(modPath) {
        return trimModName(stripQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;
    function isRelative(path) {
        return path.charAt(0) == ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.charAt(0) == "\\" || path.charAt(0) == "/" || (path.indexOf(":\\") != -1) || (path.indexOf(":/") != -1);
    }
    TypeScript.isRooted = isRooted;
    function getRootFilePath(outFname) {
        if (outFname == "") {
            return outFname;
        } else {
            var isPath = outFname.indexOf("/") != -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;
    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;
    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;
    function normalizeURL(url) {
        var hostDomainAndPortRegex = /^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;
        var matches = hostDomainAndPortRegex.exec(url);
        if (matches) {
            var hostDomainAndPort = matches[1];
            var actualPath = matches[3];
            return hostDomainAndPort + normalizePath(actualPath);
        }
        return normalizePath(url);
    }
    TypeScript.normalizeURL = normalizeURL;
    TypeScript.pathNormalizeRegExp = /\//g;
    function normalizePath(path) {
        path = switchToForwardSlashes(path);
        var startedWithSep = path.charAt(0) === "/";
        var parts = this.getPathComponents(path);
        for(var i = 0; i < parts.length; i++) {
            if (parts[i] === "." || parts[i] === "") {
                parts.splice(i, 1);
                i--;
            }
            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {
                parts.splice(i - 1, 2);
                i -= 2;
            }
        }
        return (startedWithSep ? "/" : "") + parts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
    function normalizeImportPath(path) {
        return normalizePath(path);
    }
    TypeScript.normalizeImportPath = normalizeImportPath;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceUnit = (function () {
        function SourceUnit(path, content) {
            this.path = path;
            this.content = content;
            this.referencedFiles = null;
            this.lineStarts = null;
        }
        SourceUnit.prototype.getText = function (start, end) {
            return this.content.substring(start, end);
        };
        SourceUnit.prototype.getLength = function () {
            return this.content.length;
        };
        SourceUnit.prototype.getLineStartPositions = function () {
            if (this.lineStarts === null) {
                this.lineStarts = TypeScript.LineMap.fromString(this.content).lineStarts();
            }
            return this.lineStarts;
        };
        SourceUnit.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
            throw TypeScript.Errors.notYetImplemented();
        };
        return SourceUnit;
    })();
    TypeScript.SourceUnit = SourceUnit;    
    var CompilationEnvironment = (function () {
        function CompilationEnvironment(compilationSettings, ioHost) {
            this.compilationSettings = compilationSettings;
            this.ioHost = ioHost;
            this.code = [];
            this.inputFileNameToOutputFileName = new TypeScript.StringHashTable();
        }
        return CompilationEnvironment;
    })();
    TypeScript.CompilationEnvironment = CompilationEnvironment;    
    var CodeResolver = (function () {
        function CodeResolver(environment) {
            this.environment = environment;
            this.visited = {};
        }
        CodeResolver.prototype.resolveCode = function (referencePath, parentPath, performSearch, resolutionDispatcher) {
            var resolvedFile = {
                content: null,
                path: referencePath
            };
            var ioHost = this.environment.ioHost;
            var isRelativePath = TypeScript.isRelative(referencePath);
            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(referencePath);
            var normalizedPath = isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);
            if (!TypeScript.isTSFile(normalizedPath)) {
                normalizedPath += ".ts";
            }
            normalizedPath = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(normalizedPath));
            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();
            if (!this.visited[absoluteModuleID]) {
                if (isRelativePath || isRootedPath || !performSearch) {
                    try  {
                        TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                        try  {
                            resolvedFile.content = ioHost.readFile(normalizedPath);
                        } catch (err1) {
                            if (TypeScript.isTSFile(normalizedPath)) {
                                normalizedPath = TypeScript.changePathToDTS(normalizedPath);
                                TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                resolvedFile.content = ioHost.readFile(normalizedPath);
                            }
                        }
                        TypeScript.CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);
                        resolvedFile.path = normalizedPath;
                        this.visited[absoluteModuleID] = true;
                    } catch (err4) {
                        TypeScript.CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);
                        return false;
                    }
                } else {
                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                    if (!resolvedFile) {
                        if (TypeScript.isTSFile(normalizedPath)) {
                            normalizedPath = TypeScript.changePathToDTS(normalizedPath);
                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                        }
                    }
                    if (resolvedFile) {
                        resolvedFile.path = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));
                        TypeScript.CompilerDiagnostics.debugPrint(referencePath + " resolved to: " + resolvedFile.path);
                        resolvedFile.content = resolvedFile.content;
                        this.visited[absoluteModuleID] = true;
                    } else {
                        TypeScript.CompilerDiagnostics.debugPrint("Could not find " + referencePath);
                    }
                }
                if (resolvedFile && resolvedFile.content != null) {
                    var rootDir = ioHost.dirName(resolvedFile.path);
                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);
                    var preProcessedFileInfo = TypeScript.preProcessFile(resolvedFile.path, sourceUnit, this.environment.compilationSettings);
                    var resolvedFilePath = ioHost.resolvePath(resolvedFile.path);
                    var resolutionResult;
                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;
                    for(var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {
                        var fileReference = preProcessedFileInfo.referencedFiles[i];
                        normalizedPath = TypeScript.isRooted(fileReference.path) ? fileReference.path : rootDir + "/" + fileReference.path;
                        normalizedPath = ioHost.resolvePath(normalizedPath);
                        if (resolvedFilePath == normalizedPath) {
                            resolutionDispatcher.postResolutionError(normalizedPath, fileReference, "Incorrect reference: File contains reference to itself.");
                            continue;
                        }
                        resolutionResult = this.resolveCode(fileReference.path, rootDir, false, resolutionDispatcher);
                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileReference, "Incorrect reference: referenced file: \"" + fileReference.path + "\" cannot be resolved.");
                        }
                    }
                    for(var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {
                        var fileImport = preProcessedFileInfo.importedFiles[i];
                        resolutionResult = this.resolveCode(fileImport.path, rootDir, true, resolutionDispatcher);
                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileImport, "Incorrect reference: imported file: \"" + fileImport.path + "\" cannot be resolved.");
                        }
                    }
                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);
                }
            }
            return true;
        };
        return CodeResolver;
    })();
    TypeScript.CodeResolver = CodeResolver;    
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() { }
        ArrayUtilities.isArray = function isArray(value) {
            return Object.prototype.toString.apply(value, []) === '[object Array]';
        };
        ArrayUtilities.sequenceEquals = function sequenceEquals(array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }
            if (array1 === null || array2 === null) {
                return false;
            }
            if (array1.length !== array2.length) {
                return false;
            }
            for(var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.contains = function contains(array, value) {
            for(var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
            return false;
        };
        ArrayUtilities.groupBy = function groupBy(array, func) {
            var result = {};
            for(var i = 0, n = array.length; i < n; i++) {
                var v = array[i];
                var k = func(v);
                var list = result[k] || [];
                list.push(v);
                result[k] = list;
            }
            return result;
        };
        ArrayUtilities.min = function min(array, func) {
            var min = func(array[0]);
            for(var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next < min) {
                    min = next;
                }
            }
            return min;
        };
        ArrayUtilities.max = function max(array, func) {
            var max = func(array[0]);
            for(var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next > max) {
                    max = next;
                }
            }
            return max;
        };
        ArrayUtilities.last = function last(array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }
            return array[array.length - 1];
        };
        ArrayUtilities.firstOrDefault = function firstOrDefault(array, func) {
            for(var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value)) {
                    return value;
                }
            }
            return null;
        };
        ArrayUtilities.sum = function sum(array, func) {
            var result = 0;
            for(var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }
            return result;
        };
        ArrayUtilities.whereNotNull = function whereNotNull(array) {
            var result = [];
            for(var i = 0; i < array.length; i++) {
                var value = array[i];
                if (value !== null) {
                    result.push(value);
                }
            }
            return result;
        };
        ArrayUtilities.select = function select(values, func) {
            var result = [];
            for(var i = 0; i < values.length; i++) {
                result.push(func(values[i]));
            }
            return result;
        };
        ArrayUtilities.where = function where(values, func) {
            var result = [];
            for(var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }
            return result;
        };
        ArrayUtilities.any = function any(array, func) {
            for(var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }
            return false;
        };
        ArrayUtilities.all = function all(array, func) {
            for(var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }
            return true;
        };
        ArrayUtilities.binarySearch = function binarySearch(array, value) {
            var low = 0;
            var high = array.length - 1;
            while(low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];
                if (midValue === value) {
                    return middle;
                } else if (midValue > value) {
                    high = middle - 1;
                } else {
                    low = middle + 1;
                }
            }
            return ~low;
        };
        ArrayUtilities.createArray = function createArray(length, defaultvalue) {
            var result = [];
            for(var i = 0; i < length; i++) {
                result.push(defaultvalue);
            }
            return result;
        };
        ArrayUtilities.grow = function grow(array, length, defaultValue) {
            var count = length - array.length;
            for(var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };
        ArrayUtilities.copy = function copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for(var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        return ArrayUtilities;
    })();
    TypeScript.ArrayUtilities = ArrayUtilities;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Constants) {
        Constants._map = [];
        Constants.Max31BitInteger = 1073741823;
        Constants.Min31BitInteger = -1073741824;
    })(TypeScript.Constants || (TypeScript.Constants = {}));
    var Constants = TypeScript.Constants;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Contract = (function () {
        function Contract() { }
        Contract.requires = function requires(expression) {
            if (!expression) {
                throw new Error("Contract violated. False expression.");
            }
        };
        Contract.throwIfFalse = function throwIfFalse(expression) {
            if (!expression) {
                throw new Error("Contract violated. False expression.");
            }
        };
        Contract.throwIfNull = function throwIfNull(value) {
            if (value === null) {
                throw new Error("Contract violated. Null value.");
            }
        };
        return Contract;
    })();
    TypeScript.Contract = Contract;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Debug = (function () {
        function Debug() { }
        Debug.assert = function assert(expression, message) {
            if (!expression) {
                throw new Error("Debug Failure. False expression: " + (message ? message : ""));
            }
        };
        return Debug;
    })();
    TypeScript.Debug = Debug;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory._map = [];
        DiagnosticCategory._map[0] = "Warning";
        DiagnosticCategory.Warning = 0;
        DiagnosticCategory._map[1] = "Error";
        DiagnosticCategory.Error = 1;
        DiagnosticCategory._map[2] = "NoPrefix";
        DiagnosticCategory.NoPrefix = 2;
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCode) {
        DiagnosticCode._map = [];
        DiagnosticCode._map[0] = "error_TS_0__1";
        DiagnosticCode.error_TS_0__1 = 0;
        DiagnosticCode._map[1] = "warning_TS_0__1";
        DiagnosticCode.warning_TS_0__1 = 1;
        DiagnosticCode._map[2] = "_0__NL__1_TB__2";
        DiagnosticCode._0__NL__1_TB__2 = 2;
        DiagnosticCode._map[3] = "_0_TB__1";
        DiagnosticCode._0_TB__1 = 3;
        DiagnosticCode._map[4] = "Unrecognized_escape_sequence";
        DiagnosticCode.Unrecognized_escape_sequence = 4;
        DiagnosticCode._map[5] = "Unexpected_character_0";
        DiagnosticCode.Unexpected_character_0 = 5;
        DiagnosticCode._map[6] = "Missing_closing_quote_character";
        DiagnosticCode.Missing_closing_quote_character = 6;
        DiagnosticCode._map[7] = "Identifier_expected";
        DiagnosticCode.Identifier_expected = 7;
        DiagnosticCode._map[8] = "_0_keyword_expected";
        DiagnosticCode._0_keyword_expected = 8;
        DiagnosticCode._map[9] = "_0_expected";
        DiagnosticCode._0_expected = 9;
        DiagnosticCode._map[10] = "Identifier_expected__0__is_a_keyword";
        DiagnosticCode.Identifier_expected__0__is_a_keyword = 10;
        DiagnosticCode._map[11] = "Automatic_semicolon_insertion_not_allowed";
        DiagnosticCode.Automatic_semicolon_insertion_not_allowed = 11;
        DiagnosticCode._map[12] = "Unexpected_token__0_expected";
        DiagnosticCode.Unexpected_token__0_expected = 12;
        DiagnosticCode._map[13] = "Trailing_separator_not_allowed";
        DiagnosticCode.Trailing_separator_not_allowed = 13;
        DiagnosticCode._map[14] = "_StarSlash__expected";
        DiagnosticCode._StarSlash__expected = 14;
        DiagnosticCode._map[15] = "_public_or_private_modifier_must_precede__static_";
        DiagnosticCode._public_or_private_modifier_must_precede__static_ = 15;
        DiagnosticCode._map[16] = "Unexpected_token_";
        DiagnosticCode.Unexpected_token_ = 16;
        DiagnosticCode._map[17] = "A_catch_clause_variable_cannot_have_a_type_annotation";
        DiagnosticCode.A_catch_clause_variable_cannot_have_a_type_annotation = 17;
        DiagnosticCode._map[18] = "Rest_parameter_must_be_last_in_list";
        DiagnosticCode.Rest_parameter_must_be_last_in_list = 18;
        DiagnosticCode._map[19] = "Parameter_cannot_have_question_mark_and_initializer";
        DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer = 19;
        DiagnosticCode._map[20] = "Required_parameter_cannot_follow_optional_parameter";
        DiagnosticCode.Required_parameter_cannot_follow_optional_parameter = 20;
        DiagnosticCode._map[21] = "Index_signatures_cannot_have_rest_parameters";
        DiagnosticCode.Index_signatures_cannot_have_rest_parameters = 21;
        DiagnosticCode._map[22] = "Index_signature_parameter_cannot_have_accessibility_modifierss";
        DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifierss = 22;
        DiagnosticCode._map[23] = "Index_signature_parameter_cannot_have_a_question_mark";
        DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark = 23;
        DiagnosticCode._map[24] = "Index_signature_parameter_cannot_have_an_initializer";
        DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer = 24;
        DiagnosticCode._map[25] = "Index_signature_must_have_a_type_annotation";
        DiagnosticCode.Index_signature_must_have_a_type_annotation = 25;
        DiagnosticCode._map[26] = "Index_signature_parameter_must_have_a_type_annotation";
        DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation = 26;
        DiagnosticCode._map[27] = "Index_signature_parameter_type_must_be__string__or__number_";
        DiagnosticCode.Index_signature_parameter_type_must_be__string__or__number_ = 27;
        DiagnosticCode._map[28] = "_extends__clause_already_seen";
        DiagnosticCode._extends__clause_already_seen = 28;
        DiagnosticCode._map[29] = "_extends__clause_must_precede__implements__clause";
        DiagnosticCode._extends__clause_must_precede__implements__clause = 29;
        DiagnosticCode._map[30] = "Class_can_only_extend_single_type";
        DiagnosticCode.Class_can_only_extend_single_type = 30;
        DiagnosticCode._map[31] = "_implements__clause_already_seen";
        DiagnosticCode._implements__clause_already_seen = 31;
        DiagnosticCode._map[32] = "Accessibility_modifier_already_seen";
        DiagnosticCode.Accessibility_modifier_already_seen = 32;
        DiagnosticCode._map[33] = "_0__modifier_must_precede__1__modifier";
        DiagnosticCode._0__modifier_must_precede__1__modifier = 33;
        DiagnosticCode._map[34] = "_0__modifier_already_seen";
        DiagnosticCode._0__modifier_already_seen = 34;
        DiagnosticCode._map[35] = "_0__modifier_cannot_appear_on_a_class_element";
        DiagnosticCode._0__modifier_cannot_appear_on_a_class_element = 35;
        DiagnosticCode._map[36] = "Interface_declaration_cannot_have__implements__clause";
        DiagnosticCode.Interface_declaration_cannot_have__implements__clause = 36;
        DiagnosticCode._map[37] = "Enum_element_must_have_initializer";
        DiagnosticCode.Enum_element_must_have_initializer = 37;
        DiagnosticCode._map[38] = "_super__invocation_cannot_have_type_arguments";
        DiagnosticCode._super__invocation_cannot_have_type_arguments = 38;
        DiagnosticCode._map[39] = "Non_ambient_modules_cannot_use_quoted_names";
        DiagnosticCode.Non_ambient_modules_cannot_use_quoted_names = 39;
        DiagnosticCode._map[40] = "Statements_are_not_allowed_in_ambient_contexts";
        DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts = 40;
        DiagnosticCode._map[41] = "Implementations_are_not_allowed_in_ambient_contexts";
        DiagnosticCode.Implementations_are_not_allowed_in_ambient_contexts = 41;
        DiagnosticCode._map[42] = "_declare__modifier_not_allowed_for_code_already_in_an_ambient_context";
        DiagnosticCode._declare__modifier_not_allowed_for_code_already_in_an_ambient_context = 42;
        DiagnosticCode._map[43] = "Initializers_are_not_allowed_in_ambient_contexts";
        DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts = 43;
        DiagnosticCode._map[44] = "Overload_and_ambient_signatures_cannot_specify_parameter_properties";
        DiagnosticCode.Overload_and_ambient_signatures_cannot_specify_parameter_properties = 44;
        DiagnosticCode._map[45] = "Function_implementation_expected";
        DiagnosticCode.Function_implementation_expected = 45;
        DiagnosticCode._map[46] = "Constructor_implementation_expected";
        DiagnosticCode.Constructor_implementation_expected = 46;
        DiagnosticCode._map[47] = "Function_overload_name_must_be__0_";
        DiagnosticCode.Function_overload_name_must_be__0_ = 47;
        DiagnosticCode._map[48] = "_0__modifier_cannot_appear_on_a_module_element";
        DiagnosticCode._0__modifier_cannot_appear_on_a_module_element = 48;
        DiagnosticCode._map[49] = "_declare__modifier_cannot_appear_on_an_interface_declaration";
        DiagnosticCode._declare__modifier_cannot_appear_on_an_interface_declaration = 49;
        DiagnosticCode._map[50] = "_declare__modifier_required_for_top_level_element";
        DiagnosticCode._declare__modifier_required_for_top_level_element = 50;
        DiagnosticCode._map[51] = "_set__accessor_must_have_only_one_parameter";
        DiagnosticCode._set__accessor_must_have_only_one_parameter = 51;
        DiagnosticCode._map[52] = "_set__accessor_parameter_cannot_have_accessibility_modifier";
        DiagnosticCode._set__accessor_parameter_cannot_have_accessibility_modifier = 52;
        DiagnosticCode._map[53] = "_set__accessor_parameter_cannot_be_optional";
        DiagnosticCode._set__accessor_parameter_cannot_be_optional = 53;
        DiagnosticCode._map[54] = "_set__accessor_parameter_cannot_have_initializer";
        DiagnosticCode._set__accessor_parameter_cannot_have_initializer = 54;
        DiagnosticCode._map[55] = "_set__accessor_cannot_have_rest_parameter";
        DiagnosticCode._set__accessor_cannot_have_rest_parameter = 55;
        DiagnosticCode._map[56] = "_get__accessor_cannot_have_parameters";
        DiagnosticCode._get__accessor_cannot_have_parameters = 56;
        DiagnosticCode._map[57] = "Rest_parameter_cannot_be_optional";
        DiagnosticCode.Rest_parameter_cannot_be_optional = 57;
        DiagnosticCode._map[58] = "Rest_parameter_cannot_have_initializer";
        DiagnosticCode.Rest_parameter_cannot_have_initializer = 58;
        DiagnosticCode._map[59] = "Modifiers_cannot_appear_here";
        DiagnosticCode.Modifiers_cannot_appear_here = 59;
        DiagnosticCode._map[60] = "Duplicate_identifier__0_";
        DiagnosticCode.Duplicate_identifier__0_ = 60;
        DiagnosticCode._map[61] = "The_name__0__does_not_exist_in_the_current_scope";
        DiagnosticCode.The_name__0__does_not_exist_in_the_current_scope = 61;
        DiagnosticCode._map[62] = "The_name__0__does_not_refer_to_a_value";
        DiagnosticCode.The_name__0__does_not_refer_to_a_value = 62;
        DiagnosticCode._map[63] = "Keyword__super__can_only_be_used_inside_a_class_instance_method";
        DiagnosticCode.Keyword__super__can_only_be_used_inside_a_class_instance_method = 63;
        DiagnosticCode._map[64] = "The_left_hand_side_of_an_assignment_expression_must_be_a_variable__property_or_indexer";
        DiagnosticCode.The_left_hand_side_of_an_assignment_expression_must_be_a_variable__property_or_indexer = 64;
        DiagnosticCode._map[65] = "Value_of_type__0__is_not_callable__Did_you_mean_to_include__new__";
        DiagnosticCode.Value_of_type__0__is_not_callable__Did_you_mean_to_include__new__ = 65;
        DiagnosticCode._map[66] = "Value_of_type__0__is_not_callable";
        DiagnosticCode.Value_of_type__0__is_not_callable = 66;
        DiagnosticCode._map[67] = "Value_of_type__0__is_not_newable";
        DiagnosticCode.Value_of_type__0__is_not_newable = 67;
        DiagnosticCode._map[68] = "Value_of_type__0__is_not_indexable_by_type__1_";
        DiagnosticCode.Value_of_type__0__is_not_indexable_by_type__1_ = 68;
        DiagnosticCode._map[69] = "Operator__0__cannot_be_applied_to_types__1__and__2_";
        DiagnosticCode.Operator__0__cannot_be_applied_to_types__1__and__2_ = 69;
        DiagnosticCode._map[70] = "Operator__0__cannot_be_applied_to_types__1__and__2__3";
        DiagnosticCode.Operator__0__cannot_be_applied_to_types__1__and__2__3 = 70;
        DiagnosticCode._map[71] = "Cannot_convert__0__to__1_";
        DiagnosticCode.Cannot_convert__0__to__1_ = 71;
        DiagnosticCode._map[72] = "Cannot_convert__0__to__1__NL__2";
        DiagnosticCode.Cannot_convert__0__to__1__NL__2 = 72;
        DiagnosticCode._map[73] = "Expected_var__class__interface__or_module";
        DiagnosticCode.Expected_var__class__interface__or_module = 73;
        DiagnosticCode._map[74] = "Operator__0__cannot_be_applied_to_type__1_";
        DiagnosticCode.Operator__0__cannot_be_applied_to_type__1_ = 74;
        DiagnosticCode._map[75] = "Getter__0__already_declared";
        DiagnosticCode.Getter__0__already_declared = 75;
        DiagnosticCode._map[76] = "Setter__0__already_declared";
        DiagnosticCode.Setter__0__already_declared = 76;
        DiagnosticCode._map[77] = "Accessor_may_not_take_type_parameters";
        DiagnosticCode.Accessor_may_not_take_type_parameters = 77;
        DiagnosticCode._map[78] = "Exported_class__0__extends_private_class__1_";
        DiagnosticCode.Exported_class__0__extends_private_class__1_ = 78;
        DiagnosticCode._map[79] = "Exported_class__0__implements_private_interface__1_";
        DiagnosticCode.Exported_class__0__implements_private_interface__1_ = 79;
        DiagnosticCode._map[80] = "Exported_interface__0__extends_private_interface__1_";
        DiagnosticCode.Exported_interface__0__extends_private_interface__1_ = 80;
        DiagnosticCode._map[81] = "Exported_class__0__extends_class_from_inaccessible_module__1_";
        DiagnosticCode.Exported_class__0__extends_class_from_inaccessible_module__1_ = 81;
        DiagnosticCode._map[82] = "Exported_class__0__implements_interface_from_inaccessible_module__1_";
        DiagnosticCode.Exported_class__0__implements_interface_from_inaccessible_module__1_ = 82;
        DiagnosticCode._map[83] = "Exported_interface__0__extends_interface_from_inaccessible_module__1_";
        DiagnosticCode.Exported_interface__0__extends_interface_from_inaccessible_module__1_ = 83;
        DiagnosticCode._map[84] = "Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode.Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_ = 84;
        DiagnosticCode._map[85] = "Public_property__0__of__exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode.Public_property__0__of__exported_class_has_or_is_using_private_type__1_ = 85;
        DiagnosticCode._map[86] = "Property__0__of__exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode.Property__0__of__exported_interface_has_or_is_using_private_type__1_ = 86;
        DiagnosticCode._map[87] = "Exported_variable__0__has_or_is_using_private_type__1_";
        DiagnosticCode.Exported_variable__0__has_or_is_using_private_type__1_ = 87;
        DiagnosticCode._map[88] = "Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode.Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_ = 88;
        DiagnosticCode._map[89] = "Public_property__0__of__exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode.Public_property__0__of__exported_class_is_using_inaccessible_module__1_ = 89;
        DiagnosticCode._map[90] = "Property__0__of__exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode.Property__0__of__exported_interface_is_using_inaccessible_module__1_ = 90;
        DiagnosticCode._map[91] = "Exported_variable__0__is_using_inaccessible_module__1_";
        DiagnosticCode.Exported_variable__0__is_using_inaccessible_module__1_ = 91;
        DiagnosticCode._map[92] = "Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_ = 92;
        DiagnosticCode._map[93] = "Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_ = 93;
        DiagnosticCode._map[94] = "Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_ = 94;
        DiagnosticCode._map[95] = "Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_ = 95;
        DiagnosticCode._map[96] = "Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_ = 96;
        DiagnosticCode._map[97] = "Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_ = 97;
        DiagnosticCode._map[98] = "Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_ = 98;
        DiagnosticCode._map[99] = "Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_ = 99;
        DiagnosticCode._map[100] = "Parameter__0__of_exported_function_has_or_is_using_private_type__1_";
        DiagnosticCode.Parameter__0__of_exported_function_has_or_is_using_private_type__1_ = 100;
        DiagnosticCode._map[101] = "Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_ = 101;
        DiagnosticCode._map[102] = "Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_ = 102;
        DiagnosticCode._map[103] = "Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_ = 103;
        DiagnosticCode._map[104] = "Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_ = 104;
        DiagnosticCode._map[105] = "Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_ = 105;
        DiagnosticCode._map[106] = "Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_ = 106;
        DiagnosticCode._map[107] = "Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_ = 107;
        DiagnosticCode._map[108] = "Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_ = 108;
        DiagnosticCode._map[109] = "Parameter__0__of_exported_function_is_using_inaccessible_module__1_";
        DiagnosticCode.Parameter__0__of_exported_function_is_using_inaccessible_module__1_ = 109;
        DiagnosticCode._map[110] = "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_ = 110;
        DiagnosticCode._map[111] = "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_ = 111;
        DiagnosticCode._map[112] = "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_ = 112;
        DiagnosticCode._map[113] = "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_ = 113;
        DiagnosticCode._map[114] = "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_ = 114;
        DiagnosticCode._map[115] = "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_ = 115;
        DiagnosticCode._map[116] = "Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_ = 116;
        DiagnosticCode._map[117] = "Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_ = 117;
        DiagnosticCode._map[118] = "Return_type_of_exported_function_has_or_is_using_private_type__0_";
        DiagnosticCode.Return_type_of_exported_function_has_or_is_using_private_type__0_ = 118;
        DiagnosticCode._map[119] = "Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_ = 119;
        DiagnosticCode._map[120] = "Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_ = 120;
        DiagnosticCode._map[121] = "Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_ = 121;
        DiagnosticCode._map[122] = "Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_ = 122;
        DiagnosticCode._map[123] = "Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_ = 123;
        DiagnosticCode._map[124] = "Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_ = 124;
        DiagnosticCode._map[125] = "Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_ = 125;
        DiagnosticCode._map[126] = "Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_ = 126;
        DiagnosticCode._map[127] = "Return_type_of_exported_function_is_using_inaccessible_module__0_";
        DiagnosticCode.Return_type_of_exported_function_is_using_inaccessible_module__0_ = 127;
        DiagnosticCode._map[128] = "_new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead";
        DiagnosticCode._new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead = 128;
        DiagnosticCode._map[129] = "A_parameter_list_must_follow_a_generic_type_argument_list______expected";
        DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list______expected = 129;
        DiagnosticCode._map[130] = "Multiple_constructor_implementations_are_not_allowed";
        DiagnosticCode.Multiple_constructor_implementations_are_not_allowed = 130;
        DiagnosticCode._map[131] = "Unable_to_resolve_external_module__0_";
        DiagnosticCode.Unable_to_resolve_external_module__0_ = 131;
        DiagnosticCode._map[132] = "Module_cannot_be_aliased_to_a_non_module_type";
        DiagnosticCode.Module_cannot_be_aliased_to_a_non_module_type = 132;
        DiagnosticCode._map[133] = "A_class_may_only_extend_another_class";
        DiagnosticCode.A_class_may_only_extend_another_class = 133;
        DiagnosticCode._map[134] = "A_class_may_only_implement_another_class_or_interface";
        DiagnosticCode.A_class_may_only_implement_another_class_or_interface = 134;
        DiagnosticCode._map[135] = "An_interface_may_only_extend_another_class_or_interface";
        DiagnosticCode.An_interface_may_only_extend_another_class_or_interface = 135;
        DiagnosticCode._map[136] = "An_interface_may_not_implement_another_type";
        DiagnosticCode.An_interface_may_not_implement_another_type = 136;
        DiagnosticCode._map[137] = "Unable_to_resolve_type";
        DiagnosticCode.Unable_to_resolve_type = 137;
        DiagnosticCode._map[138] = "Unable_to_resolve_type_of__0_";
        DiagnosticCode.Unable_to_resolve_type_of__0_ = 138;
        DiagnosticCode._map[139] = "Unable_to_resolve_type_parameter_constraint";
        DiagnosticCode.Unable_to_resolve_type_parameter_constraint = 139;
        DiagnosticCode._map[140] = "Type_parameter_constraint_may_not_be_a_primitive_type";
        DiagnosticCode.Type_parameter_constraint_may_not_be_a_primitive_type = 140;
        DiagnosticCode._map[141] = "Supplied_parameters_do_not_match_any_signature_of_call_target";
        DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target = 141;
        DiagnosticCode._map[142] = "Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0";
        DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0 = 142;
        DiagnosticCode._map[143] = "Invalid__new__expression";
        DiagnosticCode.Invalid__new__expression = 143;
        DiagnosticCode._map[144] = "Call_signatures_used_in_a__new__expression_must_have_a__void__return_type";
        DiagnosticCode.Call_signatures_used_in_a__new__expression_must_have_a__void__return_type = 144;
        DiagnosticCode._map[145] = "Could_not_select_overload_for__new__expression";
        DiagnosticCode.Could_not_select_overload_for__new__expression = 145;
        DiagnosticCode._map[146] = "Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_";
        DiagnosticCode.Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_ = 146;
        DiagnosticCode._map[147] = "Could_not_select_overload_for__call__expression";
        DiagnosticCode.Could_not_select_overload_for__call__expression = 147;
        DiagnosticCode._map[148] = "Unable_to_invoke_type_with_no_call_signatures";
        DiagnosticCode.Unable_to_invoke_type_with_no_call_signatures = 148;
        DiagnosticCode._map[149] = "Calls_to__super__are_only_valid_inside_a_class";
        DiagnosticCode.Calls_to__super__are_only_valid_inside_a_class = 149;
        DiagnosticCode._map[150] = "Generic_type__0__requires_1_type_argument_s_";
        DiagnosticCode.Generic_type__0__requires_1_type_argument_s_ = 150;
        DiagnosticCode._map[151] = "Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_";
        DiagnosticCode.Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_ = 151;
        DiagnosticCode._map[152] = "Type_of_array_literal_cannot_be_determined__Best_common_type_could_not_be_found_for_array_elements";
        DiagnosticCode.Type_of_array_literal_cannot_be_determined__Best_common_type_could_not_be_found_for_array_elements = 152;
        DiagnosticCode._map[153] = "Could_not_find_enclosing_symbol_for_dotted_name__0_";
        DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name__0_ = 153;
        DiagnosticCode._map[154] = "Could_not_find_dotted_name__0_";
        DiagnosticCode.Could_not_find_dotted_name__0_ = 154;
        DiagnosticCode._map[155] = "Could_not_find_symbol__0_";
        DiagnosticCode.Could_not_find_symbol__0_ = 155;
        DiagnosticCode._map[156] = "_get__and__set__accessor_must_have_the_same_type";
        DiagnosticCode._get__and__set__accessor_must_have_the_same_type = 156;
        DiagnosticCode._map[157] = "_this__may_not_be_referenced_in_current_location";
        DiagnosticCode._this__may_not_be_referenced_in_current_location = 157;
        DiagnosticCode._map[158] = "Use_of_deprecated__bool__type__Use__boolean__instead";
        DiagnosticCode.Use_of_deprecated__bool__type__Use__boolean__instead = 158;
        DiagnosticCode._map[159] = "Static_methods_may_not_reference_class_type_parameters";
        DiagnosticCode.Static_methods_may_not_reference_class_type_parameters = 159;
        DiagnosticCode._map[160] = "Class__0__is_recursively_referenced_as_a_base_type_of_itself";
        DiagnosticCode.Class__0__is_recursively_referenced_as_a_base_type_of_itself = 160;
        DiagnosticCode._map[161] = "Interface__0__is_recursively_referenced_as_a_base_type_of_itself";
        DiagnosticCode.Interface__0__is_recursively_referenced_as_a_base_type_of_itself = 161;
        DiagnosticCode._map[162] = "_super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class";
        DiagnosticCode._super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class = 162;
        DiagnosticCode._map[163] = "_super__may_not_be_referenced_in_non_derived_classes";
        DiagnosticCode._super__may_not_be_referenced_in_non_derived_classes = 163;
        DiagnosticCode._map[164] = "A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties";
        DiagnosticCode.A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties = 164;
        DiagnosticCode._map[165] = "Constructors_for_derived_classes_must_contain_a__super__call";
        DiagnosticCode.Constructors_for_derived_classes_must_contain_a__super__call = 165;
        DiagnosticCode._map[166] = "Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors";
        DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors = 166;
        DiagnosticCode._map[167] = "_0_1__is_inaccessible";
        DiagnosticCode._0_1__is_inaccessible = 167;
        DiagnosticCode._map[168] = "_this__cannot_be_referenced_within_module_bodies";
        DiagnosticCode._this__cannot_be_referenced_within_module_bodies = 168;
        DiagnosticCode._map[169] = "_this__must_only_be_used_inside_a_function_or_script_context";
        DiagnosticCode._this__must_only_be_used_inside_a_function_or_script_context = 169;
        DiagnosticCode._map[170] = "VarArgs_must_be_array_types";
        DiagnosticCode.VarArgs_must_be_array_types = 170;
        DiagnosticCode._map[171] = "Invalid__addition__expression___types_do_not_agree";
        DiagnosticCode.Invalid__addition__expression___types_do_not_agree = 171;
        DiagnosticCode._map[172] = "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type";
        DiagnosticCode.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type = 172;
        DiagnosticCode._map[173] = "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type";
        DiagnosticCode.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type = 173;
        DiagnosticCode._map[174] = "The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type";
        DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type = 174;
        DiagnosticCode._map[175] = "Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation";
        DiagnosticCode.Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation = 175;
        DiagnosticCode._map[176] = "Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_";
        DiagnosticCode.Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_ = 176;
        DiagnosticCode._map[177] = "The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter";
        DiagnosticCode.The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter = 177;
        DiagnosticCode._map[178] = "The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_";
        DiagnosticCode.The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_ = 178;
        DiagnosticCode._map[179] = "The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter";
        DiagnosticCode.The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter = 179;
        DiagnosticCode._map[180] = "The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter";
        DiagnosticCode.The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter = 180;
        DiagnosticCode._map[181] = "The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type";
        DiagnosticCode.The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type = 181;
        DiagnosticCode._map[182] = "Setters_may_not_return_a_value";
        DiagnosticCode.Setters_may_not_return_a_value = 182;
        DiagnosticCode._map[183] = "Tried_to_set_variable_type_to_uninitialized_module_type";
        DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type = 183;
        DiagnosticCode._map[184] = "Tried_to_set_variable_type_to_uninitialized_module_type__0__";
        DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type__0__ = 184;
        DiagnosticCode._map[185] = "Function__0__declared_a_non_void_return_type__but_has_no_return_expression";
        DiagnosticCode.Function__0__declared_a_non_void_return_type__but_has_no_return_expression = 185;
        DiagnosticCode._map[186] = "Getters_must_return_a_value";
        DiagnosticCode.Getters_must_return_a_value = 186;
        DiagnosticCode._map[187] = "Getter_and_setter_accessors_do_not_agree_in_visibility";
        DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility = 187;
        DiagnosticCode._map[188] = "Invalid_left_hand_side_of_assignment_expression";
        DiagnosticCode.Invalid_left_hand_side_of_assignment_expression = 188;
        DiagnosticCode._map[189] = "Function_declared_a_non_void_return_type__but_has_no_return_expression";
        DiagnosticCode.Function_declared_a_non_void_return_type__but_has_no_return_expression = 189;
        DiagnosticCode._map[190] = "Cannot_resolve_return_type_reference";
        DiagnosticCode.Cannot_resolve_return_type_reference = 190;
        DiagnosticCode._map[191] = "Constructors_cannot_have_a_return_type_of__void_";
        DiagnosticCode.Constructors_cannot_have_a_return_type_of__void_ = 191;
        DiagnosticCode._map[192] = "Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_";
        DiagnosticCode.Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_ = 192;
        DiagnosticCode._map[193] = "All_symbols_within_a__with__block_will_be_resolved_to__any__";
        DiagnosticCode.All_symbols_within_a__with__block_will_be_resolved_to__any__ = 193;
        DiagnosticCode._map[194] = "Import_declarations_in_an_internal_module_cannot_reference_an_external_module";
        DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module = 194;
        DiagnosticCode._map[195] = "Class__0__declares_interface__1__but_does_not_implement_it__NL__2";
        DiagnosticCode.Class__0__declares_interface__1__but_does_not_implement_it__NL__2 = 195;
        DiagnosticCode._map[196] = "Class__0__declares_class__1__but_does_not_implement_it__NL__2";
        DiagnosticCode.Class__0__declares_class__1__but_does_not_implement_it__NL__2 = 196;
        DiagnosticCode._map[197] = "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer";
        DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer = 197;
        DiagnosticCode._map[198] = "_this__may_not_be_referenced_in_initializers_in_a_class_body";
        DiagnosticCode._this__may_not_be_referenced_in_initializers_in_a_class_body = 198;
        DiagnosticCode._map[199] = "Class__0__cannot_extend_class__1__NL__2";
        DiagnosticCode.Class__0__cannot_extend_class__1__NL__2 = 199;
        DiagnosticCode._map[200] = "Interface__0__cannot_extend_class__1__NL__2";
        DiagnosticCode.Interface__0__cannot_extend_class__1__NL__2 = 200;
        DiagnosticCode._map[201] = "Interface__0__cannot_extend_interface__1__NL__2";
        DiagnosticCode.Interface__0__cannot_extend_interface__1__NL__2 = 201;
        DiagnosticCode._map[202] = "Duplicate_overload_signature_for__0_";
        DiagnosticCode.Duplicate_overload_signature_for__0_ = 202;
        DiagnosticCode._map[203] = "Duplicate_constructor_overload_signature";
        DiagnosticCode.Duplicate_constructor_overload_signature = 203;
        DiagnosticCode._map[204] = "Duplicate_overload_call_signature";
        DiagnosticCode.Duplicate_overload_call_signature = 204;
        DiagnosticCode._map[205] = "Duplicate_overload_construct_signature";
        DiagnosticCode.Duplicate_overload_construct_signature = 205;
        DiagnosticCode._map[206] = "Overload_signature_is_not_compatible_with_function_definition";
        DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition = 206;
        DiagnosticCode._map[207] = "Overload_signature_is_not_compatible_with_function_definition__NL__0";
        DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition__NL__0 = 207;
        DiagnosticCode._map[208] = "Overload_signatures_must_all_be_public_or_private";
        DiagnosticCode.Overload_signatures_must_all_be_public_or_private = 208;
        DiagnosticCode._map[209] = "Overload_signatures_must_all_be_exported_or_local";
        DiagnosticCode.Overload_signatures_must_all_be_exported_or_local = 209;
        DiagnosticCode._map[210] = "Overload_signatures_must_all_be_ambient_or_non_ambient";
        DiagnosticCode.Overload_signatures_must_all_be_ambient_or_non_ambient = 210;
        DiagnosticCode._map[211] = "Overload_signatures_must_all_be_optional_or_required";
        DiagnosticCode.Overload_signatures_must_all_be_optional_or_required = 211;
        DiagnosticCode._map[212] = "Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature";
        DiagnosticCode.Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature = 212;
        DiagnosticCode._map[213] = "Type__0__is_missing_property__1__from_type__2_";
        DiagnosticCode.Type__0__is_missing_property__1__from_type__2_ = 213;
        DiagnosticCode._map[214] = "Types_of_property__0__of_types__1__and__2__are_incompatible";
        DiagnosticCode.Types_of_property__0__of_types__1__and__2__are_incompatible = 214;
        DiagnosticCode._map[215] = "Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3";
        DiagnosticCode.Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3 = 215;
        DiagnosticCode._map[216] = "Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_";
        DiagnosticCode.Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_ = 216;
        DiagnosticCode._map[217] = "Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_";
        DiagnosticCode.Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_ = 217;
        DiagnosticCode._map[218] = "Types__0__and__1__define_property__2__as_private";
        DiagnosticCode.Types__0__and__1__define_property__2__as_private = 218;
        DiagnosticCode._map[219] = "Call_signatures_of_types__0__and__1__are_incompatible";
        DiagnosticCode.Call_signatures_of_types__0__and__1__are_incompatible = 219;
        DiagnosticCode._map[220] = "Call_signatures_of_types__0__and__1__are_incompatible__NL__2";
        DiagnosticCode.Call_signatures_of_types__0__and__1__are_incompatible__NL__2 = 220;
        DiagnosticCode._map[221] = "Type__0__requires_a_call_signature__but_Type__1__lacks_one";
        DiagnosticCode.Type__0__requires_a_call_signature__but_Type__1__lacks_one = 221;
        DiagnosticCode._map[222] = "Construct_signatures_of_types__0__and__1__are_incompatible";
        DiagnosticCode.Construct_signatures_of_types__0__and__1__are_incompatible = 222;
        DiagnosticCode._map[223] = "Construct_signatures_of_types__0__and__1__are_incompatible__NL__2";
        DiagnosticCode.Construct_signatures_of_types__0__and__1__are_incompatible__NL__2 = 223;
        DiagnosticCode._map[224] = "Type__0__requires_a_construct_signature__but_Type__1__lacks_one";
        DiagnosticCode.Type__0__requires_a_construct_signature__but_Type__1__lacks_one = 224;
        DiagnosticCode._map[225] = "Index_signatures_of_types__0__and__1__are_incompatible";
        DiagnosticCode.Index_signatures_of_types__0__and__1__are_incompatible = 225;
        DiagnosticCode._map[226] = "Index_signatures_of_types__0__and__1__are_incompatible__NL__2";
        DiagnosticCode.Index_signatures_of_types__0__and__1__are_incompatible__NL__2 = 226;
        DiagnosticCode._map[227] = "Call_signature_expects__0__or_fewer_parameters";
        DiagnosticCode.Call_signature_expects__0__or_fewer_parameters = 227;
        DiagnosticCode._map[228] = "Could_not_apply_type__0__to_argument__1__which_is_of_type__2_";
        DiagnosticCode.Could_not_apply_type__0__to_argument__1__which_is_of_type__2_ = 228;
        DiagnosticCode._map[229] = "Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function";
        DiagnosticCode.Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function = 229;
        DiagnosticCode._map[230] = "Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function";
        DiagnosticCode.Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function = 230;
        DiagnosticCode._map[231] = "Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor";
        DiagnosticCode.Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor = 231;
        DiagnosticCode._map[232] = "Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property";
        DiagnosticCode.Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property = 232;
        DiagnosticCode._map[233] = "Types_of_static_property__0__of_class__1__and_class__2__are_incompatible";
        DiagnosticCode.Types_of_static_property__0__of_class__1__and_class__2__are_incompatible = 233;
        DiagnosticCode._map[234] = "Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3";
        DiagnosticCode.Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3 = 234;
    })(TypeScript.DiagnosticCode || (TypeScript.DiagnosticCode = {}));
    var DiagnosticCode = TypeScript.DiagnosticCode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.diagnosticMessages = {
        error_TS_0__1: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "error TS{0}: {1}",
            code: 0
        },
        warning_TS_0__1: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "warning TS{0}: {1}",
            code: 1
        },
        _0__NL__1_TB__2: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "{0}{NL}{{1}TB}{2}",
            code: 21
        },
        _0_TB__1: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "{{0}TB}{1}",
            code: 22
        },
        Unrecognized_escape_sequence: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unrecognized escape sequence.",
            code: 1000
        },
        Unexpected_character_0: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unexpected character {0}.",
            code: 1001
        },
        Missing_closing_quote_character: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Missing close quote character.",
            code: 1002
        },
        Identifier_expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Identifier expected.",
            code: 1003
        },
        _0_keyword_expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'{0}' keyword expected.",
            code: 1004
        },
        _0_expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'{0}' expected.",
            code: 1005
        },
        Identifier_expected__0__is_a_keyword: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Identifier expected; '{0}' is a keyword.",
            code: 1006
        },
        Automatic_semicolon_insertion_not_allowed: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Automatic semicolon insertion not allowed.",
            code: 1007
        },
        Unexpected_token__0_expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unexpected token; '{0}' expected.",
            code: 1008
        },
        Trailing_separator_not_allowed: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Trailing separator not allowed.",
            code: 1009
        },
        _StarSlash__expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'*/' expected.",
            code: 1010
        },
        _public_or_private_modifier_must_precede__static_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'public' or 'private' modifier must precede 'static'.",
            code: 1011
        },
        Unexpected_token_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unexpected token.",
            code: 1012
        },
        A_catch_clause_variable_cannot_have_a_type_annotation: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "A catch clause variable cannot have a type annotation.",
            code: 1013
        },
        Rest_parameter_must_be_last_in_list: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Rest parameter must be last in list.",
            code: 1014
        },
        Parameter_cannot_have_question_mark_and_initializer: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter cannot have question mark and initializer.",
            code: 1015
        },
        Required_parameter_cannot_follow_optional_parameter: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "required parameter cannot follow optional parameter.",
            code: 1016
        },
        Index_signatures_cannot_have_rest_parameters: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Index signatures cannot have rest parameters.",
            code: 1017
        },
        Index_signature_parameter_cannot_have_accessibility_modifiers: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Index signature parameter cannot have accessibility modifiers.",
            code: 1018
        },
        Index_signature_parameter_cannot_have_a_question_mark: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Index signature parameter cannot have a question mark.",
            code: 1019
        },
        Index_signature_parameter_cannot_have_an_initializer: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Index signature parameter cannot have an initializer.",
            code: 1020
        },
        Index_signature_must_have_a_type_annotation: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Index signature must have a type annotation.",
            code: 1021
        },
        Index_signature_parameter_must_have_a_type_annotation: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Index signature parameter must have a type annotation.",
            code: 1022
        },
        Index_signature_parameter_type_must_be__string__or__number_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Index signature parameter type must be 'string' or 'number'.",
            code: 1023
        },
        _extends__clause_already_seen: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'extends' clause already seen.",
            code: 1024
        },
        _extends__clause_must_precede__implements__clause: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'extends' clause must precede 'implements' clause.",
            code: 1025
        },
        Class_can_only_extend_single_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Class can only extend single type.",
            code: 1026
        },
        _implements__clause_already_seen: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'implements' clause already seen.",
            code: 1027
        },
        Accessibility_modifier_already_seen: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Accessibility modifier already seen.",
            code: 1028
        },
        _0__modifier_must_precede__1__modifier: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'{0}' modifier must precede '{1}' modifier.",
            code: 1029
        },
        _0__modifier_already_seen: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'{0}' modifier already seen.",
            code: 1030
        },
        _0__modifier_cannot_appear_on_a_class_element: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'{0}' modifier cannot appear on a class element.",
            code: 1031
        },
        Interface_declaration_cannot_have__implements__clause: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Interface declaration cannot have 'implements' clause.",
            code: 1032
        },
        Enum_element_must_have_initializer: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Enum element must have initializer.",
            code: 1033
        },
        _super__invocation_cannot_have_type_arguments: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'super' invocation cannot have type arguments.",
            code: 1034
        },
        Non_ambient_modules_cannot_use_quoted_names: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Non ambient modules cannot use quoted names.",
            code: 1035
        },
        Statements_are_not_allowed_in_ambient_contexts: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Statements are not allowed in ambient contexts.",
            code: 1036
        },
        Implementations_are_not_allowed_in_ambient_contexts: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Implementations are not allowed in ambient contexts.",
            code: 1037
        },
        _declare__modifier_not_allowed_for_code_already_in_an_ambient_context: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'declare' modifier not allowed for code already in an ambient context.",
            code: 1038
        },
        Initializers_are_not_allowed_in_ambient_contexts: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Initializers are not allowed in ambient contexts.",
            code: 1039
        },
        Overload_and_ambient_signatures_cannot_specify_parameter_properties: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Overload and ambient signatures cannot specify parameter properties.",
            code: 1040
        },
        Function_implementation_expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Function implementation expected.",
            code: 1041
        },
        Constructor_implementation_expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Constructor implementation expected.",
            code: 1042
        },
        Function_overload_name_must_be__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Function overload name must be '{0}'.",
            code: 1043
        },
        _0__modifier_cannot_appear_on_a_module_element: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'{0}' modifier cannot appear on a module element.",
            code: 1044
        },
        _declare__modifier_cannot_appear_on_an_interface_declaration: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'declare' modifier cannot appear on an interface declaration.",
            code: 1045
        },
        _declare__modifier_required_for_top_level_element: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'declare' modifier required for top level element.",
            code: 1046
        },
        Rest_parameter_cannot_be_optional: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Rest parameter cannot be optional.",
            code: 1047
        },
        Rest_parameter_cannot_have_initializer: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Rest parameter cannot have initializer.",
            code: 1048
        },
        _set__accessor_must_have_only_one_parameter: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'set' accessor must have one and only one parameter.",
            code: 1049
        },
        _set__accessor_parameter_cannot_have_accessibility_modifier: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'set' accessor parameter cannot have accessibility modifier.",
            code: 1050
        },
        _set__accessor_parameter_cannot_be_optional: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'set' accessor parameter cannot be optional.",
            code: 1051
        },
        _set__accessor_parameter_cannot_have_initializer: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'set' accessor parameter cannot have initializer.",
            code: 1052
        },
        _set__accessor_cannot_have_rest_parameter: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'set' accessor cannot have rest parameter.",
            code: 1053
        },
        _get__accessor_cannot_have_parameters: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'get' accessor cannot have parameters.",
            code: 1054
        },
        Modifiers_cannot_appear_here: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Modifiers cannot appear here.",
            code: 1055
        },
        Duplicate_identifier__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Duplicate identifier '{0}'.",
            code: 2000
        },
        The_name__0__does_not_exist_in_the_current_scope: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The name '{0}' does not exist in the current scope.",
            code: 2001
        },
        The_name__0__does_not_refer_to_a_value: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The name '{0}' does not refer to a value.",
            code: 2002
        },
        Keyword__super__can_only_be_used_inside_a_class_instance_method: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Keyword 'super' can only be used inside a class instance method.",
            code: 2003
        },
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable__property_or_indexer: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The left-hand side of an assignment expression must be a variable, property or indexer.",
            code: 2004
        },
        Value_of_type__0__is_not_callable__Did_you_mean_to_include__new__: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
            code: 2005
        },
        Value_of_type__0__is_not_callable: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Value of type '{0}' is not callable.",
            code: 2006
        },
        Value_of_type__0__is_not_newable: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Value of type '{0}' is not newable.",
            code: 2007
        },
        Value_of_type__0__is_not_indexable_by_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Value of type '{0}' is not indexable by type '{1}'.",
            code: 2008
        },
        Operator__0__cannot_be_applied_to_types__1__and__2_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
            code: 2009
        },
        Operator__0__cannot_be_applied_to_types__1__and__2__3: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
            code: 2010
        },
        Cannot_convert__0__to__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Cannot convert '{0}' to '{1}'.",
            code: 2011
        },
        Cannot_convert__0__to__1__NL__2: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Cannot convert '{0}' to '{1}':{NL}{2}",
            code: 2012
        },
        Expected_var__class__interface__or_module: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Expected var, class, interface, or module.",
            code: 2013
        },
        Operator__0__cannot_be_applied_to_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to type '{1}'.",
            code: 2014
        },
        Getter__0__already_declared: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Getter '{0}' already declared.",
            code: 2015
        },
        Setter__0__already_declared: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Setter '{0}' already declared.",
            code: 2016
        },
        Accessor_may_not_take_type_parameters: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Accessors may not take type parameters.",
            code: 2017
        },
        Exported_class__0__extends_private_class__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported class '{0}' extends private class '{1}'.",
            code: 2018
        },
        Exported_class__0__implements_private_interface__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported class '{0}' implements private interface '{1}'.",
            code: 2019
        },
        Exported_interface__0__extends_private_interface__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported interface '{0}' extends private interface '{1}'.",
            code: 2020
        },
        Exported_class__0__extends_class_from_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported class '{0}' extends class from inaccessible module {1}.",
            code: 2021
        },
        Exported_class__0__implements_interface_from_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported class '{0}' implements interface from inaccessible module {1}.",
            code: 2022
        },
        Exported_interface__0__extends_interface_from_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported interface '{0}' extends interface from inaccessible module {1}.",
            code: 2023
        },
        Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Public static property '{0}' of exported class has or is using private type '{1}'.",
            code: 2024
        },
        Public_property__0__of__exported_class_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Public property '{0}' of exported class has or is using private type '{1}'.",
            code: 2025
        },
        Property__0__of__exported_interface_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Property '{0}' of exported interface has or is using private type '{1}'.",
            code: 2026
        },
        Exported_variable__0__has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported variable '{0}' has or is using private type '{1}'.",
            code: 2027
        },
        Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Public static property '{0}' of exported class is using inaccessible module {1}.",
            code: 2028
        },
        Public_property__0__of__exported_class_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Public property '{0}' of exported class is using inaccessible module {1}.",
            code: 2029
        },
        Property__0__of__exported_interface_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Property '{0}' of exported interface is using inaccessible module {1}.",
            code: 2030
        },
        Exported_variable__0__is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Exported variable '{0}' is using inaccessible module {1}.",
            code: 2031
        },
        Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
            code: 2032
        },
        Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
            code: 2033
        },
        Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
            code: 2034
        },
        Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
            code: 2035
        },
        Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
            code: 2036
        },
        Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
            code: 2037
        },
        Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
            code: 2038
        },
        Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
            code: 2039
        },
        Parameter__0__of_exported_function_has_or_is_using_private_type__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of exported function has or is using private type '{1}'.",
            code: 2040
        },
        Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
            code: 2041
        },
        Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
            code: 2042
        },
        Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
            code: 2043
        },
        Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
            code: 2044
        },
        Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
            code: 2045
        },
        Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
            code: 2046
        },
        Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
            code: 2047
        },
        Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
            code: 2048
        },
        Parameter__0__of_exported_function_is_using_inaccessible_module__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Parameter '{0}' of exported function is using inaccessible module {1}.",
            code: 2049
        },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public static property getter from exported class has or is using private type '{0}'.",
            code: 2050
        },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public property getter from exported class has or is using private type '{0}'.",
            code: 2051
        },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
            code: 2052
        },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of call signature from exported interface has or is using private type '{0}'.",
            code: 2053
        },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of index signature from exported interface has or is using private type '{0}'.",
            code: 2054
        },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public static method from exported class has or is using private type '{0}'.",
            code: 2055
        },
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public method from exported class has or is using private type '{0}'.",
            code: 2056
        },
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of method from exported interface has or is using private type '{0}'.",
            code: 2057
        },
        Return_type_of_exported_function_has_or_is_using_private_type__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of exported function has or is using private type '{0}'.",
            code: 2058
        },
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public static property getter from exported class is using inaccessible module {0}.",
            code: 2059
        },
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public property getter from exported class is using inaccessible module {0}.",
            code: 2060
        },
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
            code: 2061
        },
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of call signature from exported interface is using inaccessible module {0}.",
            code: 2062
        },
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of index signature from exported interface is using inaccessible module {0}.",
            code: 2063
        },
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public static method from exported class is using inaccessible module {0}.",
            code: 2064
        },
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of public method from exported class is using inaccessible module {0}.",
            code: 2065
        },
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of method from exported interface is using inaccessible module {0}.",
            code: 2066
        },
        Return_type_of_exported_function_is_using_inaccessible_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Return type of exported function is using inaccessible module {0}.",
            code: 2067
        },
        _new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
            code: 2068
        },
        A_parameter_list_must_follow_a_generic_type_argument_list______expected: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "A parameter list must follow a generic type argument list. '(' expected.",
            code: 2069
        },
        Multiple_constructor_implementations_are_not_allowed: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Multiple constructor implementations are not allowed.",
            code: 2070
        },
        Unable_to_resolve_external_module__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unable to resolve external module '{0}'.",
            code: 2071
        },
        Module_cannot_be_aliased_to_a_non_module_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Module cannot be aliased to a non-module type.",
            code: 2072
        },
        A_class_may_only_extend_another_class: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "A class may only extend another class.",
            code: 2073
        },
        A_class_may_only_implement_another_class_or_interface: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "A class may only implement another class or interface.",
            code: 2074
        },
        An_interface_may_only_extend_another_class_or_interface: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "An interface may only extend another class or interface.",
            code: 2075
        },
        An_interface_may_not_implement_another_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "An interface may not implement another type.",
            code: 2076
        },
        Unable_to_resolve_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unable to resolve type.",
            code: 2077
        },
        Unable_to_resolve_type_of__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unable to resolve type of '{0}'.",
            code: 2078
        },
        Unable_to_resolve_type_parameter_constraint: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unable to resolve type parameter constraint.",
            code: 2079
        },
        Type_parameter_constraint_may_not_be_a_primitive_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Type parameter constraint may not be a primitive type.",
            code: 2080
        },
        Supplied_parameters_do_not_match_any_signature_of_call_target: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Supplied parameters do not match any signature of call target.",
            code: 2081
        },
        Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Supplied parameters do not match any signature of call target:{NL}{0}",
            code: 2082
        },
        Invalid__new__expression: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Invalid 'new' expression.",
            code: 2083
        },
        Call_signatures_used_in_a__new__expression_must_have_a__void__return_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Call sigantures used in a 'new' expression must have a 'void' return type.",
            code: 2084
        },
        Could_not_select_overload_for__new__expression: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Could not select overload for 'new' expression.",
            code: 2085
        },
        Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.",
            code: 2086
        },
        Could_not_select_overload_for__call__expression: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Could not select overload for 'call' expression.",
            code: 2087
        },
        Unable_to_invoke_type_with_no_call_signatures: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Unable to invoke type with no call signatures.",
            code: 2088
        },
        Calls_to__super__are_only_valid_inside_a_class: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Calls to 'super' are only valid inside a class.",
            code: 2089
        },
        Generic_type__0__requires_1_type_argument_s_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Generic type '{0}' requires {1} type argument(s).",
            code: 2090
        },
        Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Type of conditional expression cannot be determined. Best common type could not be found between '{0}' and '{1}'.",
            code: 2091
        },
        Type_of_array_literal_cannot_be_determined__Best_common_type_could_not_be_found_for_array_elements: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
            code: 2092
        },
        Could_not_find_enclosing_symbol_for_dotted_name__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Could not find enclosing symbol for dotted name '{0}'.",
            code: 2093
        },
        Could_not_find_dotted_name__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Could not find dotted name '{0}'.",
            code: 2094
        },
        Could_not_find_symbol__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Could not find symbol '{0}'.",
            code: 2095
        },
        _get__and__set__accessor_must_have_the_same_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'get' and 'set' accessor must have the same type.",
            code: 2096
        },
        _this__may_not_be_referenced_in_current_location: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'this' may not be referenced in current location.",
            code: 2097
        },
        Use_of_deprecated__bool__type__Use__boolean__instead: {
            category: TypeScript.DiagnosticCategory.Warning,
            message: "Use of deprecated type 'bool'. Use 'boolean' instead.",
            code: 2098
        },
        Static_methods_may_not_reference_class_type_parameters: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Static methods may not reference class type parameters.",
            code: 2099
        },
        Class__0__is_recursively_referenced_as_a_base_type_of_itself: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Class '{0}' is recursively referenced as a base type of itself.",
            code: 2100
        },
        Interface__0__is_recursively_referenced_as_a_base_type_of_itself: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Interface '{0}' is recursively referenced as a base type of itself.",
            code: 2101
        },
        _super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'super' property access is permitted only in a constructor, instance member function, or instance member accessor of a derived class.",
            code: 2102
        },
        _super__may_not_be_referenced_in_non_derived_classes: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'super' may not be referenced in non-derived classes.",
            code: 2103
        },
        A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
            code: 2104
        },
        Constructors_for_derived_classes_must_contain_a__super__call: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Constructors for derived classes must contain a 'super' call.",
            code: 2105
        },
        Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Super calls are not permitted outside constructors or in local functions inside constructors.",
            code: 2106
        },
        _0_1__is_inaccessible: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'{0}.{1}' is inaccessible.",
            code: 2107
        },
        _this__cannot_be_referenced_within_module_bodies: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'this' cannot be referenced within module bodies.",
            code: 2108
        },
        _this__must_only_be_used_inside_a_function_or_script_context: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'this' must only be used inside a function or script context",
            code: 2109
        },
        VarArgs_must_be_array_types: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'...' parameters require both a parameter name and an array type annotation to be specified",
            code: 2110
        },
        Invalid__addition__expression___types_do_not_agree: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Invalid '+' expression - types do not agree.",
            code: 2111
        },
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
            code: 2112
        },
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
            code: 2113
        },
        The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.",
            code: 2114
        },
        Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Variable declarations for for/in expressions cannot contain a type annotation.",
            code: 2115
        },
        Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Variable declarations for for/in expressions must be of types 'string' or 'any'.",
            code: 2116
        },
        The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The right operand of a for/in expression must be of type 'any', an object type or a type parameter.",
            code: 2117
        },
        The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The left-hand side of an 'in' expression must be of types 'string' or 'any'.",
            code: 2118
        },
        The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
            code: 2119
        },
        The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The left-hand side of an 'instanceOf' expression must be of type 'any', an object type or a type parameter.",
            code: 2120
        },
        The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The right-hand side of an 'instanceOf' expression must be of type 'any' or a subtype of the 'Function' interface type.",
            code: 2121
        },
        Setters_may_not_return_a_value: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Setters may not return a value.",
            code: 2122
        },
        Tried_to_set_variable_type_to_uninitialized_module_type: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Tried to set variable type to uninitialized module type.",
            code: 2123
        },
        Tried_to_set_variable_type_to_uninitialized_module_type__0__: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Tried to set variable type to uninitialized module type '{0}'.",
            code: 2124
        },
        Function__0__declared_a_non_void_return_type__but_has_no_return_expression: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Function {0} declared a non-void return type, but has no return expression.",
            code: 2125
        },
        Getters_must_return_a_value: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Getters must return a value.",
            code: 2126
        },
        Getter_and_setter_accessors_do_not_agree_in_visibility: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Getter and setter accessors do not agree in visibility.",
            code: 2127
        },
        Invalid_left_hand_side_of_assignment_expression: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Invalid left-hand side of assignment expression.",
            code: 2130
        },
        Function_declared_a_non_void_return_type__but_has_no_return_expression: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Function declared a non-void return type, but has no return expression.",
            code: 2131
        },
        Cannot_resolve_return_type_reference: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Cannot resolve return type reference.",
            code: 2132
        },
        Constructors_cannot_have_a_return_type_of__void_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Constructors cannot have a return type of 'void'.",
            code: 2133
        },
        Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'",
            code: 2134
        },
        All_symbols_within_a__with__block_will_be_resolved_to__any__: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "All symbols within a with block will be resolved to 'any'",
            code: 2135
        },
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Import declarations in an internal module cannot reference an external module.",
            code: 2136
        },
        Class__0__declares_interface__1__but_does_not_implement_it__NL__2: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
            code: 2137
        },
        Class__0__declares_class__1__but_does_not_implement_it__NL__2: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Class {0} class interface {1} but does not implement it:{NL}{2}",
            code: 2138
        },
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "The operand of an increment or decrement operator must be a variable, property or indexer.",
            code: 2139
        },
        _this__may_not_be_referenced_in_initializers_in_a_class_body: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "'this' may not be referenced in initializers in a class body.",
            code: 2140
        },
        Class__0__cannot_extend_class__1__NL__2: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Class '{0}' cannot extend class '{1}':{NL}{2}",
            code: 2141
        },
        Interface__0__cannot_extend_class__1__NL__2: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
            code: 2142
        },
        Interface__0__cannot_extend_interface__1__NL__2: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
            code: 2143
        },
        Duplicate_overload_signature_for__0_: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Duplicate overload signature for '{0}'.",
            code: 2144
        },
        Duplicate_constructor_overload_signature: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Duplicate constructor overload signature.",
            code: 2145
        },
        Duplicate_overload_call_signature: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Duplicate overload call signature.",
            code: 2146
        },
        Duplicate_overload_construct_signature: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Duplicate overload construct signature.",
            code: 2147
        },
        Overload_signature_is_not_compatible_with_function_definition: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Overload signature is not compatible with function definition.",
            code: 2148
        },
        Overload_signature_is_not_compatible_with_function_definition__NL__0: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Overload signature is not compatible with function definition:{NL}{0}",
            code: 2149
        },
        Overload_signatures_must_all_be_public_or_private: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Overload signatures must all be public or private.",
            code: 2150
        },
        Overload_signatures_must_all_be_exported_or_local: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Overload signatures must all be exported or local.",
            code: 2151
        },
        Overload_signatures_must_all_be_ambient_or_non_ambient: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Overload signatures must all be ambient or non-ambient.",
            code: 2152
        },
        Overload_signatures_must_all_be_optional_or_required: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Overload signatures must all be optional or required.",
            code: 2153
        },
        Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature: {
            category: TypeScript.DiagnosticCategory.Error,
            message: "Specialized overload signature is not subtype of any non-specialized signature.",
            code: 2154
        },
        Type__0__is_missing_property__1__from_type__2_: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Type '{0}' is missing property '{1}' from type '{2}'.",
            code: 4000
        },
        Types_of_property__0__of_types__1__and__2__are_incompatible: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
            code: 4001
        },
        Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
            code: 4002
        },
        Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
            code: 4003
        },
        Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
            code: 4004
        },
        Types__0__and__1__define_property__2__as_private: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Types '{0}' and '{1}' define property '{2}' as private.",
            code: 4005
        },
        Call_signatures_of_types__0__and__1__are_incompatible: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Call signatures of types '{0}' and '{1}' are incompatible.",
            code: 4006
        },
        Call_signatures_of_types__0__and__1__are_incompatible__NL__2: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
            code: 4007
        },
        Type__0__requires_a_call_signature__but_Type__1__lacks_one: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
            code: 4008
        },
        Construct_signatures_of_types__0__and__1__are_incompatible: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Construct signatures of types '{0}' and '{1}' are incompatible.",
            code: 4009
        },
        Construct_signatures_of_types__0__and__1__are_incompatible__NL__2: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
            code: 40010
        },
        Type__0__requires_a_construct_signature__but_Type__1__lacks_one: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
            code: 4011
        },
        Index_signatures_of_types__0__and__1__are_incompatible: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Index signatures of types '{0}' and '{1}' are incompatible.",
            code: 4012
        },
        Index_signatures_of_types__0__and__1__are_incompatible__NL__2: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
            code: 4013
        },
        Call_signature_expects__0__or_fewer_parameters: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Call signature expects {0} or fewer parameters.",
            code: 4014
        },
        Could_not_apply_type__0__to_argument__1__which_is_of_type__2_: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Could not apply type'{0}' to argument {1} which is of type '{2}'.",
            code: 4015
        },
        Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
            code: 4016
        },
        Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
            code: 4017
        },
        Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
            code: 4018
        },
        Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
            code: 4019
        },
        Types_of_static_property__0__of_class__1__and_class__2__are_incompatible: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
            code: 4020
        },
        Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3: {
            category: TypeScript.DiagnosticCategory.NoPrefix,
            message: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
            code: 4021
        }
    };
    var seenCodes = [];
    for(var name in TypeScript.diagnosticMessages) {
        if (TypeScript.diagnosticMessages.hasOwnProperty(name)) {
            var diagnosticMessage = TypeScript.diagnosticMessages[name];
            var value = seenCodes[diagnosticMessage.code];
            if (value) {
                throw new Error("Duplicate diagnostic code: " + diagnosticMessage.code);
            }
            seenCodes[diagnosticMessage.code] = diagnosticMessage;
        }
    }
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() { }
        Errors.argument = function argument(argument, message) {
            return new Error("Invalid argument: " + argument + "." + (message ? (" " + message) : ""));
        };
        Errors.argumentOutOfRange = function argumentOutOfRange(argument) {
            return new Error("Argument out of range: " + argument + ".");
        };
        Errors.argumentNull = function argumentNull(argument) {
            return new Error("Argument null: " + argument + ".");
        };
        Errors.abstract = function abstract() {
            return new Error("Operation not implemented properly by subclass.");
        };
        Errors.notYetImplemented = function notYetImplemented() {
            return new Error("Not yet implemented.");
        };
        Errors.invalidOperation = function invalidOperation(message) {
            return new Error(message ? ("Invalid operation: " + message) : "Invalid operation.");
        };
        return Errors;
    })();
    TypeScript.Errors = Errors;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Hash = (function () {
        function Hash() { }
        Hash.FNV_BASE = 2166136261;
        Hash.FNV_PRIME = 16777619;
        Hash.computeFnv1aCharArrayHashCode = function computeFnv1aCharArrayHashCode(text, start, len) {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;
            for(var i = start; i < end; i++) {
                hashCode = (hashCode ^ text[i]) * Hash.FNV_PRIME;
            }
            return hashCode;
        };
        Hash.computeSimple31BitCharArrayHashCode = function computeSimple31BitCharArrayHashCode(key, start, len) {
            var hash = 0;
            for(var i = 0; i < len; i++) {
                var ch = key[start + i];
                hash = (((hash << 5) + hash) + ch) | 0;
            }
            return hash & 0x7FFFFFFF;
        };
        Hash.computeSimple31BitStringHashCode = function computeSimple31BitStringHashCode(key) {
            var hash = 0;
            var start = 0;
            var len = key.length;
            for(var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);
                hash = (((hash << 5) + hash) + ch) | 0;
            }
            return hash & 0x7FFFFFFF;
        };
        Hash.computeMurmur2CharArrayHashCode = function computeMurmur2CharArrayHashCode(key, start, len) {
            var m = 0x5bd1e995;
            var r = 24;
            var numberOfCharsLeft = len;
            var h = (0 ^ numberOfCharsLeft);
            var index = start;
            while(numberOfCharsLeft >= 2) {
                var c1 = key[index];
                var c2 = key[index + 1];
                var k = c1 | (c2 << 16);
                k *= m;
                k ^= k >> r;
                k *= m;
                h *= m;
                h ^= k;
                index += 2;
                numberOfCharsLeft -= 2;
            }
            if (numberOfCharsLeft === 1) {
                h ^= key[index];
                h *= m;
            }
            h ^= h >> 13;
            h *= m;
            h ^= h >> 15;
            return h;
        };
        Hash.computeMurmur2StringHashCode = function computeMurmur2StringHashCode(key) {
            var m = 0x5bd1e995;
            var r = 24;
            var start = 0;
            var len = key.length;
            var numberOfCharsLeft = len;
            var h = (0 ^ numberOfCharsLeft);
            var index = start;
            while(numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);
                var k = c1 | (c2 << 16);
                k *= m;
                k ^= k >> r;
                k *= m;
                h *= m;
                h ^= k;
                index += 2;
                numberOfCharsLeft -= 2;
            }
            if (numberOfCharsLeft === 1) {
                h ^= key.charCodeAt(index);
                h *= m;
            }
            h ^= h >> 13;
            h *= m;
            h ^= h >> 15;
            return h;
        };
        Hash.primes = [
            3, 
            7, 
            11, 
            17, 
            23, 
            29, 
            37, 
            47, 
            59, 
            71, 
            89, 
            107, 
            131, 
            163, 
            197, 
            239, 
            293, 
            353, 
            431, 
            521, 
            631, 
            761, 
            919, 
            1103, 
            1327, 
            1597, 
            1931, 
            2333, 
            2801, 
            3371, 
            4049, 
            4861, 
            5839, 
            7013, 
            8419, 
            10103, 
            12143, 
            14591, 
            17519, 
            21023, 
            25229, 
            30293, 
            36353, 
            43627, 
            52361, 
            62851, 
            75431, 
            90523, 
            108631, 
            130363, 
            156437, 
            187751, 
            225307, 
            270371, 
            324449, 
            389357, 
            467237, 
            560689, 
            672827, 
            807403, 
            968897, 
            1162687, 
            1395263, 
            1674319, 
            2009191, 
            2411033, 
            2893249, 
            3471899, 
            4166287, 
            4999559, 
            5999471, 
            7199369
        ];
        Hash.getPrime = function getPrime(min) {
            for(var i = 0; i < Hash.primes.length; i++) {
                var num = Hash.primes[i];
                if (num >= min) {
                    return num;
                }
            }
            throw TypeScript.Errors.notYetImplemented();
        };
        Hash.expandPrime = function expandPrime(oldSize) {
            var num = oldSize << 1;
            if (num > 2146435069 && 2146435069 > oldSize) {
                return 2146435069;
            }
            return Hash.getPrime(num);
        };
        Hash.combine = function combine(value, currentHash) {
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        };
        return Hash;
    })();
    TypeScript.Hash = Hash;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultHashTableCapacity = 256;
        var HashTableEntry = (function () {
            function HashTableEntry(Key, Value, HashCode, Next) {
                this.Key = Key;
                this.Value = Value;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return HashTableEntry;
        })();        
        var HashTable = (function () {
            function HashTable(capacity, hash, equals) {
                this.hash = hash;
                this.equals = equals;
                this.entries = [];
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.hash = hash;
                this.equals = equals;
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            HashTable.prototype.set = function (key, value) {
                this.addOrSet(key, value, false);
            };
            HashTable.prototype.add = function (key, value) {
                this.addOrSet(key, value, true);
            };
            HashTable.prototype.containsKey = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                return entry !== null;
            };
            HashTable.prototype.get = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                return entry === null ? null : entry.Value;
            };
            HashTable.prototype.computeHashCode = function (key) {
                var hashCode = this.hash === null ? key.hashCode() : this.hash(key);
                hashCode = hashCode & 0x7FFFFFFF;
                TypeScript.Debug.assert(hashCode > 0);
                return hashCode;
            };
            HashTable.prototype.addOrSet = function (key, value, throwOnExistingEntry) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                if (entry !== null) {
                    if (throwOnExistingEntry) {
                        throw TypeScript.Errors.argument('key', 'Key was already in table.');
                    }
                    entry.Key = key;
                    entry.Value = value;
                    return;
                }
                return this.addEntry(key, value, hashCode);
            };
            HashTable.prototype.findEntry = function (key, hashCode) {
                for(var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode) {
                        var equals = this.equals === null ? key === e.Key : this.equals(key, e.Key);
                        if (equals) {
                            return e;
                        }
                    }
                }
                return null;
            };
            HashTable.prototype.addEntry = function (key, value, hashCode) {
                var index = hashCode % this.entries.length;
                var e = new HashTableEntry(key, value, hashCode, this.entries[index]);
                this.entries[index] = e;
                if (this.count === this.entries.length) {
                    this.grow();
                }
                this.count++;
                return e.Key;
            };
            HashTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);
                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);
                this.entries = newEntries;
                for(var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];
                    while(e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };
            return HashTable;
        })();
        Collections.HashTable = HashTable;        
        function createHashTable(capacity, hash, equals) {
            if (typeof capacity === "undefined") { capacity = Collections.DefaultHashTableCapacity; }
            if (typeof hash === "undefined") { hash = null; }
            if (typeof equals === "undefined") { equals = null; }
            return new HashTable(capacity, hash, equals);
        }
        Collections.createHashTable = createHashTable;
        var currentHashCode = 1;
        function identityHashCode(value) {
            if (value.__hash === undefined) {
                value.__hash = currentHashCode;
                currentHashCode++;
            }
            return value.__hash;
        }
        Collections.identityHashCode = identityHashCode;
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Diagnostic = (function () {
        function Diagnostic(start, length, fileName, message) {
            this._fileName = fileName;
            this._start = start;
            this._length = length;
            this._message = message;
        }
        Diagnostic.prototype.fileName = function () {
            return this._fileName;
        };
        Diagnostic.prototype.start = function () {
            return this._start;
        };
        Diagnostic.prototype.length = function () {
            return this._length;
        };
        Diagnostic.prototype.message = function () {
            return this._message;
        };
        return Diagnostic;
    })();
    TypeScript.Diagnostic = Diagnostic;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IntegerUtilities = (function () {
        function IntegerUtilities() { }
        IntegerUtilities.integerDivide = function integerDivide(numerator, denominator) {
            return (numerator / denominator) >> 0;
        };
        IntegerUtilities.integerMultiplyLow32Bits = function integerMultiplyLow32Bits(n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;
            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;
            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        };
        IntegerUtilities.integerMultiplyHigh32Bits = function integerMultiplyHigh32Bits(n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;
            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;
            var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
            return resultHigh32;
        };
        return IntegerUtilities;
    })();
    TypeScript.IntegerUtilities = IntegerUtilities;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MathPrototype = (function () {
        function MathPrototype() { }
        MathPrototype.max = function max(a, b) {
            return a >= b ? a : b;
        };
        MathPrototype.min = function min(a, b) {
            return a <= b ? a : b;
        };
        return MathPrototype;
    })();
    TypeScript.MathPrototype = MathPrototype;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultStringTableCapacity = 256;
        var StringTableEntry = (function () {
            function StringTableEntry(Text, HashCode, Next) {
                this.Text = Text;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return StringTableEntry;
        })();        
        var StringTable = (function () {
            function StringTable(capacity) {
                this.entries = [];
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            StringTable.prototype.addCharArray = function (key, start, len) {
                var hashCode = TypeScript.Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;
                var entry = this.findCharArrayEntry(key, start, len, hashCode);
                if (entry !== null) {
                    return entry.Text;
                }
                var slice = key.slice(start, start + len);
                return this.addEntry(TypeScript.StringUtilities.fromCharCodeArray(slice), hashCode);
            };
            StringTable.prototype.findCharArrayEntry = function (key, start, len, hashCode) {
                for(var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                        return e;
                    }
                }
                return null;
            };
            StringTable.prototype.addEntry = function (text, hashCode) {
                var index = hashCode % this.entries.length;
                var e = new StringTableEntry(text, hashCode, this.entries[index]);
                this.entries[index] = e;
                if (this.count === this.entries.length) {
                    this.grow();
                }
                this.count++;
                return e.Text;
            };
            StringTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);
                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);
                this.entries = newEntries;
                for(var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];
                    while(e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };
            StringTable.textCharArrayEquals = function textCharArrayEquals(text, array, start, length) {
                if (text.length !== length) {
                    return false;
                }
                var s = start;
                for(var i = 0; i < length; i++) {
                    if (text.charCodeAt(i) !== array[s]) {
                        return false;
                    }
                    s++;
                }
                return true;
            };
            return StringTable;
        })();
        Collections.StringTable = StringTable;        
        Collections.DefaultStringTable = new StringTable(Collections.DefaultStringTableCapacity);
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() { }
        StringUtilities.fromCharCodeArray = function fromCharCodeArray(array) {
            return String.fromCharCode.apply(null, array);
        };
        StringUtilities.endsWith = function endsWith(string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };
        StringUtilities.startsWith = function startsWith(string, value) {
            return string.substr(0, value.length) === value;
        };
        StringUtilities.copyTo = function copyTo(source, sourceIndex, destination, destinationIndex, count) {
            for(var i = 0; i < count; i++) {
                destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
            }
        };
        StringUtilities.repeat = function repeat(value, count) {
            return Array(count + 1).join(value);
        };
        StringUtilities.stringEquals = function stringEquals(val1, val2) {
            return val1 === val2;
        };
        return StringUtilities;
    })();
    TypeScript.StringUtilities = StringUtilities;    
})(TypeScript || (TypeScript = {}));
var global = Function("return this").call(null);
var TypeScript;
(function (TypeScript) {
    var Clock;
    (function (Clock) {
        Clock.now;
        Clock.resolution;
                        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            global['WScript'].InitializeProjection();
            Clock.now = function () {
                return TestUtilities.QueryPerformanceCounter();
            };
            Clock.resolution = TestUtilities.QueryPerformanceFrequency();
        } else {
            Clock.now = function () {
                return Date.now();
            };
            Clock.resolution = 1000;
        }
    })(Clock || (Clock = {}));
    var Timer = (function () {
        function Timer() {
            this.time = 0;
        }
        Timer.prototype.start = function () {
            this.time = 0;
            this.startTime = Clock.now();
        };
        Timer.prototype.end = function () {
            this.time = (Clock.now() - this.startTime);
        };
        return Timer;
    })();
    TypeScript.Timer = Timer;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CharacterCodes) {
        CharacterCodes._map = [];
        CharacterCodes.nullCharacter = 0;
        CharacterCodes.maxAsciiCharacter = 127;
        CharacterCodes.lineFeed = 10;
        CharacterCodes.carriageReturn = 13;
        CharacterCodes.lineSeparator = 0x2028;
        CharacterCodes.paragraphSeparator = 0x2029;
        CharacterCodes.nextLine = 0x0085;
        CharacterCodes.space = 0x0020;
        CharacterCodes.nonBreakingSpace = 0x00A0;
        CharacterCodes.enQuad = 0x2000;
        CharacterCodes.emQuad = 0x2001;
        CharacterCodes.enSpace = 0x2002;
        CharacterCodes.emSpace = 0x2003;
        CharacterCodes.threePerEmSpace = 0x2004;
        CharacterCodes.fourPerEmSpace = 0x2005;
        CharacterCodes.sixPerEmSpace = 0x2006;
        CharacterCodes.figureSpace = 0x2007;
        CharacterCodes.punctuationSpace = 0x2008;
        CharacterCodes.thinSpace = 0x2009;
        CharacterCodes.hairSpace = 0x200A;
        CharacterCodes.zeroWidthSpace = 0x200B;
        CharacterCodes.narrowNoBreakSpace = 0x202F;
        CharacterCodes.ideographicSpace = 0x3000;
        CharacterCodes._ = 95;
        CharacterCodes.$ = 36;
        CharacterCodes._0 = 48;
        CharacterCodes._9 = 57;
        CharacterCodes.a = 97;
        CharacterCodes.b = 98;
        CharacterCodes.c = 99;
        CharacterCodes.d = 100;
        CharacterCodes.e = 101;
        CharacterCodes.f = 102;
        CharacterCodes.g = 103;
        CharacterCodes.h = 104;
        CharacterCodes.i = 105;
        CharacterCodes.k = 107;
        CharacterCodes.l = 108;
        CharacterCodes.m = 109;
        CharacterCodes.n = 110;
        CharacterCodes.o = 111;
        CharacterCodes.p = 112;
        CharacterCodes.r = 114;
        CharacterCodes.s = 115;
        CharacterCodes.t = 116;
        CharacterCodes.u = 117;
        CharacterCodes.v = 118;
        CharacterCodes.w = 119;
        CharacterCodes.x = 120;
        CharacterCodes.y = 121;
        CharacterCodes.z = 122;
        CharacterCodes.A = 65;
        CharacterCodes.E = 69;
        CharacterCodes.F = 70;
        CharacterCodes.X = 88;
        CharacterCodes.Z = 90;
        CharacterCodes.ampersand = 38;
        CharacterCodes.asterisk = 42;
        CharacterCodes.at = 64;
        CharacterCodes.backslash = 92;
        CharacterCodes.bar = 124;
        CharacterCodes.caret = 94;
        CharacterCodes.closeBrace = 125;
        CharacterCodes.closeBracket = 93;
        CharacterCodes.closeParen = 41;
        CharacterCodes.colon = 58;
        CharacterCodes.comma = 44;
        CharacterCodes.dot = 46;
        CharacterCodes.doubleQuote = 34;
        CharacterCodes.equals = 61;
        CharacterCodes.exclamation = 33;
        CharacterCodes.greaterThan = 62;
        CharacterCodes.lessThan = 60;
        CharacterCodes.minus = 45;
        CharacterCodes.openBrace = 123;
        CharacterCodes.openBracket = 91;
        CharacterCodes.openParen = 40;
        CharacterCodes.percent = 37;
        CharacterCodes.plus = 43;
        CharacterCodes.question = 63;
        CharacterCodes.semicolon = 59;
        CharacterCodes.singleQuote = 39;
        CharacterCodes.slash = 47;
        CharacterCodes.tilde = 126;
        CharacterCodes.backspace = 8;
        CharacterCodes.formFeed = 12;
        CharacterCodes.byteOrderMark = 0xFEFF;
        CharacterCodes.tab = 9;
        CharacterCodes.verticalTab = 11;
    })(TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
    var CharacterCodes = TypeScript.CharacterCodes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_lineStarts, length) {
            this._lineStarts = _lineStarts;
            this.length = length;
        }
        LineMap.empty = new LineMap([
            0
        ], 0);
        LineMap.prototype.toJSON = function (key) {
            return {
                lineStarts: this._lineStarts,
                length: this.length
            };
        };
        LineMap.prototype.equals = function (other) {
            return this.length === other.length && TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) {
                return v1 === v2;
            });
        };
        LineMap.prototype.lineStarts = function () {
            return this._lineStarts;
        };
        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };
        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };
        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            if (position === this.length) {
                return this.lineCount() - 1;
            }
            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }
            return lineNumber;
        };
        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };
        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };
        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };
        LineMap.fromSimpleText = function fromSimpleText(text) {
            var lineStarts = TypeScript.TextUtilities.parseLineStarts(text);
            return new LineMap(lineStarts, text.length());
        };
        LineMap.fromScriptSnapshot = function fromScriptSnapshot(scriptSnapshot) {
            return new LineMap(scriptSnapshot.getLineStartPositions(), scriptSnapshot.getLength());
        };
        LineMap.fromString = function fromString(text) {
            return LineMap.fromSimpleText(TypeScript.SimpleText.fromString(text));
        };
        return LineMap;
    })();
    TypeScript.LineMap = LineMap;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }
            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }
            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };
        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        return LineAndCharacter;
    })();
    TypeScript.LineAndCharacter = LineAndCharacter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TextFactory) {
        function getStartAndLengthOfLineBreakEndingAt(text, index, info) {
            var c = text.charCodeAt(index);
            if (c === TypeScript.CharacterCodes.lineFeed) {
                if (index > 0 && text.charCodeAt(index - 1) === TypeScript.CharacterCodes.carriageReturn) {
                    info.startPosition = index - 1;
                    info.length = 2;
                } else {
                    info.startPosition = index;
                    info.length = 1;
                }
            } else if (TypeScript.TextUtilities.isAnyLineBreakCharacter(c)) {
                info.startPosition = index;
                info.length = 1;
            } else {
                info.startPosition = index + 1;
                info.length = 0;
            }
        }
        var LinebreakInfo = (function () {
            function LinebreakInfo(startPosition, length) {
                this.startPosition = startPosition;
                this.length = length;
            }
            return LinebreakInfo;
        })();        
        var TextLine = (function () {
            function TextLine(text, body, lineBreakLength, lineNumber) {
                this._text = null;
                this._textSpan = null;
                TypeScript.Contract.throwIfNull(text);
                TypeScript.Contract.throwIfFalse(lineBreakLength >= 0);
                TypeScript.Contract.requires(lineNumber >= 0);
                this._text = text;
                this._textSpan = body;
                this._lineBreakLength = lineBreakLength;
                this._lineNumber = lineNumber;
            }
            TextLine.prototype.start = function () {
                return this._textSpan.start();
            };
            TextLine.prototype.end = function () {
                return this._textSpan.end();
            };
            TextLine.prototype.endIncludingLineBreak = function () {
                return this.end() + this._lineBreakLength;
            };
            TextLine.prototype.extent = function () {
                return this._textSpan;
            };
            TextLine.prototype.extentIncludingLineBreak = function () {
                return TypeScript.TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
            };
            TextLine.prototype.toString = function () {
                return this._text.toString(this._textSpan);
            };
            TextLine.prototype.lineNumber = function () {
                return this._lineNumber;
            };
            return TextLine;
        })();        
        var TextBase = (function () {
            function TextBase() {
                this.lazyLineStarts = null;
                this.linebreakInfo = new LinebreakInfo(0, 0);
                this.lastLineFoundForPosition = null;
            }
            TextBase.prototype.length = function () {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.charCodeAt = function (position) {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };
            TextBase.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.subText = function (span) {
                this.checkSubSpan(span);
                return new SubText(this, span);
            };
            TextBase.prototype.substr = function (start, length, intern) {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                throw TypeScript.Errors.abstract();
            };
            TextBase.prototype.lineCount = function () {
                return this.lineStarts().length;
            };
            TextBase.prototype.lines = function () {
                var lines = [];
                var length = this.lineCount();
                for(var i = 0; i < length; ++i) {
                    lines[i] = this.getLineFromLineNumber(i);
                }
                return lines;
            };
            TextBase.prototype.lineMap = function () {
                return new TypeScript.LineMap(this.lineStarts(), this.length());
            };
            TextBase.prototype.lineStarts = function () {
                if (this.lazyLineStarts === null) {
                    this.lazyLineStarts = TypeScript.TextUtilities.parseLineStarts(this);
                }
                return this.lazyLineStarts;
            };
            TextBase.prototype.getLineFromLineNumber = function (lineNumber) {
                var lineStarts = this.lineStarts();
                if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                    throw TypeScript.Errors.argumentOutOfRange("lineNumber");
                }
                var first = lineStarts[lineNumber];
                if (lineNumber === lineStarts.length - 1) {
                    return new TextLine(this, new TypeScript.TextSpan(first, this.length() - first), 0, lineNumber);
                } else {
                    getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                    return new TextLine(this, new TypeScript.TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
                }
            };
            TextBase.prototype.getLineFromPosition = function (position) {
                var lastFound = this.lastLineFoundForPosition;
                if (lastFound !== null && lastFound.start() <= position && lastFound.endIncludingLineBreak() > position) {
                    return lastFound;
                }
                var lineNumber = this.getLineNumberFromPosition(position);
                var result = this.getLineFromLineNumber(lineNumber);
                this.lastLineFoundForPosition = result;
                return result;
            };
            TextBase.prototype.getLineNumberFromPosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                if (position === this.length()) {
                    return this.lineCount() - 1;
                }
                var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
                if (lineNumber < 0) {
                    lineNumber = (~lineNumber) - 1;
                }
                return lineNumber;
            };
            TextBase.prototype.getLinePosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                var lineNumber = this.getLineNumberFromPosition(position);
                return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
            };
            return TextBase;
        })();        
        var SubText = (function (_super) {
            __extends(SubText, _super);
            function SubText(text, span) {
                _super.call(this);
                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }
                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }
                this.text = text;
                this.span = span;
            }
            SubText.prototype.length = function () {
                return this.span.length();
            };
            SubText.prototype.charCodeAt = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                return this.text.charCodeAt(this.span.start() + position);
            };
            SubText.prototype.subText = function (span) {
                this.checkSubSpan(span);
                return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };
            SubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };
            SubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };
            return SubText;
        })(TextBase);        
        var StringText = (function (_super) {
            __extends(StringText, _super);
            function StringText(data) {
                _super.call(this);
                this.source = null;
                if (data === null) {
                    throw TypeScript.Errors.argumentNull("data");
                }
                this.source = data;
            }
            StringText.prototype.length = function () {
                return this.source.length;
            };
            StringText.prototype.charCodeAt = function (position) {
                if (position < 0 || position >= this.source.length) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
                return this.source.charCodeAt(position);
            };
            StringText.prototype.substr = function (start, length, intern) {
                return this.source.substr(start, length);
            };
            StringText.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                if (span === null) {
                    span = new TypeScript.TextSpan(0, this.length());
                }
                this.checkSubSpan(span);
                if (span.start() === 0 && span.length() === this.length()) {
                    return this.source;
                }
                return this.source.substr(span.start(), span.length());
            };
            StringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
            };
            return StringText;
        })(TextBase);        
        function createText(value) {
            return new StringText(value);
        }
        TextFactory.createText = createText;
    })(TypeScript.TextFactory || (TypeScript.TextFactory = {}));
    var TextFactory = TypeScript.TextFactory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SimpleText) {
        var SimpleSubText = (function () {
            function SimpleSubText(text, span) {
                this.text = null;
                this.span = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }
                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }
                this.text = text;
                this.span = span;
            }
            SimpleSubText.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };
            SimpleSubText.prototype.checkSubPosition = function (position) {
                if (position < 0 || position >= this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
            };
            SimpleSubText.prototype.length = function () {
                return this.span.length();
            };
            SimpleSubText.prototype.subText = function (span) {
                this.checkSubSpan(span);
                return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };
            SimpleSubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };
            SimpleSubText.prototype.substr = function (start, length, intern) {
                var span = this.getCompositeSpan(start, length);
                return this.text.substr(span.start(), span.length(), intern);
            };
            SimpleSubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };
            SimpleSubText.prototype.charCodeAt = function (index) {
                this.checkSubPosition(index);
                return this.text.charCodeAt(this.span.start() + index);
            };
            SimpleSubText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            return SimpleSubText;
        })();        
        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };
            SimpleStringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
            };
            SimpleStringText.charArray = TypeScript.ArrayUtilities.createArray(1024, 0);
            SimpleStringText.prototype.substr = function (start, length, intern) {
                if (intern) {
                    var array = length <= SimpleStringText.charArray.length ? SimpleStringText.charArray : TypeScript.ArrayUtilities.createArray(length, 0);
                    this.copyTo(start, array, 0, length);
                    return TypeScript.Collections.DefaultStringTable.addCharArray(array, 0, length);
                }
                return this.value.substr(start, length);
            };
            SimpleStringText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };
            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };
            SimpleStringText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            return SimpleStringText;
        })();        
        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };
            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };
            SimpleScriptSnapshotText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var text = this.scriptSnapshot.getText(sourceIndex, sourceIndex + count);
                TypeScript.StringUtilities.copyTo(text, 0, destination, destinationIndex, count);
            };
            SimpleScriptSnapshotText.prototype.substr = function (start, length, intern) {
                return this.scriptSnapshot.getText(start, start + length);
            };
            SimpleScriptSnapshotText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };
            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var lineStartPositions = this.scriptSnapshot.getLineStartPositions();
                return new TypeScript.LineMap(lineStartPositions, this.length());
            };
            return SimpleScriptSnapshotText;
        })();        
        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;
        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(TypeScript.SimpleText || (TypeScript.SimpleText = {}));
    var SimpleText = TypeScript.SimpleText;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length();
            if (0 === length) {
                var result = [];
                result.push(0);
                return result;
            }
            var position = 0;
            var index = 0;
            var arrayBuilder = [];
            var lineNumber = 0;
            while(index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;
                if (c > TypeScript.CharacterCodes.carriageReturn && c <= 127) {
                    index++;
                    continue;
                } else if (c === TypeScript.CharacterCodes.carriageReturn && index + 1 < length && text.charCodeAt(index + 1) === TypeScript.CharacterCodes.lineFeed) {
                    lineBreakLength = 2;
                } else if (c === TypeScript.CharacterCodes.lineFeed) {
                    lineBreakLength = 1;
                } else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }
                if (0 === lineBreakLength) {
                    index++;
                } else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }
            arrayBuilder.push(position);
            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;
        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === TypeScript.CharacterCodes.carriageReturn) {
                var next = index + 1;
                return (next < text.length()) && TypeScript.CharacterCodes.lineFeed === text.charCodeAt(next) ? 2 : 1;
            } else if (isAnyLineBreakCharacter(c)) {
                return 1;
            } else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;
        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);
            if (c > TypeScript.CharacterCodes.carriageReturn && c <= 127) {
                return 0;
            }
            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;
        function isAnyLineBreakCharacter(c) {
            return c === TypeScript.CharacterCodes.lineFeed || c === TypeScript.CharacterCodes.carriageReturn || c === TypeScript.CharacterCodes.nextLine || c === TypeScript.CharacterCodes.lineSeparator || c === TypeScript.CharacterCodes.paragraphSeparator;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
    var TextUtilities = TypeScript.TextUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }
            if (start + length < start) {
                throw new Error("length");
            }
            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.start = function () {
            return this._start;
        };
        TextSpan.prototype.length = function () {
            return this._length;
        };
        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };
        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };
        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };
        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };
        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());
            return overlapStart < overlapEnd;
        };
        TextSpan.prototype.overlap = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());
            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }
            return null;
        };
        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };
        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };
        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };
        TextSpan.prototype.intersection = function (span) {
            var intersectStart = TypeScript.MathPrototype.max(this._start, span._start);
            var intersectEnd = TypeScript.MathPrototype.min(this.end(), span.end());
            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }
            return null;
        };
        TextSpan.fromBounds = function fromBounds(start, end) {
            TypeScript.Contract.requires(start >= 0);
            TypeScript.Contract.requires(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    })();
    TypeScript.TextSpan = TextSpan;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }
            this._span = span;
            this._newLength = newLength;
        }
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        TextChangeRange.prototype.span = function () {
            return this._span;
        };
        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };
        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };
        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };
        TextChangeRange.collapseChangesFromSingleVersion = function collapseChangesFromSingleVersion(changes) {
            var diff = 0;
            var start = TypeScript.Constants.Max31BitInteger;
            var end = 0;
            for(var i = 0; i < changes.length; i++) {
                var change = changes[i];
                diff += change.newLength() - change.span().length();
                if (change.span().start() < start) {
                    start = change.span().start();
                }
                if (change.span().end() > end) {
                    end = change.span().end();
                }
            }
            if (start > end) {
                return null;
            }
            var combined = TypeScript.TextSpan.fromBounds(start, end);
            var newLen = combined.length() + diff;
            return new TextChangeRange(combined, newLen);
        };
        TextChangeRange.collapseChangesAcrossMultipleVersions = function collapseChangesAcrossMultipleVersions(changes) {
            if (changes.length == 0) {
                return TextChangeRange.unchanged;
            }
            if (changes.length == 1) {
                return changes[0];
            }
            var change0 = changes[0];
            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();
            for(var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];
                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;
                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();
                oldStartN = TypeScript.MathPrototype.min(oldStart1, oldStart2);
                oldEndN = TypeScript.MathPrototype.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = TypeScript.MathPrototype.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }
            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        return TextChangeRange;
    })();
    TypeScript.TextChangeRange = TextChangeRange;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };
            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };
            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                return TypeScript.TextUtilities.parseLineStarts(TypeScript.SimpleText.fromString(this.text));
            };
            StringScriptSnapshot.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        })();        
        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
    var ScriptSnapshot = TypeScript.ScriptSnapshot;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StyleSettings = (function () {
        function StyleSettings() {
            this.bitwise = false;
            this.blockInCompoundStmt = false;
            this.eqeqeq = false;
            this.forin = false;
            this.emptyBlocks = true;
            this.newMustBeUsed = false;
            this.requireSemi = false;
            this.assignmentInCond = false;
            this.eqnull = false;
            this.evalOK = true;
            this.innerScopeDeclEscape = true;
            this.funcInLoop = true;
            this.reDeclareLocal = true;
            this.literalSubscript = true;
            this.implicitAny = false;
        }
        StyleSettings.prototype.setOption = function (opt, val) {
            var optExists = this[opt];
            if (optExists !== undefined) {
                this[opt] = val;
                return true;
            } else {
                return false;
            }
        };
        StyleSettings.prototype.parseOptions = function (str) {
            var opts = str.split(";");
            for(var i = 0, len = opts.length; i < len; i++) {
                var opt = opts[i];
                var val = true;
                var colonIndex = opt.lastIndexOf(":");
                if (colonIndex >= 0) {
                    var valStr = opt.substring(colonIndex + 1);
                    opt = opt.substring(0, colonIndex);
                    if (valStr == "off") {
                        val = false;
                    }
                }
                if (!this.setOption(opt, val)) {
                    return false;
                }
            }
            return true;
        };
        return StyleSettings;
    })();
    TypeScript.StyleSettings = StyleSettings;    
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.styleSettings = new StyleSettings();
            this.propagateConstants = false;
            this.minWhitespace = false;
            this.emitComments = false;
            this.watch = false;
            this.exec = false;
            this.resolve = true;
            this.controlFlow = false;
            this.printControlFlow = false;
            this.controlFlowUseDef = false;
            this.errorOnWith = true;
            this.canCallDefinitionSignature = false;
            this.disallowBool = false;
            this.useDefaultLib = true;
            this.codeGenTarget = TypeScript.LanguageVersion.EcmaScript3;
            this.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;
            this.optimizeModuleCodeGen = true;
            this.outputOption = "";
            this.mapSourceFiles = false;
            this.emitFullSourceMapPath = false;
            this.generateDeclarationFiles = false;
            this.useCaseSensitiveFileResolution = false;
            this.gatherDiagnostics = false;
            this.updateTC = false;
            this.parseOnly = false;
        }
        CompilationSettings.prototype.setStyleOptions = function (str) {
            this.styleSettings.parseOptions(str);
        };
        return CompilationSettings;
    })();
    TypeScript.CompilationSettings = CompilationSettings;    
    function getFileReferenceFromReferencePath(comment) {
        var referencesRegEx = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = referencesRegEx.exec(comment);
        if (match) {
            var path = TypeScript.normalizePath(match[3]);
            var adjustedPath = TypeScript.normalizePath(path);
            var isResident = match.length >= 7 && match[6] == "true";
            if (isResident) {
                TypeScript.CompilerDiagnostics.debugPrint(path + " is resident");
            }
            return {
                line: 0,
                character: 0,
                position: 0,
                length: 0,
                path: TypeScript.switchToForwardSlashes(adjustedPath),
                isResident: isResident
            };
        } else {
            return null;
        }
    }
    function getAdditionalDependencyPath(comment) {
        var amdDependencyRegEx = /^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = amdDependencyRegEx.exec(comment);
        if (match) {
            var path = match[3];
            return path;
        } else {
            return null;
        }
    }
    TypeScript.getAdditionalDependencyPath = getAdditionalDependencyPath;
    function getImplicitImport(comment) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(comment);
        if (match) {
            return true;
        }
        return false;
    }
    TypeScript.getImplicitImport = getImplicitImport;
    function getStyleSettings(comment, styleSettings) {
        var styleRegEx = /^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/gim;
        var settings = styleRegEx.exec(comment);
        if (settings) {
            var settingsRegEx = /^([a-zA-Z]+=['"]on['|"])/gim;
            settings = settingsRegEx.exec(settings[2]);
            if (settings) {
                for(var i = 0; i < settings.length; i++) {
                    var setting = (settings[i]).split("=");
                    var on = "\"on\"";
                    switch(setting[0]) {
                        case "blockInCompoundStmt":
                            styleSettings.blockInCompoundStmt = setting[1] == on;
                            break;
                        case "eqeqeq":
                            styleSettings.eqeqeq = setting[1] == on;
                            break;
                        case "forin":
                            styleSettings.forin = setting[1] == on;
                            break;
                        case "emptyBlocks":
                            styleSettings.emptyBlocks = setting[1] == on;
                            break;
                        case "newMustBeUsed":
                            styleSettings.newMustBeUsed = setting[1] == on;
                            break;
                        case "requireSemi":
                            styleSettings.requireSemi = setting[1] == on;
                            break;
                        case "assignmentInCond":
                            styleSettings.assignmentInCond = setting[1] == on;
                            break;
                        case "eqnull":
                            styleSettings.eqnull = setting[1] == on;
                            break;
                        case "evalOK":
                            styleSettings.evalOK = setting[1] == on;
                            break;
                        case "innerScopeDeclEscape":
                            styleSettings.innerScopeDeclEscape = setting[1] == on;
                            break;
                        case "funcInLoop":
                            styleSettings.funcInLoop = setting[1] == on;
                            break;
                        case "reDeclareLocal":
                            styleSettings.reDeclareLocal = setting[1] == on;
                            break;
                        case "literalSubscript":
                            styleSettings.literalSubscript = setting[1] == on;
                            break;
                        case "implicitAny":
                            styleSettings.implicitAny = setting[1] == on;
                            break;
                    }
                }
            }
        }
    }
    TypeScript.getStyleSettings = getStyleSettings;
    function getReferencedFiles(fileName, sourceText) {
        var preProcessInfo = preProcessFile(fileName, sourceText, null, false);
        return preProcessInfo.referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;
    var scannerWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
    var scannerDiagnostics = [];
    function processImports(lineMap, scanner, token, importedFiles) {
        var position = 0;
        var lineChar = {
            line: -1,
            character: -1
        };
        while(token.tokenKind !== TypeScript.SyntaxKind.EndOfFileToken) {
            if (token.tokenKind === TypeScript.SyntaxKind.ImportKeyword) {
                var importStart = position + token.leadingTriviaWidth();
                token = scanner.scan(scannerDiagnostics, false);
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(scannerDiagnostics, false);
                    if (token.tokenKind === TypeScript.SyntaxKind.EqualsToken) {
                        token = scanner.scan(scannerDiagnostics, false);
                        if (token.tokenKind === TypeScript.SyntaxKind.ModuleKeyword) {
                            token = scanner.scan(scannerDiagnostics, false);
                            if (token.tokenKind === TypeScript.SyntaxKind.OpenParenToken) {
                                var afterOpenParenPosition = scanner.absoluteIndex();
                                token = scanner.scan(scannerDiagnostics, false);
                                lineMap.fillLineAndCharacterFromPosition(importStart, lineChar);
                                if (token.tokenKind === TypeScript.SyntaxKind.StringLiteral) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: afterOpenParenPosition + token.leadingTriviaWidth(),
                                        length: token.width(),
                                        path: TypeScript.stripQuotes(TypeScript.switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }
            position = scanner.absoluteIndex();
            token = scanner.scan(scannerDiagnostics, false);
        }
    }
    function processTripleSlashDirectives(lineMap, firstToken, settings, referencedFiles) {
        var leadingTrivia = firstToken.leadingTrivia();
        var position = 0;
        var lineChar = {
            line: -1,
            character: -1
        };
        var noDefaultLib = false;
        for(var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);
            if (trivia.kind() === TypeScript.SyntaxKind.SingleLineCommentTrivia) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(triviaText);
                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;
                    referencedFiles.push(referencedCode);
                }
                if (settings) {
                    getStyleSettings(triviaText, settings.styleSettings);
                    var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    var isNoDefaultLibMatch = isNoDefaultLibRegex.exec(triviaText);
                    if (isNoDefaultLibMatch) {
                        noDefaultLib = (isNoDefaultLibMatch[3] == "true");
                    }
                }
            }
            position += trivia.fullWidth();
        }
        return {
            noDefaultLib: noDefaultLib
        };
    }
    TypeScript.processTripleSlashDirectives = processTripleSlashDirectives;
    function preProcessFile(fileName, sourceText, settings, readImportFiles) {
        if (typeof settings === "undefined") { settings = new CompilationSettings(); }
        if (typeof readImportFiles === "undefined") { readImportFiles = true; }
        var text = TypeScript.SimpleText.fromScriptSnapshot(sourceText);
        var scanner = new TypeScript.Scanner(fileName, text, TypeScript.LanguageVersion.EcmaScript5, scannerWindow);
        var firstToken = scanner.scan(scannerDiagnostics, false);
        var importedFiles = [];
        if (readImportFiles) {
            processImports(text.lineMap(), scanner, firstToken, importedFiles);
        }
        var referencedFiles = [];
        var properties = processTripleSlashDirectives(text.lineMap(), firstToken, settings, referencedFiles);
        scannerDiagnostics.length = 0;
        return {
            settings: settings,
            referencedFiles: referencedFiles,
            importedFiles: importedFiles,
            isLibFile: properties.noDefaultLib
        };
    }
    TypeScript.preProcessFile = preProcessFile;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclFileWriter = (function () {
        function DeclFileWriter(declFile) {
            this.declFile = declFile;
            this.onNewLine = true;
        }
        DeclFileWriter.prototype.Write = function (s) {
            this.declFile.Write(s);
            this.onNewLine = false;
        };
        DeclFileWriter.prototype.WriteLine = function (s) {
            this.declFile.WriteLine(s);
            this.onNewLine = true;
        };
        DeclFileWriter.prototype.Close = function () {
            try  {
                this.declFile.Close();
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };
        return DeclFileWriter;
    })();
    TypeScript.DeclFileWriter = DeclFileWriter;    
    var DeclarationEmitter = (function () {
        function DeclarationEmitter(emittingFileName, isUTF8, semanticInfoChain, emitOptions) {
            this.emittingFileName = emittingFileName;
            this.semanticInfoChain = semanticInfoChain;
            this.emitOptions = emitOptions;
            this.fileName = null;
            this.declFile = null;
            this.indenter = new TypeScript.Indenter();
            this.declarationContainerStack = [];
            this.isDottedModuleName = [];
            this.ignoreCallbackAst = null;
            this.singleDeclFile = null;
            this.varListCount = 0;
            var file = this.createFile(emittingFileName, isUTF8);
            this.declFile = new DeclFileWriter(file);
        }
        DeclarationEmitter.prototype.close = function () {
            try  {
                this.declFile.Close();
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };
        DeclarationEmitter.prototype.createFile = function (fileName, useUTF8) {
            try  {
                return this.emitOptions.ioHost.createFile(fileName, useUTF8);
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };
        DeclarationEmitter.prototype.emitDeclarations = function (script) {
            TypeScript.AstWalkerWithDetailCallback.walk(script, this);
        };
        DeclarationEmitter.prototype.getAstDeclarationContainer = function () {
            return this.declarationContainerStack[this.declarationContainerStack.length - 1];
        };
        DeclarationEmitter.prototype.emitDottedModuleName = function () {
            return (this.isDottedModuleName.length === 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];
        };
        DeclarationEmitter.prototype.getIndentString = function (declIndent) {
            if (typeof declIndent === "undefined") { declIndent = false; }
            if (this.emitOptions.compilationSettings.minWhitespace) {
                return "";
            } else {
                return this.indenter.getIndent();
            }
        };
        DeclarationEmitter.prototype.emitIndent = function () {
            this.declFile.Write(this.getIndentString());
        };
        DeclarationEmitter.prototype.canEmitSignature = function (declFlags, canEmitGlobalAmbientDecl, useDeclarationContainerTop) {
            if (typeof canEmitGlobalAmbientDecl === "undefined") { canEmitGlobalAmbientDecl = true; }
            if (typeof useDeclarationContainerTop === "undefined") { useDeclarationContainerTop = true; }
            var container;
            if (useDeclarationContainerTop) {
                container = this.getAstDeclarationContainer();
            } else {
                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];
            }
            if (container.nodeType === TypeScript.NodeType.ModuleDeclaration && !TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Exported)) {
                return false;
            }
            if (!canEmitGlobalAmbientDecl && container.nodeType === TypeScript.NodeType.Script && TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Ambient)) {
                return false;
            }
            return true;
        };
        DeclarationEmitter.prototype.canEmitPrePostAstSignature = function (declFlags, astWithPrePostCallback, preCallback) {
            if (this.ignoreCallbackAst) {
                TypeScript.CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");
                this.ignoreCallbackAst = null;
                return false;
            } else if (preCallback && !this.canEmitSignature(declFlags, true, preCallback)) {
                this.ignoreCallbackAst = astWithPrePostCallback;
                return false;
            }
            return true;
        };
        DeclarationEmitter.prototype.getDeclFlagsString = function (declFlags, typeString) {
            var result = this.getIndentString();
            if (TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Static)) {
                if (TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Private)) {
                    result += "private ";
                }
                result += "static ";
            } else {
                if (TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Private)) {
                    result += "private ";
                } else if (TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Public)) {
                    result += "public ";
                } else {
                    var emitDeclare = !TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Exported);
                    var container = this.getAstDeclarationContainer();
                    if (container.nodeType === TypeScript.NodeType.ModuleDeclaration && TypeScript.hasFlag((container).getModuleFlags(), TypeScript.ModuleFlags.IsWholeFile) && TypeScript.hasFlag(declFlags, TypeScript.DeclFlags.Exported)) {
                        result += "export ";
                        emitDeclare = true;
                    }
                    if (emitDeclare && typeString != "interface") {
                        result += "declare ";
                    }
                    result += typeString + " ";
                }
            }
            return result;
        };
        DeclarationEmitter.prototype.emitDeclFlags = function (declFlags, typeString) {
            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));
        };
        DeclarationEmitter.prototype.canEmitTypeAnnotationSignature = function (declFlag) {
            if (typeof declFlag === "undefined") { declFlag = TypeScript.DeclFlags.None; }
            return !TypeScript.hasFlag(declFlag, TypeScript.DeclFlags.Private);
        };
        DeclarationEmitter.prototype.pushDeclarationContainer = function (ast) {
            this.declarationContainerStack.push(ast);
        };
        DeclarationEmitter.prototype.popDeclarationContainer = function (ast) {
            TypeScript.CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), 'Declaration container mismatch');
            this.declarationContainerStack.pop();
        };
        DeclarationEmitter.prototype.emitTypeNamesMember = function (memberName, emitIndent) {
            if (typeof emitIndent === "undefined") { emitIndent = false; }
            if (memberName.prefix === "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix != "") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }
            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write((memberName).text);
            } else {
                var ar = memberName;
                for(var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim === "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }
            if (memberName.suffix === "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        };
        DeclarationEmitter.prototype.emitTypeSignature = function (type) {
            var declarationContainerAst = this.getAstDeclarationContainer();
            var declarationPullSymbol = this.semanticInfoChain.getSymbolForAST(declarationContainerAst, this.fileName);
            var typeNameMembers = type.getScopedNameEx(declarationPullSymbol);
            this.emitTypeNamesMember(typeNameMembers);
        };
        DeclarationEmitter.prototype.emitComment = function (comment) {
            var text = comment.getText();
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (!comment.isBlockComment) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }
            this.declFile.Write(text[0]);
            for(var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }
            if (comment.endsLine || !comment.isBlockComment) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        };
        DeclarationEmitter.prototype.emitDeclarationComments = function (astOrSymbol, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (!this.emitOptions.compilationSettings.emitComments) {
                return;
            }
            var declComments = astOrSymbol.getDocComments();
            this.writeDeclarationComments(declComments, endLine);
        };
        DeclarationEmitter.prototype.writeDeclarationComments = function (declComments, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (declComments.length > 0) {
                for(var i = 0; i < declComments.length; i++) {
                    this.emitComment(declComments[i]);
                }
                if (endLine) {
                    if (!this.declFile.onNewLine) {
                        this.declFile.WriteLine("");
                    }
                } else {
                    if (this.declFile.onNewLine) {
                        this.emitIndent();
                    }
                }
            }
        };
        DeclarationEmitter.prototype.emitTypeOfBoundDecl = function (boundDecl) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(boundDecl, this.fileName);
            var type = pullSymbol.getType();
            if (!type) {
                return;
            }
            if (boundDecl.typeExpr || (boundDecl.init && type != this.semanticInfoChain.anyTypeSymbol)) {
                this.declFile.Write(": ");
                this.emitTypeSignature(type);
            }
        };
        DeclarationEmitter.prototype.VariableDeclaratorCallback = function (pre, varDecl) {
            if (pre && this.canEmitSignature(TypeScript.ToDeclFlags(varDecl.getVarFlags()), false)) {
                var interfaceMember = (this.getAstDeclarationContainer().nodeType === TypeScript.NodeType.InterfaceDeclaration);
                this.emitDeclarationComments(varDecl);
                if (!interfaceMember) {
                    if (this.varListCount >= 0) {
                        this.emitDeclFlags(TypeScript.ToDeclFlags(varDecl.getVarFlags()), "var");
                        this.varListCount = -this.varListCount;
                    }
                    this.declFile.Write(varDecl.id.text);
                } else {
                    this.emitIndent();
                    this.declFile.Write(varDecl.id.text);
                    if (TypeScript.hasFlag(varDecl.id.getFlags(), TypeScript.ASTFlags.OptionalName)) {
                        this.declFile.Write("?");
                    }
                }
                if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(varDecl.getVarFlags()))) {
                    this.emitTypeOfBoundDecl(varDecl);
                }
                if (this.varListCount > 0) {
                    this.varListCount--;
                } else if (this.varListCount < 0) {
                    this.varListCount++;
                }
                if (this.varListCount < 0) {
                    this.declFile.Write(", ");
                } else {
                    this.declFile.WriteLine(";");
                }
            }
            return false;
        };
        DeclarationEmitter.prototype.BlockCallback = function (pre, block) {
            return false;
        };
        DeclarationEmitter.prototype.VariableStatementCallback = function (pre, variableDeclaration) {
            return true;
        };
        DeclarationEmitter.prototype.VariableDeclarationCallback = function (pre, variableDeclaration) {
            if (pre) {
                this.varListCount = variableDeclaration.declarators.members.length;
            } else {
                this.varListCount = 0;
            }
            return true;
        };
        DeclarationEmitter.prototype.emitArgDecl = function (argDecl, funcDecl) {
            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.id.text);
            if (argDecl.isOptionalArg()) {
                this.declFile.Write("?");
            }
            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.emitTypeOfBoundDecl(argDecl);
            }
        };
        DeclarationEmitter.prototype.isOverloadedCallSignature = function (funcDecl) {
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl, this.fileName);
            var funcTypeSymbol = funcSymbol.getType();
            var signatures = funcTypeSymbol.getCallSignatures();
            return signatures && signatures.length > 1;
        };
        DeclarationEmitter.prototype.FunctionDeclarationCallback = function (pre, funcDecl) {
            if (!pre) {
                return false;
            }
            if (funcDecl.isAccessor()) {
                return this.emitPropertyAccessorSignature(funcDecl);
            }
            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType === TypeScript.NodeType.InterfaceDeclaration);
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl, this.fileName);
            var funcTypeSymbol = funcSymbol.getType();
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return false;
                } else if (this.isOverloadedCallSignature(funcDecl)) {
                    return false;
                }
            } else if (!isInterfaceMember && TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Private) && this.isOverloadedCallSignature(funcDecl)) {
                var callSignatures = funcTypeSymbol.getCallSignatures();
                TypeScript.Debug.assert(callSignatures && callSignatures.length > 1);
                var firstSignature = callSignatures[0].isDefinition() ? callSignatures[1] : callSignatures[0];
                var firstSignatureDecl = firstSignature.getDeclarations()[0];
                var firstFuncDecl = this.semanticInfoChain.getASTForDecl(firstSignatureDecl);
                if (firstFuncDecl != funcDecl) {
                    return false;
                }
            }
            if (!this.canEmitSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), false)) {
                return false;
            }
            var funcSignature = this.semanticInfoChain.getDeclForAST(funcDecl, this.fileName).getSignatureSymbol();
            this.emitDeclarationComments(funcDecl);
            if (funcDecl.isConstructor) {
                this.emitIndent();
                this.declFile.Write("constructor");
                this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
            } else {
                var id = funcDecl.getNameText();
                if (!isInterfaceMember) {
                    this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), "function");
                    if (id != "__missing" || !funcDecl.name || !funcDecl.name.isMissing()) {
                        this.declFile.Write(id);
                    } else if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    }
                    this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                } else {
                    this.emitIndent();
                    if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {
                        this.declFile.Write(id);
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                        if (TypeScript.hasFlag(funcDecl.name.getFlags(), TypeScript.ASTFlags.OptionalName)) {
                            this.declFile.Write("? ");
                        }
                    } else {
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                    }
                }
            }
            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write("(");
            } else {
                this.declFile.Write("[");
            }
            this.indenter.increaseIndent();
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }
                for(var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    this.emitArgDecl(argDecl, funcDecl);
                    if (i < (argsLen - 1)) {
                        this.declFile.Write(", ");
                    }
                }
            }
            if (funcDecl.variableArgList) {
                var lastArg = funcDecl.arguments.members[funcDecl.arguments.members.length - 1];
                if (funcDecl.arguments.members.length > 1) {
                    this.declFile.Write(", ...");
                } else {
                    this.declFile.Write("...");
                }
                this.emitArgDecl(lastArg, funcDecl);
            }
            this.indenter.decreaseIndent();
            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write(")");
            } else {
                this.declFile.Write("]");
            }
            if (!funcDecl.isConstructor && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                var returnType = funcSignature.getReturnType();
                if (funcDecl.returnTypeAnnotation || (returnType && returnType != this.semanticInfoChain.anyTypeSymbol)) {
                    this.declFile.Write(": ");
                    this.emitTypeSignature(returnType);
                }
            }
            this.declFile.WriteLine(";");
            return false;
        };
        DeclarationEmitter.prototype.emitBaseExpression = function (bases, index) {
            var baseType = this.semanticInfoChain.getSymbolForAST(bases.members[index], this.fileName);
            this.emitTypeSignature(baseType);
        };
        DeclarationEmitter.prototype.emitBaseList = function (typeDecl, useExtendsList) {
            var bases = useExtendsList ? typeDecl.extendsList : typeDecl.implementsList;
            if (bases && (bases.members.length > 0)) {
                var qual = useExtendsList ? "extends" : "implements";
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.members.length;
                for(var i = 0; i < basesLen; i++) {
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    this.emitBaseExpression(bases, i);
                }
            }
        };
        DeclarationEmitter.prototype.emitAccessorDeclarationComments = function (funcDecl) {
            if (!this.emitOptions.compilationSettings.emitComments) {
                return;
            }
            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.fileName);
            var comments = [];
            if (accessors.getter) {
                comments = comments.concat(accessors.getter.getDocComments());
            }
            if (accessors.setter) {
                comments = comments.concat(accessors.setter.getDocComments());
            }
            this.writeDeclarationComments(comments);
        };
        DeclarationEmitter.prototype.emitPropertyAccessorSignature = function (funcDecl) {
            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.fileName);
            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor) && accessorSymbol.getGetter()) {
                return false;
            }
            this.emitAccessorDeclarationComments(funcDecl);
            this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), "var");
            this.declFile.Write(funcDecl.name.text);
            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.declFile.Write(" : ");
                var type = accessorSymbol.getType();
                this.emitTypeSignature(type);
            }
            this.declFile.WriteLine(";");
            return false;
        };
        DeclarationEmitter.prototype.emitClassMembersFromConstructorDefinition = function (funcDecl) {
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }
                for(var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    if (TypeScript.hasFlag(argDecl.getVarFlags(), TypeScript.VariableFlags.Property)) {
                        this.emitDeclarationComments(argDecl);
                        this.emitDeclFlags(TypeScript.ToDeclFlags(argDecl.getVarFlags()), "var");
                        this.declFile.Write(argDecl.id.text);
                        if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(argDecl.getVarFlags()))) {
                            this.emitTypeOfBoundDecl(argDecl);
                        }
                        this.declFile.WriteLine(";");
                    }
                }
            }
        };
        DeclarationEmitter.prototype.ClassDeclarationCallback = function (pre, classDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(classDecl.getVarFlags()), classDecl, pre)) {
                return false;
            }
            if (pre) {
                var className = classDecl.name.text;
                this.emitDeclarationComments(classDecl);
                this.emitDeclFlags(TypeScript.ToDeclFlags(classDecl.getVarFlags()), "class");
                this.declFile.Write(className);
                this.pushDeclarationContainer(classDecl);
                this.emitTypeParameters(classDecl.typeParameters);
                this.emitBaseList(classDecl, true);
                this.emitBaseList(classDecl, false);
                this.declFile.WriteLine(" {");
                this.indenter.increaseIndent();
                if (classDecl.constructorDecl) {
                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);
                }
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(classDecl);
                this.emitIndent();
                this.declFile.WriteLine("}");
            }
            return true;
        };
        DeclarationEmitter.prototype.emitTypeParameters = function (typeParams, funcSignature) {
            if (!typeParams || !typeParams.members.length) {
                return;
            }
            this.declFile.Write("<");
            var containerAst = this.getAstDeclarationContainer();
            var containerSymbol = this.semanticInfoChain.getSymbolForAST(containerAst, this.fileName);
            var typars;
            if (funcSignature) {
                typars = funcSignature.getTypeParameters();
            } else {
                typars = containerSymbol.getTypeArguments();
                if (!typars || !typars.length) {
                    typars = containerSymbol.getTypeParameters();
                }
            }
            for(var i = 0; i < typars.length; i++) {
                if (i) {
                    this.declFile.Write(", ");
                }
                var memberName = typars[i].getScopedNameEx(containerSymbol, true);
                this.emitTypeNamesMember(memberName);
            }
            this.declFile.Write(">");
        };
        DeclarationEmitter.prototype.InterfaceDeclarationCallback = function (pre, interfaceDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), interfaceDecl, pre)) {
                return false;
            }
            if (pre) {
                var interfaceName = interfaceDecl.name.text;
                this.emitDeclarationComments(interfaceDecl);
                this.emitDeclFlags(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), "interface");
                this.declFile.Write(interfaceName);
                this.pushDeclarationContainer(interfaceDecl);
                this.emitTypeParameters(interfaceDecl.typeParameters);
                this.emitBaseList(interfaceDecl, true);
                this.declFile.WriteLine(" {");
                this.indenter.increaseIndent();
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(interfaceDecl);
                this.emitIndent();
                this.declFile.WriteLine("}");
            }
            return true;
        };
        DeclarationEmitter.prototype.ImportDeclarationCallback = function (pre, importDecl) {
            if (pre) {
                var importSymbol = this.semanticInfoChain.getSymbolForAST(importDecl, this.fileName);
                if (importSymbol.getTypeUsedExternally()) {
                    this.emitDeclarationComments(importDecl);
                    this.emitIndent();
                    this.declFile.Write("import ");
                    this.declFile.Write(importDecl.id.text + " = ");
                    if (importDecl.isDynamicImport) {
                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");
                    } else {
                        this.declFile.WriteLine(importDecl.getAliasName() + ";");
                    }
                }
            }
            return false;
        };
        DeclarationEmitter.prototype.emitEnumSignature = function (moduleDecl) {
            if (!this.canEmitSignature(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()))) {
                return false;
            }
            this.emitDeclarationComments(moduleDecl);
            this.emitDeclFlags(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), "enum");
            this.declFile.WriteLine(moduleDecl.name.text + " {");
            this.indenter.increaseIndent();
            var membersLen = moduleDecl.members.members.length;
            for(var j = 1; j < membersLen; j++) {
                var memberDecl = moduleDecl.members.members[j];
                if (memberDecl.nodeType === TypeScript.NodeType.VariableStatement) {
                    var variableStatement = memberDecl;
                    this.emitDeclarationComments(memberDecl);
                    this.emitIndent();
                    this.declFile.WriteLine((variableStatement.declaration.declarators.members[0]).id.text + ",");
                }
            }
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.declFile.WriteLine("}");
            return false;
        };
        DeclarationEmitter.prototype.ModuleDeclarationCallback = function (pre, moduleDecl) {
            if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.IsWholeFile)) {
                if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.IsDynamic)) {
                    if (pre) {
                        if (!this.emitOptions.outputMany) {
                            this.singleDeclFile = this.declFile;
                            TypeScript.CompilerDiagnostics.assert(this.indenter.indentAmt === 0, "Indent has to be 0 when outputing new file");
                            var declareFileName = this.emitOptions.mapOutputFileName(this.fileName, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.compilationSettings.emitComments && moduleDecl.containsUnicodeCharInComment);
                            this.declFile = new DeclFileWriter(this.createFile(declareFileName, useUTF8InOutputfile));
                        }
                        this.pushDeclarationContainer(moduleDecl);
                    } else {
                        if (!this.emitOptions.outputMany) {
                            TypeScript.CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");
                            TypeScript.CompilerDiagnostics.assert(this.indenter.indentAmt === 0, "Indent has to be 0 when outputing new file");
                            try  {
                                this.declFile.Close();
                            } catch (e) {
                                TypeScript.Emitter.throwEmitterError(e);
                            }
                            this.declFile = this.singleDeclFile;
                        }
                        this.popDeclarationContainer(moduleDecl);
                    }
                }
                return true;
            }
            if (moduleDecl.isEnum()) {
                if (pre) {
                    this.emitEnumSignature(moduleDecl);
                }
                return false;
            }
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), moduleDecl, pre)) {
                return false;
            }
            if (pre) {
                if (this.emitDottedModuleName()) {
                    this.dottedModuleEmit += ".";
                } else {
                    this.dottedModuleEmit = this.getDeclFlagsString(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), "module");
                }
                this.dottedModuleEmit += moduleDecl.name.text;
                var isCurrentModuleDotted = (moduleDecl.members.members.length === 1 && moduleDecl.members.members[0].nodeType === TypeScript.NodeType.ModuleDeclaration && !(moduleDecl.members.members[0]).isEnum() && TypeScript.hasFlag((moduleDecl.members.members[0]).getModuleFlags(), TypeScript.ModuleFlags.Exported));
                var moduleDeclComments = moduleDecl.getDocComments();
                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments === null || moduleDeclComments.length === 0);
                this.isDottedModuleName.push(isCurrentModuleDotted);
                this.pushDeclarationContainer(moduleDecl);
                if (!isCurrentModuleDotted) {
                    this.emitDeclarationComments(moduleDecl);
                    this.declFile.Write(this.dottedModuleEmit);
                    this.declFile.WriteLine(" {");
                    this.indenter.increaseIndent();
                }
            } else {
                if (!this.emitDottedModuleName()) {
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.declFile.WriteLine("}");
                }
                this.popDeclarationContainer(moduleDecl);
                this.isDottedModuleName.pop();
            }
            return true;
        };
        DeclarationEmitter.prototype.ScriptCallback = function (pre, script) {
            if (pre) {
                if (this.emitOptions.outputMany) {
                    for(var i = 0; i < script.referencedFiles.length; i++) {
                        var referencePath = script.referencedFiles[i].path;
                        var declareFileName;
                        if (TypeScript.isRooted(referencePath)) {
                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                        } else {
                            declareFileName = TypeScript.getDeclareFilePath(script.referencedFiles[i].path);
                        }
                        this.declFile.WriteLine('/// <reference path="' + declareFileName + '" />');
                    }
                }
                this.pushDeclarationContainer(script);
            } else {
                this.popDeclarationContainer(script);
            }
            return true;
        };
        DeclarationEmitter.prototype.DefaultCallback = function (pre, ast) {
            return !ast.isStatement();
        };
        return DeclarationEmitter;
    })();
    TypeScript.DeclarationEmitter = DeclarationEmitter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CharacterInfo = (function () {
        function CharacterInfo() { }
        CharacterInfo.isDecimalDigit = function isDecimalDigit(c) {
            return c >= TypeScript.CharacterCodes._0 && c <= TypeScript.CharacterCodes._9;
        };
        CharacterInfo.isHexDigit = function isHexDigit(c) {
            return CharacterInfo.isDecimalDigit(c) || (c >= TypeScript.CharacterCodes.A && c <= TypeScript.CharacterCodes.F) || (c >= TypeScript.CharacterCodes.a && c <= TypeScript.CharacterCodes.f);
        };
        CharacterInfo.hexValue = function hexValue(c) {
            return CharacterInfo.isDecimalDigit(c) ? (c - TypeScript.CharacterCodes._0) : (c >= TypeScript.CharacterCodes.A && c <= TypeScript.CharacterCodes.F) ? c - TypeScript.CharacterCodes.A + 10 : c - TypeScript.CharacterCodes.a + 10;
        };
        CharacterInfo.isWhitespace = function isWhitespace(ch) {
            switch(ch) {
                case TypeScript.CharacterCodes.space:
                case TypeScript.CharacterCodes.nonBreakingSpace:
                case TypeScript.CharacterCodes.enQuad:
                case TypeScript.CharacterCodes.emQuad:
                case TypeScript.CharacterCodes.enSpace:
                case TypeScript.CharacterCodes.emSpace:
                case TypeScript.CharacterCodes.threePerEmSpace:
                case TypeScript.CharacterCodes.fourPerEmSpace:
                case TypeScript.CharacterCodes.sixPerEmSpace:
                case TypeScript.CharacterCodes.figureSpace:
                case TypeScript.CharacterCodes.punctuationSpace:
                case TypeScript.CharacterCodes.thinSpace:
                case TypeScript.CharacterCodes.hairSpace:
                case TypeScript.CharacterCodes.zeroWidthSpace:
                case TypeScript.CharacterCodes.narrowNoBreakSpace:
                case TypeScript.CharacterCodes.ideographicSpace:
                case TypeScript.CharacterCodes.tab:
                case TypeScript.CharacterCodes.verticalTab:
                case TypeScript.CharacterCodes.formFeed:
                case TypeScript.CharacterCodes.byteOrderMark:
                    return true;
            }
            return false;
        };
        CharacterInfo.isLineTerminator = function isLineTerminator(ch) {
            switch(ch) {
                case TypeScript.CharacterCodes.carriageReturn:
                case TypeScript.CharacterCodes.lineFeed:
                case TypeScript.CharacterCodes.paragraphSeparator:
                case TypeScript.CharacterCodes.lineSeparator:
                    return true;
            }
            return false;
        };
        return CharacterInfo;
    })();
    TypeScript.CharacterInfo = CharacterInfo;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxConstants) {
        SyntaxConstants._map = [];
        SyntaxConstants.TriviaNewLineMask = 0x00000001;
        SyntaxConstants.TriviaCommentMask = 0x00000002;
        SyntaxConstants.TriviaFullWidthShift = 2;
        SyntaxConstants.NodeDataComputed = 0x00000001;
        SyntaxConstants.NodeIncrementallyUnusableMask = 0x00000002;
        SyntaxConstants.NodeParsedInStrictModeMask = 0x00000004;
        SyntaxConstants.NodeFullWidthShift = 3;
    })(TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
    var SyntaxConstants = TypeScript.SyntaxConstants;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Diagnostic1 = (function () {
        function Diagnostic1(diagnosticCode, arguments) {
            this._diagnosticCode = diagnosticCode;
            this._arguments = (arguments && arguments.length > 0) ? arguments : null;
        }
        Diagnostic1.prototype.diagnosticCode = function () {
            return this._diagnosticCode;
        };
        Diagnostic1.prototype.additionalLocations = function () {
            return [];
        };
        Diagnostic1.prototype.message = function () {
            return getDiagnosticMessage(this._diagnosticCode, this._arguments);
        };
        Diagnostic1.equals = function equals(diagnostic1, diagnostic2) {
            return diagnostic1._diagnosticCode === diagnostic2._diagnosticCode && TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) {
                return v1 === v2;
            });
        };
        return Diagnostic1;
    })();
    TypeScript.Diagnostic1 = Diagnostic1;    
    function getLargestIndex(diagnostic) {
        var largest = -1;
        var stringComponents = diagnostic.split("_");
        for(var i = 0; i < stringComponents.length; i++) {
            var val = parseInt(stringComponents[i]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }
        return largest;
    }
    function getDiagnosticMessage(diagnosticType, args) {
        var diagnosticName = (TypeScript.DiagnosticCode)._map[diagnosticType];
        var diagnostic = TypeScript.diagnosticMessages[diagnosticName];
        var actualCount = args ? args.length : 0;
        if (!diagnostic) {
            throw new Error("Invalid diagnostic");
        } else {
            var expectedCount = 1 + getLargestIndex(diagnosticName);
            if (expectedCount !== actualCount) {
                throw new Error("Expected " + expectedCount + " arguments to diagnostic, got " + actualCount + " instead");
            }
        }
        var diagnosticMessage = diagnostic.message.replace(/{({(\d+)})?TB}/g, function (match, p1, num) {
            var tabChar = "\t";
            var result = tabChar;
            if (num && args[num]) {
                for(var i = 1; i < args[num]; i++) {
                    result += tabChar;
                }
            }
            return result;
        });
        diagnosticMessage = diagnosticMessage.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });
        diagnosticMessage = diagnosticMessage.replace(/{(NL)}/g, function (match) {
            return "\r\n";
        });
        var message;
        if (diagnostic.category == TypeScript.DiagnosticCategory.Error) {
            message = getDiagnosticMessage(TypeScript.DiagnosticCode.error_TS_0__1, [
                diagnostic.code, 
                diagnosticMessage
            ]);
        } else if (diagnostic.category == TypeScript.DiagnosticCategory.Warning) {
            message = getDiagnosticMessage(TypeScript.DiagnosticCode.warning_TS_0__1, [
                diagnostic.code, 
                diagnosticMessage
            ]);
        } else {
            message = diagnosticMessage;
        }
        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
var FormattingOptions = (function () {
    function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
        this.useTabs = useTabs;
        this.spacesPerTab = spacesPerTab;
        this.indentSpaces = indentSpaces;
        this.newLineCharacter = newLineCharacter;
    }
    FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
    return FormattingOptions;
})();
var TypeScript;
(function (TypeScript) {
    (function (Indentation) {
        function columnForEndOfToken(token, syntaxInformationMap, options) {
            return columnForStartOfToken(token, syntaxInformationMap, options) + token.width();
        }
        Indentation.columnForEndOfToken = columnForEndOfToken;
        function columnForStartOfToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];
            var current = token;
            while(current !== firstTokenInLine) {
                current = syntaxInformationMap.previousToken(current);
                if (current === firstTokenInLine) {
                    leadingTextInReverse.push(current.trailingTrivia().fullText());
                    leadingTextInReverse.push(current.text());
                } else {
                    leadingTextInReverse.push(current.fullText());
                }
            }
            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);
            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfToken = columnForStartOfToken;
        function columnForStartOfFirstTokenInLineContainingToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];
            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);
            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfFirstTokenInLineContainingToken = columnForStartOfFirstTokenInLineContainingToken;
        function collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse) {
            var leadingTrivia = firstTokenInLine.leadingTrivia();
            for(var i = leadingTrivia.count() - 1; i >= 0; i--) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.kind() === TypeScript.SyntaxKind.NewLineTrivia) {
                    break;
                }
                if (trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
                    var lineSegments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    leadingTextInReverse.push(TypeScript.ArrayUtilities.last(lineSegments));
                    if (lineSegments.length > 0) {
                        break;
                    }
                }
                leadingTextInReverse.push(trivia.fullText());
            }
        }
        function columnForLeadingTextInReverse(leadingTextInReverse, options) {
            var column = 0;
            for(var i = leadingTextInReverse.length - 1; i >= 0; i--) {
                var text = leadingTextInReverse[i];
                column = columnForPositionInStringWorker(text, text.length, column, options);
            }
            return column;
        }
        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;
        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;
            for(var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);
                if (ch === TypeScript.CharacterCodes.tab) {
                    column += spacesPerTab - column % spacesPerTab;
                } else {
                    column++;
                }
            }
            return column;
        }
        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = TypeScript.MathPrototype.max(0, column);
            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }
            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) + TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;
        function indentationTrivia(column, options) {
            return TypeScript.Syntax.whitespace(this.indentationString(column, options));
        }
        Indentation.indentationTrivia = indentationTrivia;
        function firstNonWhitespacePosition(value) {
            for(var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }
            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(TypeScript.Indentation || (TypeScript.Indentation = {}));
    var Indentation = TypeScript.Indentation;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (LanguageVersion) {
        LanguageVersion._map = [];
        LanguageVersion._map[0] = "EcmaScript3";
        LanguageVersion.EcmaScript3 = 0;
        LanguageVersion._map[1] = "EcmaScript5";
        LanguageVersion.EcmaScript5 = 1;
    })(TypeScript.LanguageVersion || (TypeScript.LanguageVersion = {}));
    var LanguageVersion = TypeScript.LanguageVersion;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ParseOptions = (function () {
        function ParseOptions(allowAutomaticSemicolonInsertion) {
            if (typeof allowAutomaticSemicolonInsertion === "undefined") { allowAutomaticSemicolonInsertion = true; }
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
        }
        ParseOptions.prototype.toJSON = function (key) {
            return {
                allowAutomaticSemicolonInsertion: this._allowAutomaticSemicolonInsertion
            };
        };
        ParseOptions.prototype.allowAutomaticSemicolonInsertion = function () {
            return this._allowAutomaticSemicolonInsertion;
        };
        return ParseOptions;
    })();
    TypeScript.ParseOptions = ParseOptions;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionedElement = (function () {
        function PositionedElement(parent, element, fullStart) {
            this._parent = parent;
            this._element = element;
            this._fullStart = fullStart;
        }
        PositionedElement.create = function create(parent, element, fullStart) {
            if (element === null) {
                return null;
            }
            if (element.isNode()) {
                return new PositionedNode(parent, element, fullStart);
            } else if (element.isToken()) {
                return new PositionedToken(parent, element, fullStart);
            } else if (element.isList()) {
                return new PositionedList(parent, element, fullStart);
            } else if (element.isSeparatedList()) {
                return new PositionedSeparatedList(parent, element, fullStart);
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        };
        PositionedElement.prototype.parent = function () {
            return this._parent;
        };
        PositionedElement.prototype.parentElement = function () {
            return this._parent && this._parent._element;
        };
        PositionedElement.prototype.element = function () {
            return this._element;
        };
        PositionedElement.prototype.kind = function () {
            return this.element().kind();
        };
        PositionedElement.prototype.childCount = function () {
            return this.element().childCount();
        };
        PositionedElement.prototype.childAt = function (index) {
            var offset = 0;
            for(var i = 0; i < index; i++) {
                offset += this.element().childAt(i).fullWidth();
            }
            return PositionedElement.create(this, this.element().childAt(index), offset);
        };
        PositionedElement.prototype.getPositionedChild = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return PositionedElement.create(this, child, offset);
        };
        PositionedElement.prototype.fullStart = function () {
            return this._fullStart;
        };
        PositionedElement.prototype.fullEnd = function () {
            return this.fullStart() + this.element().fullWidth();
        };
        PositionedElement.prototype.fullWidth = function () {
            return this.element().fullWidth();
        };
        PositionedElement.prototype.start = function () {
            return this.fullStart() + this.element().leadingTriviaWidth();
        };
        PositionedElement.prototype.end = function () {
            return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
        };
        PositionedElement.prototype.root = function () {
            var current = this;
            while(current.parent() !== null) {
                current = current.parent();
            }
            return current;
        };
        PositionedElement.prototype.containingNode = function () {
            var current = this.parent();
            while(current !== null && !current.element().isNode()) {
                current = current.parent();
            }
            return current;
        };
        return PositionedElement;
    })();
    TypeScript.PositionedElement = PositionedElement;    
    var PositionedNodeOrToken = (function (_super) {
        __extends(PositionedNodeOrToken, _super);
        function PositionedNodeOrToken(parent, nodeOrToken, fullStart) {
            _super.call(this, parent, nodeOrToken, fullStart);
        }
        PositionedNodeOrToken.prototype.nodeOrToken = function () {
            return this.element();
        };
        return PositionedNodeOrToken;
    })(PositionedElement);
    TypeScript.PositionedNodeOrToken = PositionedNodeOrToken;    
    var PositionedNode = (function (_super) {
        __extends(PositionedNode, _super);
        function PositionedNode(parent, node, fullStart) {
            _super.call(this, parent, node, fullStart);
        }
        PositionedNode.prototype.node = function () {
            return this.element();
        };
        return PositionedNode;
    })(PositionedNodeOrToken);
    TypeScript.PositionedNode = PositionedNode;    
    var PositionedToken = (function (_super) {
        __extends(PositionedToken, _super);
        function PositionedToken(parent, token, fullStart) {
            _super.call(this, parent, token, fullStart);
        }
        PositionedToken.prototype.token = function () {
            return this.element();
        };
        PositionedToken.prototype.previousToken = function () {
            var fullStart = this.fullStart();
            if (fullStart === 0) {
                return null;
            }
            return this.root().node().findToken(fullStart - 1);
        };
        PositionedToken.prototype.nextToken = function () {
            if (this.token().tokenKind === TypeScript.SyntaxKind.EndOfFileToken) {
                return null;
            }
            return this.root().node().findToken(this.fullEnd());
        };
        return PositionedToken;
    })(PositionedNodeOrToken);
    TypeScript.PositionedToken = PositionedToken;    
    var PositionedList = (function (_super) {
        __extends(PositionedList, _super);
        function PositionedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedList.prototype.list = function () {
            return this.element();
        };
        return PositionedList;
    })(PositionedElement);
    TypeScript.PositionedList = PositionedList;    
    var PositionedSeparatedList = (function (_super) {
        __extends(PositionedSeparatedList, _super);
        function PositionedSeparatedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedSeparatedList.prototype.list = function () {
            return this.element();
        };
        return PositionedSeparatedList;
    })(PositionedElement);
    TypeScript.PositionedSeparatedList = PositionedSeparatedList;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Scanner = (function () {
        function Scanner(fileName, text, languageVersion, window) {
            if (typeof window === "undefined") { window = TypeScript.ArrayUtilities.createArray(2048, 0); }
            Scanner.initializeStaticData();
            this.slidingWindow = new TypeScript.SlidingWindow(this, window, 0, text.length());
            this.fileName = fileName;
            this.text = text;
            this._languageVersion = languageVersion;
        }
        Scanner.isKeywordStartCharacter = [];
        Scanner.isIdentifierStartCharacter = [];
        Scanner.isIdentifierPartCharacter = [];
        Scanner.isNumericLiteralStart = [];
        Scanner.initializeStaticData = function initializeStaticData() {
            if (Scanner.isKeywordStartCharacter.length === 0) {
                Scanner.isKeywordStartCharacter = TypeScript.ArrayUtilities.createArray(TypeScript.CharacterCodes.maxAsciiCharacter, false);
                Scanner.isIdentifierStartCharacter = TypeScript.ArrayUtilities.createArray(TypeScript.CharacterCodes.maxAsciiCharacter, false);
                Scanner.isIdentifierPartCharacter = TypeScript.ArrayUtilities.createArray(TypeScript.CharacterCodes.maxAsciiCharacter, false);
                Scanner.isNumericLiteralStart = TypeScript.ArrayUtilities.createArray(TypeScript.CharacterCodes.maxAsciiCharacter, false);
                for(var character = 0; character < TypeScript.CharacterCodes.maxAsciiCharacter; character++) {
                    if (character >= TypeScript.CharacterCodes.a && character <= TypeScript.CharacterCodes.z) {
                        Scanner.isIdentifierStartCharacter[character] = true;
                        Scanner.isIdentifierPartCharacter[character] = true;
                    } else if ((character >= TypeScript.CharacterCodes.A && character <= TypeScript.CharacterCodes.Z) || character === TypeScript.CharacterCodes._ || character === TypeScript.CharacterCodes.$) {
                        Scanner.isIdentifierStartCharacter[character] = true;
                        Scanner.isIdentifierPartCharacter[character] = true;
                    } else if (character >= TypeScript.CharacterCodes._0 && character <= TypeScript.CharacterCodes._9) {
                        Scanner.isIdentifierPartCharacter[character] = true;
                        Scanner.isNumericLiteralStart[character] = true;
                    }
                }
                Scanner.isNumericLiteralStart[TypeScript.CharacterCodes.dot] = true;
                for(var keywordKind = TypeScript.SyntaxKind.FirstKeyword; keywordKind <= TypeScript.SyntaxKind.LastKeyword; keywordKind++) {
                    var keyword = TypeScript.SyntaxFacts.getText(keywordKind);
                    Scanner.isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
                }
            }
        };
        Scanner.prototype.languageVersion = function () {
            return this._languageVersion;
        };
        Scanner.prototype.fetchMoreItems = function (argument, sourceIndex, window, destinationIndex, spaceAvailable) {
            var charactersRemaining = this.text.length() - sourceIndex;
            var amountToRead = TypeScript.MathPrototype.min(charactersRemaining, spaceAvailable);
            this.text.copyTo(sourceIndex, window, destinationIndex, amountToRead);
            return amountToRead;
        };
        Scanner.prototype.currentCharCode = function () {
            return this.slidingWindow.currentItem(null);
        };
        Scanner.prototype.absoluteIndex = function () {
            return this.slidingWindow.absoluteIndex();
        };
        Scanner.prototype.setAbsoluteIndex = function (index) {
            this.slidingWindow.setAbsoluteIndex(index);
        };
        Scanner.prototype.scan = function (diagnostics, allowRegularExpression) {
            var diagnosticsLength = diagnostics.length;
            var fullStart = this.slidingWindow.absoluteIndex();
            var leadingTriviaInfo = this.scanTriviaInfo(diagnostics, false);
            var start = this.slidingWindow.absoluteIndex();
            var kind = this.scanSyntaxToken(diagnostics, allowRegularExpression);
            var end = this.slidingWindow.absoluteIndex();
            var trailingTriviaInfo = this.scanTriviaInfo(diagnostics, true);
            var token = this.createToken(fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo);
            return diagnosticsLength !== diagnostics.length ? TypeScript.Syntax.realizeToken(token) : token;
        };
        Scanner.prototype.createToken = function (fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo) {
            if (kind >= TypeScript.SyntaxKind.FirstFixedWidth) {
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.FixedWidthTokenWithNoTrivia(kind);
                    } else {
                        return new TypeScript.Syntax.FixedWidthTokenWithTrailingTrivia(this.text, fullStart, kind, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo);
                } else {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
                }
            } else {
                var width = end - start;
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.VariableWidthTokenWithNoTrivia(this.text, fullStart, kind, width);
                    } else {
                        return new TypeScript.Syntax.VariableWidthTokenWithTrailingTrivia(this.text, fullStart, kind, width, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width);
                } else {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
                }
            }
        };
        Scanner.triviaWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
        Scanner.scanTrivia = function scanTrivia(text, start, length, isTrailing) {
            var scanner = new Scanner(null, text.subText(new TypeScript.TextSpan(start, length)), TypeScript.LanguageVersion.EcmaScript5, Scanner.triviaWindow);
            return scanner.scanTrivia(isTrailing);
        };
        Scanner.prototype.scanTrivia = function (isTrailing) {
            var trivia = [];
            while(true) {
                if (!this.slidingWindow.isAtEndOfSource()) {
                    var ch = this.currentCharCode();
                    switch(ch) {
                        case TypeScript.CharacterCodes.space:
                        case TypeScript.CharacterCodes.nonBreakingSpace:
                        case TypeScript.CharacterCodes.enQuad:
                        case TypeScript.CharacterCodes.emQuad:
                        case TypeScript.CharacterCodes.enSpace:
                        case TypeScript.CharacterCodes.emSpace:
                        case TypeScript.CharacterCodes.threePerEmSpace:
                        case TypeScript.CharacterCodes.fourPerEmSpace:
                        case TypeScript.CharacterCodes.sixPerEmSpace:
                        case TypeScript.CharacterCodes.figureSpace:
                        case TypeScript.CharacterCodes.punctuationSpace:
                        case TypeScript.CharacterCodes.thinSpace:
                        case TypeScript.CharacterCodes.hairSpace:
                        case TypeScript.CharacterCodes.zeroWidthSpace:
                        case TypeScript.CharacterCodes.narrowNoBreakSpace:
                        case TypeScript.CharacterCodes.ideographicSpace:
                        case TypeScript.CharacterCodes.tab:
                        case TypeScript.CharacterCodes.verticalTab:
                        case TypeScript.CharacterCodes.formFeed:
                        case TypeScript.CharacterCodes.byteOrderMark:
                            trivia.push(this.scanWhitespaceTrivia());
                            continue;
                        case TypeScript.CharacterCodes.slash:
                            var ch2 = this.slidingWindow.peekItemN(1);
                            if (ch2 === TypeScript.CharacterCodes.slash) {
                                trivia.push(this.scanSingleLineCommentTrivia());
                                continue;
                            }
                            if (ch2 === TypeScript.CharacterCodes.asterisk) {
                                trivia.push(this.scanMultiLineCommentTrivia());
                                continue;
                            }
                            throw TypeScript.Errors.invalidOperation();
                        case TypeScript.CharacterCodes.carriageReturn:
                        case TypeScript.CharacterCodes.lineFeed:
                        case TypeScript.CharacterCodes.paragraphSeparator:
                        case TypeScript.CharacterCodes.lineSeparator:
                            trivia.push(this.scanLineTerminatorSequenceTrivia(ch));
                            if (!isTrailing) {
                                continue;
                            }
                            break;
                        default:
                            throw TypeScript.Errors.invalidOperation();
                    }
                }
                return TypeScript.Syntax.triviaList(trivia);
            }
        };
        Scanner.prototype.scanTriviaInfo = function (diagnostics, isTrailing) {
            var width = 0;
            var hasCommentOrNewLine = 0;
            while(true) {
                var ch = this.currentCharCode();
                switch(ch) {
                    case TypeScript.CharacterCodes.space:
                    case TypeScript.CharacterCodes.nonBreakingSpace:
                    case TypeScript.CharacterCodes.enQuad:
                    case TypeScript.CharacterCodes.emQuad:
                    case TypeScript.CharacterCodes.enSpace:
                    case TypeScript.CharacterCodes.emSpace:
                    case TypeScript.CharacterCodes.threePerEmSpace:
                    case TypeScript.CharacterCodes.fourPerEmSpace:
                    case TypeScript.CharacterCodes.sixPerEmSpace:
                    case TypeScript.CharacterCodes.figureSpace:
                    case TypeScript.CharacterCodes.punctuationSpace:
                    case TypeScript.CharacterCodes.thinSpace:
                    case TypeScript.CharacterCodes.hairSpace:
                    case TypeScript.CharacterCodes.zeroWidthSpace:
                    case TypeScript.CharacterCodes.narrowNoBreakSpace:
                    case TypeScript.CharacterCodes.ideographicSpace:
                    case TypeScript.CharacterCodes.tab:
                    case TypeScript.CharacterCodes.verticalTab:
                    case TypeScript.CharacterCodes.formFeed:
                    case TypeScript.CharacterCodes.byteOrderMark:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;
                    case TypeScript.CharacterCodes.slash:
                        var ch2 = this.slidingWindow.peekItemN(1);
                        if (ch2 === TypeScript.CharacterCodes.slash) {
                            hasCommentOrNewLine |= TypeScript.SyntaxConstants.TriviaCommentMask;
                            width += this.scanSingleLineCommentTriviaLength();
                            continue;
                        }
                        if (ch2 === TypeScript.CharacterCodes.asterisk) {
                            hasCommentOrNewLine |= TypeScript.SyntaxConstants.TriviaCommentMask;
                            width += this.scanMultiLineCommentTriviaLength(diagnostics);
                            continue;
                        }
                        break;
                    case TypeScript.CharacterCodes.carriageReturn:
                    case TypeScript.CharacterCodes.lineFeed:
                    case TypeScript.CharacterCodes.paragraphSeparator:
                    case TypeScript.CharacterCodes.lineSeparator:
                        hasCommentOrNewLine |= TypeScript.SyntaxConstants.TriviaNewLineMask;
                        width += this.scanLineTerminatorSequenceLength(ch);
                        if (!isTrailing) {
                            continue;
                        }
                        break;
                }
                return (width << TypeScript.SyntaxConstants.TriviaFullWidthShift) | hasCommentOrNewLine;
            }
        };
        Scanner.prototype.isNewLineCharacter = function (ch) {
            switch(ch) {
                case TypeScript.CharacterCodes.carriageReturn:
                case TypeScript.CharacterCodes.lineFeed:
                case TypeScript.CharacterCodes.paragraphSeparator:
                case TypeScript.CharacterCodes.lineSeparator:
                    return true;
                default:
                    return false;
            }
        };
        Scanner.prototype.scanWhitespaceTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = 0;
            while(true) {
                var ch = this.currentCharCode();
                switch(ch) {
                    case TypeScript.CharacterCodes.space:
                    case TypeScript.CharacterCodes.nonBreakingSpace:
                    case TypeScript.CharacterCodes.enQuad:
                    case TypeScript.CharacterCodes.emQuad:
                    case TypeScript.CharacterCodes.enSpace:
                    case TypeScript.CharacterCodes.emSpace:
                    case TypeScript.CharacterCodes.threePerEmSpace:
                    case TypeScript.CharacterCodes.fourPerEmSpace:
                    case TypeScript.CharacterCodes.sixPerEmSpace:
                    case TypeScript.CharacterCodes.figureSpace:
                    case TypeScript.CharacterCodes.punctuationSpace:
                    case TypeScript.CharacterCodes.thinSpace:
                    case TypeScript.CharacterCodes.hairSpace:
                    case TypeScript.CharacterCodes.zeroWidthSpace:
                    case TypeScript.CharacterCodes.narrowNoBreakSpace:
                    case TypeScript.CharacterCodes.ideographicSpace:
                    case TypeScript.CharacterCodes.tab:
                    case TypeScript.CharacterCodes.verticalTab:
                    case TypeScript.CharacterCodes.formFeed:
                    case TypeScript.CharacterCodes.byteOrderMark:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;
                }
                break;
            }
            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
            return TypeScript.Syntax.whitespace(text);
        };
        Scanner.prototype.scanSingleLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanSingleLineCommentTriviaLength();
            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
            return TypeScript.Syntax.singleLineComment(text);
        };
        Scanner.prototype.scanSingleLineCommentTriviaLength = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();
            var width = 2;
            while(true) {
                if (this.slidingWindow.isAtEndOfSource() || this.isNewLineCharacter(this.currentCharCode())) {
                    return width;
                }
                this.slidingWindow.moveToNextItem();
                width++;
            }
        };
        Scanner.prototype.scanMultiLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanMultiLineCommentTriviaLength(null);
            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
            return TypeScript.Syntax.multiLineComment(text);
        };
        Scanner.prototype.scanMultiLineCommentTriviaLength = function (diagnostics) {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();
            var width = 2;
            while(true) {
                if (this.slidingWindow.isAtEndOfSource()) {
                    if (diagnostics !== null) {
                        diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, this.slidingWindow.absoluteIndex(), 0, TypeScript.DiagnosticCode._StarSlash__expected, null));
                    }
                    return width;
                }
                var ch = this.currentCharCode();
                if (ch === TypeScript.CharacterCodes.asterisk && this.slidingWindow.peekItemN(1) === TypeScript.CharacterCodes.slash) {
                    this.slidingWindow.moveToNextItem();
                    this.slidingWindow.moveToNextItem();
                    width += 2;
                    return width;
                }
                this.slidingWindow.moveToNextItem();
                width++;
            }
        };
        Scanner.prototype.scanLineTerminatorSequenceTrivia = function (ch) {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanLineTerminatorSequenceLength(ch);
            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
            return TypeScript.Syntax.trivia(TypeScript.SyntaxKind.NewLineTrivia, text);
        };
        Scanner.prototype.scanLineTerminatorSequenceLength = function (ch) {
            this.slidingWindow.moveToNextItem();
            if (ch === TypeScript.CharacterCodes.carriageReturn && this.currentCharCode() === TypeScript.CharacterCodes.lineFeed) {
                this.slidingWindow.moveToNextItem();
                return 2;
            } else {
                return 1;
            }
        };
        Scanner.prototype.scanSyntaxToken = function (diagnostics, allowRegularExpression) {
            if (this.slidingWindow.isAtEndOfSource()) {
                return TypeScript.SyntaxKind.EndOfFileToken;
            }
            var character = this.currentCharCode();
            switch(character) {
                case TypeScript.CharacterCodes.doubleQuote:
                case TypeScript.CharacterCodes.singleQuote:
                    return this.scanStringLiteral(diagnostics);
                case TypeScript.CharacterCodes.slash:
                    return this.scanSlashToken(allowRegularExpression);
                case TypeScript.CharacterCodes.dot:
                    return this.scanDotToken();
                case TypeScript.CharacterCodes.minus:
                    return this.scanMinusToken();
                case TypeScript.CharacterCodes.exclamation:
                    return this.scanExclamationToken();
                case TypeScript.CharacterCodes.equals:
                    return this.scanEqualsToken();
                case TypeScript.CharacterCodes.bar:
                    return this.scanBarToken();
                case TypeScript.CharacterCodes.asterisk:
                    return this.scanAsteriskToken();
                case TypeScript.CharacterCodes.plus:
                    return this.scanPlusToken();
                case TypeScript.CharacterCodes.percent:
                    return this.scanPercentToken();
                case TypeScript.CharacterCodes.ampersand:
                    return this.scanAmpersandToken();
                case TypeScript.CharacterCodes.caret:
                    return this.scanCaretToken();
                case TypeScript.CharacterCodes.lessThan:
                    return this.scanLessThanToken();
                case TypeScript.CharacterCodes.greaterThan:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.GreaterThanToken);
                case TypeScript.CharacterCodes.comma:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.CommaToken);
                case TypeScript.CharacterCodes.colon:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.ColonToken);
                case TypeScript.CharacterCodes.semicolon:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.SemicolonToken);
                case TypeScript.CharacterCodes.tilde:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.TildeToken);
                case TypeScript.CharacterCodes.openParen:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.OpenParenToken);
                case TypeScript.CharacterCodes.closeParen:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.CloseParenToken);
                case TypeScript.CharacterCodes.openBrace:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.OpenBraceToken);
                case TypeScript.CharacterCodes.closeBrace:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.CloseBraceToken);
                case TypeScript.CharacterCodes.openBracket:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.OpenBracketToken);
                case TypeScript.CharacterCodes.closeBracket:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.CloseBracketToken);
                case TypeScript.CharacterCodes.question:
                    return this.advanceAndSetTokenKind(TypeScript.SyntaxKind.QuestionToken);
            }
            if (Scanner.isNumericLiteralStart[character]) {
                return this.scanNumericLiteral();
            }
            if (Scanner.isIdentifierStartCharacter[character]) {
                var result = this.tryFastScanIdentifierOrKeyword(character);
                if (result !== TypeScript.SyntaxKind.None) {
                    return result;
                }
            }
            if (this.isIdentifierStart(this.peekCharOrUnicodeEscape())) {
                return this.slowScanIdentifier(diagnostics);
            }
            return this.scanDefaultCharacter(character, diagnostics);
        };
        Scanner.prototype.isIdentifierStart = function (interpretedChar) {
            if (Scanner.isIdentifierStartCharacter[interpretedChar]) {
                return true;
            }
            return interpretedChar > TypeScript.CharacterCodes.maxAsciiCharacter && TypeScript.Unicode.isIdentifierStart(interpretedChar, this._languageVersion);
        };
        Scanner.prototype.isIdentifierPart = function (interpretedChar) {
            if (Scanner.isIdentifierPartCharacter[interpretedChar]) {
                return true;
            }
            return interpretedChar > TypeScript.CharacterCodes.maxAsciiCharacter && TypeScript.Unicode.isIdentifierPart(interpretedChar, this._languageVersion);
        };
        Scanner.prototype.tryFastScanIdentifierOrKeyword = function (firstCharacter) {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            while(true) {
                var character = this.currentCharCode();
                if (Scanner.isIdentifierPartCharacter[character]) {
                    this.slidingWindow.moveToNextItem();
                } else if (character === TypeScript.CharacterCodes.backslash || character > TypeScript.CharacterCodes.maxAsciiCharacter) {
                    this.slidingWindow.rewindToPinnedIndex(startIndex);
                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return TypeScript.SyntaxKind.None;
                } else {
                    var endIndex = this.slidingWindow.absoluteIndex();
                    var kind;
                    if (Scanner.isKeywordStartCharacter[firstCharacter]) {
                        var offset = startIndex - this.slidingWindow.windowAbsoluteStartIndex;
                        kind = TypeScript.ScannerUtilities.identifierKind(this.slidingWindow.window, offset, endIndex - startIndex);
                    } else {
                        kind = TypeScript.SyntaxKind.IdentifierName;
                    }
                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return kind;
                }
            }
        };
        Scanner.prototype.slowScanIdentifier = function (diagnostics) {
            var startIndex = this.slidingWindow.absoluteIndex();
            do {
                this.scanCharOrUnicodeEscape(diagnostics);
            } while(this.isIdentifierPart(this.peekCharOrUnicodeEscape()));
            return TypeScript.SyntaxKind.IdentifierName;
        };
        Scanner.prototype.scanNumericLiteral = function () {
            if (this.isHexNumericLiteral()) {
                return this.scanHexNumericLiteral();
            } else {
                return this.scanDecimalNumericLiteral();
            }
        };
        Scanner.prototype.scanDecimalNumericLiteral = function () {
            while(TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }
            if (this.currentCharCode() === TypeScript.CharacterCodes.dot) {
                this.slidingWindow.moveToNextItem();
            }
            while(TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }
            var ch = this.currentCharCode();
            if (ch === TypeScript.CharacterCodes.e || ch === TypeScript.CharacterCodes.E) {
                this.slidingWindow.moveToNextItem();
                ch = this.currentCharCode();
                if (ch === TypeScript.CharacterCodes.minus || ch === TypeScript.CharacterCodes.plus) {
                    if (TypeScript.CharacterInfo.isDecimalDigit(this.slidingWindow.peekItemN(1))) {
                        this.slidingWindow.moveToNextItem();
                    }
                }
            }
            while(TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }
            return TypeScript.SyntaxKind.NumericLiteral;
        };
        Scanner.prototype.scanHexNumericLiteral = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();
            while(TypeScript.CharacterInfo.isHexDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }
            return TypeScript.SyntaxKind.NumericLiteral;
        };
        Scanner.prototype.isHexNumericLiteral = function () {
            if (this.currentCharCode() === TypeScript.CharacterCodes._0) {
                var ch = this.slidingWindow.peekItemN(1);
                if (ch === TypeScript.CharacterCodes.x || ch === TypeScript.CharacterCodes.X) {
                    ch = this.slidingWindow.peekItemN(2);
                    return TypeScript.CharacterInfo.isHexDigit(ch);
                }
            }
            return false;
        };
        Scanner.prototype.advanceAndSetTokenKind = function (kind) {
            this.slidingWindow.moveToNextItem();
            return kind;
        };
        Scanner.prototype.scanLessThanToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.LessThanEqualsToken;
            } else if (this.currentCharCode() === TypeScript.CharacterCodes.lessThan) {
                this.slidingWindow.moveToNextItem();
                if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                    this.slidingWindow.moveToNextItem();
                    return TypeScript.SyntaxKind.LessThanLessThanEqualsToken;
                } else {
                    return TypeScript.SyntaxKind.LessThanLessThanToken;
                }
            } else {
                return TypeScript.SyntaxKind.LessThanToken;
            }
        };
        Scanner.prototype.scanBarToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.BarEqualsToken;
            } else if (this.currentCharCode() === TypeScript.CharacterCodes.bar) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.BarBarToken;
            } else {
                return TypeScript.SyntaxKind.BarToken;
            }
        };
        Scanner.prototype.scanCaretToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.CaretEqualsToken;
            } else {
                return TypeScript.SyntaxKind.CaretToken;
            }
        };
        Scanner.prototype.scanAmpersandToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.AmpersandEqualsToken;
            } else if (this.currentCharCode() === TypeScript.CharacterCodes.ampersand) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.AmpersandAmpersandToken;
            } else {
                return TypeScript.SyntaxKind.AmpersandToken;
            }
        };
        Scanner.prototype.scanPercentToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.PercentEqualsToken;
            } else {
                return TypeScript.SyntaxKind.PercentToken;
            }
        };
        Scanner.prototype.scanMinusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.MinusEqualsToken;
            } else if (character === TypeScript.CharacterCodes.minus) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.MinusMinusToken;
            } else {
                return TypeScript.SyntaxKind.MinusToken;
            }
        };
        Scanner.prototype.scanPlusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.PlusEqualsToken;
            } else if (character === TypeScript.CharacterCodes.plus) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.PlusPlusToken;
            } else {
                return TypeScript.SyntaxKind.PlusToken;
            }
        };
        Scanner.prototype.scanAsteriskToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.AsteriskEqualsToken;
            } else {
                return TypeScript.SyntaxKind.AsteriskToken;
            }
        };
        Scanner.prototype.scanEqualsToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                    this.slidingWindow.moveToNextItem();
                    return TypeScript.SyntaxKind.EqualsEqualsEqualsToken;
                } else {
                    return TypeScript.SyntaxKind.EqualsEqualsToken;
                }
            } else if (character === TypeScript.CharacterCodes.greaterThan) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.EqualsGreaterThanToken;
            } else {
                return TypeScript.SyntaxKind.EqualsToken;
            }
        };
        Scanner.prototype.isDotPrefixedNumericLiteral = function () {
            if (this.currentCharCode() === TypeScript.CharacterCodes.dot) {
                var ch = this.slidingWindow.peekItemN(1);
                return TypeScript.CharacterInfo.isDecimalDigit(ch);
            }
            return false;
        };
        Scanner.prototype.scanDotToken = function () {
            if (this.isDotPrefixedNumericLiteral()) {
                return this.scanNumericLiteral();
            }
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.dot && this.slidingWindow.peekItemN(1) === TypeScript.CharacterCodes.dot) {
                this.slidingWindow.moveToNextItem();
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.DotDotDotToken;
            } else {
                return TypeScript.SyntaxKind.DotToken;
            }
        };
        Scanner.prototype.scanSlashToken = function (allowRegularExpression) {
            if (allowRegularExpression) {
                var result = this.tryScanRegularExpressionToken();
                if (result !== TypeScript.SyntaxKind.None) {
                    return result;
                }
            }
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return TypeScript.SyntaxKind.SlashEqualsToken;
            } else {
                return TypeScript.SyntaxKind.SlashToken;
            }
        };
        Scanner.prototype.tryScanRegularExpressionToken = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();
                var inEscape = false;
                var inCharacterClass = false;
                while(true) {
                    var ch = this.currentCharCode();
                    if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                        this.slidingWindow.rewindToPinnedIndex(startIndex);
                        return TypeScript.SyntaxKind.None;
                    }
                    this.slidingWindow.moveToNextItem();
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }
                    switch(ch) {
                        case TypeScript.CharacterCodes.backslash:
                            inEscape = true;
                            continue;
                        case TypeScript.CharacterCodes.openBracket:
                            inCharacterClass = true;
                            continue;
                        case TypeScript.CharacterCodes.closeBracket:
                            inCharacterClass = false;
                            continue;
                        case TypeScript.CharacterCodes.slash:
                            if (inCharacterClass) {
                                continue;
                            }
                            break;
                        default:
                            continue;
                    }
                    break;
                }
                while(Scanner.isIdentifierPartCharacter[this.currentCharCode()]) {
                    this.slidingWindow.moveToNextItem();
                }
                return TypeScript.SyntaxKind.RegularExpressionLiteral;
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
            }
        };
        Scanner.prototype.scanExclamationToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                if (this.currentCharCode() === TypeScript.CharacterCodes.equals) {
                    this.slidingWindow.moveToNextItem();
                    return TypeScript.SyntaxKind.ExclamationEqualsEqualsToken;
                } else {
                    return TypeScript.SyntaxKind.ExclamationEqualsToken;
                }
            } else {
                return TypeScript.SyntaxKind.ExclamationToken;
            }
        };
        Scanner.prototype.scanDefaultCharacter = function (character, diagnostics) {
            var position = this.slidingWindow.absoluteIndex();
            this.slidingWindow.moveToNextItem();
            var text = String.fromCharCode(character);
            var messageText = this.getErrorMessageText(text);
            diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, position, 1, TypeScript.DiagnosticCode.Unexpected_character_0, [
                messageText
            ]));
            return TypeScript.SyntaxKind.ErrorToken;
        };
        Scanner.prototype.getErrorMessageText = function (text) {
            if (text === "\\") {
                return '"\\"';
            }
            return JSON2.stringify(text);
        };
        Scanner.prototype.skipEscapeSequence = function (diagnostics) {
            var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();
                var ch = this.currentCharCode();
                this.slidingWindow.moveToNextItem();
                switch(ch) {
                    case TypeScript.CharacterCodes.x:
                    case TypeScript.CharacterCodes.u:
                        this.slidingWindow.rewindToPinnedIndex(rewindPoint);
                        var value = this.scanUnicodeOrHexEscape(diagnostics);
                        return;
                    case TypeScript.CharacterCodes.carriageReturn:
                        if (this.currentCharCode() === TypeScript.CharacterCodes.lineFeed) {
                            this.slidingWindow.moveToNextItem();
                        }
                        return;
                    default:
                        return;
                }
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint);
            }
        };
        Scanner.prototype.scanStringLiteral = function (diagnostics) {
            var quoteCharacter = this.currentCharCode();
            this.slidingWindow.moveToNextItem();
            while(true) {
                var ch = this.currentCharCode();
                if (ch === TypeScript.CharacterCodes.backslash) {
                    this.skipEscapeSequence(diagnostics);
                } else if (ch === quoteCharacter) {
                    this.slidingWindow.moveToNextItem();
                    break;
                } else if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                    diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, this.slidingWindow.absoluteIndex(), 1, TypeScript.DiagnosticCode.Missing_closing_quote_character, null));
                    break;
                } else {
                    this.slidingWindow.moveToNextItem();
                }
            }
            return TypeScript.SyntaxKind.StringLiteral;
        };
        Scanner.prototype.isUnicodeOrHexEscape = function (character) {
            return this.isUnicodeEscape(character) || this.isHexEscape(character);
        };
        Scanner.prototype.isUnicodeEscape = function (character) {
            if (character === TypeScript.CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === TypeScript.CharacterCodes.u) {
                    return true;
                }
            }
            return false;
        };
        Scanner.prototype.isHexEscape = function (character) {
            if (character === TypeScript.CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === TypeScript.CharacterCodes.x) {
                    return true;
                }
            }
            return false;
        };
        Scanner.prototype.peekCharOrUnicodeOrHexEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeOrHexEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };
        Scanner.prototype.peekCharOrUnicodeEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };
        Scanner.prototype.peekUnicodeOrHexEscape = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var ch = this.scanUnicodeOrHexEscape(null);
            this.slidingWindow.rewindToPinnedIndex(startIndex);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
            return ch;
        };
        Scanner.prototype.scanCharOrUnicodeEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === TypeScript.CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === TypeScript.CharacterCodes.u) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }
            this.slidingWindow.moveToNextItem();
            return ch;
        };
        Scanner.prototype.scanCharOrUnicodeOrHexEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === TypeScript.CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === TypeScript.CharacterCodes.u || ch2 === TypeScript.CharacterCodes.x) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }
            this.slidingWindow.moveToNextItem();
            return ch;
        };
        Scanner.prototype.scanUnicodeOrHexEscape = function (errors) {
            var start = this.slidingWindow.absoluteIndex();
            var character = this.currentCharCode();
            this.slidingWindow.moveToNextItem();
            character = this.currentCharCode();
            var intChar = 0;
            this.slidingWindow.moveToNextItem();
            var count = character === TypeScript.CharacterCodes.u ? 4 : 2;
            for(var i = 0; i < count; i++) {
                var ch2 = this.currentCharCode();
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    if (errors !== null) {
                        var end = this.slidingWindow.absoluteIndex();
                        var info = this.createIllegalEscapeDiagnostic(start, end);
                        errors.push(info);
                    }
                    break;
                }
                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
                this.slidingWindow.moveToNextItem();
            }
            return intChar;
        };
        Scanner.prototype.substring = function (start, end, intern) {
            var length = end - start;
            var offset = start - this.slidingWindow.windowAbsoluteStartIndex;
            if (intern) {
                return TypeScript.Collections.DefaultStringTable.addCharArray(this.slidingWindow.window, offset, length);
            } else {
                return TypeScript.StringUtilities.fromCharCodeArray(this.slidingWindow.window.slice(offset, offset + length));
            }
        };
        Scanner.prototype.createIllegalEscapeDiagnostic = function (start, end) {
            return new TypeScript.SyntaxDiagnostic(this.fileName, start, end - start, TypeScript.DiagnosticCode.Unrecognized_escape_sequence, null);
        };
        return Scanner;
    })();
    TypeScript.Scanner = Scanner;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities = (function () {
        function ScannerUtilities() { }
        ScannerUtilities.identifierKind = function identifierKind(array, startIndex, length) {
            switch(length) {
                case 2:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.d:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o) ? TypeScript.SyntaxKind.DoKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.i:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.f:
                                    return TypeScript.SyntaxKind.IfKeyword;
                                case TypeScript.CharacterCodes.n:
                                    return TypeScript.SyntaxKind.InKeyword;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 3:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.ForKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.n:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.w) ? TypeScript.SyntaxKind.NewKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.t:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.r && array[startIndex + 2] === TypeScript.CharacterCodes.y) ? TypeScript.SyntaxKind.TryKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.v:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.a && array[startIndex + 2] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.VarKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.l:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.LetKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.a:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.n && array[startIndex + 2] === TypeScript.CharacterCodes.y) ? TypeScript.SyntaxKind.AnyKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.g:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.GetKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.s:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.SetKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 4:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.c:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.a && array[startIndex + 2] === TypeScript.CharacterCodes.s && array[startIndex + 3] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.CaseKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.e:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.l:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.s && array[startIndex + 3] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.ElseKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.n:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.u && array[startIndex + 3] === TypeScript.CharacterCodes.m) ? TypeScript.SyntaxKind.EnumKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.n:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.l && array[startIndex + 3] === TypeScript.CharacterCodes.l) ? TypeScript.SyntaxKind.NullKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.t:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.h:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ThisKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.r:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.u && array[startIndex + 3] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.TrueKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.v:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.d) ? TypeScript.SyntaxKind.VoidKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.w:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.i && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.h) ? TypeScript.SyntaxKind.WithKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.b:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.o && array[startIndex + 3] === TypeScript.CharacterCodes.l) ? TypeScript.SyntaxKind.BoolKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 5:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.b:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.r && array[startIndex + 2] === TypeScript.CharacterCodes.e && array[startIndex + 3] === TypeScript.CharacterCodes.a && array[startIndex + 4] === TypeScript.CharacterCodes.k) ? TypeScript.SyntaxKind.BreakKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.c:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.a:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.c && array[startIndex + 4] === TypeScript.CharacterCodes.h) ? TypeScript.SyntaxKind.CatchKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.l:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.a && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ClassKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.o:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.ConstKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.a && array[startIndex + 2] === TypeScript.CharacterCodes.l && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.FalseKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.t:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.h && array[startIndex + 2] === TypeScript.CharacterCodes.r && array[startIndex + 3] === TypeScript.CharacterCodes.o && array[startIndex + 4] === TypeScript.CharacterCodes.w) ? TypeScript.SyntaxKind.ThrowKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.w:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.h && array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.WhileKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.s:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.SuperKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.y:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.i && array[startIndex + 2] === TypeScript.CharacterCodes.e && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.d) ? TypeScript.SyntaxKind.YieldKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 6:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.d:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.l && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.t && array[startIndex + 5] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.DeleteKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.r:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.u && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.n) ? TypeScript.SyntaxKind.ReturnKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.s:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.w:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.c && array[startIndex + 5] === TypeScript.CharacterCodes.h) ? TypeScript.SyntaxKind.SwitchKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.t:
                                    switch(array[startIndex + 2]) {
                                        case TypeScript.CharacterCodes.a:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.i && array[startIndex + 5] === TypeScript.CharacterCodes.c) ? TypeScript.SyntaxKind.StaticKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        case TypeScript.CharacterCodes.r:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.i && array[startIndex + 4] === TypeScript.CharacterCodes.n && array[startIndex + 5] === TypeScript.CharacterCodes.g) ? TypeScript.SyntaxKind.StringKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        default:
                                            return TypeScript.SyntaxKind.IdentifierName;
                                    }
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.t:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.y && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.o && array[startIndex + 5] === TypeScript.CharacterCodes.f) ? TypeScript.SyntaxKind.TypeOfKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.e:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.x && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.o && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.ExportKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.i:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.m && array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.o && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.ImportKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.p:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.b && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.i && array[startIndex + 5] === TypeScript.CharacterCodes.c) ? TypeScript.SyntaxKind.PublicKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.m:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.d && array[startIndex + 3] === TypeScript.CharacterCodes.u && array[startIndex + 4] === TypeScript.CharacterCodes.l && array[startIndex + 5] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.ModuleKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.n:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.m && array[startIndex + 3] === TypeScript.CharacterCodes.b && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.NumberKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 7:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.d:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.e:
                                    switch(array[startIndex + 2]) {
                                        case TypeScript.CharacterCodes.f:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.a && array[startIndex + 4] === TypeScript.CharacterCodes.u && array[startIndex + 5] === TypeScript.CharacterCodes.l && array[startIndex + 6] === TypeScript.CharacterCodes.t) ? TypeScript.SyntaxKind.DefaultKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        case TypeScript.CharacterCodes.c:
                                            return (array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.r && array[startIndex + 6] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.DeclareKeyword : TypeScript.SyntaxKind.IdentifierName;
                                        default:
                                            return TypeScript.SyntaxKind.IdentifierName;
                                    }
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.i && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.a && array[startIndex + 4] === TypeScript.CharacterCodes.l && array[startIndex + 5] === TypeScript.CharacterCodes.l && array[startIndex + 6] === TypeScript.CharacterCodes.y) ? TypeScript.SyntaxKind.FinallyKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.e:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.x && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.n && array[startIndex + 5] === TypeScript.CharacterCodes.d && array[startIndex + 6] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ExtendsKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.p:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.a:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.c && array[startIndex + 3] === TypeScript.CharacterCodes.k && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.g && array[startIndex + 6] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.PackageKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.r:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.i && array[startIndex + 3] === TypeScript.CharacterCodes.v && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.t && array[startIndex + 6] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.PrivateKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        case TypeScript.CharacterCodes.b:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.o && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.a && array[startIndex + 6] === TypeScript.CharacterCodes.n) ? TypeScript.SyntaxKind.BooleanKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 8:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.c:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.i && array[startIndex + 5] === TypeScript.CharacterCodes.n && array[startIndex + 6] === TypeScript.CharacterCodes.u && array[startIndex + 7] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.ContinueKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.d:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.e && array[startIndex + 2] === TypeScript.CharacterCodes.b && array[startIndex + 3] === TypeScript.CharacterCodes.u && array[startIndex + 4] === TypeScript.CharacterCodes.g && array[startIndex + 5] === TypeScript.CharacterCodes.g && array[startIndex + 6] === TypeScript.CharacterCodes.e && array[startIndex + 7] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.DebuggerKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.f:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.u && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.c && array[startIndex + 4] === TypeScript.CharacterCodes.t && array[startIndex + 5] === TypeScript.CharacterCodes.i && array[startIndex + 6] === TypeScript.CharacterCodes.o && array[startIndex + 7] === TypeScript.CharacterCodes.n) ? TypeScript.SyntaxKind.FunctionKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 9:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.i:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.n && array[startIndex + 2] === TypeScript.CharacterCodes.t && array[startIndex + 3] === TypeScript.CharacterCodes.e && array[startIndex + 4] === TypeScript.CharacterCodes.r && array[startIndex + 5] === TypeScript.CharacterCodes.f && array[startIndex + 6] === TypeScript.CharacterCodes.a && array[startIndex + 7] === TypeScript.CharacterCodes.c && array[startIndex + 8] === TypeScript.CharacterCodes.e) ? TypeScript.SyntaxKind.InterfaceKeyword : TypeScript.SyntaxKind.IdentifierName;
                        case TypeScript.CharacterCodes.p:
                            return (array[startIndex + 1] === TypeScript.CharacterCodes.r && array[startIndex + 2] === TypeScript.CharacterCodes.o && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.c && array[startIndex + 6] === TypeScript.CharacterCodes.t && array[startIndex + 7] === TypeScript.CharacterCodes.e && array[startIndex + 8] === TypeScript.CharacterCodes.d) ? TypeScript.SyntaxKind.ProtectedKeyword : TypeScript.SyntaxKind.IdentifierName;
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 10:
                    switch(array[startIndex]) {
                        case TypeScript.CharacterCodes.i:
                            switch(array[startIndex + 1]) {
                                case TypeScript.CharacterCodes.n:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.s && array[startIndex + 3] === TypeScript.CharacterCodes.t && array[startIndex + 4] === TypeScript.CharacterCodes.a && array[startIndex + 5] === TypeScript.CharacterCodes.n && array[startIndex + 6] === TypeScript.CharacterCodes.c && array[startIndex + 7] === TypeScript.CharacterCodes.e && array[startIndex + 8] === TypeScript.CharacterCodes.o && array[startIndex + 9] === TypeScript.CharacterCodes.f) ? TypeScript.SyntaxKind.InstanceOfKeyword : TypeScript.SyntaxKind.IdentifierName;
                                case TypeScript.CharacterCodes.m:
                                    return (array[startIndex + 2] === TypeScript.CharacterCodes.p && array[startIndex + 3] === TypeScript.CharacterCodes.l && array[startIndex + 4] === TypeScript.CharacterCodes.e && array[startIndex + 5] === TypeScript.CharacterCodes.m && array[startIndex + 6] === TypeScript.CharacterCodes.e && array[startIndex + 7] === TypeScript.CharacterCodes.n && array[startIndex + 8] === TypeScript.CharacterCodes.t && array[startIndex + 9] === TypeScript.CharacterCodes.s) ? TypeScript.SyntaxKind.ImplementsKeyword : TypeScript.SyntaxKind.IdentifierName;
                                default:
                                    return TypeScript.SyntaxKind.IdentifierName;
                            }
                        default:
                            return TypeScript.SyntaxKind.IdentifierName;
                    }
                case 11:
                    return (array[startIndex] === TypeScript.CharacterCodes.c && array[startIndex + 1] === TypeScript.CharacterCodes.o && array[startIndex + 2] === TypeScript.CharacterCodes.n && array[startIndex + 3] === TypeScript.CharacterCodes.s && array[startIndex + 4] === TypeScript.CharacterCodes.t && array[startIndex + 5] === TypeScript.CharacterCodes.r && array[startIndex + 6] === TypeScript.CharacterCodes.u && array[startIndex + 7] === TypeScript.CharacterCodes.c && array[startIndex + 8] === TypeScript.CharacterCodes.t && array[startIndex + 9] === TypeScript.CharacterCodes.o && array[startIndex + 10] === TypeScript.CharacterCodes.r) ? TypeScript.SyntaxKind.ConstructorKeyword : TypeScript.SyntaxKind.IdentifierName;
                default:
                    return TypeScript.SyntaxKind.IdentifierName;
            }
        };
        return ScannerUtilities;
    })();
    TypeScript.ScannerUtilities = ScannerUtilities;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySeparatedSyntaxList = (function () {
            function EmptySeparatedSyntaxList() { }
            EmptySeparatedSyntaxList.prototype.kind = function () {
                return TypeScript.SyntaxKind.SeparatedList;
            };
            EmptySeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };
            EmptySeparatedSyntaxList.prototype.toJSON = function (key) {
                return [];
            };
            EmptySeparatedSyntaxList.prototype.childCount = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.toArray = function () {
                return [];
            };
            EmptySeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [];
            };
            EmptySeparatedSyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptySeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptySeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptySeparatedSyntaxList.prototype.collectTextElements = function (elements) {
            };
            EmptySeparatedSyntaxList.prototype.firstToken = function () {
                return null;
            };
            EmptySeparatedSyntaxList.prototype.lastToken = function () {
                return null;
            };
            EmptySeparatedSyntaxList.prototype.fullWidth = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.fullText = function () {
                return "";
            };
            EmptySeparatedSyntaxList.prototype.width = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };
            EmptySeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };
            EmptySeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
            };
            EmptySeparatedSyntaxList.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            EmptySeparatedSyntaxList.prototype.trailingTrivia = function () {
                return Syntax.emptyTriviaList;
            };
            EmptySeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptySeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            return EmptySeparatedSyntaxList;
        })();        
        Syntax.emptySeparatedList = new EmptySeparatedSyntaxList();
        var SingletonSeparatedSyntaxList = (function () {
            function SingletonSeparatedSyntaxList(item) {
                this.item = item;
            }
            SingletonSeparatedSyntaxList.prototype.toJSON = function (key) {
                return [
                    this.item
                ];
            };
            SingletonSeparatedSyntaxList.prototype.kind = function () {
                return TypeScript.SyntaxKind.SeparatedList;
            };
            SingletonSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };
            SingletonSeparatedSyntaxList.prototype.childCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };
            SingletonSeparatedSyntaxList.prototype.toArray = function () {
                return [
                    this.item
                ];
            };
            SingletonSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [
                    this.item
                ];
            };
            SingletonSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            SingletonSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };
            SingletonSeparatedSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };
            SingletonSeparatedSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };
            SingletonSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };
            SingletonSeparatedSyntaxList.prototype.width = function () {
                return this.item.width();
            };
            SingletonSeparatedSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };
            SingletonSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };
            SingletonSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };
            SingletonSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };
            SingletonSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };
            SingletonSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };
            SingletonSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };
            SingletonSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return (this.item).findTokenInternal(new TypeScript.PositionedSeparatedList(parent, this, fullStart), position, fullStart);
            };
            SingletonSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSeparatedSyntaxList;
        })();        
        var NormalSeparatedSyntaxList = (function () {
            function NormalSeparatedSyntaxList(elements) {
                this._data = 0;
                this.elements = elements;
            }
            NormalSeparatedSyntaxList.prototype.kind = function () {
                return TypeScript.SyntaxKind.SeparatedList;
            };
            NormalSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };
            NormalSeparatedSyntaxList.prototype.toJSON = function (key) {
                return this.elements;
            };
            NormalSeparatedSyntaxList.prototype.childCount = function () {
                return this.elements.length;
            };
            NormalSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length + 1, 2);
            };
            NormalSeparatedSyntaxList.prototype.separatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length, 2);
            };
            NormalSeparatedSyntaxList.prototype.toArray = function () {
                return this.elements.slice(0);
            };
            NormalSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                var result = [];
                for(var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    result.push(this.nonSeparatorAt(i));
                }
                return result;
            };
            NormalSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.elements[index];
            };
            NormalSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                var value = index * 2;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.elements[value];
            };
            NormalSeparatedSyntaxList.prototype.separatorAt = function (index) {
                var value = index * 2 + 1;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.elements[value];
            };
            NormalSeparatedSyntaxList.prototype.firstToken = function () {
                var token;
                for(var i = 0, n = this.elements.length; i < n; i++) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.firstToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }
                return null;
            };
            NormalSeparatedSyntaxList.prototype.lastToken = function () {
                var token;
                for(var i = this.elements.length - 1; i >= 0; i--) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.lastToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }
                return null;
            };
            NormalSeparatedSyntaxList.prototype.fullText = function () {
                var elements = [];
                this.collectTextElements(elements);
                return elements.join("");
            };
            NormalSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                for(var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                        return true;
                    }
                }
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask) !== 0;
            };
            NormalSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> TypeScript.SyntaxConstants.NodeFullWidthShift;
            };
            NormalSeparatedSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };
            NormalSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };
            NormalSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };
            NormalSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };
            NormalSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };
            NormalSeparatedSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;
                for(var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    var childWidth = element.fullWidth();
                    fullWidth += childWidth;
                    isIncrementallyUnusable = isIncrementallyUnusable || element.isIncrementallyUnusable();
                }
                return (fullWidth << TypeScript.SyntaxConstants.NodeFullWidthShift) | (isIncrementallyUnusable ? TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask : 0) | TypeScript.SyntaxConstants.NodeDataComputed;
            };
            NormalSeparatedSyntaxList.prototype.data = function () {
                if ((this._data & TypeScript.SyntaxConstants.NodeDataComputed) === 0) {
                    this._data = this.computeData();
                }
                return this._data;
            };
            NormalSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedSeparatedList(parent, this, fullStart);
                for(var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    var childWidth = element.fullWidth();
                    if (position < childWidth) {
                        return (element).findTokenInternal(parent, position, fullStart);
                    }
                    position -= childWidth;
                    fullStart += childWidth;
                }
                throw TypeScript.Errors.invalidOperation();
            };
            NormalSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                for(var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    element.collectTextElements(elements);
                }
            };
            NormalSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.elements);
                } else {
                    array.splice.apply(array, [
                        index, 
                        0
                    ].concat(this.elements));
                }
            };
            return NormalSeparatedSyntaxList;
        })();        
        function separatedList(nodes) {
            return separatedListAndValidate(nodes, false);
        }
        Syntax.separatedList = separatedList;
        function separatedListAndValidate(nodes, validate) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptySeparatedList;
            }
            if (validate) {
                for(var i = 0; i < nodes.length; i++) {
                    var item = nodes[i];
                    if (i % 2 === 1) {
                    }
                }
            }
            if (nodes.length === 1) {
                return new SingletonSeparatedSyntaxList(nodes[0]);
            }
            return new NormalSeparatedSyntaxList(nodes);
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SlidingWindow = (function () {
        function SlidingWindow(source, window, defaultValue, sourceLength) {
            if (typeof sourceLength === "undefined") { sourceLength = -1; }
            this.source = source;
            this.window = window;
            this.defaultValue = defaultValue;
            this.sourceLength = sourceLength;
            this.windowCount = 0;
            this.windowAbsoluteStartIndex = 0;
            this.currentRelativeItemIndex = 0;
            this._pinCount = 0;
            this.firstPinnedAbsoluteIndex = -1;
        }
        SlidingWindow.prototype.windowAbsoluteEndIndex = function () {
            return this.windowAbsoluteStartIndex + this.windowCount;
        };
        SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
            if (this.sourceLength >= 0 && this.absoluteIndex() >= this.sourceLength) {
                return false;
            }
            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }
            var spaceAvailable = this.window.length - this.windowCount;
            var amountFetched = this.source.fetchMoreItems(argument, this.windowAbsoluteEndIndex(), this.window, this.windowCount, spaceAvailable);
            this.windowCount += amountFetched;
            return amountFetched > 0;
        };
        SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);
            var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;
            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;
                var shiftCount = this.windowCount - shiftStartIndex;
                if (shiftCount > 0) {
                    TypeScript.ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }
                this.windowAbsoluteStartIndex += shiftStartIndex;
                this.windowCount -= shiftStartIndex;
                this.currentRelativeItemIndex -= shiftStartIndex;
            } else {
                TypeScript.ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        };
        SlidingWindow.prototype.absoluteIndex = function () {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        };
        SlidingWindow.prototype.isAtEndOfSource = function () {
            return this.absoluteIndex() >= this.sourceLength;
        };
        SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }
            return absoluteIndex;
        };
        SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
            this._pinCount--;
            if (this._pinCount === 0) {
                this.firstPinnedAbsoluteIndex = -1;
            }
        };
        SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;
            this.currentRelativeItemIndex = relativeIndex;
        };
        SlidingWindow.prototype.currentItem = function (argument) {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }
            return this.window[this.currentRelativeItemIndex];
        };
        SlidingWindow.prototype.peekItemN = function (n) {
            while(this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(null)) {
                    return this.defaultValue;
                }
            }
            return this.window[this.currentRelativeItemIndex + n];
        };
        SlidingWindow.prototype.moveToNextItem = function () {
            this.currentRelativeItemIndex++;
        };
        SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
            this.windowCount = this.currentRelativeItemIndex;
        };
        SlidingWindow.prototype.setAbsoluteIndex = function (absoluteIndex) {
            if (this.absoluteIndex() === absoluteIndex) {
                return;
            }
            if (this._pinCount > 0) {
            }
            if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
                this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
            } else {
                this.windowAbsoluteStartIndex = absoluteIndex;
                this.windowCount = 0;
                this.currentRelativeItemIndex = 0;
            }
        };
        SlidingWindow.prototype.pinCount = function () {
            return this._pinCount;
        };
        return SlidingWindow;
    })();
    TypeScript.SlidingWindow = SlidingWindow;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Strings = (function () {
        function Strings() { }
        Strings.module__class__interface__enum__import_or_statement = "module, class, interface, enum, import or statement";
        Strings.constructor__function__accessor_or_variable = "constructor, function, accessor or variable";
        Strings.statement = "statement";
        Strings.case_or_default_clause = "case or default clause";
        Strings.identifier = "identifier";
        Strings.call__construct__index__property_or_function_signature = "call, construct, index, property or function signature";
        Strings.expression = "expression";
        Strings.type_name = "type name";
        Strings.property_or_accessor = "property or accessor";
        Strings.parameter = "parameter";
        Strings.type = "type";
        Strings.type_parameter = "type parameter";
        return Strings;
    })();
    TypeScript.Strings = Strings;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function emptySourceUnit() {
            return TypeScript.Syntax.normalModeFactory.sourceUnit(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.EndOfFileToken, {
                text: ""
            }));
        }
        Syntax.emptySourceUnit = emptySourceUnit;
        function getStandaloneExpression(positionedToken) {
            var token = positionedToken.token();
            if (positionedToken !== null && positionedToken.kind() === TypeScript.SyntaxKind.IdentifierName) {
                var parentPositionedNode = positionedToken.containingNode();
                var parentNode = parentPositionedNode.node();
                if (parentNode.kind() === TypeScript.SyntaxKind.QualifiedName && (parentNode).right === token) {
                    return parentPositionedNode;
                } else if (parentNode.kind() === TypeScript.SyntaxKind.MemberAccessExpression && (parentNode).name === token) {
                    return parentPositionedNode;
                }
            }
            return positionedToken;
        }
        Syntax.getStandaloneExpression = getStandaloneExpression;
        function isInModuleOrTypeContext(positionedToken) {
            if (positionedToken !== null) {
                var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
                var parent = positionedNodeOrToken.containingNode();
                if (parent !== null) {
                    switch(parent.kind()) {
                        case TypeScript.SyntaxKind.ModuleNameModuleReference:
                            return true;
                        case TypeScript.SyntaxKind.QualifiedName:
                            return true;
                        default:
                            return isInTypeOnlyContext(positionedToken);
                    }
                }
            }
            return false;
        }
        Syntax.isInModuleOrTypeContext = isInModuleOrTypeContext;
        function isInTypeOnlyContext(positionedToken) {
            var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
            var positionedParent = positionedNodeOrToken.containingNode();
            var parent = positionedParent.node();
            var nodeOrToken = positionedNodeOrToken.nodeOrToken();
            if (parent !== null) {
                switch(parent.kind()) {
                    case TypeScript.SyntaxKind.ArrayType:
                        return (parent).type === nodeOrToken;
                    case TypeScript.SyntaxKind.CastExpression:
                        return (parent).type === nodeOrToken;
                    case TypeScript.SyntaxKind.TypeAnnotation:
                    case TypeScript.SyntaxKind.HeritageClause:
                    case TypeScript.SyntaxKind.TypeArgumentList:
                        return true;
                }
            }
            return false;
        }
        Syntax.isInTypeOnlyContext = isInTypeOnlyContext;
        function childOffset(parent, child) {
            var offset = 0;
            for(var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return offset;
                }
                if (current !== null) {
                    offset += current.fullWidth();
                }
            }
            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childOffset = childOffset;
        function nodeStructuralEquals(node1, node2) {
            if (node1 === null) {
                return node2 === null;
            }
            return node1.structuralEquals(node2);
        }
        Syntax.nodeStructuralEquals = nodeStructuralEquals;
        function nodeOrTokenStructuralEquals(node1, node2) {
            if (node1 === node2) {
                return true;
            }
            if (node1 === null || node2 === null) {
                return false;
            }
            if (node1.isToken()) {
                return node2.isToken() ? tokenStructuralEquals(node1, node2) : false;
            }
            return node2.isNode() ? nodeStructuralEquals(node1, node2) : false;
        }
        Syntax.nodeOrTokenStructuralEquals = nodeOrTokenStructuralEquals;
        function tokenStructuralEquals(token1, token2) {
            if (token1 === token2) {
                return true;
            }
            if (token1 === null || token2 === null) {
                return false;
            }
            return token1.kind() === token2.kind() && token1.width() === token2.width() && token1.fullWidth() === token2.fullWidth() && token1.text() === token2.text() && TypeScript.Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) && TypeScript.Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
        }
        Syntax.tokenStructuralEquals = tokenStructuralEquals;
        function triviaListStructuralEquals(triviaList1, triviaList2) {
            if (triviaList1.count() !== triviaList2.count()) {
                return false;
            }
            for(var i = 0, n = triviaList1.count(); i < n; i++) {
                if (!TypeScript.Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                    return false;
                }
            }
            return true;
        }
        Syntax.triviaListStructuralEquals = triviaListStructuralEquals;
        function triviaStructuralEquals(trivia1, trivia2) {
            return trivia1.kind() === trivia2.kind() && trivia1.fullWidth() === trivia2.fullWidth() && trivia1.fullText() === trivia2.fullText();
        }
        Syntax.triviaStructuralEquals = triviaStructuralEquals;
        function listStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }
            for(var i = 0, n = list1.childCount(); i < n; i++) {
                var child1 = list1.childAt(i);
                var child2 = list2.childAt(i);
                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(child1, child2)) {
                    return false;
                }
            }
            return true;
        }
        Syntax.listStructuralEquals = listStructuralEquals;
        function separatedListStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }
            for(var i = 0, n = list1.childCount(); i < n; i++) {
                var element1 = list1.childAt(i);
                var element2 = list2.childAt(i);
                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                    return false;
                }
            }
            return true;
        }
        Syntax.separatedListStructuralEquals = separatedListStructuralEquals;
        function elementStructuralEquals(element1, element2) {
            if (element1 === element2) {
                return true;
            }
            if (element1 === null || element2 === null) {
                return false;
            }
            if (element2.kind() !== element2.kind()) {
                return false;
            }
            if (element1.isToken()) {
                return tokenStructuralEquals(element1, element2);
            } else if (element1.isNode()) {
                return nodeStructuralEquals(element1, element2);
            } else if (element1.isList()) {
                return listStructuralEquals(element1, element2);
            } else if (element1.isSeparatedList()) {
                return separatedListStructuralEquals(element1, element2);
            }
            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.elementStructuralEquals = elementStructuralEquals;
        function identifierName(text, info) {
            if (typeof info === "undefined") { info = null; }
            return Syntax.identifier(text);
        }
        Syntax.identifierName = identifierName;
        function trueExpression() {
            return TypeScript.Syntax.token(TypeScript.SyntaxKind.TrueKeyword);
        }
        Syntax.trueExpression = trueExpression;
        function falseExpression() {
            return TypeScript.Syntax.token(TypeScript.SyntaxKind.FalseKeyword);
        }
        Syntax.falseExpression = falseExpression;
        function numericLiteralExpression(text) {
            return TypeScript.Syntax.token(TypeScript.SyntaxKind.NumericLiteral, {
                text: text
            });
        }
        Syntax.numericLiteralExpression = numericLiteralExpression;
        function stringLiteralExpression(text) {
            return TypeScript.Syntax.token(TypeScript.SyntaxKind.StringLiteral, {
                text: text
            });
        }
        Syntax.stringLiteralExpression = stringLiteralExpression;
        function isSuperInvocationExpression(node) {
            return node.kind() === TypeScript.SyntaxKind.InvocationExpression && (node).expression.kind() === TypeScript.SyntaxKind.SuperKeyword;
        }
        Syntax.isSuperInvocationExpression = isSuperInvocationExpression;
        function isSuperInvocationExpressionStatement(node) {
            return node.kind() === TypeScript.SyntaxKind.ExpressionStatement && isSuperInvocationExpression((node).expression);
        }
        Syntax.isSuperInvocationExpressionStatement = isSuperInvocationExpressionStatement;
        function isSuperMemberAccessExpression(node) {
            return node.kind() === TypeScript.SyntaxKind.MemberAccessExpression && (node).expression.kind() === TypeScript.SyntaxKind.SuperKeyword;
        }
        Syntax.isSuperMemberAccessExpression = isSuperMemberAccessExpression;
        function isSuperMemberAccessInvocationExpression(node) {
            return node.kind() === TypeScript.SyntaxKind.InvocationExpression && isSuperMemberAccessExpression((node).expression);
        }
        Syntax.isSuperMemberAccessInvocationExpression = isSuperMemberAccessInvocationExpression;
        function assignmentExpression(left, token, right) {
            return TypeScript.Syntax.normalModeFactory.binaryExpression(TypeScript.SyntaxKind.AssignmentExpression, left, token, right);
        }
        Syntax.assignmentExpression = assignmentExpression;
        function nodeHasSkippedOrMissingTokens(node) {
            for(var i = 0; i < node.childCount(); i++) {
                var child = node.childAt(i);
                if (child != null && child.isToken()) {
                    var token = child;
                    if (token.hasSkippedText() || (token.width() == 0 && token.kind() != TypeScript.SyntaxKind.EndOfFileToken)) {
                        return true;
                    }
                }
            }
            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxDiagnostic = (function (_super) {
        __extends(SyntaxDiagnostic, _super);
        function SyntaxDiagnostic(fileName, start, length, code, args) {
            _super.call(this, code, args);
            if (length < 0) {
                throw TypeScript.Errors.argumentOutOfRange("width");
            }
            this._fileName = fileName;
            this._start = start;
            this._length = length;
        }
        SyntaxDiagnostic.prototype.toJSON = function (key) {
            var result = {};
            result._position = this._start;
            result._width = this._length;
            result._diagnosticCode = (TypeScript.DiagnosticCode)._map[this.diagnosticCode()];
            var arguments = (this)._arguments;
            if (arguments && arguments.length > 0) {
                result._arguments = arguments;
            }
            return result;
        };
        SyntaxDiagnostic.prototype.fileName = function () {
            return this._fileName;
        };
        SyntaxDiagnostic.prototype.start = function () {
            return this._start;
        };
        SyntaxDiagnostic.prototype.length = function () {
            return this._length;
        };
        SyntaxDiagnostic.equals = function equals(diagnostic1, diagnostic2) {
            return diagnostic1._start === diagnostic2._start && diagnostic1._length === diagnostic2._length && TypeScript.Diagnostic1.equals(diagnostic1, diagnostic2);
        };
        return SyntaxDiagnostic;
    })(TypeScript.Diagnostic1);
    TypeScript.SyntaxDiagnostic = SyntaxDiagnostic;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var NormalModeFactory = (function () {
            function NormalModeFactory() { }
            NormalModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, false);
            };
            NormalModeFactory.prototype.externalModuleReference = function (moduleKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, false);
            };
            NormalModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, false);
            };
            NormalModeFactory.prototype.importDeclaration = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
            };
            NormalModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, false);
            };
            NormalModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, false);
            };
            NormalModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, false);
            };
            NormalModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, false);
            };
            NormalModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, false);
            };
            NormalModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, false);
            };
            NormalModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(false);
            };
            NormalModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, false);
            };
            NormalModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, false);
            };
            NormalModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, false);
            };
            NormalModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, false);
            };
            NormalModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, false);
            };
            NormalModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, false);
            };
            NormalModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, false);
            };
            NormalModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, false);
            };
            NormalModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, false);
            };
            NormalModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, false);
            };
            NormalModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, false);
            };
            NormalModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, false);
            };
            NormalModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, false);
            };
            NormalModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, false);
            };
            NormalModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, false);
            };
            NormalModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, false);
            };
            NormalModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, false);
            };
            NormalModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, false);
            };
            NormalModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, false);
            };
            NormalModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, false);
            };
            NormalModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, false);
            };
            NormalModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, false);
            };
            NormalModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, false);
            };
            NormalModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, false);
            };
            NormalModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, false);
            };
            NormalModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, false);
            };
            NormalModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, false);
            };
            NormalModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, false);
            };
            NormalModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, false);
            };
            NormalModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, false);
            };
            NormalModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, false);
            };
            NormalModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, false);
            };
            NormalModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, false);
            };
            NormalModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, false);
            };
            NormalModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, false);
            };
            NormalModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, false);
            };
            NormalModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, false);
            };
            NormalModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, false);
            };
            NormalModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, false);
            };
            NormalModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, false);
            };
            NormalModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, false);
            };
            NormalModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, false);
            };
            NormalModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, false);
            };
            return NormalModeFactory;
        })();
        Syntax.NormalModeFactory = NormalModeFactory;        
        var StrictModeFactory = (function () {
            function StrictModeFactory() { }
            StrictModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, true);
            };
            StrictModeFactory.prototype.externalModuleReference = function (moduleKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, true);
            };
            StrictModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, true);
            };
            StrictModeFactory.prototype.importDeclaration = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, true);
            };
            StrictModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, true);
            };
            StrictModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, true);
            };
            StrictModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, true);
            };
            StrictModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, true);
            };
            StrictModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, true);
            };
            StrictModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, true);
            };
            StrictModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(true);
            };
            StrictModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, true);
            };
            StrictModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, true);
            };
            StrictModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, true);
            };
            StrictModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, true);
            };
            StrictModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, true);
            };
            StrictModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, true);
            };
            StrictModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, true);
            };
            StrictModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, true);
            };
            StrictModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, true);
            };
            StrictModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, true);
            };
            StrictModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, true);
            };
            StrictModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, true);
            };
            StrictModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, true);
            };
            StrictModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, true);
            };
            StrictModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, true);
            };
            StrictModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, true);
            };
            StrictModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, true);
            };
            StrictModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, true);
            };
            StrictModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, true);
            };
            StrictModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, true);
            };
            StrictModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, true);
            };
            StrictModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, true);
            };
            StrictModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, true);
            };
            StrictModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, true);
            };
            StrictModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, true);
            };
            StrictModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, true);
            };
            StrictModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, true);
            };
            StrictModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, true);
            };
            StrictModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, true);
            };
            StrictModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, true);
            };
            StrictModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, true);
            };
            StrictModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, true);
            };
            StrictModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, true);
            };
            StrictModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, true);
            };
            StrictModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, true);
            };
            StrictModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, true);
            };
            StrictModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, true);
            };
            StrictModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, true);
            };
            StrictModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, true);
            };
            StrictModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, true);
            };
            StrictModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, true);
            };
            StrictModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, true);
            };
            StrictModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, true);
            };
            return StrictModeFactory;
        })();
        Syntax.StrictModeFactory = StrictModeFactory;        
        Syntax.normalModeFactory = new NormalModeFactory();
        Syntax.strictModeFactory = new StrictModeFactory();
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxKind) {
        SyntaxKind._map = [];
        SyntaxKind._map[0] = "None";
        SyntaxKind.None = 0;
        SyntaxKind._map[1] = "List";
        SyntaxKind.List = 1;
        SyntaxKind._map[2] = "SeparatedList";
        SyntaxKind.SeparatedList = 2;
        SyntaxKind._map[3] = "TriviaList";
        SyntaxKind.TriviaList = 3;
        SyntaxKind._map[4] = "WhitespaceTrivia";
        SyntaxKind.WhitespaceTrivia = 4;
        SyntaxKind._map[5] = "NewLineTrivia";
        SyntaxKind.NewLineTrivia = 5;
        SyntaxKind._map[6] = "MultiLineCommentTrivia";
        SyntaxKind.MultiLineCommentTrivia = 6;
        SyntaxKind._map[7] = "SingleLineCommentTrivia";
        SyntaxKind.SingleLineCommentTrivia = 7;
        SyntaxKind._map[8] = "SkippedTextTrivia";
        SyntaxKind.SkippedTextTrivia = 8;
        SyntaxKind._map[9] = "ErrorToken";
        SyntaxKind.ErrorToken = 9;
        SyntaxKind._map[10] = "EndOfFileToken";
        SyntaxKind.EndOfFileToken = 10;
        SyntaxKind._map[11] = "IdentifierName";
        SyntaxKind.IdentifierName = 11;
        SyntaxKind._map[12] = "RegularExpressionLiteral";
        SyntaxKind.RegularExpressionLiteral = 12;
        SyntaxKind._map[13] = "NumericLiteral";
        SyntaxKind.NumericLiteral = 13;
        SyntaxKind._map[14] = "StringLiteral";
        SyntaxKind.StringLiteral = 14;
        SyntaxKind._map[15] = "BreakKeyword";
        SyntaxKind.BreakKeyword = 15;
        SyntaxKind._map[16] = "CaseKeyword";
        SyntaxKind.CaseKeyword = 16;
        SyntaxKind._map[17] = "CatchKeyword";
        SyntaxKind.CatchKeyword = 17;
        SyntaxKind._map[18] = "ContinueKeyword";
        SyntaxKind.ContinueKeyword = 18;
        SyntaxKind._map[19] = "DebuggerKeyword";
        SyntaxKind.DebuggerKeyword = 19;
        SyntaxKind._map[20] = "DefaultKeyword";
        SyntaxKind.DefaultKeyword = 20;
        SyntaxKind._map[21] = "DeleteKeyword";
        SyntaxKind.DeleteKeyword = 21;
        SyntaxKind._map[22] = "DoKeyword";
        SyntaxKind.DoKeyword = 22;
        SyntaxKind._map[23] = "ElseKeyword";
        SyntaxKind.ElseKeyword = 23;
        SyntaxKind._map[24] = "FalseKeyword";
        SyntaxKind.FalseKeyword = 24;
        SyntaxKind._map[25] = "FinallyKeyword";
        SyntaxKind.FinallyKeyword = 25;
        SyntaxKind._map[26] = "ForKeyword";
        SyntaxKind.ForKeyword = 26;
        SyntaxKind._map[27] = "FunctionKeyword";
        SyntaxKind.FunctionKeyword = 27;
        SyntaxKind._map[28] = "IfKeyword";
        SyntaxKind.IfKeyword = 28;
        SyntaxKind._map[29] = "InKeyword";
        SyntaxKind.InKeyword = 29;
        SyntaxKind._map[30] = "InstanceOfKeyword";
        SyntaxKind.InstanceOfKeyword = 30;
        SyntaxKind._map[31] = "NewKeyword";
        SyntaxKind.NewKeyword = 31;
        SyntaxKind._map[32] = "NullKeyword";
        SyntaxKind.NullKeyword = 32;
        SyntaxKind._map[33] = "ReturnKeyword";
        SyntaxKind.ReturnKeyword = 33;
        SyntaxKind._map[34] = "SwitchKeyword";
        SyntaxKind.SwitchKeyword = 34;
        SyntaxKind._map[35] = "ThisKeyword";
        SyntaxKind.ThisKeyword = 35;
        SyntaxKind._map[36] = "ThrowKeyword";
        SyntaxKind.ThrowKeyword = 36;
        SyntaxKind._map[37] = "TrueKeyword";
        SyntaxKind.TrueKeyword = 37;
        SyntaxKind._map[38] = "TryKeyword";
        SyntaxKind.TryKeyword = 38;
        SyntaxKind._map[39] = "TypeOfKeyword";
        SyntaxKind.TypeOfKeyword = 39;
        SyntaxKind._map[40] = "VarKeyword";
        SyntaxKind.VarKeyword = 40;
        SyntaxKind._map[41] = "VoidKeyword";
        SyntaxKind.VoidKeyword = 41;
        SyntaxKind._map[42] = "WhileKeyword";
        SyntaxKind.WhileKeyword = 42;
        SyntaxKind._map[43] = "WithKeyword";
        SyntaxKind.WithKeyword = 43;
        SyntaxKind._map[44] = "ClassKeyword";
        SyntaxKind.ClassKeyword = 44;
        SyntaxKind._map[45] = "ConstKeyword";
        SyntaxKind.ConstKeyword = 45;
        SyntaxKind._map[46] = "EnumKeyword";
        SyntaxKind.EnumKeyword = 46;
        SyntaxKind._map[47] = "ExportKeyword";
        SyntaxKind.ExportKeyword = 47;
        SyntaxKind._map[48] = "ExtendsKeyword";
        SyntaxKind.ExtendsKeyword = 48;
        SyntaxKind._map[49] = "ImportKeyword";
        SyntaxKind.ImportKeyword = 49;
        SyntaxKind._map[50] = "SuperKeyword";
        SyntaxKind.SuperKeyword = 50;
        SyntaxKind._map[51] = "ImplementsKeyword";
        SyntaxKind.ImplementsKeyword = 51;
        SyntaxKind._map[52] = "InterfaceKeyword";
        SyntaxKind.InterfaceKeyword = 52;
        SyntaxKind._map[53] = "LetKeyword";
        SyntaxKind.LetKeyword = 53;
        SyntaxKind._map[54] = "PackageKeyword";
        SyntaxKind.PackageKeyword = 54;
        SyntaxKind._map[55] = "PrivateKeyword";
        SyntaxKind.PrivateKeyword = 55;
        SyntaxKind._map[56] = "ProtectedKeyword";
        SyntaxKind.ProtectedKeyword = 56;
        SyntaxKind._map[57] = "PublicKeyword";
        SyntaxKind.PublicKeyword = 57;
        SyntaxKind._map[58] = "StaticKeyword";
        SyntaxKind.StaticKeyword = 58;
        SyntaxKind._map[59] = "YieldKeyword";
        SyntaxKind.YieldKeyword = 59;
        SyntaxKind._map[60] = "AnyKeyword";
        SyntaxKind.AnyKeyword = 60;
        SyntaxKind._map[61] = "BooleanKeyword";
        SyntaxKind.BooleanKeyword = 61;
        SyntaxKind._map[62] = "BoolKeyword";
        SyntaxKind.BoolKeyword = 62;
        SyntaxKind._map[63] = "ConstructorKeyword";
        SyntaxKind.ConstructorKeyword = 63;
        SyntaxKind._map[64] = "DeclareKeyword";
        SyntaxKind.DeclareKeyword = 64;
        SyntaxKind._map[65] = "GetKeyword";
        SyntaxKind.GetKeyword = 65;
        SyntaxKind._map[66] = "ModuleKeyword";
        SyntaxKind.ModuleKeyword = 66;
        SyntaxKind._map[67] = "NumberKeyword";
        SyntaxKind.NumberKeyword = 67;
        SyntaxKind._map[68] = "SetKeyword";
        SyntaxKind.SetKeyword = 68;
        SyntaxKind._map[69] = "StringKeyword";
        SyntaxKind.StringKeyword = 69;
        SyntaxKind._map[70] = "OpenBraceToken";
        SyntaxKind.OpenBraceToken = 70;
        SyntaxKind._map[71] = "CloseBraceToken";
        SyntaxKind.CloseBraceToken = 71;
        SyntaxKind._map[72] = "OpenParenToken";
        SyntaxKind.OpenParenToken = 72;
        SyntaxKind._map[73] = "CloseParenToken";
        SyntaxKind.CloseParenToken = 73;
        SyntaxKind._map[74] = "OpenBracketToken";
        SyntaxKind.OpenBracketToken = 74;
        SyntaxKind._map[75] = "CloseBracketToken";
        SyntaxKind.CloseBracketToken = 75;
        SyntaxKind._map[76] = "DotToken";
        SyntaxKind.DotToken = 76;
        SyntaxKind._map[77] = "DotDotDotToken";
        SyntaxKind.DotDotDotToken = 77;
        SyntaxKind._map[78] = "SemicolonToken";
        SyntaxKind.SemicolonToken = 78;
        SyntaxKind._map[79] = "CommaToken";
        SyntaxKind.CommaToken = 79;
        SyntaxKind._map[80] = "LessThanToken";
        SyntaxKind.LessThanToken = 80;
        SyntaxKind._map[81] = "GreaterThanToken";
        SyntaxKind.GreaterThanToken = 81;
        SyntaxKind._map[82] = "LessThanEqualsToken";
        SyntaxKind.LessThanEqualsToken = 82;
        SyntaxKind._map[83] = "GreaterThanEqualsToken";
        SyntaxKind.GreaterThanEqualsToken = 83;
        SyntaxKind._map[84] = "EqualsEqualsToken";
        SyntaxKind.EqualsEqualsToken = 84;
        SyntaxKind._map[85] = "EqualsGreaterThanToken";
        SyntaxKind.EqualsGreaterThanToken = 85;
        SyntaxKind._map[86] = "ExclamationEqualsToken";
        SyntaxKind.ExclamationEqualsToken = 86;
        SyntaxKind._map[87] = "EqualsEqualsEqualsToken";
        SyntaxKind.EqualsEqualsEqualsToken = 87;
        SyntaxKind._map[88] = "ExclamationEqualsEqualsToken";
        SyntaxKind.ExclamationEqualsEqualsToken = 88;
        SyntaxKind._map[89] = "PlusToken";
        SyntaxKind.PlusToken = 89;
        SyntaxKind._map[90] = "MinusToken";
        SyntaxKind.MinusToken = 90;
        SyntaxKind._map[91] = "AsteriskToken";
        SyntaxKind.AsteriskToken = 91;
        SyntaxKind._map[92] = "PercentToken";
        SyntaxKind.PercentToken = 92;
        SyntaxKind._map[93] = "PlusPlusToken";
        SyntaxKind.PlusPlusToken = 93;
        SyntaxKind._map[94] = "MinusMinusToken";
        SyntaxKind.MinusMinusToken = 94;
        SyntaxKind._map[95] = "LessThanLessThanToken";
        SyntaxKind.LessThanLessThanToken = 95;
        SyntaxKind._map[96] = "GreaterThanGreaterThanToken";
        SyntaxKind.GreaterThanGreaterThanToken = 96;
        SyntaxKind._map[97] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind.GreaterThanGreaterThanGreaterThanToken = 97;
        SyntaxKind._map[98] = "AmpersandToken";
        SyntaxKind.AmpersandToken = 98;
        SyntaxKind._map[99] = "BarToken";
        SyntaxKind.BarToken = 99;
        SyntaxKind._map[100] = "CaretToken";
        SyntaxKind.CaretToken = 100;
        SyntaxKind._map[101] = "ExclamationToken";
        SyntaxKind.ExclamationToken = 101;
        SyntaxKind._map[102] = "TildeToken";
        SyntaxKind.TildeToken = 102;
        SyntaxKind._map[103] = "AmpersandAmpersandToken";
        SyntaxKind.AmpersandAmpersandToken = 103;
        SyntaxKind._map[104] = "BarBarToken";
        SyntaxKind.BarBarToken = 104;
        SyntaxKind._map[105] = "QuestionToken";
        SyntaxKind.QuestionToken = 105;
        SyntaxKind._map[106] = "ColonToken";
        SyntaxKind.ColonToken = 106;
        SyntaxKind._map[107] = "EqualsToken";
        SyntaxKind.EqualsToken = 107;
        SyntaxKind._map[108] = "PlusEqualsToken";
        SyntaxKind.PlusEqualsToken = 108;
        SyntaxKind._map[109] = "MinusEqualsToken";
        SyntaxKind.MinusEqualsToken = 109;
        SyntaxKind._map[110] = "AsteriskEqualsToken";
        SyntaxKind.AsteriskEqualsToken = 110;
        SyntaxKind._map[111] = "PercentEqualsToken";
        SyntaxKind.PercentEqualsToken = 111;
        SyntaxKind._map[112] = "LessThanLessThanEqualsToken";
        SyntaxKind.LessThanLessThanEqualsToken = 112;
        SyntaxKind._map[113] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind.GreaterThanGreaterThanEqualsToken = 113;
        SyntaxKind._map[114] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken = 114;
        SyntaxKind._map[115] = "AmpersandEqualsToken";
        SyntaxKind.AmpersandEqualsToken = 115;
        SyntaxKind._map[116] = "BarEqualsToken";
        SyntaxKind.BarEqualsToken = 116;
        SyntaxKind._map[117] = "CaretEqualsToken";
        SyntaxKind.CaretEqualsToken = 117;
        SyntaxKind._map[118] = "SlashToken";
        SyntaxKind.SlashToken = 118;
        SyntaxKind._map[119] = "SlashEqualsToken";
        SyntaxKind.SlashEqualsToken = 119;
        SyntaxKind._map[120] = "SourceUnit";
        SyntaxKind.SourceUnit = 120;
        SyntaxKind._map[121] = "QualifiedName";
        SyntaxKind.QualifiedName = 121;
        SyntaxKind._map[122] = "ObjectType";
        SyntaxKind.ObjectType = 122;
        SyntaxKind._map[123] = "FunctionType";
        SyntaxKind.FunctionType = 123;
        SyntaxKind._map[124] = "ArrayType";
        SyntaxKind.ArrayType = 124;
        SyntaxKind._map[125] = "ConstructorType";
        SyntaxKind.ConstructorType = 125;
        SyntaxKind._map[126] = "GenericType";
        SyntaxKind.GenericType = 126;
        SyntaxKind._map[127] = "InterfaceDeclaration";
        SyntaxKind.InterfaceDeclaration = 127;
        SyntaxKind._map[128] = "FunctionDeclaration";
        SyntaxKind.FunctionDeclaration = 128;
        SyntaxKind._map[129] = "ModuleDeclaration";
        SyntaxKind.ModuleDeclaration = 129;
        SyntaxKind._map[130] = "ClassDeclaration";
        SyntaxKind.ClassDeclaration = 130;
        SyntaxKind._map[131] = "EnumDeclaration";
        SyntaxKind.EnumDeclaration = 131;
        SyntaxKind._map[132] = "ImportDeclaration";
        SyntaxKind.ImportDeclaration = 132;
        SyntaxKind._map[133] = "ExportAssignment";
        SyntaxKind.ExportAssignment = 133;
        SyntaxKind._map[134] = "MemberFunctionDeclaration";
        SyntaxKind.MemberFunctionDeclaration = 134;
        SyntaxKind._map[135] = "MemberVariableDeclaration";
        SyntaxKind.MemberVariableDeclaration = 135;
        SyntaxKind._map[136] = "ConstructorDeclaration";
        SyntaxKind.ConstructorDeclaration = 136;
        SyntaxKind._map[137] = "GetMemberAccessorDeclaration";
        SyntaxKind.GetMemberAccessorDeclaration = 137;
        SyntaxKind._map[138] = "SetMemberAccessorDeclaration";
        SyntaxKind.SetMemberAccessorDeclaration = 138;
        SyntaxKind._map[139] = "PropertySignature";
        SyntaxKind.PropertySignature = 139;
        SyntaxKind._map[140] = "CallSignature";
        SyntaxKind.CallSignature = 140;
        SyntaxKind._map[141] = "ConstructSignature";
        SyntaxKind.ConstructSignature = 141;
        SyntaxKind._map[142] = "IndexSignature";
        SyntaxKind.IndexSignature = 142;
        SyntaxKind._map[143] = "MethodSignature";
        SyntaxKind.MethodSignature = 143;
        SyntaxKind._map[144] = "Block";
        SyntaxKind.Block = 144;
        SyntaxKind._map[145] = "IfStatement";
        SyntaxKind.IfStatement = 145;
        SyntaxKind._map[146] = "VariableStatement";
        SyntaxKind.VariableStatement = 146;
        SyntaxKind._map[147] = "ExpressionStatement";
        SyntaxKind.ExpressionStatement = 147;
        SyntaxKind._map[148] = "ReturnStatement";
        SyntaxKind.ReturnStatement = 148;
        SyntaxKind._map[149] = "SwitchStatement";
        SyntaxKind.SwitchStatement = 149;
        SyntaxKind._map[150] = "BreakStatement";
        SyntaxKind.BreakStatement = 150;
        SyntaxKind._map[151] = "ContinueStatement";
        SyntaxKind.ContinueStatement = 151;
        SyntaxKind._map[152] = "ForStatement";
        SyntaxKind.ForStatement = 152;
        SyntaxKind._map[153] = "ForInStatement";
        SyntaxKind.ForInStatement = 153;
        SyntaxKind._map[154] = "EmptyStatement";
        SyntaxKind.EmptyStatement = 154;
        SyntaxKind._map[155] = "ThrowStatement";
        SyntaxKind.ThrowStatement = 155;
        SyntaxKind._map[156] = "WhileStatement";
        SyntaxKind.WhileStatement = 156;
        SyntaxKind._map[157] = "TryStatement";
        SyntaxKind.TryStatement = 157;
        SyntaxKind._map[158] = "LabeledStatement";
        SyntaxKind.LabeledStatement = 158;
        SyntaxKind._map[159] = "DoStatement";
        SyntaxKind.DoStatement = 159;
        SyntaxKind._map[160] = "DebuggerStatement";
        SyntaxKind.DebuggerStatement = 160;
        SyntaxKind._map[161] = "WithStatement";
        SyntaxKind.WithStatement = 161;
        SyntaxKind._map[162] = "PlusExpression";
        SyntaxKind.PlusExpression = 162;
        SyntaxKind._map[163] = "NegateExpression";
        SyntaxKind.NegateExpression = 163;
        SyntaxKind._map[164] = "BitwiseNotExpression";
        SyntaxKind.BitwiseNotExpression = 164;
        SyntaxKind._map[165] = "LogicalNotExpression";
        SyntaxKind.LogicalNotExpression = 165;
        SyntaxKind._map[166] = "PreIncrementExpression";
        SyntaxKind.PreIncrementExpression = 166;
        SyntaxKind._map[167] = "PreDecrementExpression";
        SyntaxKind.PreDecrementExpression = 167;
        SyntaxKind._map[168] = "DeleteExpression";
        SyntaxKind.DeleteExpression = 168;
        SyntaxKind._map[169] = "TypeOfExpression";
        SyntaxKind.TypeOfExpression = 169;
        SyntaxKind._map[170] = "VoidExpression";
        SyntaxKind.VoidExpression = 170;
        SyntaxKind._map[171] = "CommaExpression";
        SyntaxKind.CommaExpression = 171;
        SyntaxKind._map[172] = "AssignmentExpression";
        SyntaxKind.AssignmentExpression = 172;
        SyntaxKind._map[173] = "AddAssignmentExpression";
        SyntaxKind.AddAssignmentExpression = 173;
        SyntaxKind._map[174] = "SubtractAssignmentExpression";
        SyntaxKind.SubtractAssignmentExpression = 174;
        SyntaxKind._map[175] = "MultiplyAssignmentExpression";
        SyntaxKind.MultiplyAssignmentExpression = 175;
        SyntaxKind._map[176] = "DivideAssignmentExpression";
        SyntaxKind.DivideAssignmentExpression = 176;
        SyntaxKind._map[177] = "ModuloAssignmentExpression";
        SyntaxKind.ModuloAssignmentExpression = 177;
        SyntaxKind._map[178] = "AndAssignmentExpression";
        SyntaxKind.AndAssignmentExpression = 178;
        SyntaxKind._map[179] = "ExclusiveOrAssignmentExpression";
        SyntaxKind.ExclusiveOrAssignmentExpression = 179;
        SyntaxKind._map[180] = "OrAssignmentExpression";
        SyntaxKind.OrAssignmentExpression = 180;
        SyntaxKind._map[181] = "LeftShiftAssignmentExpression";
        SyntaxKind.LeftShiftAssignmentExpression = 181;
        SyntaxKind._map[182] = "SignedRightShiftAssignmentExpression";
        SyntaxKind.SignedRightShiftAssignmentExpression = 182;
        SyntaxKind._map[183] = "UnsignedRightShiftAssignmentExpression";
        SyntaxKind.UnsignedRightShiftAssignmentExpression = 183;
        SyntaxKind._map[184] = "ConditionalExpression";
        SyntaxKind.ConditionalExpression = 184;
        SyntaxKind._map[185] = "LogicalOrExpression";
        SyntaxKind.LogicalOrExpression = 185;
        SyntaxKind._map[186] = "LogicalAndExpression";
        SyntaxKind.LogicalAndExpression = 186;
        SyntaxKind._map[187] = "BitwiseOrExpression";
        SyntaxKind.BitwiseOrExpression = 187;
        SyntaxKind._map[188] = "BitwiseExclusiveOrExpression";
        SyntaxKind.BitwiseExclusiveOrExpression = 188;
        SyntaxKind._map[189] = "BitwiseAndExpression";
        SyntaxKind.BitwiseAndExpression = 189;
        SyntaxKind._map[190] = "EqualsWithTypeConversionExpression";
        SyntaxKind.EqualsWithTypeConversionExpression = 190;
        SyntaxKind._map[191] = "NotEqualsWithTypeConversionExpression";
        SyntaxKind.NotEqualsWithTypeConversionExpression = 191;
        SyntaxKind._map[192] = "EqualsExpression";
        SyntaxKind.EqualsExpression = 192;
        SyntaxKind._map[193] = "NotEqualsExpression";
        SyntaxKind.NotEqualsExpression = 193;
        SyntaxKind._map[194] = "LessThanExpression";
        SyntaxKind.LessThanExpression = 194;
        SyntaxKind._map[195] = "GreaterThanExpression";
        SyntaxKind.GreaterThanExpression = 195;
        SyntaxKind._map[196] = "LessThanOrEqualExpression";
        SyntaxKind.LessThanOrEqualExpression = 196;
        SyntaxKind._map[197] = "GreaterThanOrEqualExpression";
        SyntaxKind.GreaterThanOrEqualExpression = 197;
        SyntaxKind._map[198] = "InstanceOfExpression";
        SyntaxKind.InstanceOfExpression = 198;
        SyntaxKind._map[199] = "InExpression";
        SyntaxKind.InExpression = 199;
        SyntaxKind._map[200] = "LeftShiftExpression";
        SyntaxKind.LeftShiftExpression = 200;
        SyntaxKind._map[201] = "SignedRightShiftExpression";
        SyntaxKind.SignedRightShiftExpression = 201;
        SyntaxKind._map[202] = "UnsignedRightShiftExpression";
        SyntaxKind.UnsignedRightShiftExpression = 202;
        SyntaxKind._map[203] = "MultiplyExpression";
        SyntaxKind.MultiplyExpression = 203;
        SyntaxKind._map[204] = "DivideExpression";
        SyntaxKind.DivideExpression = 204;
        SyntaxKind._map[205] = "ModuloExpression";
        SyntaxKind.ModuloExpression = 205;
        SyntaxKind._map[206] = "AddExpression";
        SyntaxKind.AddExpression = 206;
        SyntaxKind._map[207] = "SubtractExpression";
        SyntaxKind.SubtractExpression = 207;
        SyntaxKind._map[208] = "PostIncrementExpression";
        SyntaxKind.PostIncrementExpression = 208;
        SyntaxKind._map[209] = "PostDecrementExpression";
        SyntaxKind.PostDecrementExpression = 209;
        SyntaxKind._map[210] = "MemberAccessExpression";
        SyntaxKind.MemberAccessExpression = 210;
        SyntaxKind._map[211] = "InvocationExpression";
        SyntaxKind.InvocationExpression = 211;
        SyntaxKind._map[212] = "ArrayLiteralExpression";
        SyntaxKind.ArrayLiteralExpression = 212;
        SyntaxKind._map[213] = "ObjectLiteralExpression";
        SyntaxKind.ObjectLiteralExpression = 213;
        SyntaxKind._map[214] = "ObjectCreationExpression";
        SyntaxKind.ObjectCreationExpression = 214;
        SyntaxKind._map[215] = "ParenthesizedExpression";
        SyntaxKind.ParenthesizedExpression = 215;
        SyntaxKind._map[216] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind.ParenthesizedArrowFunctionExpression = 216;
        SyntaxKind._map[217] = "SimpleArrowFunctionExpression";
        SyntaxKind.SimpleArrowFunctionExpression = 217;
        SyntaxKind._map[218] = "CastExpression";
        SyntaxKind.CastExpression = 218;
        SyntaxKind._map[219] = "ElementAccessExpression";
        SyntaxKind.ElementAccessExpression = 219;
        SyntaxKind._map[220] = "FunctionExpression";
        SyntaxKind.FunctionExpression = 220;
        SyntaxKind._map[221] = "OmittedExpression";
        SyntaxKind.OmittedExpression = 221;
        SyntaxKind._map[222] = "VariableDeclaration";
        SyntaxKind.VariableDeclaration = 222;
        SyntaxKind._map[223] = "VariableDeclarator";
        SyntaxKind.VariableDeclarator = 223;
        SyntaxKind._map[224] = "ArgumentList";
        SyntaxKind.ArgumentList = 224;
        SyntaxKind._map[225] = "ParameterList";
        SyntaxKind.ParameterList = 225;
        SyntaxKind._map[226] = "TypeArgumentList";
        SyntaxKind.TypeArgumentList = 226;
        SyntaxKind._map[227] = "TypeParameterList";
        SyntaxKind.TypeParameterList = 227;
        SyntaxKind._map[228] = "HeritageClause";
        SyntaxKind.HeritageClause = 228;
        SyntaxKind._map[229] = "EqualsValueClause";
        SyntaxKind.EqualsValueClause = 229;
        SyntaxKind._map[230] = "CaseSwitchClause";
        SyntaxKind.CaseSwitchClause = 230;
        SyntaxKind._map[231] = "DefaultSwitchClause";
        SyntaxKind.DefaultSwitchClause = 231;
        SyntaxKind._map[232] = "ElseClause";
        SyntaxKind.ElseClause = 232;
        SyntaxKind._map[233] = "CatchClause";
        SyntaxKind.CatchClause = 233;
        SyntaxKind._map[234] = "FinallyClause";
        SyntaxKind.FinallyClause = 234;
        SyntaxKind._map[235] = "TypeParameter";
        SyntaxKind.TypeParameter = 235;
        SyntaxKind._map[236] = "Constraint";
        SyntaxKind.Constraint = 236;
        SyntaxKind._map[237] = "Parameter";
        SyntaxKind.Parameter = 237;
        SyntaxKind._map[238] = "EnumElement";
        SyntaxKind.EnumElement = 238;
        SyntaxKind._map[239] = "TypeAnnotation";
        SyntaxKind.TypeAnnotation = 239;
        SyntaxKind._map[240] = "SimplePropertyAssignment";
        SyntaxKind.SimplePropertyAssignment = 240;
        SyntaxKind._map[241] = "ExternalModuleReference";
        SyntaxKind.ExternalModuleReference = 241;
        SyntaxKind._map[242] = "ModuleNameModuleReference";
        SyntaxKind.ModuleNameModuleReference = 242;
        SyntaxKind._map[243] = "GetAccessorPropertyAssignment";
        SyntaxKind.GetAccessorPropertyAssignment = 243;
        SyntaxKind._map[244] = "SetAccessorPropertyAssignment";
        SyntaxKind.SetAccessorPropertyAssignment = 244;
        SyntaxKind.FirstStandardKeyword = SyntaxKind.BreakKeyword;
        SyntaxKind.LastStandardKeyword = SyntaxKind.WithKeyword;
        SyntaxKind.FirstFutureReservedKeyword = SyntaxKind.ClassKeyword;
        SyntaxKind.LastFutureReservedKeyword = SyntaxKind.SuperKeyword;
        SyntaxKind.FirstFutureReservedStrictKeyword = SyntaxKind.ImplementsKeyword;
        SyntaxKind.LastFutureReservedStrictKeyword = SyntaxKind.YieldKeyword;
        SyntaxKind.FirstTypeScriptKeyword = SyntaxKind.AnyKeyword;
        SyntaxKind.LastTypeScriptKeyword = SyntaxKind.StringKeyword;
        SyntaxKind.FirstKeyword = SyntaxKind.FirstStandardKeyword;
        SyntaxKind.LastKeyword = SyntaxKind.LastTypeScriptKeyword;
        SyntaxKind.FirstToken = SyntaxKind.ErrorToken;
        SyntaxKind.LastToken = SyntaxKind.SlashEqualsToken;
        SyntaxKind.FirstPunctuation = SyntaxKind.OpenBraceToken;
        SyntaxKind.LastPunctuation = SyntaxKind.SlashEqualsToken;
        SyntaxKind.FirstFixedWidth = SyntaxKind.FirstKeyword;
        SyntaxKind.LastFixedWidth = SyntaxKind.LastPunctuation;
    })(TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
    var SyntaxKind = TypeScript.SyntaxKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": TypeScript.SyntaxKind.AnyKeyword,
            "bool": TypeScript.SyntaxKind.BoolKeyword,
            "boolean": TypeScript.SyntaxKind.BooleanKeyword,
            "break": TypeScript.SyntaxKind.BreakKeyword,
            "case": TypeScript.SyntaxKind.CaseKeyword,
            "catch": TypeScript.SyntaxKind.CatchKeyword,
            "class": TypeScript.SyntaxKind.ClassKeyword,
            "continue": TypeScript.SyntaxKind.ContinueKeyword,
            "const": TypeScript.SyntaxKind.ConstKeyword,
            "constructor": TypeScript.SyntaxKind.ConstructorKeyword,
            "debugger": TypeScript.SyntaxKind.DebuggerKeyword,
            "declare": TypeScript.SyntaxKind.DeclareKeyword,
            "default": TypeScript.SyntaxKind.DefaultKeyword,
            "delete": TypeScript.SyntaxKind.DeleteKeyword,
            "do": TypeScript.SyntaxKind.DoKeyword,
            "else": TypeScript.SyntaxKind.ElseKeyword,
            "enum": TypeScript.SyntaxKind.EnumKeyword,
            "export": TypeScript.SyntaxKind.ExportKeyword,
            "extends": TypeScript.SyntaxKind.ExtendsKeyword,
            "false": TypeScript.SyntaxKind.FalseKeyword,
            "finally": TypeScript.SyntaxKind.FinallyKeyword,
            "for": TypeScript.SyntaxKind.ForKeyword,
            "function": TypeScript.SyntaxKind.FunctionKeyword,
            "get": TypeScript.SyntaxKind.GetKeyword,
            "if": TypeScript.SyntaxKind.IfKeyword,
            "implements": TypeScript.SyntaxKind.ImplementsKeyword,
            "import": TypeScript.SyntaxKind.ImportKeyword,
            "in": TypeScript.SyntaxKind.InKeyword,
            "instanceof": TypeScript.SyntaxKind.InstanceOfKeyword,
            "interface": TypeScript.SyntaxKind.InterfaceKeyword,
            "let": TypeScript.SyntaxKind.LetKeyword,
            "module": TypeScript.SyntaxKind.ModuleKeyword,
            "new": TypeScript.SyntaxKind.NewKeyword,
            "null": TypeScript.SyntaxKind.NullKeyword,
            "number": TypeScript.SyntaxKind.NumberKeyword,
            "package": TypeScript.SyntaxKind.PackageKeyword,
            "private": TypeScript.SyntaxKind.PrivateKeyword,
            "protected": TypeScript.SyntaxKind.ProtectedKeyword,
            "public": TypeScript.SyntaxKind.PublicKeyword,
            "return": TypeScript.SyntaxKind.ReturnKeyword,
            "set": TypeScript.SyntaxKind.SetKeyword,
            "static": TypeScript.SyntaxKind.StaticKeyword,
            "string": TypeScript.SyntaxKind.StringKeyword,
            "super": TypeScript.SyntaxKind.SuperKeyword,
            "switch": TypeScript.SyntaxKind.SwitchKeyword,
            "this": TypeScript.SyntaxKind.ThisKeyword,
            "throw": TypeScript.SyntaxKind.ThrowKeyword,
            "true": TypeScript.SyntaxKind.TrueKeyword,
            "try": TypeScript.SyntaxKind.TryKeyword,
            "typeof": TypeScript.SyntaxKind.TypeOfKeyword,
            "var": TypeScript.SyntaxKind.VarKeyword,
            "void": TypeScript.SyntaxKind.VoidKeyword,
            "while": TypeScript.SyntaxKind.WhileKeyword,
            "with": TypeScript.SyntaxKind.WithKeyword,
            "yield": TypeScript.SyntaxKind.YieldKeyword,
            "{": TypeScript.SyntaxKind.OpenBraceToken,
            "}": TypeScript.SyntaxKind.CloseBraceToken,
            "(": TypeScript.SyntaxKind.OpenParenToken,
            ")": TypeScript.SyntaxKind.CloseParenToken,
            "[": TypeScript.SyntaxKind.OpenBracketToken,
            "]": TypeScript.SyntaxKind.CloseBracketToken,
            ".": TypeScript.SyntaxKind.DotToken,
            "...": TypeScript.SyntaxKind.DotDotDotToken,
            ";": TypeScript.SyntaxKind.SemicolonToken,
            ",": TypeScript.SyntaxKind.CommaToken,
            "<": TypeScript.SyntaxKind.LessThanToken,
            ">": TypeScript.SyntaxKind.GreaterThanToken,
            "<=": TypeScript.SyntaxKind.LessThanEqualsToken,
            ">=": TypeScript.SyntaxKind.GreaterThanEqualsToken,
            "==": TypeScript.SyntaxKind.EqualsEqualsToken,
            "=>": TypeScript.SyntaxKind.EqualsGreaterThanToken,
            "!=": TypeScript.SyntaxKind.ExclamationEqualsToken,
            "===": TypeScript.SyntaxKind.EqualsEqualsEqualsToken,
            "!==": TypeScript.SyntaxKind.ExclamationEqualsEqualsToken,
            "+": TypeScript.SyntaxKind.PlusToken,
            "-": TypeScript.SyntaxKind.MinusToken,
            "*": TypeScript.SyntaxKind.AsteriskToken,
            "%": TypeScript.SyntaxKind.PercentToken,
            "++": TypeScript.SyntaxKind.PlusPlusToken,
            "--": TypeScript.SyntaxKind.MinusMinusToken,
            "<<": TypeScript.SyntaxKind.LessThanLessThanToken,
            ">>": TypeScript.SyntaxKind.GreaterThanGreaterThanToken,
            ">>>": TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
            "&": TypeScript.SyntaxKind.AmpersandToken,
            "|": TypeScript.SyntaxKind.BarToken,
            "^": TypeScript.SyntaxKind.CaretToken,
            "!": TypeScript.SyntaxKind.ExclamationToken,
            "~": TypeScript.SyntaxKind.TildeToken,
            "&&": TypeScript.SyntaxKind.AmpersandAmpersandToken,
            "||": TypeScript.SyntaxKind.BarBarToken,
            "?": TypeScript.SyntaxKind.QuestionToken,
            ":": TypeScript.SyntaxKind.ColonToken,
            "=": TypeScript.SyntaxKind.EqualsToken,
            "+=": TypeScript.SyntaxKind.PlusEqualsToken,
            "-=": TypeScript.SyntaxKind.MinusEqualsToken,
            "*=": TypeScript.SyntaxKind.AsteriskEqualsToken,
            "%=": TypeScript.SyntaxKind.PercentEqualsToken,
            "<<=": TypeScript.SyntaxKind.LessThanLessThanEqualsToken,
            ">>=": TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken,
            ">>>=": TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
            "&=": TypeScript.SyntaxKind.AmpersandEqualsToken,
            "|=": TypeScript.SyntaxKind.BarEqualsToken,
            "^=": TypeScript.SyntaxKind.CaretEqualsToken,
            "/": TypeScript.SyntaxKind.SlashToken,
            "/=": TypeScript.SyntaxKind.SlashEqualsToken
        };
        var kindToText = [];
        for(var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                kindToText[textToKeywordKind[name]] = name;
            }
        }
        kindToText[TypeScript.SyntaxKind.ConstructorKeyword] = "constructor";
        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }
            return TypeScript.SyntaxKind.None;
        }
        SyntaxFacts.getTokenKind = getTokenKind;
        function getText(kind) {
            var result = kindToText[kind];
            return result !== undefined ? result : null;
        }
        SyntaxFacts.getText = getText;
        function isTokenKind(kind) {
            return kind >= TypeScript.SyntaxKind.FirstToken && kind <= TypeScript.SyntaxKind.LastToken;
        }
        SyntaxFacts.isTokenKind = isTokenKind;
        function isAnyKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstKeyword && kind <= TypeScript.SyntaxKind.LastKeyword;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;
        function isStandardKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstStandardKeyword && kind <= TypeScript.SyntaxKind.LastStandardKeyword;
        }
        SyntaxFacts.isStandardKeyword = isStandardKeyword;
        function isFutureReservedKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstFutureReservedKeyword && kind <= TypeScript.SyntaxKind.LastFutureReservedKeyword;
        }
        SyntaxFacts.isFutureReservedKeyword = isFutureReservedKeyword;
        function isFutureReservedStrictKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword && kind <= TypeScript.SyntaxKind.LastFutureReservedStrictKeyword;
        }
        SyntaxFacts.isFutureReservedStrictKeyword = isFutureReservedStrictKeyword;
        function isAnyPunctuation(kind) {
            return kind >= TypeScript.SyntaxKind.FirstPunctuation && kind <= TypeScript.SyntaxKind.LastPunctuation;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;
        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== TypeScript.SyntaxKind.None;
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;
        function isBinaryExpressionOperatorToken(tokenKind) {
            return getBinaryExpressionFromOperatorToken(tokenKind) !== TypeScript.SyntaxKind.None;
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;
        function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
            switch(tokenKind) {
                case TypeScript.SyntaxKind.PlusToken:
                    return TypeScript.SyntaxKind.PlusExpression;
                case TypeScript.SyntaxKind.MinusToken:
                    return TypeScript.SyntaxKind.NegateExpression;
                case TypeScript.SyntaxKind.TildeToken:
                    return TypeScript.SyntaxKind.BitwiseNotExpression;
                case TypeScript.SyntaxKind.ExclamationToken:
                    return TypeScript.SyntaxKind.LogicalNotExpression;
                case TypeScript.SyntaxKind.PlusPlusToken:
                    return TypeScript.SyntaxKind.PreIncrementExpression;
                case TypeScript.SyntaxKind.MinusMinusToken:
                    return TypeScript.SyntaxKind.PreDecrementExpression;
                default:
                    return TypeScript.SyntaxKind.None;
            }
        }
        SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;
        function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
            switch(tokenKind) {
                case TypeScript.SyntaxKind.PlusPlusToken:
                    return TypeScript.SyntaxKind.PostIncrementExpression;
                case TypeScript.SyntaxKind.MinusMinusToken:
                    return TypeScript.SyntaxKind.PostDecrementExpression;
                default:
                    return TypeScript.SyntaxKind.None;
            }
        }
        SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;
        function getBinaryExpressionFromOperatorToken(tokenKind) {
            switch(tokenKind) {
                case TypeScript.SyntaxKind.AsteriskToken:
                    return TypeScript.SyntaxKind.MultiplyExpression;
                case TypeScript.SyntaxKind.SlashToken:
                    return TypeScript.SyntaxKind.DivideExpression;
                case TypeScript.SyntaxKind.PercentToken:
                    return TypeScript.SyntaxKind.ModuloExpression;
                case TypeScript.SyntaxKind.PlusToken:
                    return TypeScript.SyntaxKind.AddExpression;
                case TypeScript.SyntaxKind.MinusToken:
                    return TypeScript.SyntaxKind.SubtractExpression;
                case TypeScript.SyntaxKind.LessThanLessThanToken:
                    return TypeScript.SyntaxKind.LeftShiftExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanToken:
                    return TypeScript.SyntaxKind.SignedRightShiftExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                    return TypeScript.SyntaxKind.UnsignedRightShiftExpression;
                case TypeScript.SyntaxKind.LessThanToken:
                    return TypeScript.SyntaxKind.LessThanExpression;
                case TypeScript.SyntaxKind.GreaterThanToken:
                    return TypeScript.SyntaxKind.GreaterThanExpression;
                case TypeScript.SyntaxKind.LessThanEqualsToken:
                    return TypeScript.SyntaxKind.LessThanOrEqualExpression;
                case TypeScript.SyntaxKind.GreaterThanEqualsToken:
                    return TypeScript.SyntaxKind.GreaterThanOrEqualExpression;
                case TypeScript.SyntaxKind.InstanceOfKeyword:
                    return TypeScript.SyntaxKind.InstanceOfExpression;
                case TypeScript.SyntaxKind.InKeyword:
                    return TypeScript.SyntaxKind.InExpression;
                case TypeScript.SyntaxKind.EqualsEqualsToken:
                    return TypeScript.SyntaxKind.EqualsWithTypeConversionExpression;
                case TypeScript.SyntaxKind.ExclamationEqualsToken:
                    return TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression;
                case TypeScript.SyntaxKind.EqualsEqualsEqualsToken:
                    return TypeScript.SyntaxKind.EqualsExpression;
                case TypeScript.SyntaxKind.ExclamationEqualsEqualsToken:
                    return TypeScript.SyntaxKind.NotEqualsExpression;
                case TypeScript.SyntaxKind.AmpersandToken:
                    return TypeScript.SyntaxKind.BitwiseAndExpression;
                case TypeScript.SyntaxKind.CaretToken:
                    return TypeScript.SyntaxKind.BitwiseExclusiveOrExpression;
                case TypeScript.SyntaxKind.BarToken:
                    return TypeScript.SyntaxKind.BitwiseOrExpression;
                case TypeScript.SyntaxKind.AmpersandAmpersandToken:
                    return TypeScript.SyntaxKind.LogicalAndExpression;
                case TypeScript.SyntaxKind.BarBarToken:
                    return TypeScript.SyntaxKind.LogicalOrExpression;
                case TypeScript.SyntaxKind.BarEqualsToken:
                    return TypeScript.SyntaxKind.OrAssignmentExpression;
                case TypeScript.SyntaxKind.AmpersandEqualsToken:
                    return TypeScript.SyntaxKind.AndAssignmentExpression;
                case TypeScript.SyntaxKind.CaretEqualsToken:
                    return TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression;
                case TypeScript.SyntaxKind.LessThanLessThanEqualsToken:
                    return TypeScript.SyntaxKind.LeftShiftAssignmentExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                    return TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression;
                case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    return TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression;
                case TypeScript.SyntaxKind.PlusEqualsToken:
                    return TypeScript.SyntaxKind.AddAssignmentExpression;
                case TypeScript.SyntaxKind.MinusEqualsToken:
                    return TypeScript.SyntaxKind.SubtractAssignmentExpression;
                case TypeScript.SyntaxKind.AsteriskEqualsToken:
                    return TypeScript.SyntaxKind.MultiplyAssignmentExpression;
                case TypeScript.SyntaxKind.SlashEqualsToken:
                    return TypeScript.SyntaxKind.DivideAssignmentExpression;
                case TypeScript.SyntaxKind.PercentEqualsToken:
                    return TypeScript.SyntaxKind.ModuloAssignmentExpression;
                case TypeScript.SyntaxKind.EqualsToken:
                    return TypeScript.SyntaxKind.AssignmentExpression;
                case TypeScript.SyntaxKind.CommaToken:
                    return TypeScript.SyntaxKind.CommaExpression;
                default:
                    return TypeScript.SyntaxKind.None;
            }
        }
        SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;
        function isAnyDivideToken(kind) {
            switch(kind) {
                case TypeScript.SyntaxKind.SlashToken:
                case TypeScript.SyntaxKind.SlashEqualsToken:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideToken = isAnyDivideToken;
        function isAnyDivideOrRegularExpressionToken(kind) {
            switch(kind) {
                case TypeScript.SyntaxKind.SlashToken:
                case TypeScript.SyntaxKind.SlashEqualsToken:
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideOrRegularExpressionToken = isAnyDivideOrRegularExpressionToken;
        function isParserGenerated(kind) {
            switch(kind) {
                case TypeScript.SyntaxKind.GreaterThanGreaterThanToken:
                case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                case TypeScript.SyntaxKind.GreaterThanEqualsToken:
                case TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isParserGenerated = isParserGenerated;
        function isAnyBinaryExpression(kind) {
            switch(kind) {
                case TypeScript.SyntaxKind.CommaExpression:
                case TypeScript.SyntaxKind.AssignmentExpression:
                case TypeScript.SyntaxKind.AddAssignmentExpression:
                case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                case TypeScript.SyntaxKind.DivideAssignmentExpression:
                case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                case TypeScript.SyntaxKind.AndAssignmentExpression:
                case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                case TypeScript.SyntaxKind.OrAssignmentExpression:
                case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                case TypeScript.SyntaxKind.LogicalOrExpression:
                case TypeScript.SyntaxKind.LogicalAndExpression:
                case TypeScript.SyntaxKind.BitwiseOrExpression:
                case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                case TypeScript.SyntaxKind.BitwiseAndExpression:
                case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                case TypeScript.SyntaxKind.EqualsExpression:
                case TypeScript.SyntaxKind.NotEqualsExpression:
                case TypeScript.SyntaxKind.LessThanExpression:
                case TypeScript.SyntaxKind.GreaterThanExpression:
                case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                case TypeScript.SyntaxKind.InstanceOfExpression:
                case TypeScript.SyntaxKind.InExpression:
                case TypeScript.SyntaxKind.LeftShiftExpression:
                case TypeScript.SyntaxKind.SignedRightShiftExpression:
                case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                case TypeScript.SyntaxKind.MultiplyExpression:
                case TypeScript.SyntaxKind.DivideExpression:
                case TypeScript.SyntaxKind.ModuloExpression:
                case TypeScript.SyntaxKind.AddExpression:
                case TypeScript.SyntaxKind.SubtractExpression:
                    return true;
            }
            return false;
        }
        SyntaxFacts.isAnyBinaryExpression = isAnyBinaryExpression;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            if (node.kind() === TypeScript.SyntaxKind.ExpressionStatement) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;
                if (expression.kind() === TypeScript.SyntaxKind.StringLiteral) {
                    return true;
                }
            }
            return false;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;
        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;
            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;
        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.tokenKind;
            return tokenKind === TypeScript.SyntaxKind.IdentifierName || TypeScript.SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySyntaxList = (function () {
            function EmptySyntaxList() { }
            EmptySyntaxList.prototype.kind = function () {
                return TypeScript.SyntaxKind.List;
            };
            EmptySyntaxList.prototype.isNode = function () {
                return false;
            };
            EmptySyntaxList.prototype.isToken = function () {
                return false;
            };
            EmptySyntaxList.prototype.isList = function () {
                return true;
            };
            EmptySyntaxList.prototype.isSeparatedList = function () {
                return false;
            };
            EmptySyntaxList.prototype.toJSON = function (key) {
                return [];
            };
            EmptySyntaxList.prototype.childCount = function () {
                return 0;
            };
            EmptySyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptySyntaxList.prototype.toArray = function () {
                return [];
            };
            EmptySyntaxList.prototype.collectTextElements = function (elements) {
            };
            EmptySyntaxList.prototype.firstToken = function () {
                return null;
            };
            EmptySyntaxList.prototype.lastToken = function () {
                return null;
            };
            EmptySyntaxList.prototype.fullWidth = function () {
                return 0;
            };
            EmptySyntaxList.prototype.width = function () {
                return 0;
            };
            EmptySyntaxList.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptySyntaxList.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptySyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptySyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            EmptySyntaxList.prototype.fullText = function () {
                return "";
            };
            EmptySyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            EmptySyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };
            EmptySyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };
            EmptySyntaxList.prototype.insertChildrenInto = function (array, index) {
            };
            return EmptySyntaxList;
        })();
        Syntax.EmptySyntaxList = EmptySyntaxList;        
        Syntax.emptyList = new EmptySyntaxList();
        var SingletonSyntaxList = (function () {
            function SingletonSyntaxList(item) {
                this.item = item;
            }
            SingletonSyntaxList.prototype.kind = function () {
                return TypeScript.SyntaxKind.List;
            };
            SingletonSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isList = function () {
                return true;
            };
            SingletonSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };
            SingletonSyntaxList.prototype.toJSON = function (key) {
                return [
                    this.item
                ];
            };
            SingletonSyntaxList.prototype.childCount = function () {
                return 1;
            };
            SingletonSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSyntaxList.prototype.toArray = function () {
                return [
                    this.item
                ];
            };
            SingletonSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };
            SingletonSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };
            SingletonSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };
            SingletonSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };
            SingletonSyntaxList.prototype.width = function () {
                return this.item.width();
            };
            SingletonSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };
            SingletonSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };
            SingletonSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };
            SingletonSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };
            SingletonSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };
            SingletonSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };
            SingletonSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };
            SingletonSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return (this.item).findTokenInternal(new TypeScript.PositionedList(parent, this, fullStart), position, fullStart);
            };
            SingletonSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSyntaxList;
        })();        
        var NormalSyntaxList = (function () {
            function NormalSyntaxList(nodeOrTokens) {
                this._data = 0;
                this.nodeOrTokens = nodeOrTokens;
            }
            NormalSyntaxList.prototype.kind = function () {
                return TypeScript.SyntaxKind.List;
            };
            NormalSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSyntaxList.prototype.isList = function () {
                return true;
            };
            NormalSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };
            NormalSyntaxList.prototype.toJSON = function (key) {
                return this.nodeOrTokens;
            };
            NormalSyntaxList.prototype.childCount = function () {
                return this.nodeOrTokens.length;
            };
            NormalSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.nodeOrTokens.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.nodeOrTokens[index];
            };
            NormalSyntaxList.prototype.toArray = function () {
                return this.nodeOrTokens.slice(0);
            };
            NormalSyntaxList.prototype.collectTextElements = function (elements) {
                for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var element = this.nodeOrTokens[i];
                    element.collectTextElements(elements);
                }
            };
            NormalSyntaxList.prototype.firstToken = function () {
                for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var token = this.nodeOrTokens[i].firstToken();
                    if (token !== null) {
                        return token;
                    }
                }
                return null;
            };
            NormalSyntaxList.prototype.lastToken = function () {
                for(var i = this.nodeOrTokens.length - 1; i >= 0; i--) {
                    var token = this.nodeOrTokens[i].lastToken();
                    if (token !== null) {
                        return token;
                    }
                }
                return null;
            };
            NormalSyntaxList.prototype.fullText = function () {
                var elements = [];
                this.collectTextElements(elements);
                return elements.join("");
            };
            NormalSyntaxList.prototype.isTypeScriptSpecific = function () {
                for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    if (this.nodeOrTokens[i].isTypeScriptSpecific()) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask) !== 0;
            };
            NormalSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> TypeScript.SyntaxConstants.NodeFullWidthShift;
            };
            NormalSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };
            NormalSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };
            NormalSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };
            NormalSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };
            NormalSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };
            NormalSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;
                for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var node = this.nodeOrTokens[i];
                    fullWidth += node.fullWidth();
                    isIncrementallyUnusable = isIncrementallyUnusable || node.isIncrementallyUnusable();
                }
                return (fullWidth << TypeScript.SyntaxConstants.NodeFullWidthShift) | (isIncrementallyUnusable ? TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask : 0) | TypeScript.SyntaxConstants.NodeDataComputed;
            };
            NormalSyntaxList.prototype.data = function () {
                if ((this._data & TypeScript.SyntaxConstants.NodeDataComputed) === 0) {
                    this._data = this.computeData();
                }
                return this._data;
            };
            NormalSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedList(parent, this, fullStart);
                for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var nodeOrToken = this.nodeOrTokens[i];
                    var childWidth = nodeOrToken.fullWidth();
                    if (position < childWidth) {
                        return (nodeOrToken).findTokenInternal(parent, position, fullStart);
                    }
                    position -= childWidth;
                    fullStart += childWidth;
                }
                throw TypeScript.Errors.invalidOperation();
            };
            NormalSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.nodeOrTokens);
                } else {
                    array.splice.apply(array, [
                        index, 
                        0
                    ].concat(this.nodeOrTokens));
                }
            };
            return NormalSyntaxList;
        })();        
        function list(nodes) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptyList;
            }
            if (nodes.length === 1) {
                var item = nodes[0];
                return new SingletonSyntaxList(item);
            }
            return new NormalSyntaxList(nodes);
        }
        Syntax.list = list;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNode = (function () {
        function SyntaxNode(parsedInStrictMode) {
            this._data = parsedInStrictMode ? TypeScript.SyntaxConstants.NodeParsedInStrictModeMask : 0;
        }
        SyntaxNode.prototype.isNode = function () {
            return true;
        };
        SyntaxNode.prototype.isToken = function () {
            return false;
        };
        SyntaxNode.prototype.isList = function () {
            return false;
        };
        SyntaxNode.prototype.isSeparatedList = function () {
            return false;
        };
        SyntaxNode.prototype.kind = function () {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.childCount = function () {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.childAt = function (slot) {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.firstToken = function () {
            for(var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);
                if (element != null) {
                    if (element.fullWidth() > 0 || element.kind() === TypeScript.SyntaxKind.EndOfFileToken) {
                        return element.firstToken();
                    }
                }
            }
            return null;
        };
        SyntaxNode.prototype.lastToken = function () {
            for(var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);
                if (element != null) {
                    if (element.fullWidth() > 0 || element.kind() === TypeScript.SyntaxKind.EndOfFileToken) {
                        return element.lastToken();
                    }
                }
            }
            return null;
        };
        SyntaxNode.prototype.insertChildrenInto = function (array, index) {
            for(var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);
                if (element !== null) {
                    if (element.isNode() || element.isToken()) {
                        array.splice(index, 0, element);
                    } else if (element.isList()) {
                        (element).insertChildrenInto(array, index);
                    } else if (element.isSeparatedList()) {
                        (element).insertChildrenInto(array, index);
                    } else {
                        throw TypeScript.Errors.invalidOperation();
                    }
                }
            }
        };
        SyntaxNode.prototype.leadingTrivia = function () {
            return this.firstToken().leadingTrivia();
        };
        SyntaxNode.prototype.trailingTrivia = function () {
            return this.lastToken().trailingTrivia();
        };
        SyntaxNode.prototype.toJSON = function (key) {
            var result = {
                kind: (TypeScript.SyntaxKind)._map[this.kind()],
                fullWidth: this.fullWidth()
            };
            if (this.isIncrementallyUnusable()) {
                result.isIncrementallyUnusable = true;
            }
            if (this.parsedInStrictMode()) {
                result.parsedInStrictMode = true;
            }
            for(var i = 0, n = this.childCount(); i < n; i++) {
                var value = this.childAt(i);
                if (value) {
                    for(var name in this) {
                        if (value === this[name]) {
                            result[name] = value;
                            break;
                        }
                    }
                }
            }
            return result;
        };
        SyntaxNode.prototype.accept = function (visitor) {
            throw TypeScript.Errors.abstract();
        };
        SyntaxNode.prototype.fullText = function () {
            var elements = [];
            this.collectTextElements(elements);
            return elements.join("");
        };
        SyntaxNode.prototype.collectTextElements = function (elements) {
            for(var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);
                if (element !== null) {
                    element.collectTextElements(elements);
                }
            }
        };
        SyntaxNode.prototype.replaceToken = function (token1, token2) {
            if (token1 === token2) {
                return this;
            }
            return this.accept(new TypeScript.SyntaxTokenReplacer(token1, token2));
        };
        SyntaxNode.prototype.withLeadingTrivia = function (trivia) {
            return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
        };
        SyntaxNode.prototype.withTrailingTrivia = function (trivia) {
            return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
        };
        SyntaxNode.prototype.hasLeadingTrivia = function () {
            return this.lastToken().hasLeadingTrivia();
        };
        SyntaxNode.prototype.hasTrailingTrivia = function () {
            return this.lastToken().hasTrailingTrivia();
        };
        SyntaxNode.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        SyntaxNode.prototype.isIncrementallyUnusable = function () {
            return (this.data() & TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask) !== 0;
        };
        SyntaxNode.prototype.parsedInStrictMode = function () {
            return (this.data() & TypeScript.SyntaxConstants.NodeParsedInStrictModeMask) !== 0;
        };
        SyntaxNode.prototype.fullWidth = function () {
            return this.data() >>> TypeScript.SyntaxConstants.NodeFullWidthShift;
        };
        SyntaxNode.prototype.computeData = function () {
            var slotCount = this.childCount();
            var fullWidth = 0;
            var childWidth = 0;
            var isIncrementallyUnusable = ((this._data & TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask) !== 0) || slotCount === 0;
            for(var i = 0, n = slotCount; i < n; i++) {
                var element = this.childAt(i);
                if (element !== null) {
                    childWidth = element.fullWidth();
                    fullWidth += childWidth;
                    if (!isIncrementallyUnusable) {
                        isIncrementallyUnusable = element.isIncrementallyUnusable();
                    }
                }
            }
            return (fullWidth << TypeScript.SyntaxConstants.NodeFullWidthShift) | (isIncrementallyUnusable ? TypeScript.SyntaxConstants.NodeIncrementallyUnusableMask : 0) | TypeScript.SyntaxConstants.NodeDataComputed;
        };
        SyntaxNode.prototype.data = function () {
            if ((this._data & TypeScript.SyntaxConstants.NodeDataComputed) === 0) {
                this._data |= this.computeData();
            }
            return this._data;
        };
        SyntaxNode.prototype.findToken = function (position) {
            var endOfFileToken = this.tryGetEndOfFileAt(position);
            if (endOfFileToken !== null) {
                return endOfFileToken;
            }
            if (position < 0 || position >= this.fullWidth()) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }
            return this.findTokenInternal(null, position, 0);
        };
        SyntaxNode.prototype.tryGetEndOfFileAt = function (position) {
            if (this.kind() === TypeScript.SyntaxKind.SourceUnit && position === this.fullWidth()) {
                var sourceUnit = this;
                return new TypeScript.PositionedToken(new TypeScript.PositionedNode(null, sourceUnit, 0), sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
            }
            return null;
        };
        SyntaxNode.prototype.findTokenInternal = function (parent, position, fullStart) {
            parent = new TypeScript.PositionedNode(parent, this, fullStart);
            for(var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);
                if (element !== null) {
                    var childWidth = element.fullWidth();
                    if (position < childWidth) {
                        return (element).findTokenInternal(parent, position, fullStart);
                    }
                    position -= childWidth;
                    fullStart += childWidth;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        };
        SyntaxNode.prototype.findTokenOnLeft = function (position) {
            var positionedToken = this.findToken(position);
            var start = positionedToken.start();
            if (position > start) {
                return positionedToken;
            }
            if (positionedToken.fullStart() === 0) {
                return null;
            }
            var previousToken = this.findToken(positionedToken.fullStart() - 1);
            return previousToken;
        };
        SyntaxNode.prototype.isModuleElement = function () {
            return false;
        };
        SyntaxNode.prototype.isClassElement = function () {
            return false;
        };
        SyntaxNode.prototype.isTypeMember = function () {
            return false;
        };
        SyntaxNode.prototype.isStatement = function () {
            return false;
        };
        SyntaxNode.prototype.isSwitchClause = function () {
            return false;
        };
        SyntaxNode.prototype.structuralEquals = function (node) {
            if (this === node) {
                return true;
            }
            if (node === null) {
                return false;
            }
            if (this.kind() !== node.kind()) {
                return false;
            }
            for(var i = 0, n = this.childCount(); i < n; i++) {
                var element1 = this.childAt(i);
                var element2 = node.childAt(i);
                if (!TypeScript.Syntax.elementStructuralEquals(element1, element2)) {
                    return false;
                }
            }
            return true;
        };
        SyntaxNode.prototype.width = function () {
            return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        };
        SyntaxNode.prototype.leadingTriviaWidth = function () {
            var firstToken = this.firstToken();
            return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
        };
        SyntaxNode.prototype.trailingTriviaWidth = function () {
            var lastToken = this.lastToken();
            return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
        };
        return SyntaxNode;
    })();
    TypeScript.SyntaxNode = SyntaxNode;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceUnitSyntax = (function (_super) {
        __extends(SourceUnitSyntax, _super);
        function SourceUnitSyntax(moduleElements, endOfFileToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleElements = moduleElements;
            this.endOfFileToken = endOfFileToken;
        }
        SourceUnitSyntax.prototype.accept = function (visitor) {
            return visitor.visitSourceUnit(this);
        };
        SourceUnitSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SourceUnit;
        };
        SourceUnitSyntax.prototype.childCount = function () {
            return 2;
        };
        SourceUnitSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.moduleElements;
                case 1:
                    return this.endOfFileToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SourceUnitSyntax.prototype.update = function (moduleElements, endOfFileToken) {
            if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
                return this;
            }
            return new SourceUnitSyntax(moduleElements, endOfFileToken, this.parsedInStrictMode());
        };
        SourceUnitSyntax.create = function create(endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };
        SourceUnitSyntax.create1 = function create1(endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };
        SourceUnitSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SourceUnitSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SourceUnitSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(moduleElements, this.endOfFileToken);
        };
        SourceUnitSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([
                moduleElement
            ]));
        };
        SourceUnitSyntax.prototype.withEndOfFileToken = function (endOfFileToken) {
            return this.update(this.moduleElements, endOfFileToken);
        };
        SourceUnitSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.moduleElements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SourceUnitSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SourceUnitSyntax = SourceUnitSyntax;    
    var ModuleReferenceSyntax = (function (_super) {
        __extends(ModuleReferenceSyntax, _super);
        function ModuleReferenceSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        ModuleReferenceSyntax.prototype.isModuleReference = function () {
            return true;
        };
        ModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleReferenceSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleReferenceSyntax = ModuleReferenceSyntax;    
    var ExternalModuleReferenceSyntax = (function (_super) {
        __extends(ExternalModuleReferenceSyntax, _super);
        function ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleKeyword = moduleKeyword;
            this.openParenToken = openParenToken;
            this.stringLiteral = stringLiteral;
            this.closeParenToken = closeParenToken;
        }
        ExternalModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitExternalModuleReference(this);
        };
        ExternalModuleReferenceSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExternalModuleReference;
        };
        ExternalModuleReferenceSyntax.prototype.childCount = function () {
            return 4;
        };
        ExternalModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.moduleKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.stringLiteral;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ExternalModuleReferenceSyntax.prototype.update = function (moduleKeyword, openParenToken, stringLiteral, closeParenToken) {
            if (this.moduleKeyword === moduleKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, this.parsedInStrictMode());
        };
        ExternalModuleReferenceSyntax.create1 = function create1(stringLiteral) {
            return new ExternalModuleReferenceSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ModuleKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), stringLiteral, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ExternalModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ExternalModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ExternalModuleReferenceSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
            return this.update(moduleKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.moduleKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.moduleKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.moduleKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
        };
        ExternalModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExternalModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ExternalModuleReferenceSyntax = ExternalModuleReferenceSyntax;    
    var ModuleNameModuleReferenceSyntax = (function (_super) {
        __extends(ModuleNameModuleReferenceSyntax, _super);
        function ModuleNameModuleReferenceSyntax(moduleName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleName = moduleName;
        }
        ModuleNameModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleNameModuleReference(this);
        };
        ModuleNameModuleReferenceSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ModuleNameModuleReference;
        };
        ModuleNameModuleReferenceSyntax.prototype.childCount = function () {
            return 1;
        };
        ModuleNameModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.moduleName;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ModuleNameModuleReferenceSyntax.prototype.update = function (moduleName) {
            if (this.moduleName === moduleName) {
                return this;
            }
            return new ModuleNameModuleReferenceSyntax(moduleName, this.parsedInStrictMode());
        };
        ModuleNameModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ModuleNameModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ModuleNameModuleReferenceSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(moduleName);
        };
        ModuleNameModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleNameModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ModuleNameModuleReferenceSyntax = ModuleNameModuleReferenceSyntax;    
    var ImportDeclarationSyntax = (function (_super) {
        __extends(ImportDeclarationSyntax, _super);
        function ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.importKeyword = importKeyword;
            this.identifier = identifier;
            this.equalsToken = equalsToken;
            this.moduleReference = moduleReference;
            this.semicolonToken = semicolonToken;
        }
        ImportDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitImportDeclaration(this);
        };
        ImportDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ImportDeclaration;
        };
        ImportDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };
        ImportDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.importKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.equalsToken;
                case 3:
                    return this.moduleReference;
                case 4:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ImportDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ImportDeclarationSyntax.prototype.update = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            if (this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, this.parsedInStrictMode());
        };
        ImportDeclarationSyntax.create1 = function create1(identifier, moduleReference) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ImportKeyword), identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsToken), moduleReference, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ImportDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ImportDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ImportDeclarationSyntax.prototype.withImportKeyword = function (importKeyword) {
            return this.update(importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withModuleReference = function (moduleReference) {
            return this.update(this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
        };
        ImportDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
        };
        ImportDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ImportDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ImportDeclarationSyntax = ImportDeclarationSyntax;    
    var ExportAssignmentSyntax = (function (_super) {
        __extends(ExportAssignmentSyntax, _super);
        function ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.exportKeyword = exportKeyword;
            this.equalsToken = equalsToken;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ExportAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitExportAssignment(this);
        };
        ExportAssignmentSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExportAssignment;
        };
        ExportAssignmentSyntax.prototype.childCount = function () {
            return 4;
        };
        ExportAssignmentSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.exportKeyword;
                case 1:
                    return this.equalsToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ExportAssignmentSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ExportAssignmentSyntax.prototype.update = function (exportKeyword, equalsToken, identifier, semicolonToken) {
            if (this.exportKeyword === exportKeyword && this.equalsToken === equalsToken && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, this.parsedInStrictMode());
        };
        ExportAssignmentSyntax.create1 = function create1(identifier) {
            return new ExportAssignmentSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ExportKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsToken), identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ExportAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ExportAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ExportAssignmentSyntax.prototype.withExportKeyword = function (exportKeyword) {
            return this.update(exportKeyword, this.equalsToken, this.identifier, this.semicolonToken);
        };
        ExportAssignmentSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.exportKeyword, equalsToken, this.identifier, this.semicolonToken);
        };
        ExportAssignmentSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.exportKeyword, this.equalsToken, identifier, this.semicolonToken);
        };
        ExportAssignmentSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.exportKeyword, this.equalsToken, this.identifier, semicolonToken);
        };
        ExportAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExportAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExportAssignmentSyntax = ExportAssignmentSyntax;    
    var ClassDeclarationSyntax = (function (_super) {
        __extends(ClassDeclarationSyntax, _super);
        function ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.classKeyword = classKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.openBraceToken = openBraceToken;
            this.classElements = classElements;
            this.closeBraceToken = closeBraceToken;
        }
        ClassDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitClassDeclaration(this);
        };
        ClassDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ClassDeclaration;
        };
        ClassDeclarationSyntax.prototype.childCount = function () {
            return 8;
        };
        ClassDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.classKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.openBraceToken;
                case 6:
                    return this.classElements;
                case 7:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ClassDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ClassDeclarationSyntax.prototype.update = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, this.parsedInStrictMode());
        };
        ClassDeclarationSyntax.create = function create(classKeyword, identifier, openBraceToken, closeBraceToken) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, classKeyword, identifier, null, TypeScript.Syntax.emptyList, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        ClassDeclarationSyntax.create1 = function create1(identifier) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.ClassKeyword), identifier, null, TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ClassDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ClassDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ClassDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        ClassDeclarationSyntax.prototype.withClassKeyword = function (classKeyword) {
            return this.update(this.modifiers, classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.classKeyword, identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([
                heritageClause
            ]));
        };
        ClassDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, openBraceToken, this.classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withClassElements = function (classElements) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, classElements, this.closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.withClassElement = function (classElement) {
            return this.withClassElements(TypeScript.Syntax.list([
                classElement
            ]));
        };
        ClassDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, closeBraceToken);
        };
        ClassDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ClassDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ClassDeclarationSyntax = ClassDeclarationSyntax;    
    var InterfaceDeclarationSyntax = (function (_super) {
        __extends(InterfaceDeclarationSyntax, _super);
        function InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.interfaceKeyword = interfaceKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.body = body;
        }
        InterfaceDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitInterfaceDeclaration(this);
        };
        InterfaceDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.InterfaceDeclaration;
        };
        InterfaceDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        InterfaceDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.interfaceKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        InterfaceDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        InterfaceDeclarationSyntax.prototype.update = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
            if (this.modifiers === modifiers && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.body === body) {
                return this;
            }
            return new InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, this.parsedInStrictMode());
        };
        InterfaceDeclarationSyntax.create = function create(interfaceKeyword, identifier, body) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, interfaceKeyword, identifier, null, TypeScript.Syntax.emptyList, body, false);
        };
        InterfaceDeclarationSyntax.create1 = function create1(identifier) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.InterfaceKeyword), identifier, null, TypeScript.Syntax.emptyList, ObjectTypeSyntax.create1(), false);
        };
        InterfaceDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        InterfaceDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        InterfaceDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        InterfaceDeclarationSyntax.prototype.withInterfaceKeyword = function (interfaceKeyword) {
            return this.update(this.modifiers, interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.interfaceKeyword, identifier, this.typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, typeParameterList, this.heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, heritageClauses, this.body);
        };
        InterfaceDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([
                heritageClause
            ]));
        };
        InterfaceDeclarationSyntax.prototype.withBody = function (body) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, body);
        };
        InterfaceDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return InterfaceDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InterfaceDeclarationSyntax = InterfaceDeclarationSyntax;    
    var HeritageClauseSyntax = (function (_super) {
        __extends(HeritageClauseSyntax, _super);
        function HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsOrImplementsKeyword = extendsOrImplementsKeyword;
            this.typeNames = typeNames;
        }
        HeritageClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitHeritageClause(this);
        };
        HeritageClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.HeritageClause;
        };
        HeritageClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        HeritageClauseSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.extendsOrImplementsKeyword;
                case 1:
                    return this.typeNames;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        HeritageClauseSyntax.prototype.update = function (extendsOrImplementsKeyword, typeNames) {
            if (this.extendsOrImplementsKeyword === extendsOrImplementsKeyword && this.typeNames === typeNames) {
                return this;
            }
            return new HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, this.parsedInStrictMode());
        };
        HeritageClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        HeritageClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        HeritageClauseSyntax.prototype.withExtendsOrImplementsKeyword = function (extendsOrImplementsKeyword) {
            return this.update(extendsOrImplementsKeyword, this.typeNames);
        };
        HeritageClauseSyntax.prototype.withTypeNames = function (typeNames) {
            return this.update(this.extendsOrImplementsKeyword, typeNames);
        };
        HeritageClauseSyntax.prototype.withTypeName = function (typeName) {
            return this.withTypeNames(TypeScript.Syntax.separatedList([
                typeName
            ]));
        };
        HeritageClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return HeritageClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.HeritageClauseSyntax = HeritageClauseSyntax;    
    var ModuleDeclarationSyntax = (function (_super) {
        __extends(ModuleDeclarationSyntax, _super);
        function ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.moduleKeyword = moduleKeyword;
            this.moduleName = moduleName;
            this.stringLiteral = stringLiteral;
            this.openBraceToken = openBraceToken;
            this.moduleElements = moduleElements;
            this.closeBraceToken = closeBraceToken;
        }
        ModuleDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleDeclaration(this);
        };
        ModuleDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ModuleDeclaration;
        };
        ModuleDeclarationSyntax.prototype.childCount = function () {
            return 7;
        };
        ModuleDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.moduleKeyword;
                case 2:
                    return this.moduleName;
                case 3:
                    return this.stringLiteral;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.moduleElements;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ModuleDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ModuleDeclarationSyntax.prototype.update = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.moduleKeyword === moduleKeyword && this.moduleName === moduleName && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, this.parsedInStrictMode());
        };
        ModuleDeclarationSyntax.create = function create(moduleKeyword, openBraceToken, closeBraceToken) {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, moduleKeyword, null, null, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        ModuleDeclarationSyntax.create1 = function create1() {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.ModuleKeyword), null, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ModuleDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ModuleDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ModuleDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        ModuleDeclarationSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
            return this.update(this.modifiers, moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(this.modifiers, this.moduleKeyword, moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([
                moduleElement
            ]));
        };
        ModuleDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
        };
        ModuleDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleDeclarationSyntax = ModuleDeclarationSyntax;    
    var FunctionDeclarationSyntax = (function (_super) {
        __extends(FunctionDeclarationSyntax, _super);
        function FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        FunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionDeclaration(this);
        };
        FunctionDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionDeclaration;
        };
        FunctionDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        FunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.functionKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.callSignature;
                case 4:
                    return this.block;
                case 5:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        FunctionDeclarationSyntax.prototype.isStatement = function () {
            return true;
        };
        FunctionDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        FunctionDeclarationSyntax.prototype.update = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };
        FunctionDeclarationSyntax.create = function create(functionKeyword, identifier, callSignature) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, functionKeyword, identifier, callSignature, null, null, false);
        };
        FunctionDeclarationSyntax.create1 = function create1(identifier) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.FunctionKeyword), identifier, CallSignatureSyntax.create1(), null, null, false);
        };
        FunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        FunctionDeclarationSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(this.modifiers, functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.functionKeyword, identifier, this.callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, callSignature, this.block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, block, this.semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, semicolonToken);
        };
        FunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block !== null && this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionDeclarationSyntax = FunctionDeclarationSyntax;    
    var VariableStatementSyntax = (function (_super) {
        __extends(VariableStatementSyntax, _super);
        function VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclaration = variableDeclaration;
            this.semicolonToken = semicolonToken;
        }
        VariableStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableStatement(this);
        };
        VariableStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableStatement;
        };
        VariableStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        VariableStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclaration;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        VariableStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        VariableStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        VariableStatementSyntax.prototype.update = function (modifiers, variableDeclaration, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, this.parsedInStrictMode());
        };
        VariableStatementSyntax.create = function create(variableDeclaration, semicolonToken) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, semicolonToken, false);
        };
        VariableStatementSyntax.create1 = function create1(variableDeclaration) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        VariableStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VariableStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VariableStatementSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclaration, this.semicolonToken);
        };
        VariableStatementSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        VariableStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.modifiers, variableDeclaration, this.semicolonToken);
        };
        VariableStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclaration, semicolonToken);
        };
        VariableStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableStatementSyntax = VariableStatementSyntax;    
    var VariableDeclarationSyntax = (function (_super) {
        __extends(VariableDeclarationSyntax, _super);
        function VariableDeclarationSyntax(varKeyword, variableDeclarators, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.varKeyword = varKeyword;
            this.variableDeclarators = variableDeclarators;
        }
        VariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclaration(this);
        };
        VariableDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableDeclaration;
        };
        VariableDeclarationSyntax.prototype.childCount = function () {
            return 2;
        };
        VariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.varKeyword;
                case 1:
                    return this.variableDeclarators;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        VariableDeclarationSyntax.prototype.update = function (varKeyword, variableDeclarators) {
            if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
                return this;
            }
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, this.parsedInStrictMode());
        };
        VariableDeclarationSyntax.create1 = function create1(variableDeclarators) {
            return new VariableDeclarationSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.VarKeyword), variableDeclarators, false);
        };
        VariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VariableDeclarationSyntax.prototype.withVarKeyword = function (varKeyword) {
            return this.update(varKeyword, this.variableDeclarators);
        };
        VariableDeclarationSyntax.prototype.withVariableDeclarators = function (variableDeclarators) {
            return this.update(this.varKeyword, variableDeclarators);
        };
        VariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.withVariableDeclarators(TypeScript.Syntax.separatedList([
                variableDeclarator
            ]));
        };
        VariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclarators.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclarationSyntax = VariableDeclarationSyntax;    
    var VariableDeclaratorSyntax = (function (_super) {
        __extends(VariableDeclaratorSyntax, _super);
        function VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        VariableDeclaratorSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclarator(this);
        };
        VariableDeclaratorSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VariableDeclarator;
        };
        VariableDeclaratorSyntax.prototype.childCount = function () {
            return 3;
        };
        VariableDeclaratorSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.typeAnnotation;
                case 2:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        VariableDeclaratorSyntax.prototype.update = function (identifier, typeAnnotation, equalsValueClause) {
            if (this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }
            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };
        VariableDeclaratorSyntax.create = function create(identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };
        VariableDeclaratorSyntax.create1 = function create1(identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };
        VariableDeclaratorSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VariableDeclaratorSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VariableDeclaratorSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.typeAnnotation, this.equalsValueClause);
        };
        VariableDeclaratorSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.identifier, typeAnnotation, this.equalsValueClause);
        };
        VariableDeclaratorSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.identifier, this.typeAnnotation, equalsValueClause);
        };
        VariableDeclaratorSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclaratorSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclaratorSyntax = VariableDeclaratorSyntax;    
    var EqualsValueClauseSyntax = (function (_super) {
        __extends(EqualsValueClauseSyntax, _super);
        function EqualsValueClauseSyntax(equalsToken, value, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsToken = equalsToken;
            this.value = value;
        }
        EqualsValueClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitEqualsValueClause(this);
        };
        EqualsValueClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EqualsValueClause;
        };
        EqualsValueClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        EqualsValueClauseSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.equalsToken;
                case 1:
                    return this.value;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        EqualsValueClauseSyntax.prototype.update = function (equalsToken, value) {
            if (this.equalsToken === equalsToken && this.value === value) {
                return this;
            }
            return new EqualsValueClauseSyntax(equalsToken, value, this.parsedInStrictMode());
        };
        EqualsValueClauseSyntax.create1 = function create1(value) {
            return new EqualsValueClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsToken), value, false);
        };
        EqualsValueClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EqualsValueClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EqualsValueClauseSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(equalsToken, this.value);
        };
        EqualsValueClauseSyntax.prototype.withValue = function (value) {
            return this.update(this.equalsToken, value);
        };
        EqualsValueClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.value.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EqualsValueClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EqualsValueClauseSyntax = EqualsValueClauseSyntax;    
    var PrefixUnaryExpressionSyntax = (function (_super) {
        __extends(PrefixUnaryExpressionSyntax, _super);
        function PrefixUnaryExpressionSyntax(kind, operatorToken, operand, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operatorToken = operatorToken;
            this.operand = operand;
            this._kind = kind;
        }
        PrefixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPrefixUnaryExpression(this);
        };
        PrefixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        PrefixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.operatorToken;
                case 1:
                    return this.operand;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        PrefixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        PrefixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        PrefixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };
        PrefixUnaryExpressionSyntax.prototype.update = function (kind, operatorToken, operand) {
            if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
                return this;
            }
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.parsedInStrictMode());
        };
        PrefixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        PrefixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        PrefixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operatorToken, this.operand);
        };
        PrefixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, operatorToken, this.operand);
        };
        PrefixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, this.operatorToken, operand);
        };
        PrefixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PrefixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PrefixUnaryExpressionSyntax = PrefixUnaryExpressionSyntax;    
    var ArrayLiteralExpressionSyntax = (function (_super) {
        __extends(ArrayLiteralExpressionSyntax, _super);
        function ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.expressions = expressions;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayLiteralExpression(this);
        };
        ArrayLiteralExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArrayLiteralExpression;
        };
        ArrayLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ArrayLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.expressions;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ArrayLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ArrayLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ArrayLiteralExpressionSyntax.prototype.update = function (openBracketToken, expressions, closeBracketToken) {
            if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
                return this;
            }
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, this.parsedInStrictMode());
        };
        ArrayLiteralExpressionSyntax.create = function create(openBracketToken, closeBracketToken) {
            return new ArrayLiteralExpressionSyntax(openBracketToken, TypeScript.Syntax.emptySeparatedList, closeBracketToken, false);
        };
        ArrayLiteralExpressionSyntax.create1 = function create1() {
            return new ArrayLiteralExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), false);
        };
        ArrayLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ArrayLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ArrayLiteralExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.expressions, this.closeBracketToken);
        };
        ArrayLiteralExpressionSyntax.prototype.withExpressions = function (expressions) {
            return this.update(this.openBracketToken, expressions, this.closeBracketToken);
        };
        ArrayLiteralExpressionSyntax.prototype.withExpression = function (expression) {
            return this.withExpressions(TypeScript.Syntax.separatedList([
                expression
            ]));
        };
        ArrayLiteralExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.expressions, closeBracketToken);
        };
        ArrayLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expressions.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArrayLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayLiteralExpressionSyntax = ArrayLiteralExpressionSyntax;    
    var OmittedExpressionSyntax = (function (_super) {
        __extends(OmittedExpressionSyntax, _super);
        function OmittedExpressionSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        OmittedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitOmittedExpression(this);
        };
        OmittedExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.OmittedExpression;
        };
        OmittedExpressionSyntax.prototype.childCount = function () {
            return 0;
        };
        OmittedExpressionSyntax.prototype.childAt = function (slot) {
            throw TypeScript.Errors.invalidOperation();
        };
        OmittedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        OmittedExpressionSyntax.prototype.update = function () {
            return this;
        };
        OmittedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        OmittedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        OmittedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return OmittedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.OmittedExpressionSyntax = OmittedExpressionSyntax;    
    var ParenthesizedExpressionSyntax = (function (_super) {
        __extends(ParenthesizedExpressionSyntax, _super);
        function ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
        }
        ParenthesizedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedExpression(this);
        };
        ParenthesizedExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParenthesizedExpression;
        };
        ParenthesizedExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ParenthesizedExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.expression;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ParenthesizedExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ParenthesizedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ParenthesizedExpressionSyntax.prototype.update = function (openParenToken, expression, closeParenToken) {
            if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, this.parsedInStrictMode());
        };
        ParenthesizedExpressionSyntax.create1 = function create1(expression) {
            return new ParenthesizedExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ParenthesizedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParenthesizedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParenthesizedExpressionSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.expression, this.closeParenToken);
        };
        ParenthesizedExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.openParenToken, expression, this.closeParenToken);
        };
        ParenthesizedExpressionSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.expression, closeParenToken);
        };
        ParenthesizedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParenthesizedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParenthesizedExpressionSyntax = ParenthesizedExpressionSyntax;    
    var ArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ArrowFunctionExpressionSyntax, _super);
        function ArrowFunctionExpressionSyntax(equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.body = body;
        }
        ArrowFunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ArrowFunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrowFunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrowFunctionExpressionSyntax = ArrowFunctionExpressionSyntax;    
    var SimpleArrowFunctionExpressionSyntax = (function (_super) {
        __extends(SimpleArrowFunctionExpressionSyntax, _super);
        function SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.identifier = identifier;
        }
        SimpleArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimpleArrowFunctionExpression(this);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SimpleArrowFunctionExpression;
        };
        SimpleArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        SimpleArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SimpleArrowFunctionExpressionSyntax.prototype.update = function (identifier, equalsGreaterThanToken, body) {
            if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };
        SimpleArrowFunctionExpressionSyntax.create1 = function create1(identifier, body) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), body, false);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.equalsGreaterThanToken, this.body);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.identifier, equalsGreaterThanToken, this.body);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.identifier, this.equalsGreaterThanToken, body);
        };
        SimpleArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SimpleArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.SimpleArrowFunctionExpressionSyntax = SimpleArrowFunctionExpressionSyntax;    
    var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
        function ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.callSignature = callSignature;
        }
        ParenthesizedArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedArrowFunctionExpression(this);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression;
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.callSignature;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.update = function (callSignature, equalsGreaterThanToken, body) {
            if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };
        ParenthesizedArrowFunctionExpressionSyntax.create1 = function create1(body) {
            return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), body, false);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(callSignature, this.equalsGreaterThanToken, this.body);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.callSignature, equalsGreaterThanToken, this.body);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.callSignature, this.equalsGreaterThanToken, body);
        };
        ParenthesizedArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ParenthesizedArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax = ParenthesizedArrowFunctionExpressionSyntax;    
    var QualifiedNameSyntax = (function (_super) {
        __extends(QualifiedNameSyntax, _super);
        function QualifiedNameSyntax(left, dotToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.dotToken = dotToken;
            this.right = right;
        }
        QualifiedNameSyntax.prototype.accept = function (visitor) {
            return visitor.visitQualifiedName(this);
        };
        QualifiedNameSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.QualifiedName;
        };
        QualifiedNameSyntax.prototype.childCount = function () {
            return 3;
        };
        QualifiedNameSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        QualifiedNameSyntax.prototype.isName = function () {
            return true;
        };
        QualifiedNameSyntax.prototype.isType = function () {
            return true;
        };
        QualifiedNameSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        QualifiedNameSyntax.prototype.isExpression = function () {
            return true;
        };
        QualifiedNameSyntax.prototype.update = function (left, dotToken, right) {
            if (this.left === left && this.dotToken === dotToken && this.right === right) {
                return this;
            }
            return new QualifiedNameSyntax(left, dotToken, right, this.parsedInStrictMode());
        };
        QualifiedNameSyntax.create1 = function create1(left, right) {
            return new QualifiedNameSyntax(left, TypeScript.Syntax.token(TypeScript.SyntaxKind.DotToken), right, false);
        };
        QualifiedNameSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        QualifiedNameSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        QualifiedNameSyntax.prototype.withLeft = function (left) {
            return this.update(left, this.dotToken, this.right);
        };
        QualifiedNameSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.left, dotToken, this.right);
        };
        QualifiedNameSyntax.prototype.withRight = function (right) {
            return this.update(this.left, this.dotToken, right);
        };
        QualifiedNameSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return QualifiedNameSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.QualifiedNameSyntax = QualifiedNameSyntax;    
    var TypeArgumentListSyntax = (function (_super) {
        __extends(TypeArgumentListSyntax, _super);
        function TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeArguments = typeArguments;
            this.greaterThanToken = greaterThanToken;
        }
        TypeArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeArgumentList(this);
        };
        TypeArgumentListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeArgumentList;
        };
        TypeArgumentListSyntax.prototype.childCount = function () {
            return 3;
        };
        TypeArgumentListSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeArguments;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeArgumentListSyntax.prototype.update = function (lessThanToken, typeArguments, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
                return this;
            }
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, this.parsedInStrictMode());
        };
        TypeArgumentListSyntax.create = function create(lessThanToken, greaterThanToken) {
            return new TypeArgumentListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };
        TypeArgumentListSyntax.create1 = function create1() {
            return new TypeArgumentListSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.LessThanToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.GreaterThanToken), false);
        };
        TypeArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeArgumentListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
        };
        TypeArgumentListSyntax.prototype.withTypeArguments = function (typeArguments) {
            return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
        };
        TypeArgumentListSyntax.prototype.withTypeArgument = function (typeArgument) {
            return this.withTypeArguments(TypeScript.Syntax.separatedList([
                typeArgument
            ]));
        };
        TypeArgumentListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
        };
        TypeArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeArgumentListSyntax = TypeArgumentListSyntax;    
    var ConstructorTypeSyntax = (function (_super) {
        __extends(ConstructorTypeSyntax, _super);
        function ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        ConstructorTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorType(this);
        };
        ConstructorTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructorType;
        };
        ConstructorTypeSyntax.prototype.childCount = function () {
            return 5;
        };
        ConstructorTypeSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.typeParameterList;
                case 2:
                    return this.parameterList;
                case 3:
                    return this.equalsGreaterThanToken;
                case 4:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstructorTypeSyntax.prototype.isType = function () {
            return true;
        };
        ConstructorTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ConstructorTypeSyntax.prototype.isExpression = function () {
            return true;
        };
        ConstructorTypeSyntax.prototype.update = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };
        ConstructorTypeSyntax.create = function create(newKeyword, parameterList, equalsGreaterThanToken, type) {
            return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, false);
        };
        ConstructorTypeSyntax.create1 = function create1(type) {
            return new ConstructorTypeSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.NewKeyword), null, ParameterListSyntax.create1(), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), type, false);
        };
        ConstructorTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstructorTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstructorTypeSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };
        ConstructorTypeSyntax.prototype.withType = function (type) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };
        ConstructorTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorTypeSyntax = ConstructorTypeSyntax;    
    var FunctionTypeSyntax = (function (_super) {
        __extends(FunctionTypeSyntax, _super);
        function FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        FunctionTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionType(this);
        };
        FunctionTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionType;
        };
        FunctionTypeSyntax.prototype.childCount = function () {
            return 4;
        };
        FunctionTypeSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.equalsGreaterThanToken;
                case 3:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        FunctionTypeSyntax.prototype.isType = function () {
            return true;
        };
        FunctionTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        FunctionTypeSyntax.prototype.isExpression = function () {
            return true;
        };
        FunctionTypeSyntax.prototype.update = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };
        FunctionTypeSyntax.create = function create(parameterList, equalsGreaterThanToken, type) {
            return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, false);
        };
        FunctionTypeSyntax.create1 = function create1(type) {
            return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), TypeScript.Syntax.token(TypeScript.SyntaxKind.EqualsGreaterThanToken), type, false);
        };
        FunctionTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FunctionTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FunctionTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };
        FunctionTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };
        FunctionTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };
        FunctionTypeSyntax.prototype.withType = function (type) {
            return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };
        FunctionTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return FunctionTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionTypeSyntax = FunctionTypeSyntax;    
    var ObjectTypeSyntax = (function (_super) {
        __extends(ObjectTypeSyntax, _super);
        function ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.typeMembers = typeMembers;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectType(this);
        };
        ObjectTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectType;
        };
        ObjectTypeSyntax.prototype.childCount = function () {
            return 3;
        };
        ObjectTypeSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.typeMembers;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ObjectTypeSyntax.prototype.isType = function () {
            return true;
        };
        ObjectTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ObjectTypeSyntax.prototype.isExpression = function () {
            return true;
        };
        ObjectTypeSyntax.prototype.update = function (openBraceToken, typeMembers, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, this.parsedInStrictMode());
        };
        ObjectTypeSyntax.create = function create(openBraceToken, closeBraceToken) {
            return new ObjectTypeSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };
        ObjectTypeSyntax.create1 = function create1() {
            return new ObjectTypeSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ObjectTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ObjectTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ObjectTypeSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
        };
        ObjectTypeSyntax.prototype.withTypeMembers = function (typeMembers) {
            return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
        };
        ObjectTypeSyntax.prototype.withTypeMember = function (typeMember) {
            return this.withTypeMembers(TypeScript.Syntax.separatedList([
                typeMember
            ]));
        };
        ObjectTypeSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
        };
        ObjectTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ObjectTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectTypeSyntax = ObjectTypeSyntax;    
    var ArrayTypeSyntax = (function (_super) {
        __extends(ArrayTypeSyntax, _super);
        function ArrayTypeSyntax(type, openBracketToken, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.type = type;
            this.openBracketToken = openBracketToken;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayType(this);
        };
        ArrayTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArrayType;
        };
        ArrayTypeSyntax.prototype.childCount = function () {
            return 3;
        };
        ArrayTypeSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.type;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ArrayTypeSyntax.prototype.isType = function () {
            return true;
        };
        ArrayTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ArrayTypeSyntax.prototype.isExpression = function () {
            return true;
        };
        ArrayTypeSyntax.prototype.update = function (type, openBracketToken, closeBracketToken) {
            if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
                return this;
            }
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, this.parsedInStrictMode());
        };
        ArrayTypeSyntax.create1 = function create1(type) {
            return new ArrayTypeSyntax(type, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), false);
        };
        ArrayTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ArrayTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ArrayTypeSyntax.prototype.withType = function (type) {
            return this.update(type, this.openBracketToken, this.closeBracketToken);
        };
        ArrayTypeSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.type, openBracketToken, this.closeBracketToken);
        };
        ArrayTypeSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.type, this.openBracketToken, closeBracketToken);
        };
        ArrayTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrayTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayTypeSyntax = ArrayTypeSyntax;    
    var GenericTypeSyntax = (function (_super) {
        __extends(GenericTypeSyntax, _super);
        function GenericTypeSyntax(name, typeArgumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.name = name;
            this.typeArgumentList = typeArgumentList;
        }
        GenericTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitGenericType(this);
        };
        GenericTypeSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.GenericType;
        };
        GenericTypeSyntax.prototype.childCount = function () {
            return 2;
        };
        GenericTypeSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.name;
                case 1:
                    return this.typeArgumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        GenericTypeSyntax.prototype.isType = function () {
            return true;
        };
        GenericTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        GenericTypeSyntax.prototype.isExpression = function () {
            return true;
        };
        GenericTypeSyntax.prototype.update = function (name, typeArgumentList) {
            if (this.name === name && this.typeArgumentList === typeArgumentList) {
                return this;
            }
            return new GenericTypeSyntax(name, typeArgumentList, this.parsedInStrictMode());
        };
        GenericTypeSyntax.create1 = function create1(name) {
            return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), false);
        };
        GenericTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        GenericTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        GenericTypeSyntax.prototype.withName = function (name) {
            return this.update(name, this.typeArgumentList);
        };
        GenericTypeSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(this.name, typeArgumentList);
        };
        GenericTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GenericTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.GenericTypeSyntax = GenericTypeSyntax;    
    var TypeAnnotationSyntax = (function (_super) {
        __extends(TypeAnnotationSyntax, _super);
        function TypeAnnotationSyntax(colonToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.type = type;
        }
        TypeAnnotationSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeAnnotation(this);
        };
        TypeAnnotationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeAnnotation;
        };
        TypeAnnotationSyntax.prototype.childCount = function () {
            return 2;
        };
        TypeAnnotationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.colonToken;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeAnnotationSyntax.prototype.update = function (colonToken, type) {
            if (this.colonToken === colonToken && this.type === type) {
                return this;
            }
            return new TypeAnnotationSyntax(colonToken, type, this.parsedInStrictMode());
        };
        TypeAnnotationSyntax.create1 = function create1(type) {
            return new TypeAnnotationSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), type, false);
        };
        TypeAnnotationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeAnnotationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeAnnotationSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(colonToken, this.type);
        };
        TypeAnnotationSyntax.prototype.withType = function (type) {
            return this.update(this.colonToken, type);
        };
        TypeAnnotationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeAnnotationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeAnnotationSyntax = TypeAnnotationSyntax;    
    var BlockSyntax = (function (_super) {
        __extends(BlockSyntax, _super);
        function BlockSyntax(openBraceToken, statements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.statements = statements;
            this.closeBraceToken = closeBraceToken;
        }
        BlockSyntax.prototype.accept = function (visitor) {
            return visitor.visitBlock(this);
        };
        BlockSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.Block;
        };
        BlockSyntax.prototype.childCount = function () {
            return 3;
        };
        BlockSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.statements;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        BlockSyntax.prototype.isStatement = function () {
            return true;
        };
        BlockSyntax.prototype.isModuleElement = function () {
            return true;
        };
        BlockSyntax.prototype.update = function (openBraceToken, statements, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, this.parsedInStrictMode());
        };
        BlockSyntax.create = function create(openBraceToken, closeBraceToken) {
            return new BlockSyntax(openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        BlockSyntax.create1 = function create1() {
            return new BlockSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        BlockSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        BlockSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        BlockSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.statements, this.closeBraceToken);
        };
        BlockSyntax.prototype.withStatements = function (statements) {
            return this.update(this.openBraceToken, statements, this.closeBraceToken);
        };
        BlockSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([
                statement
            ]));
        };
        BlockSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.statements, closeBraceToken);
        };
        BlockSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BlockSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BlockSyntax = BlockSyntax;    
    var ParameterSyntax = (function (_super) {
        __extends(ParameterSyntax, _super);
        function ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.dotDotDotToken = dotDotDotToken;
            this.publicOrPrivateKeyword = publicOrPrivateKeyword;
            this.identifier = identifier;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        ParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameter(this);
        };
        ParameterSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.Parameter;
        };
        ParameterSyntax.prototype.childCount = function () {
            return 6;
        };
        ParameterSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.dotDotDotToken;
                case 1:
                    return this.publicOrPrivateKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.questionToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ParameterSyntax.prototype.update = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
            if (this.dotDotDotToken === dotDotDotToken && this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }
            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };
        ParameterSyntax.create = function create(identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };
        ParameterSyntax.create1 = function create1(identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };
        ParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParameterSyntax.prototype.withDotDotDotToken = function (dotDotDotToken) {
            return this.update(dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
            return this.update(this.dotDotDotToken, publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
        };
        ParameterSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
        };
        ParameterSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.dotDotDotToken !== null) {
                return true;
            }
            if (this.publicOrPrivateKeyword !== null) {
                return true;
            }
            if (this.questionToken !== null) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null) {
                return true;
            }
            return false;
        };
        return ParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterSyntax = ParameterSyntax;    
    var MemberAccessExpressionSyntax = (function (_super) {
        __extends(MemberAccessExpressionSyntax, _super);
        function MemberAccessExpressionSyntax(expression, dotToken, name, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.dotToken = dotToken;
            this.name = name;
        }
        MemberAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberAccessExpression(this);
        };
        MemberAccessExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberAccessExpression;
        };
        MemberAccessExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        MemberAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.name;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        MemberAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        MemberAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        MemberAccessExpressionSyntax.prototype.update = function (expression, dotToken, name) {
            if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
                return this;
            }
            return new MemberAccessExpressionSyntax(expression, dotToken, name, this.parsedInStrictMode());
        };
        MemberAccessExpressionSyntax.create1 = function create1(expression, name) {
            return new MemberAccessExpressionSyntax(expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.DotToken), name, false);
        };
        MemberAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MemberAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MemberAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.dotToken, this.name);
        };
        MemberAccessExpressionSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.expression, dotToken, this.name);
        };
        MemberAccessExpressionSyntax.prototype.withName = function (name) {
            return this.update(this.expression, this.dotToken, name);
        };
        MemberAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MemberAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessExpressionSyntax = MemberAccessExpressionSyntax;    
    var PostfixUnaryExpressionSyntax = (function (_super) {
        __extends(PostfixUnaryExpressionSyntax, _super);
        function PostfixUnaryExpressionSyntax(kind, operand, operatorToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operand = operand;
            this.operatorToken = operatorToken;
            this._kind = kind;
        }
        PostfixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPostfixUnaryExpression(this);
        };
        PostfixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        PostfixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.operand;
                case 1:
                    return this.operatorToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        PostfixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        PostfixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        PostfixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };
        PostfixUnaryExpressionSyntax.prototype.update = function (kind, operand, operatorToken) {
            if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
                return this;
            }
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.parsedInStrictMode());
        };
        PostfixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        PostfixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        PostfixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operand, this.operatorToken);
        };
        PostfixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, operand, this.operatorToken);
        };
        PostfixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.operand, operatorToken);
        };
        PostfixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PostfixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PostfixUnaryExpressionSyntax = PostfixUnaryExpressionSyntax;    
    var ElementAccessExpressionSyntax = (function (_super) {
        __extends(ElementAccessExpressionSyntax, _super);
        function ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.openBracketToken = openBracketToken;
            this.argumentExpression = argumentExpression;
            this.closeBracketToken = closeBracketToken;
        }
        ElementAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitElementAccessExpression(this);
        };
        ElementAccessExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ElementAccessExpression;
        };
        ElementAccessExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        ElementAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.argumentExpression;
                case 3:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ElementAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ElementAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ElementAccessExpressionSyntax.prototype.update = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
            if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
                return this;
            }
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, this.parsedInStrictMode());
        };
        ElementAccessExpressionSyntax.create1 = function create1(expression, argumentExpression) {
            return new ElementAccessExpressionSyntax(expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), argumentExpression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), false);
        };
        ElementAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ElementAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ElementAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.withArgumentExpression = function (argumentExpression) {
            return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
        };
        ElementAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentExpression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElementAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElementAccessExpressionSyntax = ElementAccessExpressionSyntax;    
    var InvocationExpressionSyntax = (function (_super) {
        __extends(InvocationExpressionSyntax, _super);
        function InvocationExpressionSyntax(expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.argumentList = argumentList;
        }
        InvocationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitInvocationExpression(this);
        };
        InvocationExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.InvocationExpression;
        };
        InvocationExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        InvocationExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        InvocationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        InvocationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        InvocationExpressionSyntax.prototype.update = function (expression, argumentList) {
            if (this.expression === expression && this.argumentList === argumentList) {
                return this;
            }
            return new InvocationExpressionSyntax(expression, argumentList, this.parsedInStrictMode());
        };
        InvocationExpressionSyntax.create1 = function create1(expression) {
            return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), false);
        };
        InvocationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        InvocationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        InvocationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.argumentList);
        };
        InvocationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.expression, argumentList);
        };
        InvocationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return InvocationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InvocationExpressionSyntax = InvocationExpressionSyntax;    
    var ArgumentListSyntax = (function (_super) {
        __extends(ArgumentListSyntax, _super);
        function ArgumentListSyntax(typeArgumentList, openParenToken, arguments, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeArgumentList = typeArgumentList;
            this.openParenToken = openParenToken;
            this.arguments = arguments;
            this.closeParenToken = closeParenToken;
        }
        ArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitArgumentList(this);
        };
        ArgumentListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ArgumentList;
        };
        ArgumentListSyntax.prototype.childCount = function () {
            return 4;
        };
        ArgumentListSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.typeArgumentList;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.arguments;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ArgumentListSyntax.prototype.update = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
            if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.arguments === _arguments && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, this.parsedInStrictMode());
        };
        ArgumentListSyntax.create = function create(openParenToken, closeParenToken) {
            return new ArgumentListSyntax(null, openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };
        ArgumentListSyntax.create1 = function create1() {
            return new ArgumentListSyntax(null, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ArgumentListSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(typeArgumentList, this.openParenToken, this.arguments, this.closeParenToken);
        };
        ArgumentListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.typeArgumentList, openParenToken, this.arguments, this.closeParenToken);
        };
        ArgumentListSyntax.prototype.withArguments = function (_arguments) {
            return this.update(this.typeArgumentList, this.openParenToken, _arguments, this.closeParenToken);
        };
        ArgumentListSyntax.prototype.withArgument = function (_argument) {
            return this.withArguments(TypeScript.Syntax.separatedList([
                _argument
            ]));
        };
        ArgumentListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.typeArgumentList, this.openParenToken, this.arguments, closeParenToken);
        };
        ArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.arguments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArgumentListSyntax = ArgumentListSyntax;    
    var BinaryExpressionSyntax = (function (_super) {
        __extends(BinaryExpressionSyntax, _super);
        function BinaryExpressionSyntax(kind, left, operatorToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.operatorToken = operatorToken;
            this.right = right;
            this._kind = kind;
        }
        BinaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitBinaryExpression(this);
        };
        BinaryExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        BinaryExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.operatorToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        BinaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        BinaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };
        BinaryExpressionSyntax.prototype.update = function (kind, left, operatorToken, right) {
            if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
                return this;
            }
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, this.parsedInStrictMode());
        };
        BinaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        BinaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        BinaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.left, this.operatorToken, this.right);
        };
        BinaryExpressionSyntax.prototype.withLeft = function (left) {
            return this.update(this._kind, left, this.operatorToken, this.right);
        };
        BinaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.left, operatorToken, this.right);
        };
        BinaryExpressionSyntax.prototype.withRight = function (right) {
            return this.update(this._kind, this.left, this.operatorToken, right);
        };
        BinaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.right.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BinaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BinaryExpressionSyntax = BinaryExpressionSyntax;    
    var ConditionalExpressionSyntax = (function (_super) {
        __extends(ConditionalExpressionSyntax, _super);
        function ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.condition = condition;
            this.questionToken = questionToken;
            this.whenTrue = whenTrue;
            this.colonToken = colonToken;
            this.whenFalse = whenFalse;
        }
        ConditionalExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitConditionalExpression(this);
        };
        ConditionalExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConditionalExpression;
        };
        ConditionalExpressionSyntax.prototype.childCount = function () {
            return 5;
        };
        ConditionalExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.condition;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.whenTrue;
                case 3:
                    return this.colonToken;
                case 4:
                    return this.whenFalse;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ConditionalExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ConditionalExpressionSyntax.prototype.update = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
            if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
                return this;
            }
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, this.parsedInStrictMode());
        };
        ConditionalExpressionSyntax.create1 = function create1(condition, whenTrue, whenFalse) {
            return new ConditionalExpressionSyntax(condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.QuestionToken), whenTrue, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), whenFalse, false);
        };
        ConditionalExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConditionalExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConditionalExpressionSyntax.prototype.withCondition = function (condition) {
            return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withWhenTrue = function (whenTrue) {
            return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
        };
        ConditionalExpressionSyntax.prototype.withWhenFalse = function (whenFalse) {
            return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
        };
        ConditionalExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenTrue.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenFalse.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ConditionalExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConditionalExpressionSyntax = ConditionalExpressionSyntax;    
    var ConstructSignatureSyntax = (function (_super) {
        __extends(ConstructSignatureSyntax, _super);
        function ConstructSignatureSyntax(newKeyword, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.callSignature = callSignature;
        }
        ConstructSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructSignature(this);
        };
        ConstructSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructSignature;
        };
        ConstructSignatureSyntax.prototype.childCount = function () {
            return 2;
        };
        ConstructSignatureSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstructSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        ConstructSignatureSyntax.prototype.update = function (newKeyword, callSignature) {
            if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
                return this;
            }
            return new ConstructSignatureSyntax(newKeyword, callSignature, this.parsedInStrictMode());
        };
        ConstructSignatureSyntax.create1 = function create1() {
            return new ConstructSignatureSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.NewKeyword), CallSignatureSyntax.create1(), false);
        };
        ConstructSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstructSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstructSignatureSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.callSignature);
        };
        ConstructSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.newKeyword, callSignature);
        };
        ConstructSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructSignatureSyntax = ConstructSignatureSyntax;    
    var MethodSignatureSyntax = (function (_super) {
        __extends(MethodSignatureSyntax, _super);
        function MethodSignatureSyntax(propertyName, questionToken, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.callSignature = callSignature;
        }
        MethodSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitMethodSignature(this);
        };
        MethodSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MethodSignature;
        };
        MethodSignatureSyntax.prototype.childCount = function () {
            return 3;
        };
        MethodSignatureSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        MethodSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        MethodSignatureSyntax.prototype.update = function (propertyName, questionToken, callSignature) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.callSignature === callSignature) {
                return this;
            }
            return new MethodSignatureSyntax(propertyName, questionToken, callSignature, this.parsedInStrictMode());
        };
        MethodSignatureSyntax.create = function create(propertyName, callSignature) {
            return new MethodSignatureSyntax(propertyName, null, callSignature, false);
        };
        MethodSignatureSyntax.create1 = function create1(propertyName) {
            return new MethodSignatureSyntax(propertyName, null, CallSignatureSyntax.create1(), false);
        };
        MethodSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MethodSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MethodSignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.callSignature);
        };
        MethodSignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.callSignature);
        };
        MethodSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, this.questionToken, callSignature);
        };
        MethodSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MethodSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MethodSignatureSyntax = MethodSignatureSyntax;    
    var IndexSignatureSyntax = (function (_super) {
        __extends(IndexSignatureSyntax, _super);
        function IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.parameter = parameter;
            this.closeBracketToken = closeBracketToken;
            this.typeAnnotation = typeAnnotation;
        }
        IndexSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitIndexSignature(this);
        };
        IndexSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.IndexSignature;
        };
        IndexSignatureSyntax.prototype.childCount = function () {
            return 4;
        };
        IndexSignatureSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.parameter;
                case 2:
                    return this.closeBracketToken;
                case 3:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        IndexSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        IndexSignatureSyntax.prototype.update = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
            if (this.openBracketToken === openBracketToken && this.parameter === parameter && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, this.parsedInStrictMode());
        };
        IndexSignatureSyntax.create = function create(openBracketToken, parameter, closeBracketToken) {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, null, false);
        };
        IndexSignatureSyntax.create1 = function create1(parameter) {
            return new IndexSignatureSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBracketToken), parameter, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBracketToken), null, false);
        };
        IndexSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        IndexSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        IndexSignatureSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.parameter, this.closeBracketToken, this.typeAnnotation);
        };
        IndexSignatureSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.openBracketToken, parameter, this.closeBracketToken, this.typeAnnotation);
        };
        IndexSignatureSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.parameter, closeBracketToken, this.typeAnnotation);
        };
        IndexSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.openBracketToken, this.parameter, this.closeBracketToken, typeAnnotation);
        };
        IndexSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return IndexSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IndexSignatureSyntax = IndexSignatureSyntax;    
    var PropertySignatureSyntax = (function (_super) {
        __extends(PropertySignatureSyntax, _super);
        function PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
        }
        PropertySignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitPropertySignature(this);
        };
        PropertySignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.PropertySignature;
        };
        PropertySignatureSyntax.prototype.childCount = function () {
            return 3;
        };
        PropertySignatureSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        PropertySignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        PropertySignatureSyntax.prototype.update = function (propertyName, questionToken, typeAnnotation) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }
            return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, this.parsedInStrictMode());
        };
        PropertySignatureSyntax.create = function create(propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };
        PropertySignatureSyntax.create1 = function create1(propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };
        PropertySignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        PropertySignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        PropertySignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.typeAnnotation);
        };
        PropertySignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.typeAnnotation);
        };
        PropertySignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.propertyName, this.questionToken, typeAnnotation);
        };
        PropertySignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return PropertySignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertySignatureSyntax = PropertySignatureSyntax;    
    var CallSignatureSyntax = (function (_super) {
        __extends(CallSignatureSyntax, _super);
        function CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.typeAnnotation = typeAnnotation;
        }
        CallSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitCallSignature(this);
        };
        CallSignatureSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CallSignature;
        };
        CallSignatureSyntax.prototype.childCount = function () {
            return 3;
        };
        CallSignatureSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        CallSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };
        CallSignatureSyntax.prototype.update = function (typeParameterList, parameterList, typeAnnotation) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
                return this;
            }
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, this.parsedInStrictMode());
        };
        CallSignatureSyntax.create = function create(parameterList) {
            return new CallSignatureSyntax(null, parameterList, null, false);
        };
        CallSignatureSyntax.create1 = function create1() {
            return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, false);
        };
        CallSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CallSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CallSignatureSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
        };
        CallSignatureSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
        };
        CallSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
        };
        CallSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeParameterList !== null) {
                return true;
            }
            if (this.parameterList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            return false;
        };
        return CallSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CallSignatureSyntax = CallSignatureSyntax;    
    var ParameterListSyntax = (function (_super) {
        __extends(ParameterListSyntax, _super);
        function ParameterListSyntax(openParenToken, parameters, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.parameters = parameters;
            this.closeParenToken = closeParenToken;
        }
        ParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameterList(this);
        };
        ParameterListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ParameterList;
        };
        ParameterListSyntax.prototype.childCount = function () {
            return 3;
        };
        ParameterListSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.parameters;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ParameterListSyntax.prototype.update = function (openParenToken, parameters, closeParenToken) {
            if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
                return this;
            }
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, this.parsedInStrictMode());
        };
        ParameterListSyntax.create = function create(openParenToken, closeParenToken) {
            return new ParameterListSyntax(openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };
        ParameterListSyntax.create1 = function create1() {
            return new ParameterListSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), false);
        };
        ParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ParameterListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.parameters, this.closeParenToken);
        };
        ParameterListSyntax.prototype.withParameters = function (parameters) {
            return this.update(this.openParenToken, parameters, this.closeParenToken);
        };
        ParameterListSyntax.prototype.withParameter = function (parameter) {
            return this.withParameters(TypeScript.Syntax.separatedList([
                parameter
            ]));
        };
        ParameterListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.parameters, closeParenToken);
        };
        ParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameters.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterListSyntax = ParameterListSyntax;    
    var TypeParameterListSyntax = (function (_super) {
        __extends(TypeParameterListSyntax, _super);
        function TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeParameters = typeParameters;
            this.greaterThanToken = greaterThanToken;
        }
        TypeParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameterList(this);
        };
        TypeParameterListSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeParameterList;
        };
        TypeParameterListSyntax.prototype.childCount = function () {
            return 3;
        };
        TypeParameterListSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeParameters;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeParameterListSyntax.prototype.update = function (lessThanToken, typeParameters, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
                return this;
            }
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, this.parsedInStrictMode());
        };
        TypeParameterListSyntax.create = function create(lessThanToken, greaterThanToken) {
            return new TypeParameterListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };
        TypeParameterListSyntax.create1 = function create1() {
            return new TypeParameterListSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.LessThanToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.GreaterThanToken), false);
        };
        TypeParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeParameterListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
        };
        TypeParameterListSyntax.prototype.withTypeParameters = function (typeParameters) {
            return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
        };
        TypeParameterListSyntax.prototype.withTypeParameter = function (typeParameter) {
            return this.withTypeParameters(TypeScript.Syntax.separatedList([
                typeParameter
            ]));
        };
        TypeParameterListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
        };
        TypeParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterListSyntax = TypeParameterListSyntax;    
    var TypeParameterSyntax = (function (_super) {
        __extends(TypeParameterSyntax, _super);
        function TypeParameterSyntax(identifier, constraint, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.constraint = constraint;
        }
        TypeParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameter(this);
        };
        TypeParameterSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeParameter;
        };
        TypeParameterSyntax.prototype.childCount = function () {
            return 2;
        };
        TypeParameterSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.constraint;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeParameterSyntax.prototype.update = function (identifier, constraint) {
            if (this.identifier === identifier && this.constraint === constraint) {
                return this;
            }
            return new TypeParameterSyntax(identifier, constraint, this.parsedInStrictMode());
        };
        TypeParameterSyntax.create = function create(identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };
        TypeParameterSyntax.create1 = function create1(identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };
        TypeParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.constraint);
        };
        TypeParameterSyntax.prototype.withConstraint = function (constraint) {
            return this.update(this.identifier, constraint);
        };
        TypeParameterSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterSyntax = TypeParameterSyntax;    
    var ConstraintSyntax = (function (_super) {
        __extends(ConstraintSyntax, _super);
        function ConstraintSyntax(extendsKeyword, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsKeyword = extendsKeyword;
            this.type = type;
        }
        ConstraintSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstraint(this);
        };
        ConstraintSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.Constraint;
        };
        ConstraintSyntax.prototype.childCount = function () {
            return 2;
        };
        ConstraintSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.extendsKeyword;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstraintSyntax.prototype.update = function (extendsKeyword, type) {
            if (this.extendsKeyword === extendsKeyword && this.type === type) {
                return this;
            }
            return new ConstraintSyntax(extendsKeyword, type, this.parsedInStrictMode());
        };
        ConstraintSyntax.create1 = function create1(type) {
            return new ConstraintSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ExtendsKeyword), type, false);
        };
        ConstraintSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstraintSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstraintSyntax.prototype.withExtendsKeyword = function (extendsKeyword) {
            return this.update(extendsKeyword, this.type);
        };
        ConstraintSyntax.prototype.withType = function (type) {
            return this.update(this.extendsKeyword, type);
        };
        ConstraintSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstraintSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstraintSyntax = ConstraintSyntax;    
    var ElseClauseSyntax = (function (_super) {
        __extends(ElseClauseSyntax, _super);
        function ElseClauseSyntax(elseKeyword, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.elseKeyword = elseKeyword;
            this.statement = statement;
        }
        ElseClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitElseClause(this);
        };
        ElseClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ElseClause;
        };
        ElseClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        ElseClauseSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.elseKeyword;
                case 1:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ElseClauseSyntax.prototype.update = function (elseKeyword, statement) {
            if (this.elseKeyword === elseKeyword && this.statement === statement) {
                return this;
            }
            return new ElseClauseSyntax(elseKeyword, statement, this.parsedInStrictMode());
        };
        ElseClauseSyntax.create1 = function create1(statement) {
            return new ElseClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ElseKeyword), statement, false);
        };
        ElseClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ElseClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ElseClauseSyntax.prototype.withElseKeyword = function (elseKeyword) {
            return this.update(elseKeyword, this.statement);
        };
        ElseClauseSyntax.prototype.withStatement = function (statement) {
            return this.update(this.elseKeyword, statement);
        };
        ElseClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElseClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElseClauseSyntax = ElseClauseSyntax;    
    var IfStatementSyntax = (function (_super) {
        __extends(IfStatementSyntax, _super);
        function IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.ifKeyword = ifKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
            this.elseClause = elseClause;
        }
        IfStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitIfStatement(this);
        };
        IfStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.IfStatement;
        };
        IfStatementSyntax.prototype.childCount = function () {
            return 6;
        };
        IfStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.ifKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                case 5:
                    return this.elseClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        IfStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        IfStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        IfStatementSyntax.prototype.update = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
            if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
                return this;
            }
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, this.parsedInStrictMode());
        };
        IfStatementSyntax.create = function create(ifKeyword, openParenToken, condition, closeParenToken, statement) {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, false);
        };
        IfStatementSyntax.create1 = function create1(condition, statement) {
            return new IfStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.IfKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, null, false);
        };
        IfStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        IfStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        IfStatementSyntax.prototype.withIfKeyword = function (ifKeyword) {
            return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
        };
        IfStatementSyntax.prototype.withElseClause = function (elseClause) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
        };
        IfStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return IfStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IfStatementSyntax = IfStatementSyntax;    
    var ExpressionStatementSyntax = (function (_super) {
        __extends(ExpressionStatementSyntax, _super);
        function ExpressionStatementSyntax(expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ExpressionStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitExpressionStatement(this);
        };
        ExpressionStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ExpressionStatement;
        };
        ExpressionStatementSyntax.prototype.childCount = function () {
            return 2;
        };
        ExpressionStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ExpressionStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ExpressionStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ExpressionStatementSyntax.prototype.update = function (expression, semicolonToken) {
            if (this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ExpressionStatementSyntax(expression, semicolonToken, this.parsedInStrictMode());
        };
        ExpressionStatementSyntax.create1 = function create1(expression) {
            return new ExpressionStatementSyntax(expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ExpressionStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ExpressionStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ExpressionStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.semicolonToken);
        };
        ExpressionStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.expression, semicolonToken);
        };
        ExpressionStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ExpressionStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExpressionStatementSyntax = ExpressionStatementSyntax;    
    var ConstructorDeclarationSyntax = (function (_super) {
        __extends(ConstructorDeclarationSyntax, _super);
        function ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.constructorKeyword = constructorKeyword;
            this.parameterList = parameterList;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        ConstructorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorDeclaration(this);
        };
        ConstructorDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ConstructorDeclaration;
        };
        ConstructorDeclarationSyntax.prototype.childCount = function () {
            return 4;
        };
        ConstructorDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.constructorKeyword;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.block;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ConstructorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        ConstructorDeclarationSyntax.prototype.update = function (constructorKeyword, parameterList, block, semicolonToken) {
            if (this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, this.parsedInStrictMode());
        };
        ConstructorDeclarationSyntax.create = function create(constructorKeyword, parameterList) {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, null, null, false);
        };
        ConstructorDeclarationSyntax.create1 = function create1() {
            return new ConstructorDeclarationSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ConstructorKeyword), ParameterListSyntax.create1(), null, null, false);
        };
        ConstructorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ConstructorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ConstructorDeclarationSyntax.prototype.withConstructorKeyword = function (constructorKeyword) {
            return this.update(constructorKeyword, this.parameterList, this.block, this.semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.constructorKeyword, parameterList, this.block, this.semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.constructorKeyword, this.parameterList, block, this.semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.constructorKeyword, this.parameterList, this.block, semicolonToken);
        };
        ConstructorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorDeclarationSyntax = ConstructorDeclarationSyntax;    
    var MemberFunctionDeclarationSyntax = (function (_super) {
        __extends(MemberFunctionDeclarationSyntax, _super);
        function MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        MemberFunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberFunctionDeclaration(this);
        };
        MemberFunctionDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberFunctionDeclaration;
        };
        MemberFunctionDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };
        MemberFunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                case 4:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        MemberFunctionDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };
        MemberFunctionDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        MemberFunctionDeclarationSyntax.prototype.update = function (modifiers, propertyName, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.propertyName === propertyName && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };
        MemberFunctionDeclarationSyntax.create = function create(propertyName, callSignature) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, callSignature, null, null, false);
        };
        MemberFunctionDeclarationSyntax.create1 = function create1(propertyName) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, CallSignatureSyntax.create1(), null, null, false);
        };
        MemberFunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MemberFunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MemberFunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.propertyName, this.callSignature, this.block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        MemberFunctionDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, propertyName, this.callSignature, this.block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.propertyName, callSignature, this.block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, block, this.semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, this.block, semicolonToken);
        };
        MemberFunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberFunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberFunctionDeclarationSyntax = MemberFunctionDeclarationSyntax;    
    var MemberAccessorDeclarationSyntax = (function (_super) {
        __extends(MemberAccessorDeclarationSyntax, _super);
        function MemberAccessorDeclarationSyntax(modifiers, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.parameterList = parameterList;
            this.block = block;
        }
        MemberAccessorDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };
        MemberAccessorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        MemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberAccessorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessorDeclarationSyntax = MemberAccessorDeclarationSyntax;    
    var GetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(GetMemberAccessorDeclarationSyntax, _super);
        function GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetMemberAccessorDeclaration(this);
        };
        GetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.GetMemberAccessorDeclaration;
        };
        GetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        GetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.getKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        GetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
            if (this.modifiers === modifiers && this.getKeyword === getKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }
            return new GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, this.parsedInStrictMode());
        };
        GetMemberAccessorDeclarationSyntax.create = function create(getKeyword, propertyName, parameterList, block) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, getKeyword, propertyName, parameterList, null, block, false);
        };
        GetMemberAccessorDeclarationSyntax.create1 = function create1(propertyName) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.GetKeyword), propertyName, ParameterListSyntax.create1(), null, BlockSyntax.create1(), false);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        GetMemberAccessorDeclarationSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(this.modifiers, getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.getKeyword, propertyName, this.parameterList, this.typeAnnotation, this.block);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, parameterList, this.typeAnnotation, this.block);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, typeAnnotation, this.block);
        };
        GetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, block);
        };
        GetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.GetMemberAccessorDeclarationSyntax = GetMemberAccessorDeclarationSyntax;    
    var SetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(SetMemberAccessorDeclarationSyntax, _super);
        function SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
        }
        SetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetMemberAccessorDeclaration(this);
        };
        SetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SetMemberAccessorDeclaration;
        };
        SetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };
        SetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.setKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, setKeyword, propertyName, parameterList, block) {
            if (this.modifiers === modifiers && this.setKeyword === setKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.block === block) {
                return this;
            }
            return new SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, this.parsedInStrictMode());
        };
        SetMemberAccessorDeclarationSyntax.create = function create(setKeyword, propertyName, parameterList, block) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, setKeyword, propertyName, parameterList, block, false);
        };
        SetMemberAccessorDeclarationSyntax.create1 = function create1(propertyName) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.SetKeyword), propertyName, ParameterListSyntax.create1(), BlockSyntax.create1(), false);
        };
        SetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.setKeyword, this.propertyName, this.parameterList, this.block);
        };
        SetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        SetMemberAccessorDeclarationSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(this.modifiers, setKeyword, this.propertyName, this.parameterList, this.block);
        };
        SetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.setKeyword, propertyName, this.parameterList, this.block);
        };
        SetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, parameterList, this.block);
        };
        SetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, this.parameterList, block);
        };
        SetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.SetMemberAccessorDeclarationSyntax = SetMemberAccessorDeclarationSyntax;    
    var MemberVariableDeclarationSyntax = (function (_super) {
        __extends(MemberVariableDeclarationSyntax, _super);
        function MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclarator = variableDeclarator;
            this.semicolonToken = semicolonToken;
        }
        MemberVariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberVariableDeclaration(this);
        };
        MemberVariableDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.MemberVariableDeclaration;
        };
        MemberVariableDeclarationSyntax.prototype.childCount = function () {
            return 3;
        };
        MemberVariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclarator;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        MemberVariableDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };
        MemberVariableDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };
        MemberVariableDeclarationSyntax.prototype.update = function (modifiers, variableDeclarator, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, this.parsedInStrictMode());
        };
        MemberVariableDeclarationSyntax.create = function create(variableDeclarator, semicolonToken) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, semicolonToken, false);
        };
        MemberVariableDeclarationSyntax.create1 = function create1(variableDeclarator) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        MemberVariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        MemberVariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        MemberVariableDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclarator, this.semicolonToken);
        };
        MemberVariableDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        MemberVariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.update(this.modifiers, variableDeclarator, this.semicolonToken);
        };
        MemberVariableDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclarator, semicolonToken);
        };
        MemberVariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberVariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberVariableDeclarationSyntax = MemberVariableDeclarationSyntax;    
    var ThrowStatementSyntax = (function (_super) {
        __extends(ThrowStatementSyntax, _super);
        function ThrowStatementSyntax(throwKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.throwKeyword = throwKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ThrowStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitThrowStatement(this);
        };
        ThrowStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ThrowStatement;
        };
        ThrowStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        ThrowStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.throwKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ThrowStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ThrowStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ThrowStatementSyntax.prototype.update = function (throwKeyword, expression, semicolonToken) {
            if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };
        ThrowStatementSyntax.create1 = function create1(expression) {
            return new ThrowStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ThrowKeyword), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ThrowStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ThrowStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ThrowStatementSyntax.prototype.withThrowKeyword = function (throwKeyword) {
            return this.update(throwKeyword, this.expression, this.semicolonToken);
        };
        ThrowStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.throwKeyword, expression, this.semicolonToken);
        };
        ThrowStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.throwKeyword, this.expression, semicolonToken);
        };
        ThrowStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ThrowStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ThrowStatementSyntax = ThrowStatementSyntax;    
    var ReturnStatementSyntax = (function (_super) {
        __extends(ReturnStatementSyntax, _super);
        function ReturnStatementSyntax(returnKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.returnKeyword = returnKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ReturnStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitReturnStatement(this);
        };
        ReturnStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ReturnStatement;
        };
        ReturnStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        ReturnStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.returnKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ReturnStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ReturnStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ReturnStatementSyntax.prototype.update = function (returnKeyword, expression, semicolonToken) {
            if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };
        ReturnStatementSyntax.create = function create(returnKeyword, semicolonToken) {
            return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, false);
        };
        ReturnStatementSyntax.create1 = function create1() {
            return new ReturnStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ReturnKeyword), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ReturnStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ReturnStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ReturnStatementSyntax.prototype.withReturnKeyword = function (returnKeyword) {
            return this.update(returnKeyword, this.expression, this.semicolonToken);
        };
        ReturnStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.returnKeyword, expression, this.semicolonToken);
        };
        ReturnStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.returnKeyword, this.expression, semicolonToken);
        };
        ReturnStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression !== null && this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ReturnStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ReturnStatementSyntax = ReturnStatementSyntax;    
    var ObjectCreationExpressionSyntax = (function (_super) {
        __extends(ObjectCreationExpressionSyntax, _super);
        function ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.expression = expression;
            this.argumentList = argumentList;
        }
        ObjectCreationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectCreationExpression(this);
        };
        ObjectCreationExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectCreationExpression;
        };
        ObjectCreationExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ObjectCreationExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ObjectCreationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ObjectCreationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ObjectCreationExpressionSyntax.prototype.update = function (newKeyword, expression, argumentList) {
            if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
                return this;
            }
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, this.parsedInStrictMode());
        };
        ObjectCreationExpressionSyntax.create = function create(newKeyword, expression) {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, null, false);
        };
        ObjectCreationExpressionSyntax.create1 = function create1(expression) {
            return new ObjectCreationExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.NewKeyword), expression, null, false);
        };
        ObjectCreationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ObjectCreationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ObjectCreationExpressionSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.expression, this.argumentList);
        };
        ObjectCreationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.newKeyword, expression, this.argumentList);
        };
        ObjectCreationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.newKeyword, this.expression, argumentList);
        };
        ObjectCreationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectCreationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectCreationExpressionSyntax = ObjectCreationExpressionSyntax;    
    var SwitchStatementSyntax = (function (_super) {
        __extends(SwitchStatementSyntax, _super);
        function SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.switchKeyword = switchKeyword;
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
            this.openBraceToken = openBraceToken;
            this.switchClauses = switchClauses;
            this.closeBraceToken = closeBraceToken;
        }
        SwitchStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitSwitchStatement(this);
        };
        SwitchStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SwitchStatement;
        };
        SwitchStatementSyntax.prototype.childCount = function () {
            return 7;
        };
        SwitchStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.switchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.expression;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.switchClauses;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SwitchStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        SwitchStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        SwitchStatementSyntax.prototype.update = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
            if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, this.parsedInStrictMode());
        };
        SwitchStatementSyntax.create = function create(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, closeBraceToken) {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };
        SwitchStatementSyntax.create1 = function create1(expression) {
            return new SwitchStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.SwitchKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        SwitchStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SwitchStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SwitchStatementSyntax.prototype.withSwitchKeyword = function (switchKeyword) {
            return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withSwitchClauses = function (switchClauses) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
        };
        SwitchStatementSyntax.prototype.withSwitchClause = function (switchClause) {
            return this.withSwitchClauses(TypeScript.Syntax.list([
                switchClause
            ]));
        };
        SwitchStatementSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
        };
        SwitchStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.switchClauses.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SwitchStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchStatementSyntax = SwitchStatementSyntax;    
    var SwitchClauseSyntax = (function (_super) {
        __extends(SwitchClauseSyntax, _super);
        function SwitchClauseSyntax(colonToken, statements, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.statements = statements;
        }
        SwitchClauseSyntax.prototype.isSwitchClause = function () {
            return true;
        };
        SwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return SwitchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchClauseSyntax = SwitchClauseSyntax;    
    var CaseSwitchClauseSyntax = (function (_super) {
        __extends(CaseSwitchClauseSyntax, _super);
        function CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.caseKeyword = caseKeyword;
            this.expression = expression;
        }
        CaseSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCaseSwitchClause(this);
        };
        CaseSwitchClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CaseSwitchClause;
        };
        CaseSwitchClauseSyntax.prototype.childCount = function () {
            return 4;
        };
        CaseSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.caseKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.colonToken;
                case 3:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        CaseSwitchClauseSyntax.prototype.update = function (caseKeyword, expression, colonToken, statements) {
            if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, this.parsedInStrictMode());
        };
        CaseSwitchClauseSyntax.create = function create(caseKeyword, expression, colonToken) {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, TypeScript.Syntax.emptyList, false);
        };
        CaseSwitchClauseSyntax.create1 = function create1(expression) {
            return new CaseSwitchClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.CaseKeyword), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), TypeScript.Syntax.emptyList, false);
        };
        CaseSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CaseSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CaseSwitchClauseSyntax.prototype.withCaseKeyword = function (caseKeyword) {
            return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
        };
        CaseSwitchClauseSyntax.prototype.withExpression = function (expression) {
            return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
        };
        CaseSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
        };
        CaseSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
        };
        CaseSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([
                statement
            ]));
        };
        CaseSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CaseSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.CaseSwitchClauseSyntax = CaseSwitchClauseSyntax;    
    var DefaultSwitchClauseSyntax = (function (_super) {
        __extends(DefaultSwitchClauseSyntax, _super);
        function DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.defaultKeyword = defaultKeyword;
        }
        DefaultSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitDefaultSwitchClause(this);
        };
        DefaultSwitchClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DefaultSwitchClause;
        };
        DefaultSwitchClauseSyntax.prototype.childCount = function () {
            return 3;
        };
        DefaultSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.defaultKeyword;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        DefaultSwitchClauseSyntax.prototype.update = function (defaultKeyword, colonToken, statements) {
            if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, this.parsedInStrictMode());
        };
        DefaultSwitchClauseSyntax.create = function create(defaultKeyword, colonToken) {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, TypeScript.Syntax.emptyList, false);
        };
        DefaultSwitchClauseSyntax.create1 = function create1() {
            return new DefaultSwitchClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DefaultKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), TypeScript.Syntax.emptyList, false);
        };
        DefaultSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DefaultSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DefaultSwitchClauseSyntax.prototype.withDefaultKeyword = function (defaultKeyword) {
            return this.update(defaultKeyword, this.colonToken, this.statements);
        };
        DefaultSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.defaultKeyword, colonToken, this.statements);
        };
        DefaultSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.defaultKeyword, this.colonToken, statements);
        };
        DefaultSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([
                statement
            ]));
        };
        DefaultSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DefaultSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.DefaultSwitchClauseSyntax = DefaultSwitchClauseSyntax;    
    var BreakStatementSyntax = (function (_super) {
        __extends(BreakStatementSyntax, _super);
        function BreakStatementSyntax(breakKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.breakKeyword = breakKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        BreakStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitBreakStatement(this);
        };
        BreakStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.BreakStatement;
        };
        BreakStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        BreakStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.breakKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        BreakStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        BreakStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        BreakStatementSyntax.prototype.update = function (breakKeyword, identifier, semicolonToken) {
            if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };
        BreakStatementSyntax.create = function create(breakKeyword, semicolonToken) {
            return new BreakStatementSyntax(breakKeyword, null, semicolonToken, false);
        };
        BreakStatementSyntax.create1 = function create1() {
            return new BreakStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.BreakKeyword), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        BreakStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        BreakStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        BreakStatementSyntax.prototype.withBreakKeyword = function (breakKeyword) {
            return this.update(breakKeyword, this.identifier, this.semicolonToken);
        };
        BreakStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.breakKeyword, identifier, this.semicolonToken);
        };
        BreakStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.breakKeyword, this.identifier, semicolonToken);
        };
        BreakStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BreakStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BreakStatementSyntax = BreakStatementSyntax;    
    var ContinueStatementSyntax = (function (_super) {
        __extends(ContinueStatementSyntax, _super);
        function ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.continueKeyword = continueKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ContinueStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitContinueStatement(this);
        };
        ContinueStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ContinueStatement;
        };
        ContinueStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        ContinueStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.continueKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ContinueStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        ContinueStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        ContinueStatementSyntax.prototype.update = function (continueKeyword, identifier, semicolonToken) {
            if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };
        ContinueStatementSyntax.create = function create(continueKeyword, semicolonToken) {
            return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, false);
        };
        ContinueStatementSyntax.create1 = function create1() {
            return new ContinueStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ContinueKeyword), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        ContinueStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ContinueStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ContinueStatementSyntax.prototype.withContinueKeyword = function (continueKeyword) {
            return this.update(continueKeyword, this.identifier, this.semicolonToken);
        };
        ContinueStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.continueKeyword, identifier, this.semicolonToken);
        };
        ContinueStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.continueKeyword, this.identifier, semicolonToken);
        };
        ContinueStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return ContinueStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ContinueStatementSyntax = ContinueStatementSyntax;    
    var IterationStatementSyntax = (function (_super) {
        __extends(IterationStatementSyntax, _super);
        function IterationStatementSyntax(openParenToken, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        IterationStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        IterationStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        IterationStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        IterationStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        IterationStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return IterationStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IterationStatementSyntax = IterationStatementSyntax;    
    var BaseForStatementSyntax = (function (_super) {
        __extends(BaseForStatementSyntax, _super);
        function BaseForStatementSyntax(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.forKeyword = forKeyword;
            this.variableDeclaration = variableDeclaration;
        }
        BaseForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        BaseForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        BaseForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BaseForStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.BaseForStatementSyntax = BaseForStatementSyntax;    
    var ForStatementSyntax = (function (_super) {
        __extends(ForStatementSyntax, _super);
        function ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.initializer = initializer;
            this.firstSemicolonToken = firstSemicolonToken;
            this.condition = condition;
            this.secondSemicolonToken = secondSemicolonToken;
            this.incrementor = incrementor;
        }
        ForStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForStatement(this);
        };
        ForStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ForStatement;
        };
        ForStatementSyntax.prototype.childCount = function () {
            return 10;
        };
        ForStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.initializer;
                case 4:
                    return this.firstSemicolonToken;
                case 5:
                    return this.condition;
                case 6:
                    return this.secondSemicolonToken;
                case 7:
                    return this.incrementor;
                case 8:
                    return this.closeParenToken;
                case 9:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ForStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, this.parsedInStrictMode());
        };
        ForStatementSyntax.create = function create(forKeyword, openParenToken, firstSemicolonToken, secondSemicolonToken, closeParenToken, statement) {
            return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, false);
        };
        ForStatementSyntax.create1 = function create1(statement) {
            return new ForStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ForKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), null, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), null, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        ForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ForStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withInitializer = function (initializer) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withFirstSemicolonToken = function (firstSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withSecondSemicolonToken = function (secondSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withIncrementor = function (incrementor) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
        };
        ForStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
        };
        ForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition !== null && this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForStatementSyntax = ForStatementSyntax;    
    var ForInStatementSyntax = (function (_super) {
        __extends(ForInStatementSyntax, _super);
        function ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.left = left;
            this.inKeyword = inKeyword;
            this.expression = expression;
        }
        ForInStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForInStatement(this);
        };
        ForInStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ForInStatement;
        };
        ForInStatementSyntax.prototype.childCount = function () {
            return 8;
        };
        ForInStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.left;
                case 4:
                    return this.inKeyword;
                case 5:
                    return this.expression;
                case 6:
                    return this.closeParenToken;
                case 7:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ForInStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, this.parsedInStrictMode());
        };
        ForInStatementSyntax.create = function create(forKeyword, openParenToken, inKeyword, expression, closeParenToken, statement) {
            return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, false);
        };
        ForInStatementSyntax.create1 = function create1(expression, statement) {
            return new ForInStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.ForKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), null, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.InKeyword), expression, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        ForInStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ForInStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ForInStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withLeft = function (left) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withInKeyword = function (inKeyword) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
        };
        ForInStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
        };
        ForInStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.left !== null && this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForInStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForInStatementSyntax = ForInStatementSyntax;    
    var WhileStatementSyntax = (function (_super) {
        __extends(WhileStatementSyntax, _super);
        function WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.whileKeyword = whileKeyword;
            this.condition = condition;
        }
        WhileStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWhileStatement(this);
        };
        WhileStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.WhileStatement;
        };
        WhileStatementSyntax.prototype.childCount = function () {
            return 5;
        };
        WhileStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.whileKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        WhileStatementSyntax.prototype.update = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };
        WhileStatementSyntax.create1 = function create1(condition, statement) {
            return new WhileStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.WhileKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        WhileStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        WhileStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        WhileStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };
        WhileStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };
        WhileStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WhileStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.WhileStatementSyntax = WhileStatementSyntax;    
    var WithStatementSyntax = (function (_super) {
        __extends(WithStatementSyntax, _super);
        function WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.withKeyword = withKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        WithStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWithStatement(this);
        };
        WithStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.WithStatement;
        };
        WithStatementSyntax.prototype.childCount = function () {
            return 5;
        };
        WithStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.withKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        WithStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        WithStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        WithStatementSyntax.prototype.update = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };
        WithStatementSyntax.create1 = function create1(condition, statement) {
            return new WithStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.WithKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), statement, false);
        };
        WithStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        WithStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        WithStatementSyntax.prototype.withWithKeyword = function (withKeyword) {
            return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };
        WithStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };
        WithStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WithStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.WithStatementSyntax = WithStatementSyntax;    
    var EnumDeclarationSyntax = (function (_super) {
        __extends(EnumDeclarationSyntax, _super);
        function EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.enumKeyword = enumKeyword;
            this.identifier = identifier;
            this.openBraceToken = openBraceToken;
            this.enumElements = enumElements;
            this.closeBraceToken = closeBraceToken;
        }
        EnumDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumDeclaration(this);
        };
        EnumDeclarationSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EnumDeclaration;
        };
        EnumDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };
        EnumDeclarationSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.enumKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.openBraceToken;
                case 4:
                    return this.enumElements;
                case 5:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        EnumDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };
        EnumDeclarationSyntax.prototype.update = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.enumElements === enumElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, this.parsedInStrictMode());
        };
        EnumDeclarationSyntax.create = function create(enumKeyword, identifier, openBraceToken, closeBraceToken) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, enumKeyword, identifier, openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };
        EnumDeclarationSyntax.create1 = function create1(identifier) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(TypeScript.SyntaxKind.EnumKeyword), identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        EnumDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EnumDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EnumDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([
                modifier
            ]));
        };
        EnumDeclarationSyntax.prototype.withEnumKeyword = function (enumKeyword) {
            return this.update(this.modifiers, enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.enumKeyword, identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, openBraceToken, this.enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withEnumElements = function (enumElements) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, enumElements, this.closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.withEnumElement = function (enumElement) {
            return this.withEnumElements(TypeScript.Syntax.separatedList([
                enumElement
            ]));
        };
        EnumDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, closeBraceToken);
        };
        EnumDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return EnumDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumDeclarationSyntax = EnumDeclarationSyntax;    
    var EnumElementSyntax = (function (_super) {
        __extends(EnumElementSyntax, _super);
        function EnumElementSyntax(propertyName, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.equalsValueClause = equalsValueClause;
        }
        EnumElementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumElement(this);
        };
        EnumElementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EnumElement;
        };
        EnumElementSyntax.prototype.childCount = function () {
            return 2;
        };
        EnumElementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        EnumElementSyntax.prototype.update = function (propertyName, equalsValueClause) {
            if (this.propertyName === propertyName && this.equalsValueClause === equalsValueClause) {
                return this;
            }
            return new EnumElementSyntax(propertyName, equalsValueClause, this.parsedInStrictMode());
        };
        EnumElementSyntax.create = function create(propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };
        EnumElementSyntax.create1 = function create1(propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };
        EnumElementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EnumElementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EnumElementSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.equalsValueClause);
        };
        EnumElementSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.propertyName, equalsValueClause);
        };
        EnumElementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EnumElementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumElementSyntax = EnumElementSyntax;    
    var CastExpressionSyntax = (function (_super) {
        __extends(CastExpressionSyntax, _super);
        function CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.type = type;
            this.greaterThanToken = greaterThanToken;
            this.expression = expression;
        }
        CastExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitCastExpression(this);
        };
        CastExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CastExpression;
        };
        CastExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        CastExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.type;
                case 2:
                    return this.greaterThanToken;
                case 3:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        CastExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        CastExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        CastExpressionSyntax.prototype.update = function (lessThanToken, type, greaterThanToken, expression) {
            if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
                return this;
            }
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, this.parsedInStrictMode());
        };
        CastExpressionSyntax.create1 = function create1(type, expression) {
            return new CastExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.LessThanToken), type, TypeScript.Syntax.token(TypeScript.SyntaxKind.GreaterThanToken), expression, false);
        };
        CastExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CastExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CastExpressionSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
        };
        CastExpressionSyntax.prototype.withType = function (type) {
            return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
        };
        CastExpressionSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
        };
        CastExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
        };
        CastExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return CastExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CastExpressionSyntax = CastExpressionSyntax;    
    var ObjectLiteralExpressionSyntax = (function (_super) {
        __extends(ObjectLiteralExpressionSyntax, _super);
        function ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.propertyAssignments = propertyAssignments;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectLiteralExpression(this);
        };
        ObjectLiteralExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.ObjectLiteralExpression;
        };
        ObjectLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };
        ObjectLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.propertyAssignments;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        ObjectLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        ObjectLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        ObjectLiteralExpressionSyntax.prototype.update = function (openBraceToken, propertyAssignments, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
                return this;
            }
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, this.parsedInStrictMode());
        };
        ObjectLiteralExpressionSyntax.create = function create(openBraceToken, closeBraceToken) {
            return new ObjectLiteralExpressionSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };
        ObjectLiteralExpressionSyntax.create1 = function create1() {
            return new ObjectLiteralExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenBraceToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseBraceToken), false);
        };
        ObjectLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        ObjectLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        ObjectLiteralExpressionSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
        };
        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignments = function (propertyAssignments) {
            return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
        };
        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignment = function (propertyAssignment) {
            return this.withPropertyAssignments(TypeScript.Syntax.separatedList([
                propertyAssignment
            ]));
        };
        ObjectLiteralExpressionSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
        };
        ObjectLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.propertyAssignments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectLiteralExpressionSyntax = ObjectLiteralExpressionSyntax;    
    var PropertyAssignmentSyntax = (function (_super) {
        __extends(PropertyAssignmentSyntax, _super);
        function PropertyAssignmentSyntax(propertyName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
        }
        PropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        PropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        PropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return PropertyAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertyAssignmentSyntax = PropertyAssignmentSyntax;    
    var SimplePropertyAssignmentSyntax = (function (_super) {
        __extends(SimplePropertyAssignmentSyntax, _super);
        function SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.colonToken = colonToken;
            this.expression = expression;
        }
        SimplePropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimplePropertyAssignment(this);
        };
        SimplePropertyAssignmentSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SimplePropertyAssignment;
        };
        SimplePropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };
        SimplePropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SimplePropertyAssignmentSyntax.prototype.update = function (propertyName, colonToken, expression) {
            if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
                return this;
            }
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, this.parsedInStrictMode());
        };
        SimplePropertyAssignmentSyntax.create1 = function create1(propertyName, expression) {
            return new SimplePropertyAssignmentSyntax(propertyName, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), expression, false);
        };
        SimplePropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SimplePropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SimplePropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.colonToken, this.expression);
        };
        SimplePropertyAssignmentSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.propertyName, colonToken, this.expression);
        };
        SimplePropertyAssignmentSyntax.prototype.withExpression = function (expression) {
            return this.update(this.propertyName, this.colonToken, expression);
        };
        SimplePropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SimplePropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.SimplePropertyAssignmentSyntax = SimplePropertyAssignmentSyntax;    
    var AccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(AccessorPropertyAssignmentSyntax, _super);
        function AccessorPropertyAssignmentSyntax(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        AccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        AccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        AccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return AccessorPropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.AccessorPropertyAssignmentSyntax = AccessorPropertyAssignmentSyntax;    
    var GetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(GetAccessorPropertyAssignmentSyntax, _super);
        function GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetAccessorPropertyAssignment(this);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.GetAccessorPropertyAssignment;
        };
        GetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };
        GetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.getKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        GetAccessorPropertyAssignmentSyntax.prototype.update = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
            if (this.getKeyword === getKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.closeParenToken === closeParenToken && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, this.parsedInStrictMode());
        };
        GetAccessorPropertyAssignmentSyntax.create = function create(getKeyword, propertyName, openParenToken, closeParenToken, block) {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, null, block, false);
        };
        GetAccessorPropertyAssignmentSyntax.create1 = function create1(propertyName) {
            return new GetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.GetKeyword), propertyName, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), null, BlockSyntax.create1(), false);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.getKeyword, propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.getKeyword, this.propertyName, openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, closeParenToken, this.typeAnnotation, this.block);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, typeAnnotation, this.block);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, block);
        };
        GetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return GetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.GetAccessorPropertyAssignmentSyntax = GetAccessorPropertyAssignmentSyntax;    
    var SetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(SetAccessorPropertyAssignmentSyntax, _super);
        function SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
            this.parameter = parameter;
        }
        SetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetAccessorPropertyAssignment(this);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.SetAccessorPropertyAssignment;
        };
        SetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };
        SetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.setKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.parameter;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SetAccessorPropertyAssignmentSyntax.prototype.update = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
            if (this.setKeyword === setKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.parameter === parameter && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }
            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, this.parsedInStrictMode());
        };
        SetAccessorPropertyAssignmentSyntax.create1 = function create1(propertyName, parameter) {
            return new SetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.SetKeyword), propertyName, TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), parameter, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), BlockSyntax.create1(), false);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.setKeyword, propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.setKeyword, this.propertyName, openParenToken, this.parameter, this.closeParenToken, this.block);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, parameter, this.closeParenToken, this.block);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, closeParenToken, this.block);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, block);
        };
        SetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameter.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.SetAccessorPropertyAssignmentSyntax = SetAccessorPropertyAssignmentSyntax;    
    var FunctionExpressionSyntax = (function (_super) {
        __extends(FunctionExpressionSyntax, _super);
        function FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
        }
        FunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionExpression(this);
        };
        FunctionExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FunctionExpression;
        };
        FunctionExpressionSyntax.prototype.childCount = function () {
            return 4;
        };
        FunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.functionKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        FunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        FunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        FunctionExpressionSyntax.prototype.update = function (functionKeyword, identifier, callSignature, block) {
            if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
                return this;
            }
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, this.parsedInStrictMode());
        };
        FunctionExpressionSyntax.create = function create(functionKeyword, callSignature, block) {
            return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, false);
        };
        FunctionExpressionSyntax.create1 = function create1() {
            return new FunctionExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.FunctionKeyword), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };
        FunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FunctionExpressionSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
        };
        FunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
        };
        FunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
        };
        FunctionExpressionSyntax.prototype.withBlock = function (block) {
            return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
        };
        FunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionExpressionSyntax = FunctionExpressionSyntax;    
    var EmptyStatementSyntax = (function (_super) {
        __extends(EmptyStatementSyntax, _super);
        function EmptyStatementSyntax(semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.semicolonToken = semicolonToken;
        }
        EmptyStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEmptyStatement(this);
        };
        EmptyStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.EmptyStatement;
        };
        EmptyStatementSyntax.prototype.childCount = function () {
            return 1;
        };
        EmptyStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        EmptyStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        EmptyStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        EmptyStatementSyntax.prototype.update = function (semicolonToken) {
            if (this.semicolonToken === semicolonToken) {
                return this;
            }
            return new EmptyStatementSyntax(semicolonToken, this.parsedInStrictMode());
        };
        EmptyStatementSyntax.create1 = function create1() {
            return new EmptyStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        EmptyStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        EmptyStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        EmptyStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(semicolonToken);
        };
        EmptyStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return EmptyStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EmptyStatementSyntax = EmptyStatementSyntax;    
    var TryStatementSyntax = (function (_super) {
        __extends(TryStatementSyntax, _super);
        function TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.tryKeyword = tryKeyword;
            this.block = block;
            this.catchClause = catchClause;
            this.finallyClause = finallyClause;
        }
        TryStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitTryStatement(this);
        };
        TryStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TryStatement;
        };
        TryStatementSyntax.prototype.childCount = function () {
            return 4;
        };
        TryStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.tryKeyword;
                case 1:
                    return this.block;
                case 2:
                    return this.catchClause;
                case 3:
                    return this.finallyClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        TryStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        TryStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        TryStatementSyntax.prototype.update = function (tryKeyword, block, catchClause, finallyClause) {
            if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
                return this;
            }
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, this.parsedInStrictMode());
        };
        TryStatementSyntax.create = function create(tryKeyword, block) {
            return new TryStatementSyntax(tryKeyword, block, null, null, false);
        };
        TryStatementSyntax.create1 = function create1() {
            return new TryStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.TryKeyword), BlockSyntax.create1(), null, null, false);
        };
        TryStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TryStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TryStatementSyntax.prototype.withTryKeyword = function (tryKeyword) {
            return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
        };
        TryStatementSyntax.prototype.withBlock = function (block) {
            return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
        };
        TryStatementSyntax.prototype.withCatchClause = function (catchClause) {
            return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
        };
        TryStatementSyntax.prototype.withFinallyClause = function (finallyClause) {
            return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
        };
        TryStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) {
                return true;
            }
            if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TryStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TryStatementSyntax = TryStatementSyntax;    
    var CatchClauseSyntax = (function (_super) {
        __extends(CatchClauseSyntax, _super);
        function CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.catchKeyword = catchKeyword;
            this.openParenToken = openParenToken;
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        CatchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCatchClause(this);
        };
        CatchClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.CatchClause;
        };
        CatchClauseSyntax.prototype.childCount = function () {
            return 6;
        };
        CatchClauseSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.catchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeAnnotation;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        CatchClauseSyntax.prototype.update = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
            if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, this.parsedInStrictMode());
        };
        CatchClauseSyntax.create = function create(catchKeyword, openParenToken, identifier, closeParenToken, block) {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, null, closeParenToken, block, false);
        };
        CatchClauseSyntax.create1 = function create1(identifier) {
            return new CatchClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.CatchKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), identifier, null, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), BlockSyntax.create1(), false);
        };
        CatchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        CatchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        CatchClauseSyntax.prototype.withCatchKeyword = function (catchKeyword) {
            return this.update(catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.catchKeyword, openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.catchKeyword, this.openParenToken, identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, typeAnnotation, this.closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, closeParenToken, this.block);
        };
        CatchClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, block);
        };
        CatchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CatchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CatchClauseSyntax = CatchClauseSyntax;    
    var FinallyClauseSyntax = (function (_super) {
        __extends(FinallyClauseSyntax, _super);
        function FinallyClauseSyntax(finallyKeyword, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.finallyKeyword = finallyKeyword;
            this.block = block;
        }
        FinallyClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitFinallyClause(this);
        };
        FinallyClauseSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.FinallyClause;
        };
        FinallyClauseSyntax.prototype.childCount = function () {
            return 2;
        };
        FinallyClauseSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.finallyKeyword;
                case 1:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        FinallyClauseSyntax.prototype.update = function (finallyKeyword, block) {
            if (this.finallyKeyword === finallyKeyword && this.block === block) {
                return this;
            }
            return new FinallyClauseSyntax(finallyKeyword, block, this.parsedInStrictMode());
        };
        FinallyClauseSyntax.create1 = function create1() {
            return new FinallyClauseSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.FinallyKeyword), BlockSyntax.create1(), false);
        };
        FinallyClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        FinallyClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        FinallyClauseSyntax.prototype.withFinallyKeyword = function (finallyKeyword) {
            return this.update(finallyKeyword, this.block);
        };
        FinallyClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.finallyKeyword, block);
        };
        FinallyClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FinallyClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FinallyClauseSyntax = FinallyClauseSyntax;    
    var LabeledStatementSyntax = (function (_super) {
        __extends(LabeledStatementSyntax, _super);
        function LabeledStatementSyntax(identifier, colonToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.colonToken = colonToken;
            this.statement = statement;
        }
        LabeledStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitLabeledStatement(this);
        };
        LabeledStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.LabeledStatement;
        };
        LabeledStatementSyntax.prototype.childCount = function () {
            return 3;
        };
        LabeledStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        LabeledStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        LabeledStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        LabeledStatementSyntax.prototype.update = function (identifier, colonToken, statement) {
            if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
                return this;
            }
            return new LabeledStatementSyntax(identifier, colonToken, statement, this.parsedInStrictMode());
        };
        LabeledStatementSyntax.create1 = function create1(identifier, statement) {
            return new LabeledStatementSyntax(identifier, TypeScript.Syntax.token(TypeScript.SyntaxKind.ColonToken), statement, false);
        };
        LabeledStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        LabeledStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        LabeledStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.colonToken, this.statement);
        };
        LabeledStatementSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.identifier, colonToken, this.statement);
        };
        LabeledStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.identifier, this.colonToken, statement);
        };
        LabeledStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return LabeledStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.LabeledStatementSyntax = LabeledStatementSyntax;    
    var DoStatementSyntax = (function (_super) {
        __extends(DoStatementSyntax, _super);
        function DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.doKeyword = doKeyword;
            this.whileKeyword = whileKeyword;
            this.condition = condition;
            this.semicolonToken = semicolonToken;
        }
        DoStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDoStatement(this);
        };
        DoStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DoStatement;
        };
        DoStatementSyntax.prototype.childCount = function () {
            return 7;
        };
        DoStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.doKeyword;
                case 1:
                    return this.statement;
                case 2:
                    return this.whileKeyword;
                case 3:
                    return this.openParenToken;
                case 4:
                    return this.condition;
                case 5:
                    return this.closeParenToken;
                case 6:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        DoStatementSyntax.prototype.update = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
            if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.parsedInStrictMode());
        };
        DoStatementSyntax.create1 = function create1(statement, condition) {
            return new DoStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DoKeyword), statement, TypeScript.Syntax.token(TypeScript.SyntaxKind.WhileKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.OpenParenToken), condition, TypeScript.Syntax.token(TypeScript.SyntaxKind.CloseParenToken), TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        DoStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DoStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DoStatementSyntax.prototype.withDoKeyword = function (doKeyword) {
            return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
        };
        DoStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
        };
        DoStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DoStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.DoStatementSyntax = DoStatementSyntax;    
    var TypeOfExpressionSyntax = (function (_super) {
        __extends(TypeOfExpressionSyntax, _super);
        function TypeOfExpressionSyntax(typeOfKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeOfKeyword = typeOfKeyword;
            this.expression = expression;
        }
        TypeOfExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeOfExpression(this);
        };
        TypeOfExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.TypeOfExpression;
        };
        TypeOfExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        TypeOfExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.typeOfKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        TypeOfExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        TypeOfExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        TypeOfExpressionSyntax.prototype.update = function (typeOfKeyword, expression) {
            if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
                return this;
            }
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, this.parsedInStrictMode());
        };
        TypeOfExpressionSyntax.create1 = function create1(expression) {
            return new TypeOfExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.TypeOfKeyword), expression, false);
        };
        TypeOfExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        TypeOfExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        TypeOfExpressionSyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.expression);
        };
        TypeOfExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.typeOfKeyword, expression);
        };
        TypeOfExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TypeOfExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeOfExpressionSyntax = TypeOfExpressionSyntax;    
    var DeleteExpressionSyntax = (function (_super) {
        __extends(DeleteExpressionSyntax, _super);
        function DeleteExpressionSyntax(deleteKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.deleteKeyword = deleteKeyword;
            this.expression = expression;
        }
        DeleteExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitDeleteExpression(this);
        };
        DeleteExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DeleteExpression;
        };
        DeleteExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        DeleteExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.deleteKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        DeleteExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        DeleteExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        DeleteExpressionSyntax.prototype.update = function (deleteKeyword, expression) {
            if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
                return this;
            }
            return new DeleteExpressionSyntax(deleteKeyword, expression, this.parsedInStrictMode());
        };
        DeleteExpressionSyntax.create1 = function create1(expression) {
            return new DeleteExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DeleteKeyword), expression, false);
        };
        DeleteExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DeleteExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DeleteExpressionSyntax.prototype.withDeleteKeyword = function (deleteKeyword) {
            return this.update(deleteKeyword, this.expression);
        };
        DeleteExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.deleteKeyword, expression);
        };
        DeleteExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DeleteExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DeleteExpressionSyntax = DeleteExpressionSyntax;    
    var VoidExpressionSyntax = (function (_super) {
        __extends(VoidExpressionSyntax, _super);
        function VoidExpressionSyntax(voidKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.voidKeyword = voidKeyword;
            this.expression = expression;
        }
        VoidExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitVoidExpression(this);
        };
        VoidExpressionSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.VoidExpression;
        };
        VoidExpressionSyntax.prototype.childCount = function () {
            return 2;
        };
        VoidExpressionSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.voidKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        VoidExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };
        VoidExpressionSyntax.prototype.isExpression = function () {
            return true;
        };
        VoidExpressionSyntax.prototype.update = function (voidKeyword, expression) {
            if (this.voidKeyword === voidKeyword && this.expression === expression) {
                return this;
            }
            return new VoidExpressionSyntax(voidKeyword, expression, this.parsedInStrictMode());
        };
        VoidExpressionSyntax.create1 = function create1(expression) {
            return new VoidExpressionSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.VoidKeyword), expression, false);
        };
        VoidExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        VoidExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        VoidExpressionSyntax.prototype.withVoidKeyword = function (voidKeyword) {
            return this.update(voidKeyword, this.expression);
        };
        VoidExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.voidKeyword, expression);
        };
        VoidExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VoidExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VoidExpressionSyntax = VoidExpressionSyntax;    
    var DebuggerStatementSyntax = (function (_super) {
        __extends(DebuggerStatementSyntax, _super);
        function DebuggerStatementSyntax(debuggerKeyword, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.debuggerKeyword = debuggerKeyword;
            this.semicolonToken = semicolonToken;
        }
        DebuggerStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDebuggerStatement(this);
        };
        DebuggerStatementSyntax.prototype.kind = function () {
            return TypeScript.SyntaxKind.DebuggerStatement;
        };
        DebuggerStatementSyntax.prototype.childCount = function () {
            return 2;
        };
        DebuggerStatementSyntax.prototype.childAt = function (slot) {
            switch(slot) {
                case 0:
                    return this.debuggerKeyword;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        DebuggerStatementSyntax.prototype.isStatement = function () {
            return true;
        };
        DebuggerStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };
        DebuggerStatementSyntax.prototype.update = function (debuggerKeyword, semicolonToken) {
            if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
                return this;
            }
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, this.parsedInStrictMode());
        };
        DebuggerStatementSyntax.create1 = function create1() {
            return new DebuggerStatementSyntax(TypeScript.Syntax.token(TypeScript.SyntaxKind.DebuggerKeyword), TypeScript.Syntax.token(TypeScript.SyntaxKind.SemicolonToken), false);
        };
        DebuggerStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };
        DebuggerStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };
        DebuggerStatementSyntax.prototype.withDebuggerKeyword = function (debuggerKeyword) {
            return this.update(debuggerKeyword, this.semicolonToken);
        };
        DebuggerStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.debuggerKeyword, semicolonToken);
        };
        DebuggerStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return DebuggerStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DebuggerStatementSyntax = DebuggerStatementSyntax;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxRewriter = (function () {
        function SyntaxRewriter() { }
        SyntaxRewriter.prototype.visitToken = function (token) {
            return token;
        };
        SyntaxRewriter.prototype.visitNode = function (node) {
            return node.accept(this);
        };
        SyntaxRewriter.prototype.visitNodeOrToken = function (node) {
            return node.isToken() ? this.visitToken(node) : this.visitNode(node);
        };
        SyntaxRewriter.prototype.visitList = function (list) {
            var newItems = null;
            for(var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = this.visitNodeOrToken(item);
                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for(var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }
                if (newItems) {
                    newItems.push(newItem);
                }
            }
            return newItems === null ? list : TypeScript.Syntax.list(newItems);
        };
        SyntaxRewriter.prototype.visitSeparatedList = function (list) {
            var newItems = null;
            for(var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = item.isToken() ? this.visitToken(item) : this.visitNode(item);
                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for(var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }
                if (newItems) {
                    newItems.push(newItem);
                }
            }
            return newItems === null ? list : TypeScript.Syntax.separatedList(newItems);
        };
        SyntaxRewriter.prototype.visitSourceUnit = function (node) {
            return node.update(this.visitList(node.moduleElements), this.visitToken(node.endOfFileToken));
        };
        SyntaxRewriter.prototype.visitExternalModuleReference = function (node) {
            return node.update(this.visitToken(node.moduleKeyword), this.visitToken(node.openParenToken), this.visitToken(node.stringLiteral), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitModuleNameModuleReference = function (node) {
            return node.update(this.visitNodeOrToken(node.moduleName));
        };
        SyntaxRewriter.prototype.visitImportDeclaration = function (node) {
            return node.update(this.visitToken(node.importKeyword), this.visitToken(node.identifier), this.visitToken(node.equalsToken), this.visitNode(node.moduleReference), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitExportAssignment = function (node) {
            return node.update(this.visitToken(node.exportKeyword), this.visitToken(node.equalsToken), this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitClassDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.classKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitToken(node.openBraceToken), this.visitList(node.classElements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitInterfaceDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.interfaceKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitNode(node.body));
        };
        SyntaxRewriter.prototype.visitHeritageClause = function (node) {
            return node.update(this.visitToken(node.extendsOrImplementsKeyword), this.visitSeparatedList(node.typeNames));
        };
        SyntaxRewriter.prototype.visitModuleDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.moduleKeyword), node.moduleName === null ? null : this.visitNodeOrToken(node.moduleName), node.stringLiteral === null ? null : this.visitToken(node.stringLiteral), this.visitToken(node.openBraceToken), this.visitList(node.moduleElements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.functionKeyword), this.visitToken(node.identifier), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitVariableStatement = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclaration), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitVariableDeclaration = function (node) {
            return node.update(this.visitToken(node.varKeyword), this.visitSeparatedList(node.variableDeclarators));
        };
        SyntaxRewriter.prototype.visitVariableDeclarator = function (node) {
            return node.update(this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };
        SyntaxRewriter.prototype.visitEqualsValueClause = function (node) {
            return node.update(this.visitToken(node.equalsToken), this.visitNodeOrToken(node.value));
        };
        SyntaxRewriter.prototype.visitPrefixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.operand));
        };
        SyntaxRewriter.prototype.visitArrayLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitSeparatedList(node.expressions), this.visitToken(node.closeBracketToken));
        };
        SyntaxRewriter.prototype.visitOmittedExpression = function (node) {
            return node;
        };
        SyntaxRewriter.prototype.visitParenthesizedExpression = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };
        SyntaxRewriter.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return node.update(this.visitNode(node.callSignature), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };
        SyntaxRewriter.prototype.visitQualifiedName = function (node) {
            return node.update(this.visitNodeOrToken(node.left), this.visitToken(node.dotToken), this.visitToken(node.right));
        };
        SyntaxRewriter.prototype.visitTypeArgumentList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeArguments), this.visitToken(node.greaterThanToken));
        };
        SyntaxRewriter.prototype.visitConstructorType = function (node) {
            return node.update(this.visitToken(node.newKeyword), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitFunctionType = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitObjectType = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.typeMembers), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitArrayType = function (node) {
            return node.update(this.visitNodeOrToken(node.type), this.visitToken(node.openBracketToken), this.visitToken(node.closeBracketToken));
        };
        SyntaxRewriter.prototype.visitGenericType = function (node) {
            return node.update(this.visitNodeOrToken(node.name), this.visitNode(node.typeArgumentList));
        };
        SyntaxRewriter.prototype.visitTypeAnnotation = function (node) {
            return node.update(this.visitToken(node.colonToken), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitBlock = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitList(node.statements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitParameter = function (node) {
            return node.update(node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken), node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };
        SyntaxRewriter.prototype.visitMemberAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.dotToken), this.visitToken(node.name));
        };
        SyntaxRewriter.prototype.visitPostfixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.operand), this.visitToken(node.operatorToken));
        };
        SyntaxRewriter.prototype.visitElementAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.openBracketToken), this.visitNodeOrToken(node.argumentExpression), this.visitToken(node.closeBracketToken));
        };
        SyntaxRewriter.prototype.visitInvocationExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitNode(node.argumentList));
        };
        SyntaxRewriter.prototype.visitArgumentList = function (node) {
            return node.update(node.typeArgumentList === null ? null : this.visitNode(node.typeArgumentList), this.visitToken(node.openParenToken), this.visitSeparatedList(node.arguments), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitBinaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.left), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.right));
        };
        SyntaxRewriter.prototype.visitConditionalExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.condition), this.visitToken(node.questionToken), this.visitNodeOrToken(node.whenTrue), this.visitToken(node.colonToken), this.visitNodeOrToken(node.whenFalse));
        };
        SyntaxRewriter.prototype.visitConstructSignature = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNode(node.callSignature));
        };
        SyntaxRewriter.prototype.visitMethodSignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), this.visitNode(node.callSignature));
        };
        SyntaxRewriter.prototype.visitIndexSignature = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitNode(node.parameter), this.visitToken(node.closeBracketToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };
        SyntaxRewriter.prototype.visitPropertySignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };
        SyntaxRewriter.prototype.visitCallSignature = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };
        SyntaxRewriter.prototype.visitParameterList = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitSeparatedList(node.parameters), this.visitToken(node.closeParenToken));
        };
        SyntaxRewriter.prototype.visitTypeParameterList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeParameters), this.visitToken(node.greaterThanToken));
        };
        SyntaxRewriter.prototype.visitTypeParameter = function (node) {
            return node.update(this.visitToken(node.identifier), node.constraint === null ? null : this.visitNode(node.constraint));
        };
        SyntaxRewriter.prototype.visitConstraint = function (node) {
            return node.update(this.visitToken(node.extendsKeyword), this.visitNodeOrToken(node.type));
        };
        SyntaxRewriter.prototype.visitElseClause = function (node) {
            return node.update(this.visitToken(node.elseKeyword), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitIfStatement = function (node) {
            return node.update(this.visitToken(node.ifKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement), node.elseClause === null ? null : this.visitNode(node.elseClause));
        };
        SyntaxRewriter.prototype.visitExpressionStatement = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitConstructorDeclaration = function (node) {
            return node.update(this.visitToken(node.constructorKeyword), this.visitNode(node.parameterList), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitMemberFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.propertyName), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitMemberVariableDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclarator), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitThrowStatement = function (node) {
            return node.update(this.visitToken(node.throwKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitReturnStatement = function (node) {
            return node.update(this.visitToken(node.returnKeyword), node.expression === null ? null : this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitObjectCreationExpression = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNodeOrToken(node.expression), node.argumentList === null ? null : this.visitNode(node.argumentList));
        };
        SyntaxRewriter.prototype.visitSwitchStatement = function (node) {
            return node.update(this.visitToken(node.switchKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitToken(node.openBraceToken), this.visitList(node.switchClauses), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitCaseSwitchClause = function (node) {
            return node.update(this.visitToken(node.caseKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.colonToken), this.visitList(node.statements));
        };
        SyntaxRewriter.prototype.visitDefaultSwitchClause = function (node) {
            return node.update(this.visitToken(node.defaultKeyword), this.visitToken(node.colonToken), this.visitList(node.statements));
        };
        SyntaxRewriter.prototype.visitBreakStatement = function (node) {
            return node.update(this.visitToken(node.breakKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitContinueStatement = function (node) {
            return node.update(this.visitToken(node.continueKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitForStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.initializer === null ? null : this.visitNodeOrToken(node.initializer), this.visitToken(node.firstSemicolonToken), node.condition === null ? null : this.visitNodeOrToken(node.condition), this.visitToken(node.secondSemicolonToken), node.incrementor === null ? null : this.visitNodeOrToken(node.incrementor), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitForInStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.left === null ? null : this.visitNodeOrToken(node.left), this.visitToken(node.inKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitWhileStatement = function (node) {
            return node.update(this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitWithStatement = function (node) {
            return node.update(this.visitToken(node.withKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitEnumDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.enumKeyword), this.visitToken(node.identifier), this.visitToken(node.openBraceToken), this.visitSeparatedList(node.enumElements), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitEnumElement = function (node) {
            return node.update(this.visitToken(node.propertyName), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };
        SyntaxRewriter.prototype.visitCastExpression = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitNodeOrToken(node.type), this.visitToken(node.greaterThanToken), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitObjectLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.propertyAssignments), this.visitToken(node.closeBraceToken));
        };
        SyntaxRewriter.prototype.visitSimplePropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitToken(node.colonToken), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitToken(node.closeParenToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitNode(node.parameter), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitFunctionExpression = function (node) {
            return node.update(this.visitToken(node.functionKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitNode(node.callSignature), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitEmptyStatement = function (node) {
            return node.update(this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitTryStatement = function (node) {
            return node.update(this.visitToken(node.tryKeyword), this.visitNode(node.block), node.catchClause === null ? null : this.visitNode(node.catchClause), node.finallyClause === null ? null : this.visitNode(node.finallyClause));
        };
        SyntaxRewriter.prototype.visitCatchClause = function (node) {
            return node.update(this.visitToken(node.catchKeyword), this.visitToken(node.openParenToken), this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitFinallyClause = function (node) {
            return node.update(this.visitToken(node.finallyKeyword), this.visitNode(node.block));
        };
        SyntaxRewriter.prototype.visitLabeledStatement = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.colonToken), this.visitNodeOrToken(node.statement));
        };
        SyntaxRewriter.prototype.visitDoStatement = function (node) {
            return node.update(this.visitToken(node.doKeyword), this.visitNodeOrToken(node.statement), this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitToken(node.semicolonToken));
        };
        SyntaxRewriter.prototype.visitTypeOfExpression = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitDeleteExpression = function (node) {
            return node.update(this.visitToken(node.deleteKeyword), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitVoidExpression = function (node) {
            return node.update(this.visitToken(node.voidKeyword), this.visitNodeOrToken(node.expression));
        };
        SyntaxRewriter.prototype.visitDebuggerStatement = function (node) {
            return node.update(this.visitToken(node.debuggerKeyword), this.visitToken(node.semicolonToken));
        };
        return SyntaxRewriter;
    })();
    TypeScript.SyntaxRewriter = SyntaxRewriter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxDedenter = (function (_super) {
        __extends(SyntaxDedenter, _super);
        function SyntaxDedenter(dedentFirstToken, dedentationAmount, minimumIndent, options) {
            _super.call(this);
            this.dedentationAmount = dedentationAmount;
            this.minimumIndent = minimumIndent;
            this.options = options;
            this.lastTriviaWasNewLine = dedentFirstToken;
        }
        SyntaxDedenter.prototype.abort = function () {
            this.lastTriviaWasNewLine = false;
            this.dedentationAmount = 0;
        };
        SyntaxDedenter.prototype.isAborted = function () {
            return this.dedentationAmount === 0;
        };
        SyntaxDedenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }
            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.dedentTriviaList(token.leadingTrivia()));
            }
            if (this.isAborted()) {
                return token;
            }
            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };
        SyntaxDedenter.prototype.dedentTriviaList = function (triviaList) {
            var result = [];
            var dedentNextWhitespace = true;
            for(var i = 0, n = triviaList.count(); i < n && !this.isAborted(); i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var dedentThisTrivia = dedentNextWhitespace;
                dedentNextWhitespace = false;
                if (dedentThisTrivia) {
                    if (trivia.kind() === TypeScript.SyntaxKind.WhitespaceTrivia) {
                        var hasFollowingNewLine = (i < triviaList.count() - 1) && triviaList.syntaxTriviaAt(i + 1).kind() === TypeScript.SyntaxKind.NewLineTrivia;
                        result.push(this.dedentWhitespace(trivia, hasFollowingNewLine));
                        continue;
                    } else if (trivia.kind() !== TypeScript.SyntaxKind.NewLineTrivia) {
                        this.abort();
                        break;
                    }
                }
                if (trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia) {
                    result.push(this.dedentMultiLineComment(trivia));
                    continue;
                }
                result.push(trivia);
                if (trivia.kind() === TypeScript.SyntaxKind.NewLineTrivia) {
                    dedentNextWhitespace = true;
                }
            }
            if (dedentNextWhitespace) {
                this.abort();
            }
            if (this.isAborted()) {
                return triviaList;
            }
            return TypeScript.Syntax.triviaList(result);
        };
        SyntaxDedenter.prototype.dedentSegment = function (segment, hasFollowingNewLineTrivia) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
            if (firstNonWhitespacePosition === segment.length) {
                if (hasFollowingNewLineTrivia) {
                    return "";
                }
            } else if (TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment.substring(firstNonWhitespacePosition);
            }
            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
            var newFirstNonWhitespaceColumn = TypeScript.MathPrototype.min(firstNonWhitespaceColumn, TypeScript.MathPrototype.max(firstNonWhitespaceColumn - this.dedentationAmount, this.minimumIndent));
            if (newFirstNonWhitespaceColumn === firstNonWhitespaceColumn) {
                this.abort();
                return segment;
            }
            this.dedentationAmount = firstNonWhitespaceColumn - newFirstNonWhitespaceColumn;
            TypeScript.Debug.assert(this.dedentationAmount >= 0);
            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);
            return indentationString + segment.substring(firstNonWhitespacePosition);
        };
        SyntaxDedenter.prototype.dedentWhitespace = function (trivia, hasFollowingNewLineTrivia) {
            var newIndentation = this.dedentSegment(trivia.fullText(), hasFollowingNewLineTrivia);
            return TypeScript.Syntax.whitespace(newIndentation);
        };
        SyntaxDedenter.prototype.dedentMultiLineComment = function (trivia) {
            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            if (segments.length === 1) {
                return trivia;
            }
            for(var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                segments[i] = this.dedentSegment(segment, false);
            }
            var result = segments.join("");
            return TypeScript.Syntax.multiLineComment(result);
        };
        SyntaxDedenter.dedentNode = function dedentNode(node, dedentFirstToken, dedentAmount, minimumIndent, options) {
            var dedenter = new SyntaxDedenter(dedentFirstToken, dedentAmount, minimumIndent, options);
            var result = node.accept(dedenter);
            if (dedenter.isAborted()) {
                return node;
            }
            return result;
        };
        return SyntaxDedenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxDedenter = SyntaxDedenter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxIndenter = (function (_super) {
        __extends(SyntaxIndenter, _super);
        function SyntaxIndenter(indentFirstToken, indentationAmount, options) {
            _super.call(this);
            this.indentationAmount = indentationAmount;
            this.options = options;
            this.lastTriviaWasNewLine = indentFirstToken;
            this.indentationTrivia = TypeScript.Indentation.indentationTrivia(this.indentationAmount, this.options);
        }
        SyntaxIndenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }
            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.indentTriviaList(token.leadingTrivia()));
            }
            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };
        SyntaxIndenter.prototype.indentTriviaList = function (triviaList) {
            var result = [];
            var indentNextTrivia = true;
            for(var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                var indentThisTrivia = indentNextTrivia;
                indentNextTrivia = false;
                switch(trivia.kind()) {
                    case TypeScript.SyntaxKind.MultiLineCommentTrivia:
                        this.indentMultiLineComment(trivia, indentThisTrivia, result);
                        continue;
                    case TypeScript.SyntaxKind.SingleLineCommentTrivia:
                    case TypeScript.SyntaxKind.SkippedTextTrivia:
                        this.indentSingleLineOrSkippedText(trivia, indentThisTrivia, result);
                        continue;
                    case TypeScript.SyntaxKind.WhitespaceTrivia:
                        this.indentWhitespace(trivia, indentThisTrivia, result);
                        continue;
                    case TypeScript.SyntaxKind.NewLineTrivia:
                        result.push(trivia);
                        indentNextTrivia = true;
                        continue;
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }
            if (indentNextTrivia) {
                result.push(this.indentationTrivia);
            }
            return TypeScript.Syntax.triviaList(result);
        };
        SyntaxIndenter.prototype.indentSegment = function (segment) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
            if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment;
            }
            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
            var newFirstNonWhitespaceColumn = firstNonWhitespaceColumn + this.indentationAmount;
            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);
            return indentationString + segment.substring(firstNonWhitespacePosition);
        };
        SyntaxIndenter.prototype.indentWhitespace = function (trivia, indentThisTrivia, result) {
            if (!indentThisTrivia) {
                result.push(trivia);
                return;
            }
            var newIndentation = this.indentSegment(trivia.fullText());
            result.push(TypeScript.Syntax.whitespace(newIndentation));
        };
        SyntaxIndenter.prototype.indentSingleLineOrSkippedText = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }
            result.push(trivia);
        };
        SyntaxIndenter.prototype.indentMultiLineComment = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }
            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            for(var i = 1; i < segments.length; i++) {
                segments[i] = this.indentSegment(segments[i]);
            }
            var newText = segments.join("");
            result.push(TypeScript.Syntax.multiLineComment(newText));
        };
        SyntaxIndenter.indentNode = function indentNode(node, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            return node.accept(indenter);
        };
        SyntaxIndenter.indentNodes = function indentNodes(nodes, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            var result = TypeScript.ArrayUtilities.select(nodes, function (n) {
                return n.accept(indenter);
            });
            return result;
        };
        return SyntaxIndenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxIndenter = SyntaxIndenter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var VariableWidthTokenWithNoTrivia = (function () {
            function VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithNoTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithNoTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth);
            };
            VariableWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            VariableWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            VariableWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            VariableWidthTokenWithNoTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithNoTrivia.prototype.end = function () {
                return this.start() + this.width();
            };
            VariableWidthTokenWithNoTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };
            VariableWidthTokenWithNoTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };
            VariableWidthTokenWithNoTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }
                return (this)._value;
            };
            VariableWidthTokenWithNoTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }
                return (this)._valueText;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            VariableWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithNoTrivia;
        })();
        Syntax.VariableWidthTokenWithNoTrivia = VariableWidthTokenWithNoTrivia;        
        var VariableWidthTokenWithLeadingTrivia = (function () {
            function VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            VariableWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }
                return (this)._value;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }
                return (this)._valueText;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithLeadingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingTrivia = VariableWidthTokenWithLeadingTrivia;        
        var VariableWidthTokenWithTrailingTrivia = (function () {
            function VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth, this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            VariableWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };
            VariableWidthTokenWithTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }
                return (this)._value;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }
                return (this)._valueText;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithTrailingTrivia = VariableWidthTokenWithTrailingTrivia;        
        var VariableWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth, this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === TypeScript.SyntaxKind.IdentifierName);
                }
                return this._textOrWidth;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }
                return (this)._value;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }
                return (this)._valueText;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia = VariableWidthTokenWithLeadingAndTrailingTrivia;        
        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(kind) {
                this.tokenKind = kind;
            }
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            FixedWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            FixedWidthTokenWithNoTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithNoTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this.text();
            };
            FixedWidthTokenWithNoTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            FixedWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithNoTrivia;
        })();
        Syntax.FixedWidthTokenWithNoTrivia = FixedWidthTokenWithNoTrivia;        
        var FixedWidthTokenWithLeadingTrivia = (function () {
            function FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
            }
            FixedWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            FixedWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithLeadingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingTrivia = FixedWidthTokenWithLeadingTrivia;        
        var FixedWidthTokenWithTrailingTrivia = (function () {
            function FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            FixedWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };
            FixedWidthTokenWithTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithTrailingTrivia = FixedWidthTokenWithTrailingTrivia;        
        var FixedWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia = FixedWidthTokenWithLeadingAndTrailingTrivia;        
        function collectTokenTextElements(token, elements) {
            token.leadingTrivia().collectTextElements(elements);
            elements.push(token.text());
            token.trailingTrivia().collectTextElements(elements);
        }
        function fixedWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new FixedWidthTokenWithNoTrivia(kind);
                } else {
                    return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
            } else {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
            }
        }
        Syntax.fixedWidthToken = fixedWidthToken;
        function variableWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
                } else {
                    return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
            } else {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
            }
        }
        Syntax.variableWidthToken = variableWidthToken;
        function getTriviaWidth(value) {
            return value >>> TypeScript.SyntaxConstants.TriviaFullWidthShift;
        }
        function hasTriviaComment(value) {
            return (value & TypeScript.SyntaxConstants.TriviaCommentMask) !== 0;
        }
        function hasTriviaNewLine(value) {
            return (value & TypeScript.SyntaxConstants.TriviaNewLineMask) !== 0;
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function realizeToken(token) {
            return new RealizedToken(token.tokenKind, token.leadingTrivia(), token.text(), token.value(), token.valueText(), token.trailingTrivia());
        }
        Syntax.realizeToken = realizeToken;
        function convertToIdentifierName(token) {
            TypeScript.Debug.assert(TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind));
            return new RealizedToken(TypeScript.SyntaxKind.IdentifierName, token.leadingTrivia(), token.text(), token.text(), token.text(), token.trailingTrivia());
        }
        Syntax.convertToIdentifierName = convertToIdentifierName;
        function tokenToJSON(token) {
            var result = {};
            result.kind = (TypeScript.SyntaxKind)._map[token.kind()];
            result.width = token.width();
            if (token.fullWidth() !== token.width()) {
                result.fullWidth = token.fullWidth();
            }
            result.text = token.text();
            var value = token.value();
            if (value !== null) {
                result.value = value;
                result.valueText = token.valueText();
            }
            if (token.hasLeadingTrivia()) {
                result.hasLeadingTrivia = true;
            }
            if (token.hasLeadingComment()) {
                result.hasLeadingComment = true;
            }
            if (token.hasLeadingNewLine()) {
                result.hasLeadingNewLine = true;
            }
            if (token.hasLeadingSkippedText()) {
                result.hasLeadingSkippedText = true;
            }
            if (token.hasTrailingTrivia()) {
                result.hasTrailingTrivia = true;
            }
            if (token.hasTrailingComment()) {
                result.hasTrailingComment = true;
            }
            if (token.hasTrailingNewLine()) {
                result.hasTrailingNewLine = true;
            }
            if (token.hasTrailingSkippedText()) {
                result.hasTrailingSkippedText = true;
            }
            var trivia = token.leadingTrivia();
            if (trivia.count() > 0) {
                result.leadingTrivia = trivia;
            }
            trivia = token.trailingTrivia();
            if (trivia.count() > 0) {
                result.trailingTrivia = trivia;
            }
            return result;
        }
        Syntax.tokenToJSON = tokenToJSON;
        function value(token) {
            return value1(token.tokenKind, token.text());
        }
        Syntax.value = value;
        function hexValue(text, start, length) {
            var intChar = 0;
            for(var i = 0; i < length; i++) {
                var ch2 = text.charCodeAt(start + i);
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    break;
                }
                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
            }
            return intChar;
        }
        var characterArray = [];
        function convertEscapes(text) {
            characterArray.length = 0;
            for(var i = 0, n = text.length; i < n; i++) {
                var ch = text.charCodeAt(i);
                if (ch === TypeScript.CharacterCodes.backslash) {
                    i++;
                    if (i < n) {
                        ch = text.charCodeAt(i);
                        switch(ch) {
                            case TypeScript.CharacterCodes._0:
                                characterArray.push(TypeScript.CharacterCodes.nullCharacter);
                                continue;
                            case TypeScript.CharacterCodes.b:
                                characterArray.push(TypeScript.CharacterCodes.backspace);
                                continue;
                            case TypeScript.CharacterCodes.f:
                                characterArray.push(TypeScript.CharacterCodes.formFeed);
                                continue;
                            case TypeScript.CharacterCodes.n:
                                characterArray.push(TypeScript.CharacterCodes.lineFeed);
                                continue;
                            case TypeScript.CharacterCodes.r:
                                characterArray.push(TypeScript.CharacterCodes.carriageReturn);
                                continue;
                            case TypeScript.CharacterCodes.t:
                                characterArray.push(TypeScript.CharacterCodes.tab);
                                continue;
                            case TypeScript.CharacterCodes.v:
                                characterArray.push(TypeScript.CharacterCodes.verticalTab);
                                continue;
                            case TypeScript.CharacterCodes.x:
                                characterArray.push(hexValue(text, i + 1, 2));
                                i += 2;
                                continue;
                            case TypeScript.CharacterCodes.u:
                                characterArray.push(hexValue(text, i + 1, 4));
                                i += 4;
                                continue;
                            default:
                        }
                    }
                }
                characterArray.push(ch);
            }
            return String.fromCharCode.apply(null, characterArray);
        }
        function massageEscapes(text) {
            return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
        }
        function value1(kind, text) {
            if (kind === TypeScript.SyntaxKind.IdentifierName) {
                return massageEscapes(text);
            }
            switch(kind) {
                case TypeScript.SyntaxKind.TrueKeyword:
                    return true;
                case TypeScript.SyntaxKind.FalseKeyword:
                    return false;
                case TypeScript.SyntaxKind.NullKeyword:
                    return null;
            }
            if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
                return TypeScript.SyntaxFacts.getText(kind);
            }
            if (kind === TypeScript.SyntaxKind.NumericLiteral) {
                return parseFloat(text);
            } else if (kind === TypeScript.SyntaxKind.StringLiteral) {
                if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                    return massageEscapes(text.substr(1, text.length - 2));
                } else {
                    return massageEscapes(text.substr(1));
                }
            } else if (kind === TypeScript.SyntaxKind.RegularExpressionLiteral) {
                try  {
                    var lastSlash = text.lastIndexOf("/");
                    var body = text.substring(1, lastSlash);
                    var flags = text.substring(lastSlash + 1);
                    return new RegExp(body, flags);
                } catch (e) {
                    return null;
                }
            } else if (kind === TypeScript.SyntaxKind.EndOfFileToken || kind === TypeScript.SyntaxKind.ErrorToken) {
                return null;
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        }
        function valueText1(kind, text) {
            var value = value1(kind, text);
            return value === null ? "" : value.toString();
        }
        function valueText(token) {
            var value = token.value();
            return value === null ? "" : value.toString();
        }
        Syntax.valueText = valueText;
        var EmptyToken = (function () {
            function EmptyToken(kind) {
                this.tokenKind = kind;
            }
            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.tokenKind);
            };
            EmptyToken.prototype.kind = function () {
                return this.tokenKind;
            };
            EmptyToken.prototype.isToken = function () {
                return true;
            };
            EmptyToken.prototype.isNode = function () {
                return false;
            };
            EmptyToken.prototype.isList = function () {
                return false;
            };
            EmptyToken.prototype.isSeparatedList = function () {
                return false;
            };
            EmptyToken.prototype.childCount = function () {
                return 0;
            };
            EmptyToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            EmptyToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            EmptyToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            EmptyToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            EmptyToken.prototype.firstToken = function () {
                return this;
            };
            EmptyToken.prototype.lastToken = function () {
                return this;
            };
            EmptyToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            EmptyToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };
            EmptyToken.prototype.fullWidth = function () {
                return 0;
            };
            EmptyToken.prototype.width = function () {
                return 0;
            };
            EmptyToken.prototype.text = function () {
                return "";
            };
            EmptyToken.prototype.fullText = function () {
                return "";
            };
            EmptyToken.prototype.value = function () {
                return null;
            };
            EmptyToken.prototype.valueText = function () {
                return "";
            };
            EmptyToken.prototype.hasLeadingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.hasTrailingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.hasSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.realize = function () {
                return realizeToken(this);
            };
            EmptyToken.prototype.collectTextElements = function (elements) {
            };
            EmptyToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };
            EmptyToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return EmptyToken;
        })();        
        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;
        var RealizedToken = (function () {
            function RealizedToken(tokenKind, leadingTrivia, text, value, valueText, trailingTrivia) {
                this.tokenKind = tokenKind;
                this._leadingTrivia = leadingTrivia;
                this._text = text;
                this._value = value;
                this._valueText = valueText;
                this._trailingTrivia = trailingTrivia;
            }
            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };
            RealizedToken.prototype.kind = function () {
                return this.tokenKind;
            };
            RealizedToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            RealizedToken.prototype.firstToken = function () {
                return this;
            };
            RealizedToken.prototype.lastToken = function () {
                return this;
            };
            RealizedToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            RealizedToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };
            RealizedToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            RealizedToken.prototype.childCount = function () {
                return 0;
            };
            RealizedToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };
            RealizedToken.prototype.isToken = function () {
                return true;
            };
            RealizedToken.prototype.isNode = function () {
                return false;
            };
            RealizedToken.prototype.isList = function () {
                return false;
            };
            RealizedToken.prototype.isSeparatedList = function () {
                return false;
            };
            RealizedToken.prototype.isTrivia = function () {
                return false;
            };
            RealizedToken.prototype.isTriviaList = function () {
                return false;
            };
            RealizedToken.prototype.fullWidth = function () {
                return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth();
            };
            RealizedToken.prototype.width = function () {
                return this.text().length;
            };
            RealizedToken.prototype.text = function () {
                return this._text;
            };
            RealizedToken.prototype.fullText = function () {
                return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText();
            };
            RealizedToken.prototype.value = function () {
                return this._value;
            };
            RealizedToken.prototype.valueText = function () {
                return this._valueText;
            };
            RealizedToken.prototype.hasLeadingTrivia = function () {
                return this._leadingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasLeadingComment = function () {
                return this._leadingTrivia.hasComment();
            };
            RealizedToken.prototype.hasLeadingNewLine = function () {
                return this._leadingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasLeadingSkippedText = function () {
                return this._leadingTrivia.hasSkippedText();
            };
            RealizedToken.prototype.leadingTriviaWidth = function () {
                return this._leadingTrivia.fullWidth();
            };
            RealizedToken.prototype.hasTrailingTrivia = function () {
                return this._trailingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasTrailingComment = function () {
                return this._trailingTrivia.hasComment();
            };
            RealizedToken.prototype.hasTrailingNewLine = function () {
                return this._trailingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasTrailingSkippedText = function () {
                return this._trailingTrivia.hasSkippedText();
            };
            RealizedToken.prototype.trailingTriviaWidth = function () {
                return this._trailingTrivia.fullWidth();
            };
            RealizedToken.prototype.hasSkippedText = function () {
                return this.hasLeadingSkippedText() || this.hasTrailingSkippedText();
            };
            RealizedToken.prototype.leadingTrivia = function () {
                return this._leadingTrivia;
            };
            RealizedToken.prototype.trailingTrivia = function () {
                return this._trailingTrivia;
            };
            RealizedToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };
            RealizedToken.prototype.collectTextElements = function (elements) {
                this.leadingTrivia().collectTextElements(elements);
                elements.push(this.text());
                this.trailingTrivia().collectTextElements(elements);
            };
            RealizedToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return new RealizedToken(this.tokenKind, leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };
            RealizedToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, trailingTrivia);
            };
            return RealizedToken;
        })();        
        function token(kind, info) {
            if (typeof info === "undefined") { info = null; }
            var text = (info !== null && info.text !== undefined) ? info.text : TypeScript.SyntaxFacts.getText(kind);
            return new RealizedToken(kind, TypeScript.Syntax.triviaList(info === null ? null : info.leadingTrivia), text, value1(kind, text), valueText1(kind, text), TypeScript.Syntax.triviaList(info === null ? null : info.trailingTrivia));
        }
        Syntax.token = token;
        function identifier(text, info) {
            if (typeof info === "undefined") { info = null; }
            info = info || {};
            info.text = text;
            return token(TypeScript.SyntaxKind.IdentifierName, info);
        }
        Syntax.identifier = identifier;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTokenReplacer = (function (_super) {
        __extends(SyntaxTokenReplacer, _super);
        function SyntaxTokenReplacer(token1, token2) {
            _super.call(this);
            this.token1 = token1;
            this.token2 = token2;
        }
        SyntaxTokenReplacer.prototype.visitToken = function (token) {
            if (token === this.token1) {
                var result = this.token2;
                this.token1 = null;
                this.token2 = null;
                return result;
            }
            return token;
        };
        SyntaxTokenReplacer.prototype.visitNode = function (node) {
            if (this.token1 === null) {
                return node;
            }
            return _super.prototype.visitNode.call(this, node);
        };
        SyntaxTokenReplacer.prototype.visitList = function (list) {
            if (this.token1 === null) {
                return list;
            }
            return _super.prototype.visitList.call(this, list);
        };
        SyntaxTokenReplacer.prototype.visitSeparatedList = function (list) {
            if (this.token1 === null) {
                return list;
            }
            return _super.prototype.visitSeparatedList.call(this, list);
        };
        return SyntaxTokenReplacer;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxTokenReplacer = SyntaxTokenReplacer;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var SyntaxTrivia = (function () {
            function SyntaxTrivia(kind, text) {
                this._kind = kind;
                this._text = text;
            }
            SyntaxTrivia.prototype.toJSON = function (key) {
                var result = {};
                result.kind = (TypeScript.SyntaxKind)._map[this._kind];
                result.text = this._text;
                return result;
            };
            SyntaxTrivia.prototype.kind = function () {
                return this._kind;
            };
            SyntaxTrivia.prototype.fullWidth = function () {
                return this._text.length;
            };
            SyntaxTrivia.prototype.fullText = function () {
                return this._text;
            };
            SyntaxTrivia.prototype.isWhitespace = function () {
                return this.kind() === TypeScript.SyntaxKind.WhitespaceTrivia;
            };
            SyntaxTrivia.prototype.isComment = function () {
                return this.kind() === TypeScript.SyntaxKind.SingleLineCommentTrivia || this.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia;
            };
            SyntaxTrivia.prototype.isNewLine = function () {
                return this.kind() === TypeScript.SyntaxKind.NewLineTrivia;
            };
            SyntaxTrivia.prototype.isSkippedText = function () {
                return this.kind() === TypeScript.SyntaxKind.SkippedTextTrivia;
            };
            SyntaxTrivia.prototype.collectTextElements = function (elements) {
                elements.push(this.fullText());
            };
            return SyntaxTrivia;
        })();        
        function trivia(kind, text) {
            return new SyntaxTrivia(kind, text);
        }
        Syntax.trivia = trivia;
        function spaces(count) {
            return trivia(TypeScript.SyntaxKind.WhitespaceTrivia, TypeScript.StringUtilities.repeat(" ", count));
        }
        Syntax.spaces = spaces;
        function whitespace(text) {
            return trivia(TypeScript.SyntaxKind.WhitespaceTrivia, text);
        }
        Syntax.whitespace = whitespace;
        function multiLineComment(text) {
            return trivia(TypeScript.SyntaxKind.MultiLineCommentTrivia, text);
        }
        Syntax.multiLineComment = multiLineComment;
        function singleLineComment(text) {
            return trivia(TypeScript.SyntaxKind.SingleLineCommentTrivia, text);
        }
        Syntax.singleLineComment = singleLineComment;
        Syntax.spaceTrivia = spaces(1);
        Syntax.lineFeedTrivia = trivia(TypeScript.SyntaxKind.NewLineTrivia, "\n");
        Syntax.carriageReturnTrivia = trivia(TypeScript.SyntaxKind.NewLineTrivia, "\r");
        Syntax.carriageReturnLineFeedTrivia = trivia(TypeScript.SyntaxKind.NewLineTrivia, "\r\n");
        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            var result = [];
            var triviaText = trivia.fullText();
            var currentIndex = 0;
            for(var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);
                var isCarriageReturnLineFeed = false;
                switch(ch) {
                    case TypeScript.CharacterCodes.carriageReturn:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === TypeScript.CharacterCodes.lineFeed) {
                            i++;
                        }
                    case TypeScript.CharacterCodes.lineFeed:
                    case TypeScript.CharacterCodes.paragraphSeparator:
                    case TypeScript.CharacterCodes.lineSeparator:
                        result.push(triviaText.substring(currentIndex, i + 1));
                        currentIndex = i + 1;
                        continue;
                }
            }
            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        Syntax.emptyTriviaList = {
            kind: function () {
                return TypeScript.SyntaxKind.TriviaList;
            },
            count: function () {
                return 0;
            },
            syntaxTriviaAt: function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            last: function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            fullWidth: function () {
                return 0;
            },
            fullText: function () {
                return "";
            },
            hasComment: function () {
                return false;
            },
            hasNewLine: function () {
                return false;
            },
            hasSkippedText: function () {
                return false;
            },
            toJSON: function (key) {
                return [];
            },
            collectTextElements: function (elements) {
            },
            toArray: function () {
                return [];
            },
            concat: function (trivia) {
                return trivia;
            }
        };
        function concatTrivia(list1, list2) {
            if (list1.count() === 0) {
                return list2;
            }
            if (list2.count() === 0) {
                return list1;
            }
            var trivia = list1.toArray();
            trivia.push.apply(trivia, list2.toArray());
            return triviaList(trivia);
        }
        function isComment(trivia) {
            return trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia || trivia.kind() === TypeScript.SyntaxKind.SingleLineCommentTrivia;
        }
        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item;
            }
            SingletonSyntaxTriviaList.prototype.kind = function () {
                return TypeScript.SyntaxKind.TriviaList;
            };
            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };
            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };
            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };
            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };
            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };
            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind() === TypeScript.SyntaxKind.NewLineTrivia;
            };
            SingletonSyntaxTriviaList.prototype.hasSkippedText = function () {
                return this.item.kind() === TypeScript.SyntaxKind.SkippedTextTrivia;
            };
            SingletonSyntaxTriviaList.prototype.toJSON = function (key) {
                return [
                    this.item
                ];
            };
            SingletonSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                (this.item).collectTextElements(elements);
            };
            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [
                    this.item
                ];
            };
            SingletonSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return SingletonSyntaxTriviaList;
        })();        
        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                this.trivia = trivia;
            }
            NormalSyntaxTriviaList.prototype.kind = function () {
                return TypeScript.SyntaxKind.TriviaList;
            };
            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };
            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }
                return this.trivia[index];
            };
            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };
            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) {
                    return t.fullWidth();
                });
            };
            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = "";
                for(var i = 0, n = this.trivia.length; i < n; i++) {
                    result += this.trivia[i].fullText();
                }
                return result;
            };
            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for(var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for(var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === TypeScript.SyntaxKind.NewLineTrivia) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.hasSkippedText = function () {
                for(var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === TypeScript.SyntaxKind.SkippedTextTrivia) {
                        return true;
                    }
                }
                return false;
            };
            NormalSyntaxTriviaList.prototype.toJSON = function (key) {
                return this.trivia;
            };
            NormalSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                for(var i = 0; i < this.trivia.length; i++) {
                    (this.trivia[i]).collectTextElements(elements);
                }
            };
            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };
            NormalSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return NormalSyntaxTriviaList;
        })();        
        function triviaList(trivia) {
            if (trivia === undefined || trivia === null || trivia.length === 0) {
                return TypeScript.Syntax.emptyTriviaList;
            }
            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }
            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;
        Syntax.spaceTriviaList = triviaList([
            TypeScript.Syntax.spaceTrivia
        ]);
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxUtilities = (function () {
        function SyntaxUtilities() { }
        SyntaxUtilities.isAngleBracket = function isAngleBracket(positionedElement) {
            var element = positionedElement.element();
            var parent = positionedElement.parentElement();
            if (parent !== null && (element.kind() === TypeScript.SyntaxKind.LessThanToken || element.kind() === TypeScript.SyntaxKind.GreaterThanToken)) {
                switch(parent.kind()) {
                    case TypeScript.SyntaxKind.TypeArgumentList:
                    case TypeScript.SyntaxKind.TypeParameterList:
                    case TypeScript.SyntaxKind.CastExpression:
                        return true;
                }
            }
            return false;
        };
        return SyntaxUtilities;
    })();
    TypeScript.SyntaxUtilities = SyntaxUtilities;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxVisitor = (function () {
        function SyntaxVisitor() { }
        SyntaxVisitor.prototype.defaultVisit = function (node) {
            return null;
        };
        SyntaxVisitor.prototype.visitToken = function (token) {
            return this.defaultVisit(token);
        };
        SyntaxVisitor.prototype.visitSourceUnit = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitExternalModuleReference = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitModuleNameModuleReference = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitImportDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitExportAssignment = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitClassDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitInterfaceDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitHeritageClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitModuleDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVariableStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVariableDeclarator = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEqualsValueClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitArrayLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitOmittedExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParenthesizedExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitQualifiedName = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeArgumentList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstructorType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFunctionType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitObjectType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitArrayType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitGenericType = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeAnnotation = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitBlock = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParameter = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMemberAccessExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitElementAccessExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitInvocationExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitArgumentList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitBinaryExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConditionalExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstructSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMethodSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitIndexSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitPropertySignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCallSignature = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitParameterList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeParameterList = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeParameter = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstraint = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitElseClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitIfStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitExpressionStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitConstructorDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitThrowStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitReturnStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitObjectCreationExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSwitchStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCaseSwitchClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDefaultSwitchClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitBreakStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitContinueStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitForStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitForInStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitWhileStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitWithStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEnumDeclaration = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEnumElement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCastExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitObjectLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitEmptyStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTryStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitCatchClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitFinallyClause = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitLabeledStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDoStatement = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitTypeOfExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDeleteExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitVoidExpression = function (node) {
            return this.defaultVisit(node);
        };
        SyntaxVisitor.prototype.visitDebuggerStatement = function (node) {
            return this.defaultVisit(node);
        };
        return SyntaxVisitor;
    })();
    TypeScript.SyntaxVisitor = SyntaxVisitor;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() { }
        SyntaxWalker.prototype.visitToken = function (token) {
        };
        SyntaxWalker.prototype.visitNode = function (node) {
            node.accept(this);
        };
        SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken.isToken()) {
                this.visitToken(nodeOrToken);
            } else {
                this.visitNode(nodeOrToken);
            }
        };
        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === null) {
                return;
            }
            this.visitToken(token);
        };
        SyntaxWalker.prototype.visitOptionalNode = function (node) {
            if (node === null) {
                return;
            }
            this.visitNode(node);
        };
        SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken === null) {
                return;
            }
            this.visitNodeOrToken(nodeOrToken);
        };
        SyntaxWalker.prototype.visitList = function (list) {
            for(var i = 0, n = list.childCount(); i < n; i++) {
                this.visitNodeOrToken(list.childAt(i));
            }
        };
        SyntaxWalker.prototype.visitSeparatedList = function (list) {
            for(var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                this.visitNodeOrToken(item);
            }
        };
        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };
        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.moduleKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            this.visitNodeOrToken(node.moduleName);
        };
        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNode(node.moduleReference);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        };
        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        };
        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.moduleName);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        };
        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        };
        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        };
        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };
        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };
        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };
        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };
        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitFunctionType = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitArrayType = function (node) {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitGenericType = function (node) {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        };
        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };
        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        };
        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };
        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        };
        SyntaxWalker.prototype.visitArgumentList = function (node) {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        };
        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        };
        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        };
        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        };
        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitCallSignature = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        };
        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        };
        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };
        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        };
        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.type);
        };
        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        };
        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        };
        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };
        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitEnumElement = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        };
        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };
        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitToken(node.closeParenToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        };
        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        };
        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        };
        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.semicolonToken);
        };
        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        };
        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitToken(node.semicolonToken);
        };
        return SyntaxWalker;
    })();
    TypeScript.SyntaxWalker = SyntaxWalker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionTrackingWalker = (function (_super) {
        __extends(PositionTrackingWalker, _super);
        function PositionTrackingWalker() {
            _super.apply(this, arguments);

            this._position = 0;
        }
        PositionTrackingWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };
        PositionTrackingWalker.prototype.position = function () {
            return this._position;
        };
        PositionTrackingWalker.prototype.skip = function (element) {
            this._position += element.fullWidth();
        };
        return PositionTrackingWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.PositionTrackingWalker = PositionTrackingWalker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxInformationMap = (function (_super) {
        __extends(SyntaxInformationMap, _super);
        function SyntaxInformationMap(trackParents, trackPreviousToken) {
            _super.call(this);
            this.trackParents = trackParents;
            this.trackPreviousToken = trackPreviousToken;
            this.tokenToInformation = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this.elementToPosition = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._previousToken = null;
            this._previousTokenInformation = null;
            this._currentPosition = 0;
            this._elementToParent = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._parentStack = [];
            this._parentStack.push(null);
        }
        SyntaxInformationMap.create = function create(node, trackParents, trackPreviousToken) {
            var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
            map.visitNode(node);
            return map;
        };
        SyntaxInformationMap.prototype.visitNode = function (node) {
            this.trackParents && this._elementToParent.add(node, TypeScript.ArrayUtilities.last(this._parentStack));
            this.elementToPosition.add(node, this._currentPosition);
            this.trackParents && this._parentStack.push(node);
            _super.prototype.visitNode.call(this, node);
            this.trackParents && this._parentStack.pop();
        };
        SyntaxInformationMap.prototype.visitToken = function (token) {
            this.trackParents && this._elementToParent.add(token, TypeScript.ArrayUtilities.last(this._parentStack));
            if (this.trackPreviousToken) {
                var tokenInformation = {
                    previousToken: this._previousToken,
                    nextToken: null
                };
                if (this._previousTokenInformation !== null) {
                    this._previousTokenInformation.nextToken = token;
                }
                this._previousToken = token;
                this._previousTokenInformation = tokenInformation;
                this.tokenToInformation.add(token, tokenInformation);
            }
            this.elementToPosition.add(token, this._currentPosition);
            this._currentPosition += token.fullWidth();
        };
        SyntaxInformationMap.prototype.parent = function (element) {
            return this._elementToParent.get(element);
        };
        SyntaxInformationMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };
        SyntaxInformationMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };
        SyntaxInformationMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };
        SyntaxInformationMap.prototype.previousToken = function (token) {
            return this.tokenInformation(token).previousToken;
        };
        SyntaxInformationMap.prototype.tokenInformation = function (token) {
            return this.tokenToInformation.get(token);
        };
        SyntaxInformationMap.prototype.firstTokenInLineContainingToken = function (token) {
            var current = token;
            while(true) {
                var information = this.tokenInformation(current);
                if (this.isFirstTokenInLineWorker(information)) {
                    break;
                }
                current = information.previousToken;
            }
            return current;
        };
        SyntaxInformationMap.prototype.isFirstTokenInLine = function (token) {
            var information = this.tokenInformation(token);
            return this.isFirstTokenInLineWorker(information);
        };
        SyntaxInformationMap.prototype.isFirstTokenInLineWorker = function (information) {
            return information.previousToken === null || information.previousToken.hasTrailingNewLine();
        };
        return SyntaxInformationMap;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxInformationMap = SyntaxInformationMap;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNodeInvariantsChecker = (function (_super) {
        __extends(SyntaxNodeInvariantsChecker, _super);
        function SyntaxNodeInvariantsChecker() {
            _super.apply(this, arguments);

            this.tokenTable = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
        }
        SyntaxNodeInvariantsChecker.checkInvariants = function checkInvariants(node) {
            node.accept(new SyntaxNodeInvariantsChecker());
        };
        SyntaxNodeInvariantsChecker.prototype.visitToken = function (token) {
            this.tokenTable.add(token, token);
        };
        return SyntaxNodeInvariantsChecker;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxNodeInvariantsChecker = SyntaxNodeInvariantsChecker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DepthLimitedWalker = (function (_super) {
        __extends(DepthLimitedWalker, _super);
        function DepthLimitedWalker(maximumDepth) {
            _super.call(this);
            this._depth = 0;
            this._maximumDepth = 0;
            this._maximumDepth = maximumDepth;
        }
        DepthLimitedWalker.prototype.visitNode = function (node) {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                _super.prototype.visitNode.call(this, node);
                this._depth--;
            } else {
                this.skip(node);
            }
        };
        return DepthLimitedWalker;
    })(TypeScript.PositionTrackingWalker);
    TypeScript.DepthLimitedWalker = DepthLimitedWalker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Parser) {
        var ExpressionPrecedence;
        (function (ExpressionPrecedence) {
            ExpressionPrecedence._map = [];
            ExpressionPrecedence.CommaExpressionPrecedence = 1;
            ExpressionPrecedence.AssignmentExpressionPrecedence = 2;
            ExpressionPrecedence.ConditionalExpressionPrecedence = 3;
            ExpressionPrecedence.ArrowFunctionPrecedence = 4;
            ExpressionPrecedence.LogicalOrExpressionPrecedence = 5;
            ExpressionPrecedence.LogicalAndExpressionPrecedence = 6;
            ExpressionPrecedence.BitwiseOrExpressionPrecedence = 7;
            ExpressionPrecedence.BitwiseExclusiveOrExpressionPrecedence = 8;
            ExpressionPrecedence.BitwiseAndExpressionPrecedence = 9;
            ExpressionPrecedence.EqualityExpressionPrecedence = 10;
            ExpressionPrecedence.RelationalExpressionPrecedence = 11;
            ExpressionPrecedence.ShiftExpressionPrecdence = 12;
            ExpressionPrecedence.AdditiveExpressionPrecedence = 13;
            ExpressionPrecedence.MultiplicativeExpressionPrecedence = 14;
            ExpressionPrecedence.UnaryExpressionPrecedence = 15;
        })(ExpressionPrecedence || (ExpressionPrecedence = {}));
        var ListParsingState;
        (function (ListParsingState) {
            ListParsingState._map = [];
            ListParsingState.SourceUnit_ModuleElements = 1 << 0;
            ListParsingState.ClassDeclaration_ClassElements = 1 << 1;
            ListParsingState.ModuleDeclaration_ModuleElements = 1 << 2;
            ListParsingState.SwitchStatement_SwitchClauses = 1 << 3;
            ListParsingState.SwitchClause_Statements = 1 << 4;
            ListParsingState.Block_Statements = 1 << 5;
            ListParsingState.TryBlock_Statements = 1 << 6;
            ListParsingState.CatchBlock_Statements = 1 << 7;
            ListParsingState.EnumDeclaration_EnumElements = 1 << 8;
            ListParsingState.ObjectType_TypeMembers = 1 << 9;
            ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses = 1 << 10;
            ListParsingState.HeritageClause_TypeNameList = 1 << 11;
            ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn = 1 << 12;
            ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn = 1 << 13;
            ListParsingState.ArgumentList_AssignmentExpressions = 1 << 14;
            ListParsingState.ObjectLiteralExpression_PropertyAssignments = 1 << 15;
            ListParsingState.ArrayLiteralExpression_AssignmentExpressions = 1 << 16;
            ListParsingState.ParameterList_Parameters = 1 << 17;
            ListParsingState.TypeArgumentList_Types = 1 << 18;
            ListParsingState.TypeParameterList_TypeParameters = 1 << 19;
            ListParsingState.FirstListParsingState = ListParsingState.SourceUnit_ModuleElements;
            ListParsingState.LastListParsingState = ListParsingState.TypeArgumentList_Types;
        })(ListParsingState || (ListParsingState = {}));
        var SyntaxCursor = (function () {
            function SyntaxCursor(sourceUnit) {
                this._elements = [];
                this._index = 0;
                this._pinCount = 0;
                sourceUnit.insertChildrenInto(this._elements, 0);
            }
            SyntaxCursor.prototype.isFinished = function () {
                return this._index === this._elements.length;
            };
            SyntaxCursor.prototype.currentElement = function () {
                if (this.isFinished()) {
                    return null;
                }
                return this._elements[this._index];
            };
            SyntaxCursor.prototype.currentNode = function () {
                var element = this.currentElement();
                return element !== null && element.isNode() ? element : null;
            };
            SyntaxCursor.prototype.moveToFirstChild = function () {
                if (this.isFinished()) {
                    return;
                }
                var element = this._elements[this._index];
                if (element.isToken()) {
                    return;
                }
                var node = element;
                this._elements.splice(this._index, 1);
                node.insertChildrenInto(this._elements, this._index);
            };
            SyntaxCursor.prototype.moveToNextSibling = function () {
                if (this.isFinished()) {
                    return;
                }
                if (this._pinCount > 0) {
                    this._index++;
                    return;
                }
                this._elements.shift();
            };
            SyntaxCursor.prototype.getAndPinCursorIndex = function () {
                this._pinCount++;
                return this._index;
            };
            SyntaxCursor.prototype.releaseAndUnpinCursorIndex = function (index) {
                this._pinCount--;
                if (this._pinCount === 0) {
                }
            };
            SyntaxCursor.prototype.rewindToPinnedCursorIndex = function (index) {
                this._index = index;
            };
            SyntaxCursor.prototype.pinCount = function () {
                return this._pinCount;
            };
            SyntaxCursor.prototype.moveToFirstToken = function () {
                var element;
                while(!this.isFinished()) {
                    element = this.currentElement();
                    if (element.isNode()) {
                        this.moveToFirstChild();
                        continue;
                    }
                    return;
                }
            };
            SyntaxCursor.prototype.currentToken = function () {
                this.moveToFirstToken();
                if (this.isFinished()) {
                    return null;
                }
                var element = this.currentElement();
                return element;
            };
            SyntaxCursor.prototype.peekToken = function (n) {
                this.moveToFirstToken();
                var pin = this.getAndPinCursorIndex();
                try  {
                    for(var i = 0; i < n; i++) {
                        this.moveToNextSibling();
                        this.moveToFirstToken();
                    }
                    return this.currentToken();
                } finally {
                    this.rewindToPinnedCursorIndex(pin);
                    this.releaseAndUnpinCursorIndex(pin);
                }
            };
            return SyntaxCursor;
        })();        
        var NormalParserSource = (function () {
            function NormalParserSource(fileName, text, languageVersion) {
                this._previousToken = null;
                this._absolutePosition = 0;
                this._tokenDiagnostics = [];
                this.rewindPointPool = [];
                this.rewindPointPoolCount = 0;
                this.slidingWindow = new TypeScript.SlidingWindow(this, TypeScript.ArrayUtilities.createArray(32, null), null);
                this.scanner = new TypeScript.Scanner(fileName, text, languageVersion);
            }
            NormalParserSource.prototype.languageVersion = function () {
                return this.scanner.languageVersion();
            };
            NormalParserSource.prototype.currentNode = function () {
                return null;
            };
            NormalParserSource.prototype.moveToNextNode = function () {
                throw TypeScript.Errors.invalidOperation();
            };
            NormalParserSource.prototype.absolutePosition = function () {
                return this._absolutePosition;
            };
            NormalParserSource.prototype.previousToken = function () {
                return this._previousToken;
            };
            NormalParserSource.prototype.tokenDiagnostics = function () {
                return this._tokenDiagnostics;
            };
            NormalParserSource.prototype.getOrCreateRewindPoint = function () {
                if (this.rewindPointPoolCount === 0) {
                    return {};
                }
                this.rewindPointPoolCount--;
                var result = this.rewindPointPool[this.rewindPointPoolCount];
                this.rewindPointPool[this.rewindPointPoolCount] = null;
                return result;
            };
            NormalParserSource.prototype.getRewindPoint = function () {
                var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();
                var rewindPoint = this.getOrCreateRewindPoint();
                rewindPoint.slidingWindowIndex = slidingWindowIndex;
                rewindPoint.previousToken = this._previousToken;
                rewindPoint.absolutePosition = this._absolutePosition;
                rewindPoint.pinCount = this.slidingWindow.pinCount();
                return rewindPoint;
            };
            NormalParserSource.prototype.isPinned = function () {
                return this.slidingWindow.pinCount() > 0;
            };
            NormalParserSource.prototype.rewind = function (rewindPoint) {
                this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);
                this._previousToken = rewindPoint.previousToken;
                this._absolutePosition = rewindPoint.absolutePosition;
            };
            NormalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex((rewindPoint).absoluteIndex);
                this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
                this.rewindPointPoolCount++;
            };
            NormalParserSource.prototype.fetchMoreItems = function (allowRegularExpression, sourceIndex, window, destinationIndex, spaceAvailable) {
                window[destinationIndex] = this.scanner.scan(this._tokenDiagnostics, allowRegularExpression);
                return 1;
            };
            NormalParserSource.prototype.peekToken = function (n) {
                return this.slidingWindow.peekItemN(n);
            };
            NormalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();
                this._absolutePosition += currentToken.fullWidth();
                this._previousToken = currentToken;
                this.slidingWindow.moveToNextItem();
            };
            NormalParserSource.prototype.currentToken = function () {
                return this.slidingWindow.currentItem(false);
            };
            NormalParserSource.prototype.removeDiagnosticsOnOrAfterPosition = function (position) {
                var tokenDiagnosticsLength = this._tokenDiagnostics.length;
                while(tokenDiagnosticsLength > 0) {
                    var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                    if (diagnostic.start() >= position) {
                        tokenDiagnosticsLength--;
                    } else {
                        break;
                    }
                }
                this._tokenDiagnostics.length = tokenDiagnosticsLength;
            };
            NormalParserSource.prototype.resetToPosition = function (absolutePosition, previousToken) {
                this._absolutePosition = absolutePosition;
                this._previousToken = previousToken;
                this.removeDiagnosticsOnOrAfterPosition(absolutePosition);
                this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();
                this.scanner.setAbsoluteIndex(absolutePosition);
            };
            NormalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                this.resetToPosition(this._absolutePosition, this._previousToken);
                var token = this.slidingWindow.currentItem(true);
                return token;
            };
            return NormalParserSource;
        })();        
        var IncrementalParserSource = (function () {
            function IncrementalParserSource(oldSyntaxTree, textChangeRange, newText) {
                this._changeDelta = 0;
                var oldSourceUnit = oldSyntaxTree.sourceUnit();
                this._oldSourceUnitCursor = new SyntaxCursor(oldSourceUnit);
                this._changeRange = IncrementalParserSource.extendToAffectedRange(textChangeRange, oldSourceUnit);
                this._normalParserSource = new NormalParserSource(oldSyntaxTree.fileName(), newText, oldSyntaxTree.languageVersion());
            }
            IncrementalParserSource.extendToAffectedRange = function extendToAffectedRange(changeRange, sourceUnit) {
                var maxLookahead = 1;
                var start = changeRange.span().start();
                for(var i = 0; start > 0 && i <= maxLookahead; i++) {
                    var token = sourceUnit.findToken(start);
                    var position = token.fullStart();
                    start = TypeScript.MathPrototype.max(0, position - 1);
                }
                var finalSpan = TypeScript.TextSpan.fromBounds(start, changeRange.span().end());
                var finalLength = changeRange.newLength() + (changeRange.span().start() - start);
                return new TypeScript.TextChangeRange(finalSpan, finalLength);
            };
            IncrementalParserSource.prototype.languageVersion = function () {
                return this._normalParserSource.languageVersion();
            };
            IncrementalParserSource.prototype.absolutePosition = function () {
                return this._normalParserSource.absolutePosition();
            };
            IncrementalParserSource.prototype.previousToken = function () {
                return this._normalParserSource.previousToken();
            };
            IncrementalParserSource.prototype.tokenDiagnostics = function () {
                return this._normalParserSource.tokenDiagnostics();
            };
            IncrementalParserSource.prototype.getRewindPoint = function () {
                var rewindPoint = this._normalParserSource.getRewindPoint();
                var oldSourceUnitCursorIndex = this._oldSourceUnitCursor.getAndPinCursorIndex();
                rewindPoint.changeDelta = this._changeDelta;
                rewindPoint.changeRange = this._changeRange;
                rewindPoint.oldSourceUnitCursorIndex = oldSourceUnitCursorIndex;
                return rewindPoint;
            };
            IncrementalParserSource.prototype.rewind = function (rewindPoint) {
                this._changeRange = rewindPoint.changeRange;
                this._changeDelta = rewindPoint.changeDelta;
                this._oldSourceUnitCursor.rewindToPinnedCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
                this._normalParserSource.rewind(rewindPoint);
            };
            IncrementalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this._oldSourceUnitCursor.releaseAndUnpinCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
                this._normalParserSource.releaseRewindPoint(rewindPoint);
            };
            IncrementalParserSource.prototype.canReadFromOldSourceUnit = function () {
                if (this._normalParserSource.isPinned()) {
                    return false;
                }
                if (this._changeRange !== null && this._changeRange.newSpan().intersectsWithPosition(this.absolutePosition())) {
                    return false;
                }
                this.syncCursorToNewTextIfBehind();
                return this._changeDelta === 0 && !this._oldSourceUnitCursor.isFinished();
            };
            IncrementalParserSource.prototype.currentNode = function () {
                if (this.canReadFromOldSourceUnit()) {
                    return this.tryGetNodeFromOldSourceUnit();
                }
                return null;
            };
            IncrementalParserSource.prototype.currentToken = function () {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryGetTokenFromOldSourceUnit();
                    if (token !== null) {
                        return token;
                    }
                }
                return this._normalParserSource.currentToken();
            };
            IncrementalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                return this._normalParserSource.currentTokenAllowingRegularExpression();
            };
            IncrementalParserSource.prototype.syncCursorToNewTextIfBehind = function () {
                while(true) {
                    if (this._oldSourceUnitCursor.isFinished()) {
                        break;
                    }
                    if (this._changeDelta >= 0) {
                        break;
                    }
                    var currentElement = this._oldSourceUnitCursor.currentElement();
                    if (currentElement.isNode() && (currentElement.fullWidth() > Math.abs(this._changeDelta))) {
                        this._oldSourceUnitCursor.moveToFirstChild();
                    } else {
                        this._oldSourceUnitCursor.moveToNextSibling();
                        this._changeDelta += currentElement.fullWidth();
                    }
                }
            };
            IncrementalParserSource.prototype.intersectsWithChangeRangeSpanInOriginalText = function (start, length) {
                return this._changeRange !== null && this._changeRange.span().intersectsWith(start, length);
            };
            IncrementalParserSource.prototype.tryGetNodeFromOldSourceUnit = function () {
                while(true) {
                    var node = this._oldSourceUnitCursor.currentNode();
                    if (node === null) {
                        return null;
                    }
                    if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), node.fullWidth())) {
                        if (!node.isIncrementallyUnusable()) {
                            return node;
                        }
                    }
                    this._oldSourceUnitCursor.moveToFirstChild();
                }
            };
            IncrementalParserSource.prototype.canReuseTokenFromOldSourceUnit = function (position, token) {
                if (token !== null) {
                    if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                        if (!token.isIncrementallyUnusable()) {
                            return true;
                        }
                    }
                }
                return false;
            };
            IncrementalParserSource.prototype.tryGetTokenFromOldSourceUnit = function () {
                var token = this._oldSourceUnitCursor.currentToken();
                return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) ? token : null;
            };
            IncrementalParserSource.prototype.peekToken = function (n) {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryPeekTokenFromOldSourceUnit(n);
                    if (token !== null) {
                        return token;
                    }
                }
                return this._normalParserSource.peekToken(n);
            };
            IncrementalParserSource.prototype.tryPeekTokenFromOldSourceUnit = function (n) {
                var currentPosition = this.absolutePosition();
                for(var i = 0; i < n; i++) {
                    var interimToken = this._oldSourceUnitCursor.peekToken(i);
                    if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                        return null;
                    }
                    currentPosition += interimToken.fullWidth();
                }
                var token = this._oldSourceUnitCursor.peekToken(n);
                return this.canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : null;
            };
            IncrementalParserSource.prototype.moveToNextNode = function () {
                var currentElement = this._oldSourceUnitCursor.currentElement();
                var currentNode = this._oldSourceUnitCursor.currentNode();
                this._oldSourceUnitCursor.moveToNextSibling();
                var absolutePosition = this.absolutePosition() + currentNode.fullWidth();
                var previousToken = currentNode.lastToken();
                this._normalParserSource.resetToPosition(absolutePosition, previousToken);
                if (this._changeRange !== null) {
                }
            };
            IncrementalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();
                if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                    this._oldSourceUnitCursor.moveToNextSibling();
                    var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                    var previousToken = currentToken;
                    this._normalParserSource.resetToPosition(absolutePosition, previousToken);
                    if (this._changeRange !== null) {
                    }
                } else {
                    this._changeDelta -= currentToken.fullWidth();
                    this._normalParserSource.moveToNextToken();
                    if (this._changeRange !== null) {
                        var changeRangeSpanInNewText = this._changeRange.newSpan();
                        if (this.absolutePosition() >= changeRangeSpanInNewText.end()) {
                            this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();
                            this._changeRange = null;
                        }
                    }
                }
            };
            return IncrementalParserSource;
        })();        
        var ParserImpl = (function () {
            function ParserImpl(fileName, lineMap, source, parseOptions) {
                this.listParsingState = 0;
                this.isInStrictMode = false;
                this.diagnostics = [];
                this.factory = TypeScript.Syntax.normalModeFactory;
                this.mergeTokensStorage = [];
                this.arrayPool = [];
                this.fileName = fileName;
                this.lineMap = lineMap;
                this.source = source;
                this.parseOptions = parseOptions;
            }
            ParserImpl.prototype.getRewindPoint = function () {
                var rewindPoint = this.source.getRewindPoint();
                rewindPoint.diagnosticsCount = this.diagnostics.length;
                rewindPoint.isInStrictMode = this.isInStrictMode;
                rewindPoint.listParsingState = this.listParsingState;
                return rewindPoint;
            };
            ParserImpl.prototype.rewind = function (rewindPoint) {
                this.source.rewind(rewindPoint);
                this.diagnostics.length = rewindPoint.diagnosticsCount;
            };
            ParserImpl.prototype.releaseRewindPoint = function (rewindPoint) {
                this.source.releaseRewindPoint(rewindPoint);
            };
            ParserImpl.prototype.currentTokenStart = function () {
                return this.source.absolutePosition() + this.currentToken().leadingTriviaWidth();
            };
            ParserImpl.prototype.previousTokenStart = function () {
                if (this.previousToken() === null) {
                    return 0;
                }
                return this.source.absolutePosition() - this.previousToken().fullWidth() + this.previousToken().leadingTriviaWidth();
            };
            ParserImpl.prototype.previousTokenEnd = function () {
                if (this.previousToken() === null) {
                    return 0;
                }
                return this.previousTokenStart() + this.previousToken().width();
            };
            ParserImpl.prototype.currentNode = function () {
                var node = this.source.currentNode();
                if (node === null || node.parsedInStrictMode() !== this.isInStrictMode) {
                    return null;
                }
                return node;
            };
            ParserImpl.prototype.currentToken = function () {
                return this.source.currentToken();
            };
            ParserImpl.prototype.currentTokenAllowingRegularExpression = function () {
                return this.source.currentTokenAllowingRegularExpression();
            };
            ParserImpl.prototype.peekToken = function (n) {
                return this.source.peekToken(n);
            };
            ParserImpl.prototype.eatAnyToken = function () {
                var token = this.currentToken();
                this.moveToNextToken();
                return token;
            };
            ParserImpl.prototype.moveToNextToken = function () {
                this.source.moveToNextToken();
            };
            ParserImpl.prototype.previousToken = function () {
                return this.source.previousToken();
            };
            ParserImpl.prototype.eatNode = function () {
                var node = this.source.currentNode();
                this.source.moveToNextNode();
                return node;
            };
            ParserImpl.prototype.eatToken = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }
                return this.createMissingToken(kind, token);
            };
            ParserImpl.prototype.tryEatToken = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatToken(kind);
                }
                return null;
            };
            ParserImpl.prototype.tryEatKeyword = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatKeyword(kind);
                }
                return null;
            };
            ParserImpl.prototype.eatKeyword = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }
                return this.createMissingToken(kind, token);
            };
            ParserImpl.prototype.isIdentifier = function (token) {
                var tokenKind = token.tokenKind;
                if (tokenKind === TypeScript.SyntaxKind.IdentifierName) {
                    return true;
                }
                if (tokenKind >= TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword) {
                    if (tokenKind <= TypeScript.SyntaxKind.LastFutureReservedStrictKeyword) {
                        return !this.isInStrictMode;
                    }
                    return tokenKind <= TypeScript.SyntaxKind.LastTypeScriptKeyword;
                }
                return false;
            };
            ParserImpl.prototype.eatIdentifierNameToken = function () {
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.IdentifierName) {
                    this.moveToNextToken();
                    return token;
                }
                if (TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind)) {
                    this.moveToNextToken();
                    return TypeScript.Syntax.convertToIdentifierName(token);
                }
                return this.createMissingToken(TypeScript.SyntaxKind.IdentifierName, token);
            };
            ParserImpl.prototype.eatIdentifierToken = function () {
                var token = this.currentToken();
                if (this.isIdentifier(token)) {
                    this.moveToNextToken();
                    return token;
                }
                return this.createMissingToken(TypeScript.SyntaxKind.IdentifierName, token);
            };
            ParserImpl.prototype.canEatAutomaticSemicolon = function (allowWithoutNewLine) {
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.EndOfFileToken) {
                    return true;
                }
                if (token.tokenKind === TypeScript.SyntaxKind.CloseBraceToken) {
                    return true;
                }
                if (allowWithoutNewLine) {
                    return true;
                }
                if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.canEatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.SemicolonToken) {
                    return true;
                }
                return this.canEatAutomaticSemicolon(allowWithoutNewline);
            };
            ParserImpl.prototype.eatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.SemicolonToken) {
                    return this.eatToken(TypeScript.SyntaxKind.SemicolonToken);
                }
                if (this.canEatAutomaticSemicolon(allowWithoutNewline)) {
                    var semicolonToken = TypeScript.Syntax.emptyToken(TypeScript.SyntaxKind.SemicolonToken);
                    if (!this.parseOptions.allowAutomaticSemicolonInsertion()) {
                        this.addDiagnostic(new TypeScript.SyntaxDiagnostic(this.fileName, this.previousTokenEnd(), 0, TypeScript.DiagnosticCode.Automatic_semicolon_insertion_not_allowed, null));
                    }
                    return semicolonToken;
                }
                return this.eatToken(TypeScript.SyntaxKind.SemicolonToken);
            };
            ParserImpl.prototype.isKeyword = function (kind) {
                if (kind >= TypeScript.SyntaxKind.FirstKeyword) {
                    if (kind <= TypeScript.SyntaxKind.LastFutureReservedKeyword) {
                        return true;
                    }
                    if (this.isInStrictMode) {
                        return kind <= TypeScript.SyntaxKind.LastFutureReservedStrictKeyword;
                    }
                }
                return false;
            };
            ParserImpl.prototype.createMissingToken = function (expectedKind, actual) {
                var diagnostic = this.getExpectedTokenDiagnostic(expectedKind, actual);
                this.addDiagnostic(diagnostic);
                return TypeScript.Syntax.emptyToken(expectedKind);
            };
            ParserImpl.prototype.getExpectedTokenDiagnostic = function (expectedKind, actual) {
                var token = this.currentToken();
                if (TypeScript.SyntaxFacts.isAnyKeyword(expectedKind) || TypeScript.SyntaxFacts.isAnyPunctuation(expectedKind)) {
                    return new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode._0_expected, [
                        TypeScript.SyntaxFacts.getText(expectedKind)
                    ]);
                } else {
                    if (actual !== null && TypeScript.SyntaxFacts.isAnyKeyword(actual.tokenKind)) {
                        return new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Identifier_expected__0__is_a_keyword, [
                            TypeScript.SyntaxFacts.getText(actual.tokenKind)
                        ]);
                    } else {
                        return new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Identifier_expected, null);
                    }
                }
            };
            ParserImpl.getPrecedence = function getPrecedence(expressionKind) {
                switch(expressionKind) {
                    case TypeScript.SyntaxKind.CommaExpression:
                        return ExpressionPrecedence.CommaExpressionPrecedence;
                    case TypeScript.SyntaxKind.AssignmentExpression:
                    case TypeScript.SyntaxKind.AddAssignmentExpression:
                    case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                    case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                    case TypeScript.SyntaxKind.DivideAssignmentExpression:
                    case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                    case TypeScript.SyntaxKind.AndAssignmentExpression:
                    case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                    case TypeScript.SyntaxKind.OrAssignmentExpression:
                    case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                        return ExpressionPrecedence.AssignmentExpressionPrecedence;
                    case TypeScript.SyntaxKind.ConditionalExpression:
                        return ExpressionPrecedence.ConditionalExpressionPrecedence;
                    case TypeScript.SyntaxKind.LogicalOrExpression:
                        return ExpressionPrecedence.LogicalOrExpressionPrecedence;
                    case TypeScript.SyntaxKind.LogicalAndExpression:
                        return ExpressionPrecedence.LogicalAndExpressionPrecedence;
                    case TypeScript.SyntaxKind.BitwiseOrExpression:
                        return ExpressionPrecedence.BitwiseOrExpressionPrecedence;
                    case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                        return ExpressionPrecedence.BitwiseExclusiveOrExpressionPrecedence;
                    case TypeScript.SyntaxKind.BitwiseAndExpression:
                        return ExpressionPrecedence.BitwiseAndExpressionPrecedence;
                    case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                    case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                    case TypeScript.SyntaxKind.EqualsExpression:
                    case TypeScript.SyntaxKind.NotEqualsExpression:
                        return ExpressionPrecedence.EqualityExpressionPrecedence;
                    case TypeScript.SyntaxKind.LessThanExpression:
                    case TypeScript.SyntaxKind.GreaterThanExpression:
                    case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                    case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                    case TypeScript.SyntaxKind.InstanceOfExpression:
                    case TypeScript.SyntaxKind.InExpression:
                        return ExpressionPrecedence.RelationalExpressionPrecedence;
                    case TypeScript.SyntaxKind.LeftShiftExpression:
                    case TypeScript.SyntaxKind.SignedRightShiftExpression:
                    case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                        return ExpressionPrecedence.ShiftExpressionPrecdence;
                    case TypeScript.SyntaxKind.AddExpression:
                    case TypeScript.SyntaxKind.SubtractExpression:
                        return ExpressionPrecedence.AdditiveExpressionPrecedence;
                    case TypeScript.SyntaxKind.MultiplyExpression:
                    case TypeScript.SyntaxKind.DivideExpression:
                    case TypeScript.SyntaxKind.ModuloExpression:
                        return ExpressionPrecedence.MultiplicativeExpressionPrecedence;
                    case TypeScript.SyntaxKind.PlusExpression:
                    case TypeScript.SyntaxKind.NegateExpression:
                    case TypeScript.SyntaxKind.BitwiseNotExpression:
                    case TypeScript.SyntaxKind.LogicalNotExpression:
                    case TypeScript.SyntaxKind.DeleteExpression:
                    case TypeScript.SyntaxKind.TypeOfExpression:
                    case TypeScript.SyntaxKind.VoidExpression:
                    case TypeScript.SyntaxKind.PreIncrementExpression:
                    case TypeScript.SyntaxKind.PreDecrementExpression:
                        return ExpressionPrecedence.UnaryExpressionPrecedence;
                }
                throw TypeScript.Errors.invalidOperation();
            };
            ParserImpl.prototype.addSkippedTokenAfterNodeOrToken = function (nodeOrToken, skippedToken) {
                if (nodeOrToken.isToken()) {
                    return this.addSkippedTokenAfterToken(nodeOrToken, skippedToken);
                } else if (nodeOrToken.isNode()) {
                    return this.addSkippedTokenAfterNode(nodeOrToken, skippedToken);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.addSkippedTokenAfterNode = function (node, skippedToken) {
                var oldToken = node.lastToken();
                var newToken = this.addSkippedTokenAfterToken(oldToken, skippedToken);
                return node.replaceToken(oldToken, newToken);
            };
            ParserImpl.prototype.addSkippedTokensBeforeNode = function (node, skippedTokens) {
                if (skippedTokens.length > 0) {
                    var oldToken = node.firstToken();
                    var newToken = this.addSkippedTokensBeforeToken(oldToken, skippedTokens);
                    return node.replaceToken(oldToken, newToken);
                }
                return node;
            };
            ParserImpl.prototype.addSkippedTokensBeforeToken = function (token, skippedTokens) {
                var leadingTrivia = [];
                for(var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(leadingTrivia, skippedTokens[i]);
                }
                this.addTriviaTo(token.leadingTrivia(), leadingTrivia);
                this.returnArray(skippedTokens);
                return token.withLeadingTrivia(TypeScript.Syntax.triviaList(leadingTrivia));
            };
            ParserImpl.prototype.addSkippedTokensAfterToken = function (token, skippedTokens) {
                if (skippedTokens.length === 0) {
                    this.returnArray(skippedTokens);
                    return token;
                }
                var trailingTrivia = token.trailingTrivia().toArray();
                for(var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
                }
                this.returnArray(skippedTokens);
                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };
            ParserImpl.prototype.addSkippedTokenAfterToken = function (token, skippedToken) {
                var trailingTrivia = token.trailingTrivia().toArray();
                this.addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);
                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };
            ParserImpl.prototype.addSkippedTokenToTriviaArray = function (array, skippedToken) {
                this.addTriviaTo(skippedToken.leadingTrivia(), array);
                array.push(TypeScript.Syntax.trivia(TypeScript.SyntaxKind.SkippedTextTrivia, skippedToken.text()));
                this.addTriviaTo(skippedToken.trailingTrivia(), array);
            };
            ParserImpl.prototype.addTriviaTo = function (list, array) {
                for(var i = 0, n = list.count(); i < n; i++) {
                    array.push(list.syntaxTriviaAt(i));
                }
            };
            ParserImpl.prototype.parseSyntaxTree = function (isDeclaration) {
                var sourceUnit = this.parseSourceUnit();
                var allDiagnostics = this.source.tokenDiagnostics().concat(this.diagnostics);
                allDiagnostics.sort(function (a, b) {
                    return a.start() - b.start();
                });
                return new TypeScript.SyntaxTree(sourceUnit, isDeclaration, allDiagnostics, this.fileName, this.lineMap, this.source.languageVersion(), this.parseOptions);
            };
            ParserImpl.prototype.setStrictMode = function (isInStrictMode) {
                this.isInStrictMode = isInStrictMode;
                this.factory = isInStrictMode ? TypeScript.Syntax.strictModeFactory : TypeScript.Syntax.normalModeFactory;
            };
            ParserImpl.prototype.parseSourceUnit = function () {
                var savedIsInStrictMode = this.isInStrictMode;
                var result = this.parseSyntaxList(ListParsingState.SourceUnit_ModuleElements, ParserImpl.updateStrictModeState);
                var moduleElements = result.list;
                this.setStrictMode(savedIsInStrictMode);
                var sourceUnit = this.factory.sourceUnit(moduleElements, this.currentToken());
                sourceUnit = this.addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);
                return sourceUnit;
            };
            ParserImpl.updateStrictModeState = function updateStrictModeState(parser, items) {
                if (!parser.isInStrictMode) {
                    for(var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (!TypeScript.SyntaxFacts.isDirectivePrologueElement(item)) {
                            return;
                        }
                    }
                    parser.setStrictMode(TypeScript.SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
                }
            };
            ParserImpl.prototype.isModuleElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return true;
                }
                return this.isImportDeclaration() || this.isExportAssignment() || this.isModuleDeclaration() || this.isInterfaceDeclaration() || this.isClassDeclaration() || this.isEnumDeclaration() || this.isStatement(inErrorRecovery);
            };
            ParserImpl.prototype.parseModuleElement = function () {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return this.eatNode();
                }
                if (this.isImportDeclaration()) {
                    return this.parseImportDeclaration();
                } else if (this.isExportAssignment()) {
                    return this.parseExportAssignment();
                } else if (this.isModuleDeclaration()) {
                    return this.parseModuleDeclaration();
                } else if (this.isInterfaceDeclaration()) {
                    return this.parseInterfaceDeclaration();
                } else if (this.isClassDeclaration()) {
                    return this.parseClassDeclaration();
                } else if (this.isEnumDeclaration()) {
                    return this.parseEnumDeclaration();
                } else if (this.isStatement(false)) {
                    return this.parseStatement();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.isImportDeclaration = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ImportKeyword;
            };
            ParserImpl.prototype.parseImportDeclaration = function () {
                var importKeyword = this.eatKeyword(TypeScript.SyntaxKind.ImportKeyword);
                var identifier = this.eatIdentifierToken();
                var equalsToken = this.eatToken(TypeScript.SyntaxKind.EqualsToken);
                var moduleReference = this.parseModuleReference();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.importDeclaration(importKeyword, identifier, equalsToken, moduleReference, semicolonToken);
            };
            ParserImpl.prototype.isExportAssignment = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ExportKeyword && this.peekToken(1).tokenKind === TypeScript.SyntaxKind.EqualsToken;
            };
            ParserImpl.prototype.parseExportAssignment = function () {
                var exportKeyword = this.eatKeyword(TypeScript.SyntaxKind.ExportKeyword);
                var equalsToken = this.eatToken(TypeScript.SyntaxKind.EqualsToken);
                var identifier = this.eatIdentifierToken();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.exportAssignment(exportKeyword, equalsToken, identifier, semicolonToken);
            };
            ParserImpl.prototype.parseModuleReference = function () {
                if (this.isExternalModuleReference()) {
                    return this.parseExternalModuleReference();
                } else {
                    return this.parseModuleNameModuleReference();
                }
            };
            ParserImpl.prototype.isExternalModuleReference = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ModuleKeyword && this.peekToken(1).tokenKind === TypeScript.SyntaxKind.OpenParenToken;
            };
            ParserImpl.prototype.parseExternalModuleReference = function () {
                var moduleKeyword = this.eatKeyword(TypeScript.SyntaxKind.ModuleKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var stringLiteral = this.eatToken(TypeScript.SyntaxKind.StringLiteral);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                return this.factory.externalModuleReference(moduleKeyword, openParenToken, stringLiteral, closeParenToken);
            };
            ParserImpl.prototype.parseModuleNameModuleReference = function () {
                var name = this.parseName();
                return this.factory.moduleNameModuleReference(name);
            };
            ParserImpl.prototype.parseIdentifierName = function () {
                var identifierName = this.eatIdentifierNameToken();
                return identifierName;
            };
            ParserImpl.prototype.isName = function () {
                return this.isIdentifier(this.currentToken());
            };
            ParserImpl.prototype.tryParseTypeArgumentList = function (inExpression) {
                if (this.currentToken().kind() !== TypeScript.SyntaxKind.LessThanToken) {
                    return null;
                }
                var lessThanToken;
                var greaterThanToken;
                var result;
                var typeArguments;
                if (!inExpression) {
                    lessThanToken = this.eatToken(TypeScript.SyntaxKind.LessThanToken);
                    result = this.parseSeparatedSyntaxList(ListParsingState.TypeArgumentList_Types);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);
                    greaterThanToken = this.eatToken(TypeScript.SyntaxKind.GreaterThanToken);
                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                }
                var rewindPoint = this.getRewindPoint();
                try  {
                    lessThanToken = this.eatToken(TypeScript.SyntaxKind.LessThanToken);
                    result = this.parseSeparatedSyntaxList(ListParsingState.TypeArgumentList_Types);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);
                    greaterThanToken = this.eatToken(TypeScript.SyntaxKind.GreaterThanToken);
                    if (greaterThanToken.fullWidth() === 0 || !this.canFollowTypeArgumentListInExpression(this.currentToken().kind())) {
                        this.rewind(rewindPoint);
                        return null;
                    }
                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };
            ParserImpl.prototype.canFollowTypeArgumentListInExpression = function (kind) {
                switch(kind) {
                    case TypeScript.SyntaxKind.OpenParenToken:
                    case TypeScript.SyntaxKind.DotToken:
                    case TypeScript.SyntaxKind.CloseParenToken:
                    case TypeScript.SyntaxKind.CloseBracketToken:
                    case TypeScript.SyntaxKind.ColonToken:
                    case TypeScript.SyntaxKind.SemicolonToken:
                    case TypeScript.SyntaxKind.CommaToken:
                    case TypeScript.SyntaxKind.QuestionToken:
                    case TypeScript.SyntaxKind.EqualsEqualsToken:
                    case TypeScript.SyntaxKind.EqualsEqualsEqualsToken:
                    case TypeScript.SyntaxKind.ExclamationEqualsToken:
                    case TypeScript.SyntaxKind.ExclamationEqualsEqualsToken:
                    case TypeScript.SyntaxKind.AmpersandAmpersandToken:
                    case TypeScript.SyntaxKind.BarBarToken:
                    case TypeScript.SyntaxKind.CaretToken:
                    case TypeScript.SyntaxKind.AmpersandToken:
                    case TypeScript.SyntaxKind.BarToken:
                    case TypeScript.SyntaxKind.CloseBraceToken:
                    case TypeScript.SyntaxKind.EndOfFileToken:
                        return true;
                    default:
                        return false;
                }
            };
            ParserImpl.prototype.parseName = function () {
                var shouldContinue = this.isIdentifier(this.currentToken());
                var current = this.eatIdentifierToken();
                while(shouldContinue && this.currentToken().tokenKind === TypeScript.SyntaxKind.DotToken) {
                    var dotToken = this.eatToken(TypeScript.SyntaxKind.DotToken);
                    var currentToken = this.currentToken();
                    var identifierName;
                    if (TypeScript.SyntaxFacts.isAnyKeyword(currentToken.tokenKind) && this.previousToken().hasTrailingNewLine() && !currentToken.hasTrailingNewLine() && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.peekToken(1))) {
                        identifierName = this.createMissingToken(TypeScript.SyntaxKind.IdentifierName, currentToken);
                    } else {
                        identifierName = this.eatIdentifierNameToken();
                    }
                    current = this.factory.qualifiedName(current, dotToken, identifierName);
                    shouldContinue = identifierName.fullWidth() > 0;
                }
                return current;
            };
            ParserImpl.prototype.isEnumDeclaration = function () {
                var index = this.modifierCount();
                if (index > 0 && this.peekToken(index).tokenKind === TypeScript.SyntaxKind.EnumKeyword) {
                    return true;
                }
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.EnumKeyword && this.isIdentifier(this.peekToken(1));
            };
            ParserImpl.prototype.parseEnumDeclaration = function () {
                var modifiers = this.parseModifiers();
                var enumKeyword = this.eatKeyword(TypeScript.SyntaxKind.EnumKeyword);
                var identifier = this.eatIdentifierToken();
                var openBraceToken = this.eatToken(TypeScript.SyntaxKind.OpenBraceToken);
                var enumElements = TypeScript.Syntax.emptySeparatedList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(ListParsingState.EnumDeclaration_EnumElements);
                    enumElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }
                var closeBraceToken = this.eatToken(TypeScript.SyntaxKind.CloseBraceToken);
                return this.factory.enumDeclaration(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken);
            };
            ParserImpl.prototype.isEnumElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().kind() === TypeScript.SyntaxKind.EnumElement) {
                    return true;
                }
                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };
            ParserImpl.prototype.parseEnumElement = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === TypeScript.SyntaxKind.EnumElement) {
                    return this.eatNode();
                }
                var propertyName = this.eatPropertyName();
                var equalsValueClause = null;
                if (this.isEqualsValueClause(false)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }
                return this.factory.enumElement(propertyName, equalsValueClause);
            };
            ParserImpl.isModifier = function isModifier(token) {
                switch(token.tokenKind) {
                    case TypeScript.SyntaxKind.PublicKeyword:
                    case TypeScript.SyntaxKind.PrivateKeyword:
                    case TypeScript.SyntaxKind.StaticKeyword:
                    case TypeScript.SyntaxKind.ExportKeyword:
                    case TypeScript.SyntaxKind.DeclareKeyword:
                        return true;
                    default:
                        return false;
                }
            };
            ParserImpl.prototype.modifierCount = function () {
                var modifierCount = 0;
                while(true) {
                    if (ParserImpl.isModifier(this.peekToken(modifierCount))) {
                        modifierCount++;
                        continue;
                    }
                    break;
                }
                return modifierCount;
            };
            ParserImpl.prototype.parseModifiers = function () {
                var tokens = this.getArray();
                while(true) {
                    if (ParserImpl.isModifier(this.currentToken())) {
                        tokens.push(this.eatAnyToken());
                        continue;
                    }
                    break;
                }
                var result = TypeScript.Syntax.list(tokens);
                this.returnZeroOrOneLengthArray(tokens);
                return result;
            };
            ParserImpl.prototype.isClassDeclaration = function () {
                var index = this.modifierCount();
                if (index > 0 && this.peekToken(index).tokenKind === TypeScript.SyntaxKind.ClassKeyword) {
                    return true;
                }
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ClassKeyword && this.isIdentifier(this.peekToken(1));
            };
            ParserImpl.prototype.parseHeritageClauses = function () {
                var heritageClauses = TypeScript.Syntax.emptyList;
                if (this.isHeritageClause()) {
                    var result = this.parseSyntaxList(ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses);
                    heritageClauses = result.list;
                    TypeScript.Debug.assert(result.skippedTokens.length === 0);
                }
                return heritageClauses;
            };
            ParserImpl.prototype.parseClassDeclaration = function () {
                var modifiers = this.parseModifiers();
                var classKeyword = this.eatKeyword(TypeScript.SyntaxKind.ClassKeyword);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();
                var openBraceToken = this.eatToken(TypeScript.SyntaxKind.OpenBraceToken);
                var classElements = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(ListParsingState.ClassDeclaration_ClassElements);
                    classElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }
                var closeBraceToken = this.eatToken(TypeScript.SyntaxKind.CloseBraceToken);
                return this.factory.classDeclaration(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken);
            };
            ParserImpl.prototype.isConstructorDeclaration = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ConstructorKeyword;
            };
            ParserImpl.isPublicOrPrivateKeyword = function isPublicOrPrivateKeyword(token) {
                return token.tokenKind === TypeScript.SyntaxKind.PublicKeyword || token.tokenKind === TypeScript.SyntaxKind.PrivateKeyword;
            };
            ParserImpl.prototype.isMemberAccessorDeclaration = function (inErrorRecovery) {
                var index = this.modifierCount();
                if (this.peekToken(index).tokenKind !== TypeScript.SyntaxKind.GetKeyword && this.peekToken(index).tokenKind !== TypeScript.SyntaxKind.SetKeyword) {
                    return false;
                }
                index++;
                return this.isPropertyName(this.peekToken(index), inErrorRecovery);
            };
            ParserImpl.prototype.parseMemberAccessorDeclaration = function () {
                var modifiers = this.parseModifiers();
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.GetKeyword) {
                    return this.parseGetMemberAccessorDeclaration(modifiers);
                } else if (this.currentToken().tokenKind === TypeScript.SyntaxKind.SetKeyword) {
                    return this.parseSetMemberAccessorDeclaration(modifiers);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.parseGetMemberAccessorDeclaration = function (modifiers) {
                var getKeyword = this.eatKeyword(TypeScript.SyntaxKind.GetKeyword);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, false);
                return this.factory.getMemberAccessorDeclaration(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block);
            };
            ParserImpl.prototype.parseSetMemberAccessorDeclaration = function (modifiers) {
                var setKeyword = this.eatKeyword(TypeScript.SyntaxKind.SetKeyword);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var block = this.parseBlock(false, false);
                return this.factory.setMemberAccessorDeclaration(modifiers, setKeyword, propertyName, parameterList, block);
            };
            ParserImpl.prototype.isClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return true;
                }
                return this.isConstructorDeclaration() || this.isMemberFunctionDeclaration(inErrorRecovery) || this.isMemberAccessorDeclaration(inErrorRecovery) || this.isMemberVariableDeclaration(inErrorRecovery);
            };
            ParserImpl.prototype.parseConstructorDeclaration = function () {
                var constructorKeyword = this.eatKeyword(TypeScript.SyntaxKind.ConstructorKeyword);
                var parameterList = this.parseParameterList();
                var semicolonToken = null;
                var block = null;
                if (this.isBlock()) {
                    block = this.parseBlock(false, false);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }
                return this.factory.constructorDeclaration(constructorKeyword, parameterList, block, semicolonToken);
            };
            ParserImpl.prototype.isMemberFunctionDeclaration = function (inErrorRecovery) {
                var index = 0;
                while(true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isCallSignature(index + 1)) {
                        return true;
                    }
                    if (ParserImpl.isModifier(token)) {
                        index++;
                        continue;
                    }
                    return false;
                }
            };
            ParserImpl.prototype.parseMemberFunctionDeclaration = function () {
                var modifierArray = this.getArray();
                while(true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isCallSignature(1)) {
                        break;
                    }
                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }
                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);
                var propertyName = this.eatPropertyName();
                var callSignature = this.parseCallSignature(false);
                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
                callSignature = newCallSignature;
                var block = null;
                var semicolon = null;
                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, false);
                } else {
                    semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                }
                return this.factory.memberFunctionDeclaration(modifiers, propertyName, callSignature, block, semicolon);
            };
            ParserImpl.prototype.isDefinitelyMemberVariablePropertyName = function (index) {
                if (TypeScript.SyntaxFacts.isAnyKeyword(this.peekToken(index).tokenKind)) {
                    switch(this.peekToken(index + 1).tokenKind) {
                        case TypeScript.SyntaxKind.SemicolonToken:
                        case TypeScript.SyntaxKind.EqualsToken:
                        case TypeScript.SyntaxKind.ColonToken:
                        case TypeScript.SyntaxKind.CloseBraceToken:
                        case TypeScript.SyntaxKind.EndOfFileToken:
                            return true;
                        default:
                            return false;
                    }
                } else {
                    return true;
                }
            };
            ParserImpl.prototype.isMemberVariableDeclaration = function (inErrorRecovery) {
                var index = 0;
                while(true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isDefinitelyMemberVariablePropertyName(index)) {
                        return true;
                    }
                    if (ParserImpl.isModifier(this.peekToken(index))) {
                        index++;
                        continue;
                    }
                    return false;
                }
            };
            ParserImpl.prototype.parseMemberVariableDeclaration = function () {
                var modifierArray = this.getArray();
                while(true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isDefinitelyMemberVariablePropertyName(0)) {
                        break;
                    }
                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }
                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);
                var variableDeclarator = this.parseVariableDeclarator(true, true);
                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.memberVariableDeclaration(modifiers, variableDeclarator, semicolon);
            };
            ParserImpl.prototype.parseClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return this.eatNode();
                }
                if (this.isConstructorDeclaration()) {
                    return this.parseConstructorDeclaration();
                } else if (this.isMemberFunctionDeclaration(inErrorRecovery)) {
                    return this.parseMemberFunctionDeclaration();
                } else if (this.isMemberAccessorDeclaration(inErrorRecovery)) {
                    return this.parseMemberAccessorDeclaration();
                } else if (this.isMemberVariableDeclaration(inErrorRecovery)) {
                    return this.parseMemberVariableDeclaration();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.tryAddUnexpectedEqualsGreaterThanToken = function (callSignature) {
                var token0 = this.currentToken();
                var hasEqualsGreaterThanToken = token0.tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken;
                if (hasEqualsGreaterThanToken) {
                    var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token0.width(), TypeScript.DiagnosticCode.Unexpected_token_, []);
                    this.addDiagnostic(diagnostic);
                    var token = this.eatAnyToken();
                    return this.addSkippedTokenAfterNode(callSignature, token0);
                }
                return callSignature;
            };
            ParserImpl.prototype.isFunctionDeclaration = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === TypeScript.SyntaxKind.FunctionKeyword;
            };
            ParserImpl.prototype.parseFunctionDeclaration = function () {
                var modifiers = this.parseModifiers();
                var functionKeyword = this.eatKeyword(TypeScript.SyntaxKind.FunctionKeyword);
                var identifier = this.eatIdentifierToken();
                var callSignature = this.parseCallSignature(false);
                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
                callSignature = newCallSignature;
                var semicolonToken = null;
                var block = null;
                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }
                return this.factory.functionDeclaration(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
            };
            ParserImpl.prototype.isModuleDeclaration = function () {
                var index = this.modifierCount();
                if (index > 0 && this.peekToken(index).tokenKind === TypeScript.SyntaxKind.ModuleKeyword) {
                    return true;
                }
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.ModuleKeyword) {
                    var token1 = this.peekToken(1);
                    return this.isIdentifier(token1) || token1.tokenKind === TypeScript.SyntaxKind.StringLiteral;
                }
                return false;
            };
            ParserImpl.prototype.parseModuleDeclaration = function () {
                var modifiers = this.parseModifiers();
                var moduleKeyword = this.eatKeyword(TypeScript.SyntaxKind.ModuleKeyword);
                var moduleName = null;
                var stringLiteral = null;
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.StringLiteral) {
                    stringLiteral = this.eatToken(TypeScript.SyntaxKind.StringLiteral);
                } else {
                    moduleName = this.parseName();
                }
                var openBraceToken = this.eatToken(TypeScript.SyntaxKind.OpenBraceToken);
                var moduleElements = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(ListParsingState.ModuleDeclaration_ModuleElements);
                    moduleElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }
                var closeBraceToken = this.eatToken(TypeScript.SyntaxKind.CloseBraceToken);
                return this.factory.moduleDeclaration(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken);
            };
            ParserImpl.prototype.isInterfaceDeclaration = function () {
                var index = this.modifierCount();
                if (index > 0 && this.peekToken(index).tokenKind === TypeScript.SyntaxKind.InterfaceKeyword) {
                    return true;
                }
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.InterfaceKeyword && this.isIdentifier(this.peekToken(1));
            };
            ParserImpl.prototype.parseInterfaceDeclaration = function () {
                var modifiers = this.parseModifiers();
                var interfaceKeyword = this.eatKeyword(TypeScript.SyntaxKind.InterfaceKeyword);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();
                var objectType = this.parseObjectType();
                return this.factory.interfaceDeclaration(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, objectType);
            };
            ParserImpl.prototype.parseObjectType = function () {
                var openBraceToken = this.eatToken(TypeScript.SyntaxKind.OpenBraceToken);
                var typeMembers = TypeScript.Syntax.emptySeparatedList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(ListParsingState.ObjectType_TypeMembers);
                    typeMembers = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }
                var closeBraceToken = this.eatToken(TypeScript.SyntaxKind.CloseBraceToken);
                return this.factory.objectType(openBraceToken, typeMembers, closeBraceToken);
            };
            ParserImpl.prototype.isTypeMember = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return true;
                }
                return this.isCallSignature(0) || this.isConstructSignature() || this.isIndexSignature() || this.isMethodSignature(inErrorRecovery) || this.isPropertySignature(inErrorRecovery);
            };
            ParserImpl.prototype.parseTypeMember = function () {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return this.eatNode();
                }
                if (this.isCallSignature(0)) {
                    return this.parseCallSignature(false);
                } else if (this.isConstructSignature()) {
                    return this.parseConstructSignature();
                } else if (this.isIndexSignature()) {
                    return this.parseIndexSignature();
                } else if (this.isMethodSignature(false)) {
                    return this.parseMethodSignature();
                } else if (this.isPropertySignature(false)) {
                    return this.parsePropertySignature();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.parseConstructSignature = function () {
                var newKeyword = this.eatKeyword(TypeScript.SyntaxKind.NewKeyword);
                var callSignature = this.parseCallSignature(false);
                return this.factory.constructSignature(newKeyword, callSignature);
            };
            ParserImpl.prototype.parseIndexSignature = function () {
                var openBracketToken = this.eatToken(TypeScript.SyntaxKind.OpenBracketToken);
                var parameter = this.parseParameter();
                var closeBracketToken = this.eatToken(TypeScript.SyntaxKind.CloseBracketToken);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                return this.factory.indexSignature(openBracketToken, parameter, closeBracketToken, typeAnnotation);
            };
            ParserImpl.prototype.parseMethodSignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(TypeScript.SyntaxKind.QuestionToken);
                var callSignature = this.parseCallSignature(false);
                return this.factory.methodSignature(propertyName, questionToken, callSignature);
            };
            ParserImpl.prototype.parsePropertySignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(TypeScript.SyntaxKind.QuestionToken);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                return this.factory.propertySignature(propertyName, questionToken, typeAnnotation);
            };
            ParserImpl.prototype.isCallSignature = function (tokenIndex) {
                var tokenKind = this.peekToken(tokenIndex).tokenKind;
                return tokenKind === TypeScript.SyntaxKind.OpenParenToken || tokenKind === TypeScript.SyntaxKind.LessThanToken;
            };
            ParserImpl.prototype.isConstructSignature = function () {
                if (this.currentToken().tokenKind !== TypeScript.SyntaxKind.NewKeyword) {
                    return false;
                }
                var token1 = this.peekToken(1);
                return token1.tokenKind === TypeScript.SyntaxKind.LessThanToken || token1.tokenKind === TypeScript.SyntaxKind.OpenParenToken;
            };
            ParserImpl.prototype.isIndexSignature = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.OpenBracketToken;
            };
            ParserImpl.prototype.isMethodSignature = function (inErrorRecovery) {
                if (this.isPropertyName(this.currentToken(), inErrorRecovery)) {
                    if (this.isCallSignature(1)) {
                        return true;
                    }
                    if (this.peekToken(1).tokenKind === TypeScript.SyntaxKind.QuestionToken && this.isCallSignature(2)) {
                        return true;
                    }
                }
                return false;
            };
            ParserImpl.prototype.isPropertySignature = function (inErrorRecovery) {
                var currentToken = this.currentToken();
                if (ParserImpl.isModifier(currentToken) && !currentToken.hasTrailingNewLine() && this.isPropertyName(this.peekToken(1), inErrorRecovery)) {
                    return false;
                }
                return this.isPropertyName(currentToken, inErrorRecovery);
            };
            ParserImpl.prototype.isHeritageClause = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword || token0.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword;
            };
            ParserImpl.prototype.isNotHeritageClauseTypeName = function () {
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.ImplementsKeyword || this.currentToken().tokenKind === TypeScript.SyntaxKind.ExtendsKeyword) {
                    return this.isIdentifier(this.peekToken(1));
                }
                return false;
            };
            ParserImpl.prototype.isHeritageClauseTypeName = function () {
                if (this.isName()) {
                    return !this.isNotHeritageClauseTypeName();
                }
                return false;
            };
            ParserImpl.prototype.parseHeritageClause = function () {
                var extendsOrImplementsKeyword = this.eatAnyToken();
                TypeScript.Debug.assert(extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword || extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword);
                var result = this.parseSeparatedSyntaxList(ListParsingState.HeritageClause_TypeNameList);
                var typeNames = result.list;
                extendsOrImplementsKeyword = this.addSkippedTokensAfterToken(extendsOrImplementsKeyword, result.skippedTokens);
                return this.factory.heritageClause(extendsOrImplementsKeyword, typeNames);
            };
            ParserImpl.prototype.isStatement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return true;
                }
                switch(this.currentToken().tokenKind) {
                    case TypeScript.SyntaxKind.PublicKeyword:
                    case TypeScript.SyntaxKind.PrivateKeyword:
                    case TypeScript.SyntaxKind.StaticKeyword:
                        if (this.isClassElement(inErrorRecovery)) {
                            return false;
                        }
                }
                return this.isVariableStatement() || this.isLabeledStatement() || this.isFunctionDeclaration() || this.isIfStatement() || this.isBlock() || this.isExpressionStatement() || this.isReturnStatement() || this.isSwitchStatement() || this.isThrowStatement() || this.isBreakStatement() || this.isContinueStatement() || this.isForOrForInStatement() || this.isEmptyStatement(inErrorRecovery) || this.isWhileStatement() || this.isWithStatement() || this.isDoStatement() || this.isTryStatement() || this.isDebuggerStatement();
            };
            ParserImpl.prototype.parseStatement = function () {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return this.eatNode();
                }
                if (this.isVariableStatement()) {
                    return this.parseVariableStatement();
                } else if (this.isLabeledStatement()) {
                    return this.parseLabeledStatement();
                } else if (this.isFunctionDeclaration()) {
                    return this.parseFunctionDeclaration();
                } else if (this.isIfStatement()) {
                    return this.parseIfStatement();
                } else if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else if (this.isReturnStatement()) {
                    return this.parseReturnStatement();
                } else if (this.isSwitchStatement()) {
                    return this.parseSwitchStatement();
                } else if (this.isThrowStatement()) {
                    return this.parseThrowStatement();
                } else if (this.isBreakStatement()) {
                    return this.parseBreakStatement();
                } else if (this.isContinueStatement()) {
                    return this.parseContinueStatement();
                } else if (this.isForOrForInStatement()) {
                    return this.parseForOrForInStatement();
                } else if (this.isEmptyStatement(false)) {
                    return this.parseEmptyStatement();
                } else if (this.isWhileStatement()) {
                    return this.parseWhileStatement();
                } else if (this.isWithStatement()) {
                    return this.parseWithStatement();
                } else if (this.isDoStatement()) {
                    return this.parseDoStatement();
                } else if (this.isTryStatement()) {
                    return this.parseTryStatement();
                } else if (this.isDebuggerStatement()) {
                    return this.parseDebuggerStatement();
                } else {
                    return this.parseExpressionStatement();
                }
            };
            ParserImpl.prototype.isDebuggerStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.DebuggerKeyword;
            };
            ParserImpl.prototype.parseDebuggerStatement = function () {
                var debuggerKeyword = this.eatKeyword(TypeScript.SyntaxKind.DebuggerKeyword);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.debuggerStatement(debuggerKeyword, semicolonToken);
            };
            ParserImpl.prototype.isDoStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.DoKeyword;
            };
            ParserImpl.prototype.parseDoStatement = function () {
                var doKeyword = this.eatKeyword(TypeScript.SyntaxKind.DoKeyword);
                var statement = this.parseStatement();
                var whileKeyword = this.eatKeyword(TypeScript.SyntaxKind.WhileKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(true);
                return this.factory.doStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            };
            ParserImpl.prototype.isLabeledStatement = function () {
                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === TypeScript.SyntaxKind.ColonToken;
            };
            ParserImpl.prototype.parseLabeledStatement = function () {
                var identifier = this.eatIdentifierToken();
                var colonToken = this.eatToken(TypeScript.SyntaxKind.ColonToken);
                var statement = this.parseStatement();
                return this.factory.labeledStatement(identifier, colonToken, statement);
            };
            ParserImpl.prototype.isTryStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.TryKeyword;
            };
            ParserImpl.prototype.parseTryStatement = function () {
                var tryKeyword = this.eatKeyword(TypeScript.SyntaxKind.TryKeyword);
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= ListParsingState.TryBlock_Statements;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;
                var catchClause = null;
                if (this.isCatchClause()) {
                    catchClause = this.parseCatchClause();
                }
                var finallyClause = null;
                if (catchClause === null || this.isFinallyClause()) {
                    finallyClause = this.parseFinallyClause();
                }
                return this.factory.tryStatement(tryKeyword, block, catchClause, finallyClause);
            };
            ParserImpl.prototype.isCatchClause = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CatchKeyword;
            };
            ParserImpl.prototype.parseCatchClause = function () {
                var catchKeyword = this.eatKeyword(TypeScript.SyntaxKind.CatchKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var identifier = this.eatIdentifierToken();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= ListParsingState.CatchBlock_Statements;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;
                return this.factory.catchClause(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block);
            };
            ParserImpl.prototype.isFinallyClause = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.FinallyKeyword;
            };
            ParserImpl.prototype.parseFinallyClause = function () {
                var finallyKeyword = this.eatKeyword(TypeScript.SyntaxKind.FinallyKeyword);
                var block = this.parseBlock(false, false);
                return this.factory.finallyClause(finallyKeyword, block);
            };
            ParserImpl.prototype.isWithStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.WithKeyword;
            };
            ParserImpl.prototype.parseWithStatement = function () {
                var withKeyword = this.eatKeyword(TypeScript.SyntaxKind.WithKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var statement = this.parseStatement();
                return this.factory.withStatement(withKeyword, openParenToken, condition, closeParenToken, statement);
            };
            ParserImpl.prototype.isWhileStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.WhileKeyword;
            };
            ParserImpl.prototype.parseWhileStatement = function () {
                var whileKeyword = this.eatKeyword(TypeScript.SyntaxKind.WhileKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var statement = this.parseStatement();
                return this.factory.whileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            };
            ParserImpl.prototype.isEmptyStatement = function (inErrorRecovery) {
                if (inErrorRecovery) {
                    return false;
                }
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.SemicolonToken;
            };
            ParserImpl.prototype.parseEmptyStatement = function () {
                var semicolonToken = this.eatToken(TypeScript.SyntaxKind.SemicolonToken);
                return this.factory.emptyStatement(semicolonToken);
            };
            ParserImpl.prototype.isForOrForInStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ForKeyword;
            };
            ParserImpl.prototype.parseForOrForInStatement = function () {
                var forKeyword = this.eatKeyword(TypeScript.SyntaxKind.ForKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var currentToken = this.currentToken();
                if (currentToken.tokenKind === TypeScript.SyntaxKind.VarKeyword) {
                    return this.parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
                } else if (currentToken.tokenKind === TypeScript.SyntaxKind.SemicolonToken) {
                    return this.parseForStatement(forKeyword, openParenToken);
                } else {
                    return this.parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
                }
            };
            ParserImpl.prototype.parseForOrForInStatementWithVariableDeclaration = function (forKeyword, openParenToken) {
                var variableDeclaration = this.parseVariableDeclaration(false);
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.InKeyword) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
                }
                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            };
            ParserImpl.prototype.parseForInStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var inKeyword = this.eatKeyword(TypeScript.SyntaxKind.InKeyword);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var statement = this.parseStatement();
                return this.factory.forInStatement(forKeyword, openParenToken, variableDeclaration, initializer, inKeyword, expression, closeParenToken, statement);
            };
            ParserImpl.prototype.parseForOrForInStatementWithInitializer = function (forKeyword, openParenToken) {
                var initializer = this.parseExpression(false);
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.InKeyword) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                } else {
                    return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                }
            };
            ParserImpl.prototype.parseForStatement = function (forKeyword, openParenToken) {
                var initializer = null;
                if (this.currentToken().tokenKind !== TypeScript.SyntaxKind.SemicolonToken && this.currentToken().tokenKind !== TypeScript.SyntaxKind.CloseParenToken && this.currentToken().tokenKind !== TypeScript.SyntaxKind.EndOfFileToken) {
                    initializer = this.parseExpression(false);
                }
                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            };
            ParserImpl.prototype.parseForStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var firstSemicolonToken = this.eatToken(TypeScript.SyntaxKind.SemicolonToken);
                var condition = null;
                if (this.currentToken().tokenKind !== TypeScript.SyntaxKind.SemicolonToken && this.currentToken().tokenKind !== TypeScript.SyntaxKind.CloseParenToken && this.currentToken().tokenKind !== TypeScript.SyntaxKind.EndOfFileToken) {
                    condition = this.parseExpression(true);
                }
                var secondSemicolonToken = this.eatToken(TypeScript.SyntaxKind.SemicolonToken);
                var incrementor = null;
                if (this.currentToken().tokenKind !== TypeScript.SyntaxKind.CloseParenToken && this.currentToken().tokenKind !== TypeScript.SyntaxKind.EndOfFileToken) {
                    incrementor = this.parseExpression(true);
                }
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var statement = this.parseStatement();
                return this.factory.forStatement(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement);
            };
            ParserImpl.prototype.isBreakStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.BreakKeyword;
            };
            ParserImpl.prototype.parseBreakStatement = function () {
                var breakKeyword = this.eatKeyword(TypeScript.SyntaxKind.BreakKeyword);
                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }
                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.breakStatement(breakKeyword, identifier, semicolon);
            };
            ParserImpl.prototype.isContinueStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ContinueKeyword;
            };
            ParserImpl.prototype.parseContinueStatement = function () {
                var continueKeyword = this.eatKeyword(TypeScript.SyntaxKind.ContinueKeyword);
                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }
                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.continueStatement(continueKeyword, identifier, semicolon);
            };
            ParserImpl.prototype.isSwitchStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.SwitchKeyword;
            };
            ParserImpl.prototype.parseSwitchStatement = function () {
                var switchKeyword = this.eatKeyword(TypeScript.SyntaxKind.SwitchKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var openBraceToken = this.eatToken(TypeScript.SyntaxKind.OpenBraceToken);
                var switchClauses = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(ListParsingState.SwitchStatement_SwitchClauses);
                    switchClauses = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }
                var closeBraceToken = this.eatToken(TypeScript.SyntaxKind.CloseBraceToken);
                return this.factory.switchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken);
            };
            ParserImpl.prototype.isCaseSwitchClause = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CaseKeyword;
            };
            ParserImpl.prototype.isDefaultSwitchClause = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.DefaultKeyword;
            };
            ParserImpl.prototype.isSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return true;
                }
                return this.isCaseSwitchClause() || this.isDefaultSwitchClause();
            };
            ParserImpl.prototype.parseSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return this.eatNode();
                }
                if (this.isCaseSwitchClause()) {
                    return this.parseCaseSwitchClause();
                } else if (this.isDefaultSwitchClause()) {
                    return this.parseDefaultSwitchClause();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.parseCaseSwitchClause = function () {
                var caseKeyword = this.eatKeyword(TypeScript.SyntaxKind.CaseKeyword);
                var expression = this.parseExpression(true);
                var colonToken = this.eatToken(TypeScript.SyntaxKind.ColonToken);
                var statements = TypeScript.Syntax.emptyList;
                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(ListParsingState.SwitchClause_Statements);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }
                return this.factory.caseSwitchClause(caseKeyword, expression, colonToken, statements);
            };
            ParserImpl.prototype.parseDefaultSwitchClause = function () {
                var defaultKeyword = this.eatKeyword(TypeScript.SyntaxKind.DefaultKeyword);
                var colonToken = this.eatToken(TypeScript.SyntaxKind.ColonToken);
                var statements = TypeScript.Syntax.emptyList;
                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(ListParsingState.SwitchClause_Statements);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }
                return this.factory.defaultSwitchClause(defaultKeyword, colonToken, statements);
            };
            ParserImpl.prototype.isThrowStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ThrowKeyword;
            };
            ParserImpl.prototype.parseThrowStatement = function () {
                var throwKeyword = this.eatKeyword(TypeScript.SyntaxKind.ThrowKeyword);
                var expression = null;
                if (this.canEatExplicitOrAutomaticSemicolon(false)) {
                    var token = this.createMissingToken(TypeScript.SyntaxKind.IdentifierName, null);
                    expression = token;
                } else {
                    expression = this.parseExpression(true);
                }
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.throwStatement(throwKeyword, expression, semicolonToken);
            };
            ParserImpl.prototype.isReturnStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ReturnKeyword;
            };
            ParserImpl.prototype.parseReturnStatement = function () {
                var returnKeyword = this.eatKeyword(TypeScript.SyntaxKind.ReturnKeyword);
                var expression = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    expression = this.parseExpression(true);
                }
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.returnStatement(returnKeyword, expression, semicolonToken);
            };
            ParserImpl.prototype.isExpressionStatement = function () {
                var currentToken = this.currentToken();
                var kind = currentToken.tokenKind;
                if (kind === TypeScript.SyntaxKind.OpenBraceToken || kind === TypeScript.SyntaxKind.FunctionKeyword) {
                    return false;
                }
                return this.isExpression();
            };
            ParserImpl.prototype.isAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.CommaToken) {
                    return true;
                }
                return this.isExpression();
            };
            ParserImpl.prototype.parseAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.CommaToken) {
                    return this.factory.omittedExpression();
                }
                return this.parseAssignmentExpression(true);
            };
            ParserImpl.prototype.isExpression = function () {
                var currentToken = this.currentToken();
                var kind = currentToken.tokenKind;
                switch(kind) {
                    case TypeScript.SyntaxKind.NumericLiteral:
                    case TypeScript.SyntaxKind.StringLiteral:
                    case TypeScript.SyntaxKind.RegularExpressionLiteral:
                        return true;
                    case TypeScript.SyntaxKind.OpenBracketToken:
                    case TypeScript.SyntaxKind.OpenParenToken:
                        return true;
                    case TypeScript.SyntaxKind.LessThanToken:
                        return true;
                    case TypeScript.SyntaxKind.PlusPlusToken:
                    case TypeScript.SyntaxKind.MinusMinusToken:
                    case TypeScript.SyntaxKind.PlusToken:
                    case TypeScript.SyntaxKind.MinusToken:
                    case TypeScript.SyntaxKind.TildeToken:
                    case TypeScript.SyntaxKind.ExclamationToken:
                        return true;
                    case TypeScript.SyntaxKind.OpenBraceToken:
                        return true;
                    case TypeScript.SyntaxKind.EqualsGreaterThanToken:
                        return true;
                    case TypeScript.SyntaxKind.SlashToken:
                    case TypeScript.SyntaxKind.SlashEqualsToken:
                        return true;
                    case TypeScript.SyntaxKind.SuperKeyword:
                    case TypeScript.SyntaxKind.ThisKeyword:
                    case TypeScript.SyntaxKind.TrueKeyword:
                    case TypeScript.SyntaxKind.FalseKeyword:
                    case TypeScript.SyntaxKind.NullKeyword:
                        return true;
                    case TypeScript.SyntaxKind.NewKeyword:
                        return true;
                    case TypeScript.SyntaxKind.DeleteKeyword:
                    case TypeScript.SyntaxKind.VoidKeyword:
                    case TypeScript.SyntaxKind.TypeOfKeyword:
                        return true;
                    case TypeScript.SyntaxKind.FunctionKeyword:
                        return true;
                }
                if (this.isIdentifier(this.currentToken())) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.parseExpressionStatement = function () {
                var expression = this.parseExpression(true);
                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.expressionStatement(expression, semicolon);
            };
            ParserImpl.prototype.isIfStatement = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.IfKeyword;
            };
            ParserImpl.prototype.parseIfStatement = function () {
                var ifKeyword = this.eatKeyword(TypeScript.SyntaxKind.IfKeyword);
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var statement = this.parseStatement();
                var elseClause = null;
                if (this.isElseClause()) {
                    elseClause = this.parseElseClause();
                }
                return this.factory.ifStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause);
            };
            ParserImpl.prototype.isElseClause = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ElseKeyword;
            };
            ParserImpl.prototype.parseElseClause = function () {
                var elseKeyword = this.eatKeyword(TypeScript.SyntaxKind.ElseKeyword);
                var statement = this.parseStatement();
                return this.factory.elseClause(elseKeyword, statement);
            };
            ParserImpl.prototype.isVariableStatement = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === TypeScript.SyntaxKind.VarKeyword;
            };
            ParserImpl.prototype.parseVariableStatement = function () {
                var modifiers = this.parseModifiers();
                var variableDeclaration = this.parseVariableDeclaration(true);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.variableStatement(modifiers, variableDeclaration, semicolonToken);
            };
            ParserImpl.prototype.parseVariableDeclaration = function (allowIn) {
                var varKeyword = this.eatKeyword(TypeScript.SyntaxKind.VarKeyword);
                var listParsingState = allowIn ? ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn : ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn;
                var result = this.parseSeparatedSyntaxList(listParsingState);
                var variableDeclarators = result.list;
                varKeyword = this.addSkippedTokensAfterToken(varKeyword, result.skippedTokens);
                return this.factory.variableDeclaration(varKeyword, variableDeclarators);
            };
            ParserImpl.prototype.isVariableDeclarator = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === TypeScript.SyntaxKind.VariableDeclarator) {
                    return true;
                }
                return this.isIdentifier(this.currentToken());
            };
            ParserImpl.prototype.canReuseVariableDeclaratorNode = function (node) {
                if (node === null || node.kind() !== TypeScript.SyntaxKind.VariableDeclarator) {
                    return false;
                }
                var variableDeclarator = node;
                return variableDeclarator.equalsValueClause === null;
            };
            ParserImpl.prototype.parseVariableDeclarator = function (allowIn, allowPropertyName) {
                if (this.canReuseVariableDeclaratorNode(this.currentNode())) {
                    return this.eatNode();
                }
                var propertyName = allowPropertyName ? this.eatPropertyName() : this.eatIdentifierToken();
                var equalsValueClause = null;
                var typeAnnotation = null;
                if (propertyName.width() > 0) {
                    typeAnnotation = this.parseOptionalTypeAnnotation(false);
                    if (this.isEqualsValueClause(false)) {
                        equalsValueClause = this.parseEqualsValueClause(allowIn);
                    }
                }
                return this.factory.variableDeclarator(propertyName, typeAnnotation, equalsValueClause);
            };
            ParserImpl.prototype.isColonValueClause = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ColonToken;
            };
            ParserImpl.prototype.isEqualsValueClause = function (inParameter) {
                var token0 = this.currentToken();
                if (token0.tokenKind === TypeScript.SyntaxKind.EqualsToken) {
                    return true;
                }
                if (!this.previousToken().hasTrailingNewLine()) {
                    if (token0.tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken) {
                        return false;
                    }
                    if (token0.tokenKind === TypeScript.SyntaxKind.OpenBraceToken && inParameter) {
                        return false;
                    }
                    return this.isExpression();
                }
                return false;
            };
            ParserImpl.prototype.parseEqualsValueClause = function (allowIn) {
                var equalsToken = this.eatToken(TypeScript.SyntaxKind.EqualsToken);
                var value = this.parseAssignmentExpression(allowIn);
                return this.factory.equalsValueClause(equalsToken, value);
            };
            ParserImpl.prototype.parseExpression = function (allowIn) {
                return this.parseSubExpression(0, allowIn);
            };
            ParserImpl.prototype.parseAssignmentExpression = function (allowIn) {
                return this.parseSubExpression(ExpressionPrecedence.AssignmentExpressionPrecedence, allowIn);
            };
            ParserImpl.prototype.parseUnaryExpression = function () {
                var currentTokenKind = this.currentToken().tokenKind;
                if (TypeScript.SyntaxFacts.isPrefixUnaryExpressionOperatorToken(currentTokenKind)) {
                    var operatorKind = TypeScript.SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);
                    var operatorToken = this.eatAnyToken();
                    var operand = this.parseUnaryExpression();
                    return this.factory.prefixUnaryExpression(operatorKind, operatorToken, operand);
                } else {
                    return this.parseTerm(false);
                }
            };
            ParserImpl.prototype.parseSubExpression = function (precedence, allowIn) {
                var leftOperand = this.parseUnaryExpression();
                leftOperand = this.parseBinaryOrConditionalExpressions(precedence, allowIn, leftOperand);
                return leftOperand;
            };
            ParserImpl.prototype.parseBinaryOrConditionalExpressions = function (precedence, allowIn, leftOperand) {
                while(true) {
                    var token0 = this.currentToken();
                    var token0Kind = token0.tokenKind;
                    if (TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(token0Kind)) {
                        if (token0Kind === TypeScript.SyntaxKind.InKeyword && !allowIn) {
                            break;
                        }
                        var mergedToken = this.tryMergeBinaryExpressionTokens();
                        var tokenKind = mergedToken === null ? token0Kind : mergedToken.syntaxKind;
                        var binaryExpressionKind = TypeScript.SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                        var newPrecedence = ParserImpl.getPrecedence(binaryExpressionKind);
                        if (newPrecedence < precedence) {
                            break;
                        }
                        if (newPrecedence === precedence && !this.isRightAssociative(binaryExpressionKind)) {
                            break;
                        }
                        var operatorToken = mergedToken === null ? token0 : TypeScript.Syntax.token(mergedToken.syntaxKind).withLeadingTrivia(token0.leadingTrivia()).withTrailingTrivia(this.peekToken(mergedToken.tokenCount - 1).trailingTrivia());
                        var skipCount = mergedToken === null ? 1 : mergedToken.tokenCount;
                        for(var i = 0; i < skipCount; i++) {
                            this.eatAnyToken();
                        }
                        leftOperand = this.factory.binaryExpression(binaryExpressionKind, leftOperand, operatorToken, this.parseSubExpression(newPrecedence, allowIn));
                        continue;
                    }
                    if (token0Kind === TypeScript.SyntaxKind.QuestionToken && precedence <= ExpressionPrecedence.ConditionalExpressionPrecedence) {
                        var questionToken = this.eatToken(TypeScript.SyntaxKind.QuestionToken);
                        var whenTrueExpression = this.parseAssignmentExpression(allowIn);
                        var colon = this.eatToken(TypeScript.SyntaxKind.ColonToken);
                        var whenFalseExpression = this.parseAssignmentExpression(allowIn);
                        leftOperand = this.factory.conditionalExpression(leftOperand, questionToken, whenTrueExpression, colon, whenFalseExpression);
                        continue;
                    }
                    break;
                }
                return leftOperand;
            };
            ParserImpl.prototype.tryMergeBinaryExpressionTokens = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === TypeScript.SyntaxKind.GreaterThanToken && !token0.hasTrailingTrivia()) {
                    var storage = this.mergeTokensStorage;
                    storage[0] = TypeScript.SyntaxKind.None;
                    storage[1] = TypeScript.SyntaxKind.None;
                    storage[2] = TypeScript.SyntaxKind.None;
                    for(var i = 0; i < storage.length; i++) {
                        var nextToken = this.peekToken(i + 1);
                        if (!nextToken.hasLeadingTrivia()) {
                            storage[i] = nextToken.tokenKind;
                        }
                        if (nextToken.hasTrailingTrivia()) {
                            break;
                        }
                    }
                    if (storage[0] === TypeScript.SyntaxKind.GreaterThanToken) {
                        if (storage[1] === TypeScript.SyntaxKind.GreaterThanToken) {
                            if (storage[2] === TypeScript.SyntaxKind.EqualsToken) {
                                return {
                                    tokenCount: 4,
                                    syntaxKind: TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken
                                };
                            } else {
                                return {
                                    tokenCount: 3,
                                    syntaxKind: TypeScript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken
                                };
                            }
                        } else if (storage[1] === TypeScript.SyntaxKind.EqualsToken) {
                            return {
                                tokenCount: 3,
                                syntaxKind: TypeScript.SyntaxKind.GreaterThanGreaterThanEqualsToken
                            };
                        } else {
                            return {
                                tokenCount: 2,
                                syntaxKind: TypeScript.SyntaxKind.GreaterThanGreaterThanToken
                            };
                        }
                    } else if (storage[0] === TypeScript.SyntaxKind.EqualsToken) {
                        return {
                            tokenCount: 2,
                            syntaxKind: TypeScript.SyntaxKind.GreaterThanEqualsToken
                        };
                    }
                }
                return null;
            };
            ParserImpl.prototype.isRightAssociative = function (expressionKind) {
                switch(expressionKind) {
                    case TypeScript.SyntaxKind.AssignmentExpression:
                    case TypeScript.SyntaxKind.AddAssignmentExpression:
                    case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                    case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                    case TypeScript.SyntaxKind.DivideAssignmentExpression:
                    case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                    case TypeScript.SyntaxKind.AndAssignmentExpression:
                    case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                    case TypeScript.SyntaxKind.OrAssignmentExpression:
                    case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                        return true;
                    default:
                        return false;
                }
            };
            ParserImpl.prototype.parseTerm = function (inObjectCreation) {
                var term = this.parseTermWorker();
                if (term === null) {
                    return this.eatIdentifierToken();
                }
                return this.parsePostFixExpression(term, inObjectCreation);
            };
            ParserImpl.prototype.parsePostFixExpression = function (expression, inObjectCreation) {
                while(true) {
                    var currentTokenKind = this.currentToken().tokenKind;
                    switch(currentTokenKind) {
                        case TypeScript.SyntaxKind.OpenParenToken:
                            if (inObjectCreation) {
                                return expression;
                            }
                            expression = this.factory.invocationExpression(expression, this.parseArgumentList(null));
                            continue;
                        case TypeScript.SyntaxKind.LessThanToken:
                            if (inObjectCreation) {
                                return expression;
                            }
                            var argumentList = this.tryParseArgumentList();
                            if (argumentList !== null) {
                                expression = this.factory.invocationExpression(expression, argumentList);
                                continue;
                            }
                            break;
                        case TypeScript.SyntaxKind.OpenBracketToken:
                            expression = this.parseElementAccessExpression(expression, inObjectCreation);
                            continue;
                        case TypeScript.SyntaxKind.PlusPlusToken:
                        case TypeScript.SyntaxKind.MinusMinusToken:
                            if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                                break;
                            }
                            expression = this.factory.postfixUnaryExpression(TypeScript.SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(currentTokenKind), expression, this.eatAnyToken());
                            continue;
                        case TypeScript.SyntaxKind.DotToken:
                            expression = this.factory.memberAccessExpression(expression, this.eatToken(TypeScript.SyntaxKind.DotToken), this.eatIdentifierNameToken());
                            continue;
                    }
                    return expression;
                }
            };
            ParserImpl.prototype.tryParseArgumentList = function () {
                var typeArgumentList = null;
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.LessThanToken) {
                    var rewindPoint = this.getRewindPoint();
                    try  {
                        typeArgumentList = this.tryParseTypeArgumentList(true);
                        var token0 = this.currentToken();
                        var isOpenParen = token0.tokenKind === TypeScript.SyntaxKind.OpenParenToken;
                        var isDot = token0.tokenKind === TypeScript.SyntaxKind.DotToken;
                        var isOpenParenOrDot = isOpenParen || isDot;
                        if (typeArgumentList === null || !isOpenParenOrDot) {
                            this.rewind(rewindPoint);
                            return null;
                        }
                        if (isDot) {
                            var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token0.width(), TypeScript.DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list______expected, null);
                            this.addDiagnostic(diagnostic);
                            return this.factory.argumentList(typeArgumentList, TypeScript.Syntax.emptyToken(TypeScript.SyntaxKind.OpenParenToken), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.emptyToken(TypeScript.SyntaxKind.CloseParenToken));
                        }
                    } finally {
                        this.releaseRewindPoint(rewindPoint);
                    }
                }
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.OpenParenToken) {
                    return this.parseArgumentList(typeArgumentList);
                }
                return null;
            };
            ParserImpl.prototype.parseArgumentList = function (typeArgumentList) {
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var arguments = TypeScript.Syntax.emptySeparatedList;
                if (openParenToken.fullWidth() > 0) {
                    var result = this.parseSeparatedSyntaxList(ListParsingState.ArgumentList_AssignmentExpressions);
                    arguments = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                return this.factory.argumentList(typeArgumentList, openParenToken, arguments, closeParenToken);
            };
            ParserImpl.prototype.parseElementAccessExpression = function (expression, inObjectCreation) {
                var start = this.currentTokenStart();
                var openBracketToken = this.eatToken(TypeScript.SyntaxKind.OpenBracketToken);
                var argumentExpression;
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBracketToken && inObjectCreation) {
                    var end = this.currentTokenStart() + this.currentToken().width();
                    var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, start, end - start, TypeScript.DiagnosticCode._new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead, null);
                    this.addDiagnostic(diagnostic);
                    argumentExpression = TypeScript.Syntax.emptyToken(TypeScript.SyntaxKind.IdentifierName);
                } else {
                    argumentExpression = this.parseExpression(true);
                }
                var closeBracketToken = this.eatToken(TypeScript.SyntaxKind.CloseBracketToken);
                return this.factory.elementAccessExpression(expression, openBracketToken, argumentExpression, closeBracketToken);
            };
            ParserImpl.prototype.parseTermWorker = function () {
                var currentToken = this.currentToken();
                if (currentToken.tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken) {
                    return this.parseSimpleArrowFunctionExpression();
                }
                if (this.isIdentifier(currentToken)) {
                    if (this.isSimpleArrowFunctionExpression()) {
                        return this.parseSimpleArrowFunctionExpression();
                    } else {
                        var identifier = this.eatIdentifierToken();
                        return identifier;
                    }
                }
                var currentTokenKind = currentToken.tokenKind;
                switch(currentTokenKind) {
                    case TypeScript.SyntaxKind.ThisKeyword:
                        return this.parseThisExpression();
                    case TypeScript.SyntaxKind.TrueKeyword:
                    case TypeScript.SyntaxKind.FalseKeyword:
                        return this.parseLiteralExpression();
                    case TypeScript.SyntaxKind.NullKeyword:
                        return this.parseLiteralExpression();
                    case TypeScript.SyntaxKind.NewKeyword:
                        return this.parseObjectCreationExpression();
                    case TypeScript.SyntaxKind.FunctionKeyword:
                        return this.parseFunctionExpression();
                    case TypeScript.SyntaxKind.SuperKeyword:
                        return this.parseSuperExpression();
                    case TypeScript.SyntaxKind.TypeOfKeyword:
                        return this.parseTypeOfExpression();
                    case TypeScript.SyntaxKind.DeleteKeyword:
                        return this.parseDeleteExpression();
                    case TypeScript.SyntaxKind.VoidKeyword:
                        return this.parseVoidExpression();
                    case TypeScript.SyntaxKind.NumericLiteral:
                        return this.parseLiteralExpression();
                    case TypeScript.SyntaxKind.RegularExpressionLiteral:
                        return this.parseLiteralExpression();
                    case TypeScript.SyntaxKind.StringLiteral:
                        return this.parseLiteralExpression();
                    case TypeScript.SyntaxKind.OpenBracketToken:
                        return this.parseArrayLiteralExpression();
                    case TypeScript.SyntaxKind.OpenBraceToken:
                        return this.parseObjectLiteralExpression();
                    case TypeScript.SyntaxKind.OpenParenToken:
                        return this.parseParenthesizedOrArrowFunctionExpression();
                    case TypeScript.SyntaxKind.LessThanToken:
                        return this.parseCastOrArrowFunctionExpression();
                    case TypeScript.SyntaxKind.SlashToken:
                    case TypeScript.SyntaxKind.SlashEqualsToken:
                        var result = this.tryReparseDivideAsRegularExpression();
                        if (result !== null) {
                            return result;
                        }
                        break;
                }
                return null;
            };
            ParserImpl.prototype.tryReparseDivideAsRegularExpression = function () {
                var currentToken = this.currentToken();
                if (this.previousToken() !== null) {
                    var previousTokenKind = this.previousToken().tokenKind;
                    switch(previousTokenKind) {
                        case TypeScript.SyntaxKind.IdentifierName:
                            return null;
                        case TypeScript.SyntaxKind.ThisKeyword:
                        case TypeScript.SyntaxKind.TrueKeyword:
                        case TypeScript.SyntaxKind.FalseKeyword:
                            return null;
                        case TypeScript.SyntaxKind.StringLiteral:
                        case TypeScript.SyntaxKind.NumericLiteral:
                        case TypeScript.SyntaxKind.RegularExpressionLiteral:
                        case TypeScript.SyntaxKind.PlusPlusToken:
                        case TypeScript.SyntaxKind.MinusMinusToken:
                        case TypeScript.SyntaxKind.CloseBracketToken:
                        case TypeScript.SyntaxKind.CloseBraceToken:
                            return null;
                    }
                }
                currentToken = this.currentTokenAllowingRegularExpression();
                if (currentToken.tokenKind === TypeScript.SyntaxKind.SlashToken || currentToken.tokenKind === TypeScript.SyntaxKind.SlashEqualsToken) {
                    return null;
                } else if (currentToken.tokenKind === TypeScript.SyntaxKind.RegularExpressionLiteral) {
                    return this.parseLiteralExpression();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.parseTypeOfExpression = function () {
                var typeOfKeyword = this.eatKeyword(TypeScript.SyntaxKind.TypeOfKeyword);
                var expression = this.parseUnaryExpression();
                return this.factory.typeOfExpression(typeOfKeyword, expression);
            };
            ParserImpl.prototype.parseDeleteExpression = function () {
                var deleteKeyword = this.eatKeyword(TypeScript.SyntaxKind.DeleteKeyword);
                var expression = this.parseUnaryExpression();
                return this.factory.deleteExpression(deleteKeyword, expression);
            };
            ParserImpl.prototype.parseVoidExpression = function () {
                var voidKeyword = this.eatKeyword(TypeScript.SyntaxKind.VoidKeyword);
                var expression = this.parseUnaryExpression();
                return this.factory.voidExpression(voidKeyword, expression);
            };
            ParserImpl.prototype.parseSuperExpression = function () {
                var superKeyword = this.eatKeyword(TypeScript.SyntaxKind.SuperKeyword);
                return superKeyword;
            };
            ParserImpl.prototype.parseFunctionExpression = function () {
                var functionKeyword = this.eatKeyword(TypeScript.SyntaxKind.FunctionKeyword);
                var identifier = null;
                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }
                var callSignature = this.parseCallSignature(false);
                var block = this.parseBlock(false, true);
                return this.factory.functionExpression(functionKeyword, identifier, callSignature, block);
            };
            ParserImpl.prototype.parseObjectCreationExpression = function () {
                var newKeyword = this.eatKeyword(TypeScript.SyntaxKind.NewKeyword);
                var expression = this.parseTerm(true);
                var argumentList = this.tryParseArgumentList();
                return this.factory.objectCreationExpression(newKeyword, expression, argumentList);
            };
            ParserImpl.prototype.parseCastOrArrowFunctionExpression = function () {
                var rewindPoint = this.getRewindPoint();
                try  {
                    var arrowFunction = this.tryParseArrowFunctionExpression();
                    if (arrowFunction !== null) {
                        return arrowFunction;
                    }
                    this.rewind(rewindPoint);
                    return this.parseCastExpression();
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };
            ParserImpl.prototype.parseCastExpression = function () {
                var lessThanToken = this.eatToken(TypeScript.SyntaxKind.LessThanToken);
                var type = this.parseType();
                var greaterThanToken = this.eatToken(TypeScript.SyntaxKind.GreaterThanToken);
                var expression = this.parseUnaryExpression();
                return this.factory.castExpression(lessThanToken, type, greaterThanToken, expression);
            };
            ParserImpl.prototype.parseParenthesizedOrArrowFunctionExpression = function () {
                var result = this.tryParseArrowFunctionExpression();
                if (result !== null) {
                    return result;
                }
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                return this.factory.parenthesizedExpression(openParenToken, expression, closeParenToken);
            };
            ParserImpl.prototype.tryParseArrowFunctionExpression = function () {
                var tokenKind = this.currentToken().tokenKind;
                if (this.isDefinitelyArrowFunctionExpression()) {
                    return this.parseParenthesizedArrowFunctionExpression(false);
                }
                if (!this.isPossiblyArrowFunctionExpression()) {
                    return null;
                }
                var rewindPoint = this.getRewindPoint();
                try  {
                    var arrowFunction = this.parseParenthesizedArrowFunctionExpression(true);
                    if (arrowFunction === null) {
                        this.rewind(rewindPoint);
                    }
                    return arrowFunction;
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };
            ParserImpl.prototype.parseParenthesizedArrowFunctionExpression = function (requireArrow) {
                var currentToken = this.currentToken();
                var callSignature = this.parseCallSignature(true);
                if (requireArrow && this.currentToken().tokenKind !== TypeScript.SyntaxKind.EqualsGreaterThanToken) {
                    return null;
                }
                var equalsGreaterThanToken = this.eatToken(TypeScript.SyntaxKind.EqualsGreaterThanToken);
                var body = this.parseArrowFunctionBody();
                return this.factory.parenthesizedArrowFunctionExpression(callSignature, equalsGreaterThanToken, body);
            };
            ParserImpl.prototype.parseArrowFunctionBody = function () {
                if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else {
                    return this.parseAssignmentExpression(true);
                }
            };
            ParserImpl.prototype.isSimpleArrowFunctionExpression = function () {
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken) {
                    return true;
                }
                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken;
            };
            ParserImpl.prototype.parseSimpleArrowFunctionExpression = function () {
                var identifier = this.eatIdentifierToken();
                var equalsGreaterThanToken = this.eatToken(TypeScript.SyntaxKind.EqualsGreaterThanToken);
                var body = this.parseArrowFunctionBody();
                return this.factory.simpleArrowFunctionExpression(identifier, equalsGreaterThanToken, body);
            };
            ParserImpl.prototype.isBlock = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.OpenBraceToken;
            };
            ParserImpl.prototype.isDefinitelyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== TypeScript.SyntaxKind.OpenParenToken) {
                    return false;
                }
                var token1 = this.peekToken(1);
                var token2;
                if (token1.tokenKind === TypeScript.SyntaxKind.CloseParenToken) {
                    token2 = this.peekToken(2);
                    return token2.tokenKind === TypeScript.SyntaxKind.ColonToken || token2.tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken || token2.tokenKind === TypeScript.SyntaxKind.OpenBraceToken;
                }
                if (token1.tokenKind === TypeScript.SyntaxKind.DotDotDotToken) {
                    return true;
                }
                if (!this.isIdentifier(token1)) {
                    return false;
                }
                token2 = this.peekToken(2);
                if (token2.tokenKind === TypeScript.SyntaxKind.ColonToken) {
                    return true;
                }
                var token3 = this.peekToken(3);
                if (token2.tokenKind === TypeScript.SyntaxKind.QuestionToken) {
                    if (token3.tokenKind === TypeScript.SyntaxKind.ColonToken || token3.tokenKind === TypeScript.SyntaxKind.CloseParenToken || token3.tokenKind === TypeScript.SyntaxKind.CommaToken) {
                        return true;
                    }
                }
                if (token2.tokenKind === TypeScript.SyntaxKind.CloseParenToken) {
                    if (token3.tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken) {
                        return true;
                    }
                }
                return false;
            };
            ParserImpl.prototype.isPossiblyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== TypeScript.SyntaxKind.OpenParenToken) {
                    return true;
                }
                var token1 = this.peekToken(1);
                if (!this.isIdentifier(token1)) {
                    return false;
                }
                var token2 = this.peekToken(2);
                if (token2.tokenKind === TypeScript.SyntaxKind.EqualsToken) {
                    return true;
                }
                if (token2.tokenKind === TypeScript.SyntaxKind.CommaToken) {
                    return true;
                }
                if (token2.tokenKind === TypeScript.SyntaxKind.CloseParenToken) {
                    var token3 = this.peekToken(3);
                    if (token3.tokenKind === TypeScript.SyntaxKind.ColonToken) {
                        return true;
                    }
                }
                return false;
            };
            ParserImpl.prototype.parseObjectLiteralExpression = function () {
                var openBraceToken = this.eatToken(TypeScript.SyntaxKind.OpenBraceToken);
                var result = this.parseSeparatedSyntaxList(ListParsingState.ObjectLiteralExpression_PropertyAssignments);
                var propertyAssignments = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                var closeBraceToken = this.eatToken(TypeScript.SyntaxKind.CloseBraceToken);
                return this.factory.objectLiteralExpression(openBraceToken, propertyAssignments, closeBraceToken);
            };
            ParserImpl.prototype.parsePropertyAssignment = function () {
                if (this.isGetAccessorPropertyAssignment(false)) {
                    return this.parseGetAccessorPropertyAssignment();
                } else if (this.isSetAccessorPropertyAssignment(false)) {
                    return this.parseSetAccessorPropertyAssignment();
                } else if (this.isSimplePropertyAssignment(false)) {
                    return this.parseSimplePropertyAssignment();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.isPropertyAssignment = function (inErrorRecovery) {
                return this.isGetAccessorPropertyAssignment(inErrorRecovery) || this.isSetAccessorPropertyAssignment(inErrorRecovery) || this.isSimplePropertyAssignment(inErrorRecovery);
            };
            ParserImpl.prototype.isGetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.GetKeyword && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };
            ParserImpl.prototype.parseGetAccessorPropertyAssignment = function () {
                var getKeyword = this.eatKeyword(TypeScript.SyntaxKind.GetKeyword);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, true);
                return this.factory.getAccessorPropertyAssignment(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block);
            };
            ParserImpl.prototype.isSetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.SetKeyword && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };
            ParserImpl.prototype.parseSetAccessorPropertyAssignment = function () {
                var setKeyword = this.eatKeyword(TypeScript.SyntaxKind.SetKeyword);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var parameter = this.parseParameter();
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                var block = this.parseBlock(false, true);
                return this.factory.setAccessorPropertyAssignment(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block);
            };
            ParserImpl.prototype.isSimplePropertyAssignment = function (inErrorRecovery) {
                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };
            ParserImpl.prototype.eatPropertyName = function () {
                return TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.currentToken()) ? this.eatIdentifierNameToken() : this.eatAnyToken();
            };
            ParserImpl.prototype.parseSimplePropertyAssignment = function () {
                var propertyName = this.eatPropertyName();
                var colonToken = this.eatToken(TypeScript.SyntaxKind.ColonToken);
                var expression = this.parseAssignmentExpression(true);
                return this.factory.simplePropertyAssignment(propertyName, colonToken, expression);
            };
            ParserImpl.prototype.isPropertyName = function (token, inErrorRecovery) {
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    if (inErrorRecovery) {
                        return this.isIdentifier(token);
                    } else {
                        return true;
                    }
                }
                switch(token.tokenKind) {
                    case TypeScript.SyntaxKind.StringLiteral:
                    case TypeScript.SyntaxKind.NumericLiteral:
                        return true;
                    default:
                        return false;
                }
            };
            ParserImpl.prototype.parseArrayLiteralExpression = function () {
                var openBracketToken = this.eatToken(TypeScript.SyntaxKind.OpenBracketToken);
                var result = this.parseSeparatedSyntaxList(ListParsingState.ArrayLiteralExpression_AssignmentExpressions);
                var expressions = result.list;
                openBracketToken = this.addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);
                var closeBracketToken = this.eatToken(TypeScript.SyntaxKind.CloseBracketToken);
                return this.factory.arrayLiteralExpression(openBracketToken, expressions, closeBracketToken);
            };
            ParserImpl.prototype.parseLiteralExpression = function () {
                return this.eatAnyToken();
            };
            ParserImpl.prototype.parseThisExpression = function () {
                var thisKeyword = this.eatKeyword(TypeScript.SyntaxKind.ThisKeyword);
                return thisKeyword;
            };
            ParserImpl.prototype.parseBlock = function (parseBlockEvenWithNoOpenBrace, checkForStrictMode) {
                var openBraceToken = this.eatToken(TypeScript.SyntaxKind.OpenBraceToken);
                var statements = TypeScript.Syntax.emptyList;
                if (parseBlockEvenWithNoOpenBrace || openBraceToken.width() > 0) {
                    var savedIsInStrictMode = this.isInStrictMode;
                    var processItems = checkForStrictMode ? ParserImpl.updateStrictModeState : null;
                    var result = this.parseSyntaxList(ListParsingState.Block_Statements, processItems);
                    statements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                    this.setStrictMode(savedIsInStrictMode);
                }
                var closeBraceToken = this.eatToken(TypeScript.SyntaxKind.CloseBraceToken);
                return this.factory.block(openBraceToken, statements, closeBraceToken);
            };
            ParserImpl.prototype.parseCallSignature = function (requireCompleteTypeParameterList) {
                var typeParameterList = this.parseOptionalTypeParameterList(requireCompleteTypeParameterList);
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                return this.factory.callSignature(typeParameterList, parameterList, typeAnnotation);
            };
            ParserImpl.prototype.parseOptionalTypeParameterList = function (requireCompleteTypeParameterList) {
                if (this.currentToken().tokenKind !== TypeScript.SyntaxKind.LessThanToken) {
                    return null;
                }
                var rewindPoint = this.getRewindPoint();
                try  {
                    var lessThanToken = this.eatToken(TypeScript.SyntaxKind.LessThanToken);
                    var result = this.parseSeparatedSyntaxList(ListParsingState.TypeParameterList_TypeParameters);
                    var typeParameterList = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);
                    var greaterThanToken = this.eatToken(TypeScript.SyntaxKind.GreaterThanToken);
                    if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                        this.rewind(rewindPoint);
                        return null;
                    }
                    return this.factory.typeParameterList(lessThanToken, typeParameterList, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };
            ParserImpl.prototype.isTypeParameter = function () {
                return this.isIdentifier(this.currentToken());
            };
            ParserImpl.prototype.parseTypeParameter = function () {
                var identifier = this.eatIdentifierToken();
                var constraint = this.parseOptionalConstraint();
                return this.factory.typeParameter(identifier, constraint);
            };
            ParserImpl.prototype.parseOptionalConstraint = function () {
                if (this.currentToken().kind() !== TypeScript.SyntaxKind.ExtendsKeyword) {
                    return null;
                }
                var extendsKeyword = this.eatKeyword(TypeScript.SyntaxKind.ExtendsKeyword);
                var type = this.parseType();
                return this.factory.constraint(extendsKeyword, type);
            };
            ParserImpl.prototype.parseParameterList = function () {
                var openParenToken = this.eatToken(TypeScript.SyntaxKind.OpenParenToken);
                var parameters = TypeScript.Syntax.emptySeparatedList;
                if (openParenToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(ListParsingState.ParameterList_Parameters);
                    parameters = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }
                var closeParenToken = this.eatToken(TypeScript.SyntaxKind.CloseParenToken);
                return this.factory.parameterList(openParenToken, parameters, closeParenToken);
            };
            ParserImpl.prototype.isTypeAnnotation = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.ColonToken;
            };
            ParserImpl.prototype.parseOptionalTypeAnnotation = function (allowStringLiteral) {
                return this.isTypeAnnotation() ? this.parseTypeAnnotation(allowStringLiteral) : null;
            };
            ParserImpl.prototype.parseTypeAnnotation = function (allowStringLiteral) {
                var colonToken = this.eatToken(TypeScript.SyntaxKind.ColonToken);
                var type = allowStringLiteral && this.currentToken().tokenKind === TypeScript.SyntaxKind.StringLiteral ? this.eatToken(TypeScript.SyntaxKind.StringLiteral) : this.parseType();
                return this.factory.typeAnnotation(colonToken, type);
            };
            ParserImpl.prototype.isType = function () {
                return this.isPredefinedType() || this.isTypeLiteral() || this.isName();
            };
            ParserImpl.prototype.parseType = function () {
                var type = this.parseNonArrayType();
                while(this.currentToken().tokenKind === TypeScript.SyntaxKind.OpenBracketToken) {
                    var openBracketToken = this.eatToken(TypeScript.SyntaxKind.OpenBracketToken);
                    var closeBracketToken = this.eatToken(TypeScript.SyntaxKind.CloseBracketToken);
                    type = this.factory.arrayType(type, openBracketToken, closeBracketToken);
                }
                return type;
            };
            ParserImpl.prototype.parseNonArrayType = function () {
                if (this.isPredefinedType()) {
                    return this.parsePredefinedType();
                } else if (this.isTypeLiteral()) {
                    return this.parseTypeLiteral();
                } else {
                    return this.parseNameOrGenericType();
                }
            };
            ParserImpl.prototype.parseNameOrGenericType = function () {
                var name = this.parseName();
                var typeArgumentList = this.tryParseTypeArgumentList(false);
                return typeArgumentList === null ? name : this.factory.genericType(name, typeArgumentList);
            };
            ParserImpl.prototype.parseTypeLiteral = function () {
                if (this.isObjectType()) {
                    return this.parseObjectType();
                } else if (this.isFunctionType()) {
                    return this.parseFunctionType();
                } else if (this.isConstructorType()) {
                    return this.parseConstructorType();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.parseFunctionType = function () {
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(TypeScript.SyntaxKind.EqualsGreaterThanToken);
                var returnType = this.parseType();
                return this.factory.functionType(typeParameterList, parameterList, equalsGreaterThanToken, returnType);
            };
            ParserImpl.prototype.parseConstructorType = function () {
                var newKeyword = this.eatKeyword(TypeScript.SyntaxKind.NewKeyword);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(TypeScript.SyntaxKind.EqualsGreaterThanToken);
                var type = this.parseType();
                return this.factory.constructorType(newKeyword, null, parameterList, equalsGreaterThanToken, type);
            };
            ParserImpl.prototype.isTypeLiteral = function () {
                return this.isObjectType() || this.isFunctionType() || this.isConstructorType();
            };
            ParserImpl.prototype.isObjectType = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.OpenBraceToken;
            };
            ParserImpl.prototype.isFunctionType = function () {
                var tokenKind = this.currentToken().tokenKind;
                return tokenKind === TypeScript.SyntaxKind.OpenParenToken || tokenKind === TypeScript.SyntaxKind.LessThanToken;
            };
            ParserImpl.prototype.isConstructorType = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.NewKeyword;
            };
            ParserImpl.prototype.parsePredefinedType = function () {
                return this.eatAnyToken();
            };
            ParserImpl.prototype.isPredefinedType = function () {
                switch(this.currentToken().tokenKind) {
                    case TypeScript.SyntaxKind.AnyKeyword:
                    case TypeScript.SyntaxKind.NumberKeyword:
                    case TypeScript.SyntaxKind.BooleanKeyword:
                    case TypeScript.SyntaxKind.BoolKeyword:
                    case TypeScript.SyntaxKind.StringKeyword:
                    case TypeScript.SyntaxKind.VoidKeyword:
                        return true;
                }
                return false;
            };
            ParserImpl.prototype.isParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === TypeScript.SyntaxKind.Parameter) {
                    return true;
                }
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.DotDotDotToken) {
                    return true;
                }
                if (ParserImpl.isPublicOrPrivateKeyword(token)) {
                    return true;
                }
                return this.isIdentifier(token);
            };
            ParserImpl.prototype.parseParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === TypeScript.SyntaxKind.Parameter) {
                    return this.eatNode();
                }
                var dotDotDotToken = this.tryEatToken(TypeScript.SyntaxKind.DotDotDotToken);
                var publicOrPrivateToken = null;
                if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                    publicOrPrivateToken = this.eatAnyToken();
                }
                var identifier = this.eatIdentifierToken();
                var questionToken = this.tryEatToken(TypeScript.SyntaxKind.QuestionToken);
                var typeAnnotation = this.parseOptionalTypeAnnotation(true);
                var equalsValueClause = null;
                if (this.isEqualsValueClause(true)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }
                return this.factory.parameter(dotDotDotToken, publicOrPrivateToken, identifier, questionToken, typeAnnotation, equalsValueClause);
            };
            ParserImpl.prototype.parseSyntaxList = function (currentListType, processItems) {
                if (typeof processItems === "undefined") { processItems = null; }
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;
                var result = this.parseSyntaxListWorker(currentListType, processItems);
                this.listParsingState = savedListParsingState;
                return result;
            };
            ParserImpl.prototype.parseSeparatedSyntaxList = function (currentListType) {
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;
                var result = this.parseSeparatedSyntaxListWorker(currentListType);
                this.listParsingState = savedListParsingState;
                return result;
            };
            ParserImpl.prototype.abortParsingListOrMoveToNextToken = function (currentListType, items, skippedTokens) {
                this.reportUnexpectedTokenDiagnostic(currentListType);
                for(var state = ListParsingState.LastListParsingState; state >= ListParsingState.FirstListParsingState; state >>= 1) {
                    if ((this.listParsingState & state) !== 0) {
                        if (this.isExpectedListTerminator(state) || this.isExpectedListItem(state, true)) {
                            return true;
                        }
                    }
                }
                var skippedToken = this.currentToken();
                this.moveToNextToken();
                this.addSkippedTokenToList(items, skippedTokens, skippedToken);
                return false;
            };
            ParserImpl.prototype.addSkippedTokenToList = function (items, skippedTokens, skippedToken) {
                for(var i = items.length - 1; i >= 0; i--) {
                    var item = items[i];
                    var lastToken = item.lastToken();
                    if (lastToken.fullWidth() > 0) {
                        items[i] = this.addSkippedTokenAfterNodeOrToken(item, skippedToken);
                        return;
                    }
                }
                skippedTokens.push(skippedToken);
            };
            ParserImpl.prototype.tryParseExpectedListItem = function (currentListType, inErrorRecovery, items, processItems) {
                if (this.isExpectedListItem(currentListType, inErrorRecovery)) {
                    var item = this.parseExpectedListItem(currentListType);
                    items.push(item);
                    if (processItems !== null) {
                        processItems(this, items);
                    }
                }
            };
            ParserImpl.prototype.listIsTerminated = function (currentListType) {
                return this.isExpectedListTerminator(currentListType) || this.currentToken().tokenKind === TypeScript.SyntaxKind.EndOfFileToken;
            };
            ParserImpl.prototype.getArray = function () {
                if (this.arrayPool.length > 0) {
                    return this.arrayPool.pop();
                }
                return [];
            };
            ParserImpl.prototype.returnZeroOrOneLengthArray = function (array) {
                if (array.length <= 1) {
                    this.returnArray(array);
                }
            };
            ParserImpl.prototype.returnArray = function (array) {
                array.length = 0;
                this.arrayPool.push(array);
            };
            ParserImpl.prototype.parseSyntaxListWorker = function (currentListType, processItems) {
                var items = this.getArray();
                var skippedTokens = this.getArray();
                while(true) {
                    var oldItemsCount = items.length;
                    this.tryParseExpectedListItem(currentListType, false, items, processItems);
                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            break;
                        }
                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        }
                    }
                }
                var result = TypeScript.Syntax.list(items);
                this.returnZeroOrOneLengthArray(items);
                return {
                    skippedTokens: skippedTokens,
                    list: result
                };
            };
            ParserImpl.prototype.parseSeparatedSyntaxListWorker = function (currentListType) {
                var items = this.getArray();
                var skippedTokens = this.getArray();
                TypeScript.Debug.assert(items.length === 0);
                TypeScript.Debug.assert(skippedTokens.length === 0);
                TypeScript.Debug.assert(skippedTokens !== items);
                var allowAutomaticSemicolonInsertion = this.allowsAutomaticSemicolonInsertion(currentListType);
                var separatorKind = this.separatorKind(currentListType);
                var inErrorRecovery = false;
                var listWasTerminated = false;
                while(true) {
                    var oldItemsCount = items.length;
                    this.tryParseExpectedListItem(currentListType, inErrorRecovery, items, null);
                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            listWasTerminated = true;
                            break;
                        }
                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        } else {
                            inErrorRecovery = true;
                            continue;
                        }
                    }
                    inErrorRecovery = false;
                    var currentToken = this.currentToken();
                    if (currentToken.tokenKind === separatorKind || currentToken.tokenKind === TypeScript.SyntaxKind.CommaToken) {
                        items.push(this.eatAnyToken());
                        continue;
                    }
                    if (this.listIsTerminated(currentListType)) {
                        listWasTerminated = true;
                        break;
                    }
                    if (allowAutomaticSemicolonInsertion && this.canEatAutomaticSemicolon(false)) {
                        items.push(this.eatExplicitOrAutomaticSemicolon(false));
                        continue;
                    }
                    items.push(this.eatToken(separatorKind));
                    inErrorRecovery = true;
                }
                var result = TypeScript.Syntax.separatedList(items);
                this.returnZeroOrOneLengthArray(items);
                return {
                    skippedTokens: skippedTokens,
                    list: result
                };
            };
            ParserImpl.prototype.allowsAutomaticSemicolonInsertion = function (currentListType) {
                switch(currentListType) {
                    case ListParsingState.ObjectType_TypeMembers:
                        return true;
                    case ListParsingState.HeritageClause_TypeNameList:
                    case ListParsingState.EnumDeclaration_EnumElements:
                    case ListParsingState.ArgumentList_AssignmentExpressions:
                    case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    case ListParsingState.ParameterList_Parameters:
                    case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    case ListParsingState.TypeArgumentList_Types:
                    case ListParsingState.TypeParameterList_TypeParameters:
                        return false;
                    case ListParsingState.SourceUnit_ModuleElements:
                    case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                    case ListParsingState.ClassDeclaration_ClassElements:
                    case ListParsingState.ModuleDeclaration_ModuleElements:
                    case ListParsingState.SwitchStatement_SwitchClauses:
                    case ListParsingState.SwitchClause_Statements:
                    case ListParsingState.Block_Statements:
                    default:
                        throw TypeScript.Errors.notYetImplemented();
                }
            };
            ParserImpl.prototype.separatorKind = function (currentListType) {
                switch(currentListType) {
                    case ListParsingState.HeritageClause_TypeNameList:
                    case ListParsingState.ArgumentList_AssignmentExpressions:
                    case ListParsingState.EnumDeclaration_EnumElements:
                    case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    case ListParsingState.ParameterList_Parameters:
                    case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    case ListParsingState.TypeArgumentList_Types:
                    case ListParsingState.TypeParameterList_TypeParameters:
                        return TypeScript.SyntaxKind.CommaToken;
                    case ListParsingState.ObjectType_TypeMembers:
                        return TypeScript.SyntaxKind.SemicolonToken;
                    case ListParsingState.SourceUnit_ModuleElements:
                    case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                    case ListParsingState.ClassDeclaration_ClassElements:
                    case ListParsingState.ModuleDeclaration_ModuleElements:
                    case ListParsingState.SwitchStatement_SwitchClauses:
                    case ListParsingState.SwitchClause_Statements:
                    case ListParsingState.Block_Statements:
                    default:
                        throw TypeScript.Errors.notYetImplemented();
                }
            };
            ParserImpl.prototype.reportUnexpectedTokenDiagnostic = function (listType) {
                var token = this.currentToken();
                var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Unexpected_token__0_expected, [
                    this.getExpectedListElementType(listType)
                ]);
                this.addDiagnostic(diagnostic);
            };
            ParserImpl.prototype.addDiagnostic = function (diagnostic) {
                if (this.diagnostics.length > 0 && this.diagnostics[this.diagnostics.length - 1].start() === diagnostic.start()) {
                    return;
                }
                this.diagnostics.push(diagnostic);
            };
            ParserImpl.prototype.isExpectedListTerminator = function (currentListType) {
                switch(currentListType) {
                    case ListParsingState.SourceUnit_ModuleElements:
                        return this.isExpectedSourceUnit_ModuleElementsTerminator();
                    case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                        return this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();
                    case ListParsingState.ClassDeclaration_ClassElements:
                        return this.isExpectedClassDeclaration_ClassElementsTerminator();
                    case ListParsingState.ModuleDeclaration_ModuleElements:
                        return this.isExpectedModuleDeclaration_ModuleElementsTerminator();
                    case ListParsingState.SwitchStatement_SwitchClauses:
                        return this.isExpectedSwitchStatement_SwitchClausesTerminator();
                    case ListParsingState.SwitchClause_Statements:
                        return this.isExpectedSwitchClause_StatementsTerminator();
                    case ListParsingState.Block_Statements:
                        return this.isExpectedBlock_StatementsTerminator();
                    case ListParsingState.TryBlock_Statements:
                        return this.isExpectedTryBlock_StatementsTerminator();
                    case ListParsingState.CatchBlock_Statements:
                        return this.isExpectedCatchBlock_StatementsTerminator();
                    case ListParsingState.EnumDeclaration_EnumElements:
                        return this.isExpectedEnumDeclaration_EnumElementsTerminator();
                    case ListParsingState.ObjectType_TypeMembers:
                        return this.isExpectedObjectType_TypeMembersTerminator();
                    case ListParsingState.ArgumentList_AssignmentExpressions:
                        return this.isExpectedArgumentList_AssignmentExpressionsTerminator();
                    case ListParsingState.HeritageClause_TypeNameList:
                        return this.isExpectedHeritageClause_TypeNameListTerminator();
                    case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();
                    case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();
                    case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                        return this.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();
                    case ListParsingState.ParameterList_Parameters:
                        return this.isExpectedParameterList_ParametersTerminator();
                    case ListParsingState.TypeArgumentList_Types:
                        return this.isExpectedTypeArgumentList_TypesTerminator();
                    case ListParsingState.TypeParameterList_TypeParameters:
                        return this.isExpectedTypeParameterList_TypeParametersTerminator();
                    case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                        return this.isExpectedLiteralExpression_AssignmentExpressionsTerminator();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.isExpectedSourceUnit_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.EndOfFileToken;
            };
            ParserImpl.prototype.isExpectedEnumDeclaration_EnumElementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken;
            };
            ParserImpl.prototype.isExpectedModuleDeclaration_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken;
            };
            ParserImpl.prototype.isExpectedObjectType_TypeMembersTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken;
            };
            ParserImpl.prototype.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken;
            };
            ParserImpl.prototype.isExpectedLiteralExpression_AssignmentExpressionsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBracketToken;
            };
            ParserImpl.prototype.isExpectedTypeArgumentList_TypesTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.GreaterThanToken) {
                    return true;
                }
                if (this.canFollowTypeArgumentListInExpression(token.tokenKind)) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.isExpectedTypeParameterList_TypeParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.GreaterThanToken) {
                    return true;
                }
                if (token.tokenKind === TypeScript.SyntaxKind.OpenParenToken || token.tokenKind === TypeScript.SyntaxKind.OpenBraceToken || token.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword || token.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.isExpectedParameterList_ParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === TypeScript.SyntaxKind.CloseParenToken) {
                    return true;
                }
                if (token.tokenKind === TypeScript.SyntaxKind.OpenBraceToken) {
                    return true;
                }
                if (token.tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator = function () {
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.SemicolonToken || this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseParenToken) {
                    return true;
                }
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.InKeyword) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator = function () {
                if (this.previousToken().tokenKind === TypeScript.SyntaxKind.CommaToken) {
                    return false;
                }
                if (this.currentToken().tokenKind === TypeScript.SyntaxKind.EqualsGreaterThanToken) {
                    return true;
                }
                return this.canEatExplicitOrAutomaticSemicolon(false);
            };
            ParserImpl.prototype.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === TypeScript.SyntaxKind.OpenBraceToken || token0.tokenKind === TypeScript.SyntaxKind.CloseBraceToken) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.isExpectedHeritageClause_TypeNameListTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword || token0.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword) {
                    return true;
                }
                if (this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                    return true;
                }
                return false;
            };
            ParserImpl.prototype.isExpectedArgumentList_AssignmentExpressionsTerminator = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === TypeScript.SyntaxKind.CloseParenToken || token0.tokenKind === TypeScript.SyntaxKind.SemicolonToken;
            };
            ParserImpl.prototype.isExpectedClassDeclaration_ClassElementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken;
            };
            ParserImpl.prototype.isExpectedSwitchStatement_SwitchClausesTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken;
            };
            ParserImpl.prototype.isExpectedSwitchClause_StatementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken || this.isSwitchClause();
            };
            ParserImpl.prototype.isExpectedBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CloseBraceToken;
            };
            ParserImpl.prototype.isExpectedTryBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.CatchKeyword || this.currentToken().tokenKind === TypeScript.SyntaxKind.FinallyKeyword;
            };
            ParserImpl.prototype.isExpectedCatchBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === TypeScript.SyntaxKind.FinallyKeyword;
            };
            ParserImpl.prototype.isExpectedListItem = function (currentListType, inErrorRecovery) {
                switch(currentListType) {
                    case ListParsingState.SourceUnit_ModuleElements:
                        return this.isModuleElement(inErrorRecovery);
                    case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                        return this.isHeritageClause();
                    case ListParsingState.ClassDeclaration_ClassElements:
                        return this.isClassElement(inErrorRecovery);
                    case ListParsingState.ModuleDeclaration_ModuleElements:
                        return this.isModuleElement(inErrorRecovery);
                    case ListParsingState.SwitchStatement_SwitchClauses:
                        return this.isSwitchClause();
                    case ListParsingState.SwitchClause_Statements:
                        return this.isStatement(inErrorRecovery);
                    case ListParsingState.Block_Statements:
                        return this.isStatement(inErrorRecovery);
                    case ListParsingState.TryBlock_Statements:
                    case ListParsingState.CatchBlock_Statements:
                        return false;
                    case ListParsingState.EnumDeclaration_EnumElements:
                        return this.isEnumElement(inErrorRecovery);
                    case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                        return this.isVariableDeclarator();
                    case ListParsingState.ObjectType_TypeMembers:
                        return this.isTypeMember(inErrorRecovery);
                    case ListParsingState.ArgumentList_AssignmentExpressions:
                        return this.isExpression();
                    case ListParsingState.HeritageClause_TypeNameList:
                        return this.isHeritageClauseTypeName();
                    case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                        return this.isPropertyAssignment(inErrorRecovery);
                    case ListParsingState.ParameterList_Parameters:
                        return this.isParameter();
                    case ListParsingState.TypeArgumentList_Types:
                        return this.isType();
                    case ListParsingState.TypeParameterList_TypeParameters:
                        return this.isTypeParameter();
                    case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                        return this.isAssignmentOrOmittedExpression();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.parseExpectedListItem = function (currentListType) {
                switch(currentListType) {
                    case ListParsingState.SourceUnit_ModuleElements:
                        return this.parseModuleElement();
                    case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                        return this.parseHeritageClause();
                    case ListParsingState.ClassDeclaration_ClassElements:
                        return this.parseClassElement(false);
                    case ListParsingState.ModuleDeclaration_ModuleElements:
                        return this.parseModuleElement();
                    case ListParsingState.SwitchStatement_SwitchClauses:
                        return this.parseSwitchClause();
                    case ListParsingState.SwitchClause_Statements:
                        return this.parseStatement();
                    case ListParsingState.Block_Statements:
                        return this.parseStatement();
                    case ListParsingState.EnumDeclaration_EnumElements:
                        return this.parseEnumElement();
                    case ListParsingState.ObjectType_TypeMembers:
                        return this.parseTypeMember();
                    case ListParsingState.ArgumentList_AssignmentExpressions:
                        return this.parseAssignmentExpression(true);
                    case ListParsingState.HeritageClause_TypeNameList:
                        return this.parseNameOrGenericType();
                    case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                        return this.parseVariableDeclarator(true, false);
                    case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                        return this.parseVariableDeclarator(false, false);
                    case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                        return this.parsePropertyAssignment();
                    case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                        return this.parseAssignmentOrOmittedExpression();
                    case ListParsingState.ParameterList_Parameters:
                        return this.parseParameter();
                    case ListParsingState.TypeArgumentList_Types:
                        return this.parseType();
                    case ListParsingState.TypeParameterList_TypeParameters:
                        return this.parseTypeParameter();
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };
            ParserImpl.prototype.getExpectedListElementType = function (currentListType) {
                switch(currentListType) {
                    case ListParsingState.SourceUnit_ModuleElements:
                        return TypeScript.Strings.module__class__interface__enum__import_or_statement;
                    case ListParsingState.ClassOrInterfaceDeclaration_HeritageClauses:
                        return '{';
                    case ListParsingState.ClassDeclaration_ClassElements:
                        return TypeScript.Strings.constructor__function__accessor_or_variable;
                    case ListParsingState.ModuleDeclaration_ModuleElements:
                        return TypeScript.Strings.module__class__interface__enum__import_or_statement;
                    case ListParsingState.SwitchStatement_SwitchClauses:
                        return TypeScript.Strings.case_or_default_clause;
                    case ListParsingState.SwitchClause_Statements:
                        return TypeScript.Strings.statement;
                    case ListParsingState.Block_Statements:
                        return TypeScript.Strings.statement;
                    case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                        return TypeScript.Strings.identifier;
                    case ListParsingState.EnumDeclaration_EnumElements:
                        return TypeScript.Strings.identifier;
                    case ListParsingState.ObjectType_TypeMembers:
                        return TypeScript.Strings.call__construct__index__property_or_function_signature;
                    case ListParsingState.ArgumentList_AssignmentExpressions:
                        return TypeScript.Strings.expression;
                    case ListParsingState.HeritageClause_TypeNameList:
                        return TypeScript.Strings.type_name;
                    case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                        return TypeScript.Strings.property_or_accessor;
                    case ListParsingState.ParameterList_Parameters:
                        return TypeScript.Strings.parameter;
                    case ListParsingState.TypeArgumentList_Types:
                        return TypeScript.Strings.type;
                    case ListParsingState.TypeParameterList_TypeParameters:
                        return TypeScript.Strings.type_parameter;
                    case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                        return TypeScript.Strings.expression;
                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };
            return ParserImpl;
        })();        
        function parse(fileName, text, isDeclaration, languageVersion, options) {
            if (typeof languageVersion === "undefined") { languageVersion = TypeScript.LanguageVersion.EcmaScript5; }
            if (typeof options === "undefined") { options = null; }
            var source = new NormalParserSource(fileName, text, languageVersion);
            options = options || new TypeScript.ParseOptions();
            return new ParserImpl(fileName, text.lineMap(), source, options).parseSyntaxTree(isDeclaration);
        }
        Parser.parse = parse;
        function incrementalParse(oldSyntaxTree, textChangeRange, newText) {
            if (textChangeRange.isUnchanged()) {
                return oldSyntaxTree;
            }
            var source = new IncrementalParserSource(oldSyntaxTree, textChangeRange, newText);
            return new ParserImpl(oldSyntaxTree.fileName(), newText.lineMap(), source, oldSyntaxTree.parseOptions()).parseSyntaxTree(oldSyntaxTree.isDeclaration());
        }
        Parser.incrementalParse = incrementalParse;
    })(TypeScript.Parser || (TypeScript.Parser = {}));
    var Parser = TypeScript.Parser;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTree = (function () {
        function SyntaxTree(sourceUnit, isDeclaration, diagnostics, fileName, lineMap, languageVersion, parseOtions) {
            this._allDiagnostics = null;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._languageVersion = languageVersion;
            this._parseOptions = parseOtions;
        }
        SyntaxTree.prototype.toJSON = function (key) {
            var result = {};
            result.isDeclaration = this._isDeclaration;
            result.languageVersion = (TypeScript.LanguageVersion)._map[this._languageVersion];
            result.parseOptions = this._parseOptions;
            if (this.diagnostics().length > 0) {
                result.diagnostics = this.diagnostics();
            }
            result.sourceUnit = this._sourceUnit;
            result.lineMap = this._lineMap;
            return result;
        };
        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };
        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };
        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }
            var diagnostics = [];
            this.sourceUnit().accept(new GrammarCheckerWalker(this.sourceUnit(), this.fileName(), diagnostics, this.isDeclaration()));
            return diagnostics;
        };
        SyntaxTree.prototype.diagnostics = function () {
            if (this._allDiagnostics === null) {
                this._allDiagnostics = this.computeDiagnostics();
            }
            return this._allDiagnostics;
        };
        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };
        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };
        SyntaxTree.prototype.languageVersion = function () {
            return this._languageVersion;
        };
        SyntaxTree.prototype.parseOptions = function () {
            return this._parseOptions;
        };
        SyntaxTree.prototype.structuralEquals = function (tree) {
            return TypeScript.ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), TypeScript.SyntaxDiagnostic.equals) && this.sourceUnit().structuralEquals(tree.sourceUnit());
        };
        return SyntaxTree;
    })();
    TypeScript.SyntaxTree = SyntaxTree;    
    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(sourceUnit, fileName, diagnostics, isDeclaration) {
            _super.call(this);
            this.sourceUnit = sourceUnit;
            this.fileName = fileName;
            this.diagnostics = diagnostics;
            this.isDeclaration = isDeclaration;
            this.inAmbientDeclaration = false;
            this.inBlock = false;
            this.currentConstructor = null;
        }
        GrammarCheckerWalker.prototype.childFullStart = function (parent, child) {
            return this.position() + TypeScript.Syntax.childOffset(parent, child);
        };
        GrammarCheckerWalker.prototype.childStart = function (parent, child) {
            return this.childFullStart(parent, child) + child.leadingTriviaWidth();
        };
        GrammarCheckerWalker.prototype.getToken = function (list, kind) {
            for(var i = 0, n = list.childCount(); i < n; i++) {
                var token = list.childAt(i);
                if (token.tokenKind === kind) {
                    return token;
                }
            }
            return null;
        };
        GrammarCheckerWalker.prototype.containsToken = function (list, kind) {
            return this.getToken(list, kind) !== null;
        };
        GrammarCheckerWalker.prototype.pushDiagnostic = function (start, length, diagnosticCode, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, start, length, diagnosticCode, args));
        };
        GrammarCheckerWalker.prototype.pushDiagnostic1 = function (elementFullStart, element, diagnosticCode, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, elementFullStart + element.leadingTriviaWidth(), element.width(), diagnosticCode, args));
        };
        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(this.childStart(node, node.typeAnnotation), node.typeAnnotation.width(), TypeScript.DiagnosticCode.A_catch_clause_variable_cannot_have_a_type_annotation);
            }
            _super.prototype.visitCatchClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameters);
            var seenOptionalParameter = false;
            var parameterCount = node.parameters.nonSeparatorCount();
            for(var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameterIndex = i / 2;
                    var parameter = node.parameters.childAt(i);
                    if (parameter.dotDotDotToken) {
                        if (parameterIndex != (parameterCount - 1)) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_must_be_last_in_list);
                            return true;
                        }
                        if (parameter.questionToken) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_be_optional);
                            return true;
                        }
                        if (parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_have_initializer);
                            return true;
                        }
                    } else if (parameter.questionToken || parameter.equalsValueClause) {
                        seenOptionalParameter = true;
                        if (parameter.questionToken && parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                            return true;
                        }
                    } else {
                        if (seenOptionalParameter) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Required_parameter_cannot_follow_optional_parameter);
                            return true;
                        }
                    }
                }
                parameterFullStart += nodeOrToken.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            if (this.currentConstructor !== null && this.currentConstructor.parameterList === node && this.currentConstructor.block && !this.inAmbientDeclaration) {
                return false;
            }
            var parameterFullStart = this.childFullStart(node, node.parameters);
            for(var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameter = node.parameters.childAt(i);
                    if (parameter.publicOrPrivateKeyword) {
                        var keywordFullStart = parameterFullStart + TypeScript.Syntax.childOffset(parameter, parameter.publicOrPrivateKeyword);
                        this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, TypeScript.DiagnosticCode.Overload_and_ambient_signatures_cannot_specify_parameter_properties);
                    }
                }
                parameterFullStart += nodeOrToken.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForTrailingSeparator = function (parent, list) {
            if (list.childCount() === 0 || list.childCount() % 2 === 1) {
                return false;
            }
            var currentElementFullStart = this.childFullStart(parent, list);
            for(var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i === n - 1) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode.Trailing_separator_not_allowed);
                }
                currentElementFullStart += child.fullWidth();
            }
            return true;
        };
        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (parent, list, expected) {
            if (list.childCount() > 0) {
                return false;
            }
            var listFullStart = this.childFullStart(parent, list);
            var tokenAtStart = this.sourceUnit.findToken(listFullStart);
            this.pushDiagnostic1(listFullStart, tokenAtStart.token(), TypeScript.DiagnosticCode.Unexpected_token__0_expected, [
                expected
            ]);
            return true;
        };
        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) || this.checkParameterListOrder(node) || this.checkForTrailingSeparator(node, node.parameters)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeNames) || this.checkForAtLeastOneElement(node, node.typeNames, TypeScript.Strings.type_name)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitHeritageClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.arguments)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForTrailingSeparator(node, node.variableDeclarators) || this.checkForAtLeastOneElement(node, node.variableDeclarators, TypeScript.Strings.identifier)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeArguments) || this.checkForAtLeastOneElement(node, node.typeArguments, TypeScript.Strings.identifier)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitTypeArgumentList.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeParameters) || this.checkForAtLeastOneElement(node, node.typeParameters, TypeScript.Strings.identifier)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitTypeParameterList.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameter);
            var parameter = node.parameter;
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            } else if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifierss);
                return true;
            } else if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            } else if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            } else if (!parameter.typeAnnotation) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            } else if (parameter.typeAnnotation.type.kind() !== TypeScript.SyntaxKind.StringKeyword && parameter.typeAnnotation.type.kind() !== TypeScript.SyntaxKind.NumberKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_type_must_be__string__or__number_);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                this.skip(node);
                return;
            }
            if (!node.typeAnnotation) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.Index_signature_must_have_a_type_annotation);
                this.skip(node);
                return;
            }
            _super.prototype.visitIndexSignature.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);
            var seenExtendsClause = false;
            var seenImplementsClause = false;
            for(var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses.childAt(i);
                if (heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode._extends__clause_already_seen);
                        return true;
                    }
                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode._extends__clause_must_precede__implements__clause);
                        return true;
                    }
                    if (heritageClause.typeNames.nonSeparatorCount() > 1) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Class_can_only_extend_single_type);
                        return true;
                    }
                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword);
                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode._implements__clause_already_seen);
                        return true;
                    }
                    seenImplementsClause = true;
                }
                heritageClauseFullStart += heritageClause.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                var declareToken = this.getToken(modifiers, TypeScript.SyntaxKind.DeclareKeyword);
                if (declareToken) {
                    this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, TypeScript.DiagnosticCode._declare__modifier_not_allowed_for_code_already_in_an_ambient_context);
                    return true;
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, typeKeyword, modifiers) {
            if (!this.inAmbientDeclaration && this.isDeclaration) {
                if (!this.containsToken(modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                    this.pushDiagnostic1(this.childFullStart(moduleElement, typeKeyword), typeKeyword.firstToken(), TypeScript.DiagnosticCode._declare__modifier_required_for_top_level_element);
                    return true;
                }
            }
        };
        GrammarCheckerWalker.prototype.checkFunctionOverloads = function (node, moduleElements) {
            if (!this.inAmbientDeclaration && !this.isDeclaration) {
                var moduleElementFullStart = this.childFullStart(node, moduleElements);
                var inFunctionOverloadChain = false;
                var functionOverloadChainName = null;
                for(var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var moduleElement = moduleElements.childAt(i);
                    var lastElement = i === (n - 1);
                    if (inFunctionOverloadChain) {
                        if (moduleElement.kind() !== TypeScript.SyntaxKind.FunctionDeclaration) {
                            this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                        var functionDeclaration = moduleElement;
                        if (functionDeclaration.identifier.valueText() !== functionOverloadChainName) {
                            var identifierFullStart = moduleElementFullStart + TypeScript.Syntax.childOffset(moduleElement, functionDeclaration.identifier);
                            this.pushDiagnostic1(identifierFullStart, functionDeclaration.identifier, TypeScript.DiagnosticCode.Function_overload_name_must_be__0_, [
                                functionOverloadChainName
                            ]);
                            return true;
                        }
                    }
                    if (moduleElement.kind() === TypeScript.SyntaxKind.FunctionDeclaration) {
                        functionDeclaration = moduleElement;
                        if (!this.containsToken(functionDeclaration.modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                            inFunctionOverloadChain = functionDeclaration.block === null;
                            functionOverloadChainName = functionDeclaration.identifier.valueText();
                            if (lastElement && inFunctionOverloadChain) {
                                this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                                return true;
                            }
                        } else {
                            inFunctionOverloadChain = false;
                            functionOverloadChainName = "";
                        }
                    }
                    moduleElementFullStart += moduleElement.fullWidth();
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkClassOverloads = function (node) {
            if (!this.inAmbientDeclaration && !this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                var classElementFullStart = this.childFullStart(node, node.classElements);
                var inFunctionOverloadChain = false;
                var inConstructorOverloadChain = false;
                var functionOverloadChainName = null;
                var memberFunctionDeclaration = null;
                for(var i = 0, n = node.classElements.childCount(); i < n; i++) {
                    var classElement = node.classElements.childAt(i);
                    var lastElement = i === (n - 1);
                    if (inFunctionOverloadChain) {
                        if (classElement.kind() !== TypeScript.SyntaxKind.MemberFunctionDeclaration) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                        memberFunctionDeclaration = classElement;
                        if (memberFunctionDeclaration.propertyName.valueText() !== functionOverloadChainName) {
                            var propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, TypeScript.DiagnosticCode.Function_overload_name_must_be__0_, [
                                functionOverloadChainName
                            ]);
                            return true;
                        }
                    } else if (inConstructorOverloadChain) {
                        if (classElement.kind() !== TypeScript.SyntaxKind.ConstructorDeclaration) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }
                    if (classElement.kind() === TypeScript.SyntaxKind.MemberFunctionDeclaration) {
                        memberFunctionDeclaration = classElement;
                        inFunctionOverloadChain = memberFunctionDeclaration.block === null;
                        functionOverloadChainName = memberFunctionDeclaration.propertyName.valueText();
                        if (lastElement && inFunctionOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                    } else if (classElement.kind() === TypeScript.SyntaxKind.ConstructorDeclaration) {
                        var constructorDeclaration = classElement;
                        inConstructorOverloadChain = constructorDeclaration.block === null;
                        if (lastElement && inConstructorOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }
                    classElementFullStart += classElement.fullWidth();
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.classKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkClassDeclarationHeritageClauses(node) || this.checkClassOverloads(node)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.isDeclaration || this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);
            var seenExtendsClause = false;
            for(var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses.childAt(i);
                if (heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode._extends__clause_already_seen);
                        return true;
                    }
                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword);
                    this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Interface_declaration_cannot_have__implements__clause);
                    return true;
                }
                heritageClauseFullStart += heritageClause.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            var modifierFullStart = this.position();
            for(var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === TypeScript.SyntaxKind.DeclareKeyword) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._declare__modifier_cannot_appear_on_an_interface_declaration);
                    return true;
                }
                modifierFullStart += modifier.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkInterfaceModifiers(node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkInterfaceDeclarationHeritageClauses(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var modifierFullStart = this.position();
            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;
            for(var i = 0, n = list.childCount(); i < n; i++) {
                var modifier = list.childAt(i);
                if (modifier.tokenKind === TypeScript.SyntaxKind.PublicKeyword || modifier.tokenKind === TypeScript.SyntaxKind.PrivateKeyword) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }
                    if (seenStaticModifier) {
                        var previousToken = list.childAt(i - 1);
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0__modifier_must_precede__1__modifier, [
                            modifier.text(), 
                            previousToken.text()
                        ]);
                        return true;
                    }
                    seenAccessibilityModifier = true;
                } else if (modifier.tokenKind === TypeScript.SyntaxKind.StaticKeyword) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0__modifier_already_seen, [
                            modifier.text()
                        ]);
                        return true;
                    }
                    seenStaticModifier = true;
                } else {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0__modifier_cannot_appear_on_a_class_element, [
                        modifier.text()
                    ]);
                    return true;
                }
                modifierFullStart += modifier.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkGetMemberAccessorParameter = function (node) {
            var getKeywordFullStart = this.childFullStart(node, node.getKeyword);
            if (node.parameterList.parameters.childCount() !== 0) {
                this.pushDiagnostic1(getKeywordFullStart, node.getKeyword, TypeScript.DiagnosticCode._get__accessor_cannot_have_parameters);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) || this.checkGetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitGetMemberAccessorDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkSetMemberAccessorParameter = function (node) {
            var setKeywordFullStart = this.childFullStart(node, node.setKeyword);
            if (node.parameterList.parameters.childCount() !== 1) {
                this.pushDiagnostic1(setKeywordFullStart, node.setKeyword, TypeScript.DiagnosticCode._set__accessor_must_have_only_one_parameter);
                return true;
            }
            var parameterListFullStart = this.childFullStart(node, node.parameterList);
            var parameterFullStart = parameterListFullStart + TypeScript.Syntax.childOffset(node.parameterList, node.parameterList.openParenToken);
            var parameter = node.parameterList.parameters.childAt(0);
            if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode._set__accessor_parameter_cannot_have_accessibility_modifier);
                return true;
            }
            if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode._set__accessor_parameter_cannot_be_optional);
                return true;
            }
            if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode._set__accessor_parameter_cannot_have_initializer);
                return true;
            }
            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode._set__accessor_cannot_have_rest_parameter);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers) || this.checkSetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitSetMemberAccessorDeclaration.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkEnumDeclarationElements = function (node) {
            var enumElementFullStart = this.childFullStart(node, node.enumElements);
            var seenExplicitMember = false;
            for(var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                var nodeOrToken = node.enumElements.childAt(i);
                if (i % 2 === 0) {
                    var enumElement = nodeOrToken;
                    if (enumElement.equalsValueClause) {
                        seenExplicitMember = true;
                    } else if (seenExplicitMember) {
                        this.pushDiagnostic1(enumElementFullStart, enumElement, TypeScript.DiagnosticCode.Enum_element_must_have_initializer);
                        return true;
                    }
                }
                enumElementFullStart += nodeOrToken.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.enumKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkEnumDeclarationElements(node)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.isDeclaration || this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind() === TypeScript.SyntaxKind.SuperKeyword && node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode._super__invocation_cannot_have_type_arguments);
            }
            _super.prototype.visitInvocationExpression.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var modifierFullStart = this.position();
            var seenExportModifier = false;
            var seenDeclareModifier = false;
            for(var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === TypeScript.SyntaxKind.PublicKeyword || modifier.tokenKind === TypeScript.SyntaxKind.PrivateKeyword || modifier.tokenKind === TypeScript.SyntaxKind.StaticKeyword) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0__modifier_cannot_appear_on_a_module_element, [
                        modifier.text()
                    ]);
                    return true;
                }
                if (modifier.tokenKind === TypeScript.SyntaxKind.DeclareKeyword) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }
                    seenDeclareModifier = true;
                } else if (modifier.tokenKind === TypeScript.SyntaxKind.ExportKeyword) {
                    if (seenExportModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0__modifier_already_seen, [
                            modifier.text()
                        ]);
                        return;
                    }
                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0__modifier_must_precede__1__modifier, [
                            TypeScript.SyntaxFacts.getText(TypeScript.SyntaxKind.ExportKeyword), 
                            TypeScript.SyntaxFacts.getText(TypeScript.SyntaxKind.DeclareKeyword)
                        ]);
                        return;
                    }
                    seenExportModifier = true;
                }
                modifierFullStart += modifier.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            if (node.stringLiteral === null) {
                var currentElementFullStart = this.childFullStart(node, node.moduleElements);
                for(var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                    var child = node.moduleElements.childAt(i);
                    if (child.kind() === TypeScript.SyntaxKind.ImportDeclaration) {
                        var importDeclaration = child;
                        if (importDeclaration.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                            this.pushDiagnostic1(currentElementFullStart, importDeclaration, TypeScript.DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module, null);
                        }
                    }
                    currentElementFullStart += child.fullWidth();
                }
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.moduleKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedImportDeclaration(node) || (!this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword) && this.checkFunctionOverloads(node, node.moduleElements))) {
                this.skip(node);
                return;
            }
            if (node.stringLiteral && !this.inAmbientDeclaration && !this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword)) {
                var stringLiteralFullStart = this.childFullStart(node, node.stringLiteral);
                this.pushDiagnostic1(stringLiteralFullStart, node.stringLiteral, TypeScript.DiagnosticCode.Non_ambient_modules_cannot_use_quoted_names);
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.isDeclaration || this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.inAmbientDeclaration || this.isDeclaration) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Implementations_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }
            if (this.checkFunctionOverloads(node, node.statements)) {
                this.skip(node);
                return;
            }
            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };
        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.isDeclaration) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitBreakStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitContinueStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitDebuggerStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitDoStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitEmptyStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitExpressionStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitForInStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitForStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitIfStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitLabeledStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitReturnStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitSwitchStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitThrowStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitTryStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitWhileStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitWithStatement.call(this, node);
        };
        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (parent, modifiers) {
            if (this.inBlock && modifiers.childCount() > 0) {
                var modifierFullStart = this.childFullStart(parent, modifiers);
                this.pushDiagnostic1(modifierFullStart, modifiers.childAt(0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.functionKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.isDeclaration || this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.variableDeclaration, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.isDeclaration || this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.checkListSeparators = function (parent, list, kind) {
            var currentElementFullStart = this.childFullStart(parent, list);
            for(var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode._0_expected, [
                        TypeScript.SyntaxFacts.getText(kind)
                    ]);
                }
                currentElementFullStart += child.fullWidth();
            }
            return false;
        };
        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node, node.typeMembers, TypeScript.SyntaxKind.SemicolonToken)) {
                this.skip(node);
                return;
            }
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };
        GrammarCheckerWalker.prototype.visitEqualsValueClause = function (node) {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }
            _super.prototype.visitEqualsValueClause.call(this, node);
        };
        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            var savedCurrentConstructor = this.currentConstructor;
            this.currentConstructor = node;
            _super.prototype.visitConstructorDeclaration.call(this, node);
            this.currentConstructor = savedCurrentConstructor;
        };
        GrammarCheckerWalker.prototype.visitSourceUnit = function (node) {
            if (this.checkFunctionOverloads(node, node.moduleElements)) {
                this.skip(node);
                return;
            }
            _super.prototype.visitSourceUnit.call(this, node);
        };
        return GrammarCheckerWalker;
    })(TypeScript.PositionTrackingWalker);    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpanWalker = (function (_super) {
        __extends(TextSpanWalker, _super);
        function TextSpanWalker(textSpan) {
            _super.call(this);
            this.textSpan = textSpan;
            this._position = 0;
        }
        TextSpanWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };
        TextSpanWalker.prototype.visitNode = function (node) {
            var nodeSpan = new TypeScript.TextSpan(this.position(), node.fullWidth());
            if (nodeSpan.intersectsWithTextSpan(this.textSpan)) {
                node.accept(this);
            } else {
                this._position += node.fullWidth();
            }
        };
        TextSpanWalker.prototype.position = function () {
            return this._position;
        };
        return TextSpanWalker;
    })(TypeScript.SyntaxWalker);    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() { }
        Unicode.unicodeES3IdentifierStart = [
            170, 
            170, 
            181, 
            181, 
            186, 
            186, 
            192, 
            214, 
            216, 
            246, 
            248, 
            543, 
            546, 
            563, 
            592, 
            685, 
            688, 
            696, 
            699, 
            705, 
            720, 
            721, 
            736, 
            740, 
            750, 
            750, 
            890, 
            890, 
            902, 
            902, 
            904, 
            906, 
            908, 
            908, 
            910, 
            929, 
            931, 
            974, 
            976, 
            983, 
            986, 
            1011, 
            1024, 
            1153, 
            1164, 
            1220, 
            1223, 
            1224, 
            1227, 
            1228, 
            1232, 
            1269, 
            1272, 
            1273, 
            1329, 
            1366, 
            1369, 
            1369, 
            1377, 
            1415, 
            1488, 
            1514, 
            1520, 
            1522, 
            1569, 
            1594, 
            1600, 
            1610, 
            1649, 
            1747, 
            1749, 
            1749, 
            1765, 
            1766, 
            1786, 
            1788, 
            1808, 
            1808, 
            1810, 
            1836, 
            1920, 
            1957, 
            2309, 
            2361, 
            2365, 
            2365, 
            2384, 
            2384, 
            2392, 
            2401, 
            2437, 
            2444, 
            2447, 
            2448, 
            2451, 
            2472, 
            2474, 
            2480, 
            2482, 
            2482, 
            2486, 
            2489, 
            2524, 
            2525, 
            2527, 
            2529, 
            2544, 
            2545, 
            2565, 
            2570, 
            2575, 
            2576, 
            2579, 
            2600, 
            2602, 
            2608, 
            2610, 
            2611, 
            2613, 
            2614, 
            2616, 
            2617, 
            2649, 
            2652, 
            2654, 
            2654, 
            2674, 
            2676, 
            2693, 
            2699, 
            2701, 
            2701, 
            2703, 
            2705, 
            2707, 
            2728, 
            2730, 
            2736, 
            2738, 
            2739, 
            2741, 
            2745, 
            2749, 
            2749, 
            2768, 
            2768, 
            2784, 
            2784, 
            2821, 
            2828, 
            2831, 
            2832, 
            2835, 
            2856, 
            2858, 
            2864, 
            2866, 
            2867, 
            2870, 
            2873, 
            2877, 
            2877, 
            2908, 
            2909, 
            2911, 
            2913, 
            2949, 
            2954, 
            2958, 
            2960, 
            2962, 
            2965, 
            2969, 
            2970, 
            2972, 
            2972, 
            2974, 
            2975, 
            2979, 
            2980, 
            2984, 
            2986, 
            2990, 
            2997, 
            2999, 
            3001, 
            3077, 
            3084, 
            3086, 
            3088, 
            3090, 
            3112, 
            3114, 
            3123, 
            3125, 
            3129, 
            3168, 
            3169, 
            3205, 
            3212, 
            3214, 
            3216, 
            3218, 
            3240, 
            3242, 
            3251, 
            3253, 
            3257, 
            3294, 
            3294, 
            3296, 
            3297, 
            3333, 
            3340, 
            3342, 
            3344, 
            3346, 
            3368, 
            3370, 
            3385, 
            3424, 
            3425, 
            3461, 
            3478, 
            3482, 
            3505, 
            3507, 
            3515, 
            3517, 
            3517, 
            3520, 
            3526, 
            3585, 
            3632, 
            3634, 
            3635, 
            3648, 
            3654, 
            3713, 
            3714, 
            3716, 
            3716, 
            3719, 
            3720, 
            3722, 
            3722, 
            3725, 
            3725, 
            3732, 
            3735, 
            3737, 
            3743, 
            3745, 
            3747, 
            3749, 
            3749, 
            3751, 
            3751, 
            3754, 
            3755, 
            3757, 
            3760, 
            3762, 
            3763, 
            3773, 
            3773, 
            3776, 
            3780, 
            3782, 
            3782, 
            3804, 
            3805, 
            3840, 
            3840, 
            3904, 
            3911, 
            3913, 
            3946, 
            3976, 
            3979, 
            4096, 
            4129, 
            4131, 
            4135, 
            4137, 
            4138, 
            4176, 
            4181, 
            4256, 
            4293, 
            4304, 
            4342, 
            4352, 
            4441, 
            4447, 
            4514, 
            4520, 
            4601, 
            4608, 
            4614, 
            4616, 
            4678, 
            4680, 
            4680, 
            4682, 
            4685, 
            4688, 
            4694, 
            4696, 
            4696, 
            4698, 
            4701, 
            4704, 
            4742, 
            4744, 
            4744, 
            4746, 
            4749, 
            4752, 
            4782, 
            4784, 
            4784, 
            4786, 
            4789, 
            4792, 
            4798, 
            4800, 
            4800, 
            4802, 
            4805, 
            4808, 
            4814, 
            4816, 
            4822, 
            4824, 
            4846, 
            4848, 
            4878, 
            4880, 
            4880, 
            4882, 
            4885, 
            4888, 
            4894, 
            4896, 
            4934, 
            4936, 
            4954, 
            5024, 
            5108, 
            5121, 
            5740, 
            5743, 
            5750, 
            5761, 
            5786, 
            5792, 
            5866, 
            6016, 
            6067, 
            6176, 
            6263, 
            6272, 
            6312, 
            7680, 
            7835, 
            7840, 
            7929, 
            7936, 
            7957, 
            7960, 
            7965, 
            7968, 
            8005, 
            8008, 
            8013, 
            8016, 
            8023, 
            8025, 
            8025, 
            8027, 
            8027, 
            8029, 
            8029, 
            8031, 
            8061, 
            8064, 
            8116, 
            8118, 
            8124, 
            8126, 
            8126, 
            8130, 
            8132, 
            8134, 
            8140, 
            8144, 
            8147, 
            8150, 
            8155, 
            8160, 
            8172, 
            8178, 
            8180, 
            8182, 
            8188, 
            8319, 
            8319, 
            8450, 
            8450, 
            8455, 
            8455, 
            8458, 
            8467, 
            8469, 
            8469, 
            8473, 
            8477, 
            8484, 
            8484, 
            8486, 
            8486, 
            8488, 
            8488, 
            8490, 
            8493, 
            8495, 
            8497, 
            8499, 
            8505, 
            8544, 
            8579, 
            12293, 
            12295, 
            12321, 
            12329, 
            12337, 
            12341, 
            12344, 
            12346, 
            12353, 
            12436, 
            12445, 
            12446, 
            12449, 
            12538, 
            12540, 
            12542, 
            12549, 
            12588, 
            12593, 
            12686, 
            12704, 
            12727, 
            13312, 
            13312, 
            19893, 
            19893, 
            19968, 
            19968, 
            40869, 
            40869, 
            40960, 
            42124, 
            44032, 
            44032, 
            55203, 
            55203, 
            63744, 
            64045, 
            64256, 
            64262, 
            64275, 
            64279, 
            64285, 
            64285, 
            64287, 
            64296, 
            64298, 
            64310, 
            64312, 
            64316, 
            64318, 
            64318, 
            64320, 
            64321, 
            64323, 
            64324, 
            64326, 
            64433, 
            64467, 
            64829, 
            64848, 
            64911, 
            64914, 
            64967, 
            65008, 
            65019, 
            65136, 
            65138, 
            65140, 
            65140, 
            65142, 
            65276, 
            65313, 
            65338, 
            65345, 
            65370, 
            65382, 
            65470, 
            65474, 
            65479, 
            65482, 
            65487, 
            65490, 
            65495, 
            65498, 
            65500
        ];
        Unicode.unicodeES3IdentifierPart = [
            768, 
            846, 
            864, 
            866, 
            1155, 
            1158, 
            1425, 
            1441, 
            1443, 
            1465, 
            1467, 
            1469, 
            1471, 
            1471, 
            1473, 
            1474, 
            1476, 
            1476, 
            1611, 
            1621, 
            1632, 
            1641, 
            1648, 
            1648, 
            1750, 
            1756, 
            1759, 
            1764, 
            1767, 
            1768, 
            1770, 
            1773, 
            1776, 
            1785, 
            1809, 
            1809, 
            1840, 
            1866, 
            1958, 
            1968, 
            2305, 
            2307, 
            2364, 
            2364, 
            2366, 
            2381, 
            2385, 
            2388, 
            2402, 
            2403, 
            2406, 
            2415, 
            2433, 
            2435, 
            2492, 
            2492, 
            2494, 
            2500, 
            2503, 
            2504, 
            2507, 
            2509, 
            2519, 
            2519, 
            2530, 
            2531, 
            2534, 
            2543, 
            2562, 
            2562, 
            2620, 
            2620, 
            2622, 
            2626, 
            2631, 
            2632, 
            2635, 
            2637, 
            2662, 
            2673, 
            2689, 
            2691, 
            2748, 
            2748, 
            2750, 
            2757, 
            2759, 
            2761, 
            2763, 
            2765, 
            2790, 
            2799, 
            2817, 
            2819, 
            2876, 
            2876, 
            2878, 
            2883, 
            2887, 
            2888, 
            2891, 
            2893, 
            2902, 
            2903, 
            2918, 
            2927, 
            2946, 
            2947, 
            3006, 
            3010, 
            3014, 
            3016, 
            3018, 
            3021, 
            3031, 
            3031, 
            3047, 
            3055, 
            3073, 
            3075, 
            3134, 
            3140, 
            3142, 
            3144, 
            3146, 
            3149, 
            3157, 
            3158, 
            3174, 
            3183, 
            3202, 
            3203, 
            3262, 
            3268, 
            3270, 
            3272, 
            3274, 
            3277, 
            3285, 
            3286, 
            3302, 
            3311, 
            3330, 
            3331, 
            3390, 
            3395, 
            3398, 
            3400, 
            3402, 
            3405, 
            3415, 
            3415, 
            3430, 
            3439, 
            3458, 
            3459, 
            3530, 
            3530, 
            3535, 
            3540, 
            3542, 
            3542, 
            3544, 
            3551, 
            3570, 
            3571, 
            3633, 
            3633, 
            3636, 
            3642, 
            3655, 
            3662, 
            3664, 
            3673, 
            3761, 
            3761, 
            3764, 
            3769, 
            3771, 
            3772, 
            3784, 
            3789, 
            3792, 
            3801, 
            3864, 
            3865, 
            3872, 
            3881, 
            3893, 
            3893, 
            3895, 
            3895, 
            3897, 
            3897, 
            3902, 
            3903, 
            3953, 
            3972, 
            3974, 
            3975, 
            3984, 
            3991, 
            3993, 
            4028, 
            4038, 
            4038, 
            4140, 
            4146, 
            4150, 
            4153, 
            4160, 
            4169, 
            4182, 
            4185, 
            4969, 
            4977, 
            6068, 
            6099, 
            6112, 
            6121, 
            6160, 
            6169, 
            6313, 
            6313, 
            8255, 
            8256, 
            8400, 
            8412, 
            8417, 
            8417, 
            12330, 
            12335, 
            12441, 
            12442, 
            12539, 
            12539, 
            64286, 
            64286, 
            65056, 
            65059, 
            65075, 
            65076, 
            65101, 
            65103, 
            65296, 
            65305, 
            65343, 
            65343, 
            65381, 
            65381
        ];
        Unicode.unicodeES5IdentifierStart = [
            170, 
            170, 
            181, 
            181, 
            186, 
            186, 
            192, 
            214, 
            216, 
            246, 
            248, 
            705, 
            710, 
            721, 
            736, 
            740, 
            748, 
            748, 
            750, 
            750, 
            880, 
            884, 
            886, 
            887, 
            890, 
            893, 
            902, 
            902, 
            904, 
            906, 
            908, 
            908, 
            910, 
            929, 
            931, 
            1013, 
            1015, 
            1153, 
            1162, 
            1319, 
            1329, 
            1366, 
            1369, 
            1369, 
            1377, 
            1415, 
            1488, 
            1514, 
            1520, 
            1522, 
            1568, 
            1610, 
            1646, 
            1647, 
            1649, 
            1747, 
            1749, 
            1749, 
            1765, 
            1766, 
            1774, 
            1775, 
            1786, 
            1788, 
            1791, 
            1791, 
            1808, 
            1808, 
            1810, 
            1839, 
            1869, 
            1957, 
            1969, 
            1969, 
            1994, 
            2026, 
            2036, 
            2037, 
            2042, 
            2042, 
            2048, 
            2069, 
            2074, 
            2074, 
            2084, 
            2084, 
            2088, 
            2088, 
            2112, 
            2136, 
            2208, 
            2208, 
            2210, 
            2220, 
            2308, 
            2361, 
            2365, 
            2365, 
            2384, 
            2384, 
            2392, 
            2401, 
            2417, 
            2423, 
            2425, 
            2431, 
            2437, 
            2444, 
            2447, 
            2448, 
            2451, 
            2472, 
            2474, 
            2480, 
            2482, 
            2482, 
            2486, 
            2489, 
            2493, 
            2493, 
            2510, 
            2510, 
            2524, 
            2525, 
            2527, 
            2529, 
            2544, 
            2545, 
            2565, 
            2570, 
            2575, 
            2576, 
            2579, 
            2600, 
            2602, 
            2608, 
            2610, 
            2611, 
            2613, 
            2614, 
            2616, 
            2617, 
            2649, 
            2652, 
            2654, 
            2654, 
            2674, 
            2676, 
            2693, 
            2701, 
            2703, 
            2705, 
            2707, 
            2728, 
            2730, 
            2736, 
            2738, 
            2739, 
            2741, 
            2745, 
            2749, 
            2749, 
            2768, 
            2768, 
            2784, 
            2785, 
            2821, 
            2828, 
            2831, 
            2832, 
            2835, 
            2856, 
            2858, 
            2864, 
            2866, 
            2867, 
            2869, 
            2873, 
            2877, 
            2877, 
            2908, 
            2909, 
            2911, 
            2913, 
            2929, 
            2929, 
            2947, 
            2947, 
            2949, 
            2954, 
            2958, 
            2960, 
            2962, 
            2965, 
            2969, 
            2970, 
            2972, 
            2972, 
            2974, 
            2975, 
            2979, 
            2980, 
            2984, 
            2986, 
            2990, 
            3001, 
            3024, 
            3024, 
            3077, 
            3084, 
            3086, 
            3088, 
            3090, 
            3112, 
            3114, 
            3123, 
            3125, 
            3129, 
            3133, 
            3133, 
            3160, 
            3161, 
            3168, 
            3169, 
            3205, 
            3212, 
            3214, 
            3216, 
            3218, 
            3240, 
            3242, 
            3251, 
            3253, 
            3257, 
            3261, 
            3261, 
            3294, 
            3294, 
            3296, 
            3297, 
            3313, 
            3314, 
            3333, 
            3340, 
            3342, 
            3344, 
            3346, 
            3386, 
            3389, 
            3389, 
            3406, 
            3406, 
            3424, 
            3425, 
            3450, 
            3455, 
            3461, 
            3478, 
            3482, 
            3505, 
            3507, 
            3515, 
            3517, 
            3517, 
            3520, 
            3526, 
            3585, 
            3632, 
            3634, 
            3635, 
            3648, 
            3654, 
            3713, 
            3714, 
            3716, 
            3716, 
            3719, 
            3720, 
            3722, 
            3722, 
            3725, 
            3725, 
            3732, 
            3735, 
            3737, 
            3743, 
            3745, 
            3747, 
            3749, 
            3749, 
            3751, 
            3751, 
            3754, 
            3755, 
            3757, 
            3760, 
            3762, 
            3763, 
            3773, 
            3773, 
            3776, 
            3780, 
            3782, 
            3782, 
            3804, 
            3807, 
            3840, 
            3840, 
            3904, 
            3911, 
            3913, 
            3948, 
            3976, 
            3980, 
            4096, 
            4138, 
            4159, 
            4159, 
            4176, 
            4181, 
            4186, 
            4189, 
            4193, 
            4193, 
            4197, 
            4198, 
            4206, 
            4208, 
            4213, 
            4225, 
            4238, 
            4238, 
            4256, 
            4293, 
            4295, 
            4295, 
            4301, 
            4301, 
            4304, 
            4346, 
            4348, 
            4680, 
            4682, 
            4685, 
            4688, 
            4694, 
            4696, 
            4696, 
            4698, 
            4701, 
            4704, 
            4744, 
            4746, 
            4749, 
            4752, 
            4784, 
            4786, 
            4789, 
            4792, 
            4798, 
            4800, 
            4800, 
            4802, 
            4805, 
            4808, 
            4822, 
            4824, 
            4880, 
            4882, 
            4885, 
            4888, 
            4954, 
            4992, 
            5007, 
            5024, 
            5108, 
            5121, 
            5740, 
            5743, 
            5759, 
            5761, 
            5786, 
            5792, 
            5866, 
            5870, 
            5872, 
            5888, 
            5900, 
            5902, 
            5905, 
            5920, 
            5937, 
            5952, 
            5969, 
            5984, 
            5996, 
            5998, 
            6000, 
            6016, 
            6067, 
            6103, 
            6103, 
            6108, 
            6108, 
            6176, 
            6263, 
            6272, 
            6312, 
            6314, 
            6314, 
            6320, 
            6389, 
            6400, 
            6428, 
            6480, 
            6509, 
            6512, 
            6516, 
            6528, 
            6571, 
            6593, 
            6599, 
            6656, 
            6678, 
            6688, 
            6740, 
            6823, 
            6823, 
            6917, 
            6963, 
            6981, 
            6987, 
            7043, 
            7072, 
            7086, 
            7087, 
            7098, 
            7141, 
            7168, 
            7203, 
            7245, 
            7247, 
            7258, 
            7293, 
            7401, 
            7404, 
            7406, 
            7409, 
            7413, 
            7414, 
            7424, 
            7615, 
            7680, 
            7957, 
            7960, 
            7965, 
            7968, 
            8005, 
            8008, 
            8013, 
            8016, 
            8023, 
            8025, 
            8025, 
            8027, 
            8027, 
            8029, 
            8029, 
            8031, 
            8061, 
            8064, 
            8116, 
            8118, 
            8124, 
            8126, 
            8126, 
            8130, 
            8132, 
            8134, 
            8140, 
            8144, 
            8147, 
            8150, 
            8155, 
            8160, 
            8172, 
            8178, 
            8180, 
            8182, 
            8188, 
            8305, 
            8305, 
            8319, 
            8319, 
            8336, 
            8348, 
            8450, 
            8450, 
            8455, 
            8455, 
            8458, 
            8467, 
            8469, 
            8469, 
            8473, 
            8477, 
            8484, 
            8484, 
            8486, 
            8486, 
            8488, 
            8488, 
            8490, 
            8493, 
            8495, 
            8505, 
            8508, 
            8511, 
            8517, 
            8521, 
            8526, 
            8526, 
            8544, 
            8584, 
            11264, 
            11310, 
            11312, 
            11358, 
            11360, 
            11492, 
            11499, 
            11502, 
            11506, 
            11507, 
            11520, 
            11557, 
            11559, 
            11559, 
            11565, 
            11565, 
            11568, 
            11623, 
            11631, 
            11631, 
            11648, 
            11670, 
            11680, 
            11686, 
            11688, 
            11694, 
            11696, 
            11702, 
            11704, 
            11710, 
            11712, 
            11718, 
            11720, 
            11726, 
            11728, 
            11734, 
            11736, 
            11742, 
            11823, 
            11823, 
            12293, 
            12295, 
            12321, 
            12329, 
            12337, 
            12341, 
            12344, 
            12348, 
            12353, 
            12438, 
            12445, 
            12447, 
            12449, 
            12538, 
            12540, 
            12543, 
            12549, 
            12589, 
            12593, 
            12686, 
            12704, 
            12730, 
            12784, 
            12799, 
            13312, 
            13312, 
            19893, 
            19893, 
            19968, 
            19968, 
            40908, 
            40908, 
            40960, 
            42124, 
            42192, 
            42237, 
            42240, 
            42508, 
            42512, 
            42527, 
            42538, 
            42539, 
            42560, 
            42606, 
            42623, 
            42647, 
            42656, 
            42735, 
            42775, 
            42783, 
            42786, 
            42888, 
            42891, 
            42894, 
            42896, 
            42899, 
            42912, 
            42922, 
            43000, 
            43009, 
            43011, 
            43013, 
            43015, 
            43018, 
            43020, 
            43042, 
            43072, 
            43123, 
            43138, 
            43187, 
            43250, 
            43255, 
            43259, 
            43259, 
            43274, 
            43301, 
            43312, 
            43334, 
            43360, 
            43388, 
            43396, 
            43442, 
            43471, 
            43471, 
            43520, 
            43560, 
            43584, 
            43586, 
            43588, 
            43595, 
            43616, 
            43638, 
            43642, 
            43642, 
            43648, 
            43695, 
            43697, 
            43697, 
            43701, 
            43702, 
            43705, 
            43709, 
            43712, 
            43712, 
            43714, 
            43714, 
            43739, 
            43741, 
            43744, 
            43754, 
            43762, 
            43764, 
            43777, 
            43782, 
            43785, 
            43790, 
            43793, 
            43798, 
            43808, 
            43814, 
            43816, 
            43822, 
            43968, 
            44002, 
            44032, 
            44032, 
            55203, 
            55203, 
            55216, 
            55238, 
            55243, 
            55291, 
            63744, 
            64109, 
            64112, 
            64217, 
            64256, 
            64262, 
            64275, 
            64279, 
            64285, 
            64285, 
            64287, 
            64296, 
            64298, 
            64310, 
            64312, 
            64316, 
            64318, 
            64318, 
            64320, 
            64321, 
            64323, 
            64324, 
            64326, 
            64433, 
            64467, 
            64829, 
            64848, 
            64911, 
            64914, 
            64967, 
            65008, 
            65019, 
            65136, 
            65140, 
            65142, 
            65276, 
            65313, 
            65338, 
            65345, 
            65370, 
            65382, 
            65470, 
            65474, 
            65479, 
            65482, 
            65487, 
            65490, 
            65495, 
            65498, 
            65500
        ];
        Unicode.unicodeES5IdentifierPart = [
            768, 
            879, 
            1155, 
            1159, 
            1425, 
            1469, 
            1471, 
            1471, 
            1473, 
            1474, 
            1476, 
            1477, 
            1479, 
            1479, 
            1552, 
            1562, 
            1611, 
            1641, 
            1648, 
            1648, 
            1750, 
            1756, 
            1759, 
            1764, 
            1767, 
            1768, 
            1770, 
            1773, 
            1776, 
            1785, 
            1809, 
            1809, 
            1840, 
            1866, 
            1958, 
            1968, 
            1984, 
            1993, 
            2027, 
            2035, 
            2070, 
            2073, 
            2075, 
            2083, 
            2085, 
            2087, 
            2089, 
            2093, 
            2137, 
            2139, 
            2276, 
            2302, 
            2304, 
            2307, 
            2362, 
            2364, 
            2366, 
            2383, 
            2385, 
            2391, 
            2402, 
            2403, 
            2406, 
            2415, 
            2433, 
            2435, 
            2492, 
            2492, 
            2494, 
            2500, 
            2503, 
            2504, 
            2507, 
            2509, 
            2519, 
            2519, 
            2530, 
            2531, 
            2534, 
            2543, 
            2561, 
            2563, 
            2620, 
            2620, 
            2622, 
            2626, 
            2631, 
            2632, 
            2635, 
            2637, 
            2641, 
            2641, 
            2662, 
            2673, 
            2677, 
            2677, 
            2689, 
            2691, 
            2748, 
            2748, 
            2750, 
            2757, 
            2759, 
            2761, 
            2763, 
            2765, 
            2786, 
            2787, 
            2790, 
            2799, 
            2817, 
            2819, 
            2876, 
            2876, 
            2878, 
            2884, 
            2887, 
            2888, 
            2891, 
            2893, 
            2902, 
            2903, 
            2914, 
            2915, 
            2918, 
            2927, 
            2946, 
            2946, 
            3006, 
            3010, 
            3014, 
            3016, 
            3018, 
            3021, 
            3031, 
            3031, 
            3046, 
            3055, 
            3073, 
            3075, 
            3134, 
            3140, 
            3142, 
            3144, 
            3146, 
            3149, 
            3157, 
            3158, 
            3170, 
            3171, 
            3174, 
            3183, 
            3202, 
            3203, 
            3260, 
            3260, 
            3262, 
            3268, 
            3270, 
            3272, 
            3274, 
            3277, 
            3285, 
            3286, 
            3298, 
            3299, 
            3302, 
            3311, 
            3330, 
            3331, 
            3390, 
            3396, 
            3398, 
            3400, 
            3402, 
            3405, 
            3415, 
            3415, 
            3426, 
            3427, 
            3430, 
            3439, 
            3458, 
            3459, 
            3530, 
            3530, 
            3535, 
            3540, 
            3542, 
            3542, 
            3544, 
            3551, 
            3570, 
            3571, 
            3633, 
            3633, 
            3636, 
            3642, 
            3655, 
            3662, 
            3664, 
            3673, 
            3761, 
            3761, 
            3764, 
            3769, 
            3771, 
            3772, 
            3784, 
            3789, 
            3792, 
            3801, 
            3864, 
            3865, 
            3872, 
            3881, 
            3893, 
            3893, 
            3895, 
            3895, 
            3897, 
            3897, 
            3902, 
            3903, 
            3953, 
            3972, 
            3974, 
            3975, 
            3981, 
            3991, 
            3993, 
            4028, 
            4038, 
            4038, 
            4139, 
            4158, 
            4160, 
            4169, 
            4182, 
            4185, 
            4190, 
            4192, 
            4194, 
            4196, 
            4199, 
            4205, 
            4209, 
            4212, 
            4226, 
            4237, 
            4239, 
            4253, 
            4957, 
            4959, 
            5906, 
            5908, 
            5938, 
            5940, 
            5970, 
            5971, 
            6002, 
            6003, 
            6068, 
            6099, 
            6109, 
            6109, 
            6112, 
            6121, 
            6155, 
            6157, 
            6160, 
            6169, 
            6313, 
            6313, 
            6432, 
            6443, 
            6448, 
            6459, 
            6470, 
            6479, 
            6576, 
            6592, 
            6600, 
            6601, 
            6608, 
            6617, 
            6679, 
            6683, 
            6741, 
            6750, 
            6752, 
            6780, 
            6783, 
            6793, 
            6800, 
            6809, 
            6912, 
            6916, 
            6964, 
            6980, 
            6992, 
            7001, 
            7019, 
            7027, 
            7040, 
            7042, 
            7073, 
            7085, 
            7088, 
            7097, 
            7142, 
            7155, 
            7204, 
            7223, 
            7232, 
            7241, 
            7248, 
            7257, 
            7376, 
            7378, 
            7380, 
            7400, 
            7405, 
            7405, 
            7410, 
            7412, 
            7616, 
            7654, 
            7676, 
            7679, 
            8204, 
            8205, 
            8255, 
            8256, 
            8276, 
            8276, 
            8400, 
            8412, 
            8417, 
            8417, 
            8421, 
            8432, 
            11503, 
            11505, 
            11647, 
            11647, 
            11744, 
            11775, 
            12330, 
            12335, 
            12441, 
            12442, 
            42528, 
            42537, 
            42607, 
            42607, 
            42612, 
            42621, 
            42655, 
            42655, 
            42736, 
            42737, 
            43010, 
            43010, 
            43014, 
            43014, 
            43019, 
            43019, 
            43043, 
            43047, 
            43136, 
            43137, 
            43188, 
            43204, 
            43216, 
            43225, 
            43232, 
            43249, 
            43264, 
            43273, 
            43302, 
            43309, 
            43335, 
            43347, 
            43392, 
            43395, 
            43443, 
            43456, 
            43472, 
            43481, 
            43561, 
            43574, 
            43587, 
            43587, 
            43596, 
            43597, 
            43600, 
            43609, 
            43643, 
            43643, 
            43696, 
            43696, 
            43698, 
            43700, 
            43703, 
            43704, 
            43710, 
            43711, 
            43713, 
            43713, 
            43755, 
            43759, 
            43765, 
            43766, 
            44003, 
            44010, 
            44012, 
            44013, 
            44016, 
            44025, 
            64286, 
            64286, 
            65024, 
            65039, 
            65056, 
            65062, 
            65075, 
            65076, 
            65101, 
            65103, 
            65296, 
            65305, 
            65343, 
            65343
        ];
        Unicode.lookupInUnicodeMap = function lookupInUnicodeMap(code, map) {
            if (code < map[0]) {
                return false;
            }
            var lo = 0;
            var hi = map.length;
            var mid;
            while(lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;
                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }
                if (code < map[mid]) {
                    hi = mid;
                } else {
                    lo = mid + 2;
                }
            }
            return false;
        };
        Unicode.isIdentifierStart = function isIdentifierStart(code, languageVersion) {
            if (languageVersion === TypeScript.LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            } else if (languageVersion === TypeScript.LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.isIdentifierPart = function isIdentifierPart(code, languageVersion) {
            if (languageVersion === TypeScript.LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            } else if (languageVersion === TypeScript.LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        return Unicode;
    })();
    TypeScript.Unicode = Unicode;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DataMap = (function () {
        function DataMap() {
            this.map = {};
        }
        DataMap.prototype.link = function (id, data) {
            this.map[id] = data;
        };
        DataMap.prototype.unlink = function (id) {
            this.map[id] = undefined;
        };
        DataMap.prototype.read = function (id) {
            return this.map[id];
        };
        DataMap.prototype.flush = function () {
            this.map = {};
        };
        DataMap.prototype.unpatch = function () {
            return null;
        };
        return DataMap;
    })();
    TypeScript.DataMap = DataMap;    
    var PatchedDataMap = (function (_super) {
        __extends(PatchedDataMap, _super);
        function PatchedDataMap(parent) {
            _super.call(this);
            this.parent = parent;
            this.diffs = {};
        }
        PatchedDataMap.prototype.link = function (id, data) {
            this.diffs[id] = data;
        };
        PatchedDataMap.prototype.unlink = function (id) {
            this.diffs[id] = undefined;
        };
        PatchedDataMap.prototype.read = function (id) {
            var data = this.diffs[id];
            if (data) {
                return data;
            }
            return this.parent.read(id);
        };
        PatchedDataMap.prototype.flush = function () {
            this.diffs = {};
        };
        PatchedDataMap.prototype.unpatch = function () {
            this.flush();
            return this.parent;
        };
        return PatchedDataMap;
    })(DataMap);
    TypeScript.PatchedDataMap = PatchedDataMap;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullElementFlags) {
        PullElementFlags._map = [];
        PullElementFlags.None = 0;
        PullElementFlags.Exported = 1;
        PullElementFlags.Private = 1 << 1;
        PullElementFlags.Public = 1 << 2;
        PullElementFlags.Ambient = 1 << 3;
        PullElementFlags.Static = 1 << 4;
        PullElementFlags.GetAccessor = 1 << 5;
        PullElementFlags.SetAccessor = 1 << 6;
        PullElementFlags.Optional = 1 << 7;
        PullElementFlags.Call = 1 << 8;
        PullElementFlags.Constructor = 1 << 9;
        PullElementFlags.Index = 1 << 10;
        PullElementFlags.Signature = 1 << 11;
        PullElementFlags.Enum = 1 << 12;
        PullElementFlags.FatArrow = 1 << 13;
        PullElementFlags.ClassConstructorVariable = 1 << 14;
        PullElementFlags.InitializedModule = 1 << 15;
        PullElementFlags.InitializedDynamicModule = 1 << 16;
        PullElementFlags.MustCaptureThis = 1 << 17;
        PullElementFlags.Constant = 1 << 18;
        PullElementFlags.ExpressionElement = 1 << 19;
        PullElementFlags.DeclaredInAWithBlock = 1 << 20;
        PullElementFlags.ImplicitVariable = PullElementFlags.ClassConstructorVariable | PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule;
        PullElementFlags.SomeInitializedModule = PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule;
    })(TypeScript.PullElementFlags || (TypeScript.PullElementFlags = {}));
    var PullElementFlags = TypeScript.PullElementFlags;
    (function (PullElementKind) {
        PullElementKind._map = [];
        PullElementKind.None = 0;
        PullElementKind.Script = 1;
        PullElementKind.Global = 1 << 1;
        PullElementKind.Primitive = 1 << 2;
        PullElementKind.Container = 1 << 3;
        PullElementKind.Class = 1 << 4;
        PullElementKind.Interface = 1 << 5;
        PullElementKind.DynamicModule = 1 << 6;
        PullElementKind.Enum = 1 << 7;
        PullElementKind.Array = 1 << 8;
        PullElementKind.TypeAlias = 1 << 9;
        PullElementKind.ObjectLiteral = 1 << 10;
        PullElementKind.Variable = 1 << 11;
        PullElementKind.Parameter = 1 << 12;
        PullElementKind.Property = 1 << 13;
        PullElementKind.TypeParameter = 1 << 14;
        PullElementKind.Function = 1 << 15;
        PullElementKind.ConstructorMethod = 1 << 16;
        PullElementKind.Method = 1 << 17;
        PullElementKind.FunctionExpression = 1 << 18;
        PullElementKind.GetAccessor = 1 << 19;
        PullElementKind.SetAccessor = 1 << 20;
        PullElementKind.CallSignature = 1 << 21;
        PullElementKind.ConstructSignature = 1 << 22;
        PullElementKind.IndexSignature = 1 << 23;
        PullElementKind.ObjectType = 1 << 24;
        PullElementKind.FunctionType = 1 << 25;
        PullElementKind.ConstructorType = 1 << 26;
        PullElementKind.EnumMember = 1 << 27;
        PullElementKind.ErrorType = 1 << 28;
        PullElementKind.Expression = 1 << 29;
        PullElementKind.WithBlock = 1 << 30;
        PullElementKind.CatchBlock = 1 << 31;
        PullElementKind.All = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Container | PullElementKind.Class | PullElementKind.Interface | PullElementKind.DynamicModule | PullElementKind.Enum | PullElementKind.Array | PullElementKind.TypeAlias | PullElementKind.ObjectLiteral | PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.TypeParameter | PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.EnumMember | PullElementKind.ErrorType | PullElementKind.Expression | PullElementKind.WithBlock | PullElementKind.CatchBlock;
        PullElementKind.SomeFunction = PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature;
        PullElementKind.SomeValue = PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.EnumMember | PullElementKind.SomeFunction;
        PullElementKind.SomeType = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Container | PullElementKind.Class | PullElementKind.Interface | PullElementKind.DynamicModule | PullElementKind.Enum | PullElementKind.Array | PullElementKind.TypeAlias | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.TypeParameter | PullElementKind.ErrorType;
        PullElementKind.SomeContainer = PullElementKind.Container | PullElementKind.DynamicModule | PullElementKind.TypeAlias;
        PullElementKind.SomeBlock = PullElementKind.WithBlock | PullElementKind.CatchBlock;
        PullElementKind.SomeSignature = PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature;
        PullElementKind.SomeAccessor = PullElementKind.GetAccessor | PullElementKind.SetAccessor;
        PullElementKind.SomeLHS = PullElementKind.Variable | PullElementKind.Property | PullElementKind.Parameter | PullElementKind.SetAccessor | PullElementKind.Method;
    })(TypeScript.PullElementKind || (TypeScript.PullElementKind = {}));
    var PullElementKind = TypeScript.PullElementKind;
    (function (SymbolLinkKind) {
        SymbolLinkKind._map = [];
        SymbolLinkKind._map[0] = "TypedAs";
        SymbolLinkKind.TypedAs = 0;
        SymbolLinkKind._map[1] = "ContextuallyTypedAs";
        SymbolLinkKind.ContextuallyTypedAs = 1;
        SymbolLinkKind._map[2] = "ProvidesInferredType";
        SymbolLinkKind.ProvidesInferredType = 2;
        SymbolLinkKind._map[3] = "ArrayType";
        SymbolLinkKind.ArrayType = 3;
        SymbolLinkKind._map[4] = "ArrayOf";
        SymbolLinkKind.ArrayOf = 4;
        SymbolLinkKind._map[5] = "PublicMember";
        SymbolLinkKind.PublicMember = 5;
        SymbolLinkKind._map[6] = "PrivateMember";
        SymbolLinkKind.PrivateMember = 6;
        SymbolLinkKind._map[7] = "ConstructorMethod";
        SymbolLinkKind.ConstructorMethod = 7;
        SymbolLinkKind._map[8] = "Aliases";
        SymbolLinkKind.Aliases = 8;
        SymbolLinkKind._map[9] = "ContainedBy";
        SymbolLinkKind.ContainedBy = 9;
        SymbolLinkKind._map[10] = "Extends";
        SymbolLinkKind.Extends = 10;
        SymbolLinkKind._map[11] = "Implements";
        SymbolLinkKind.Implements = 11;
        SymbolLinkKind._map[12] = "Parameter";
        SymbolLinkKind.Parameter = 12;
        SymbolLinkKind._map[13] = "ReturnType";
        SymbolLinkKind.ReturnType = 13;
        SymbolLinkKind._map[14] = "CallSignature";
        SymbolLinkKind.CallSignature = 14;
        SymbolLinkKind._map[15] = "ConstructSignature";
        SymbolLinkKind.ConstructSignature = 15;
        SymbolLinkKind._map[16] = "IndexSignature";
        SymbolLinkKind.IndexSignature = 16;
        SymbolLinkKind._map[17] = "TypeParameter";
        SymbolLinkKind.TypeParameter = 17;
        SymbolLinkKind._map[18] = "TypeArgument";
        SymbolLinkKind.TypeArgument = 18;
        SymbolLinkKind._map[19] = "TypeParameterSpecializedTo";
        SymbolLinkKind.TypeParameterSpecializedTo = 19;
        SymbolLinkKind._map[20] = "SpecializedTo";
        SymbolLinkKind.SpecializedTo = 20;
        SymbolLinkKind._map[21] = "TypeConstraint";
        SymbolLinkKind.TypeConstraint = 21;
        SymbolLinkKind._map[22] = "ContributesToExpression";
        SymbolLinkKind.ContributesToExpression = 22;
        SymbolLinkKind._map[23] = "GetterFunction";
        SymbolLinkKind.GetterFunction = 23;
        SymbolLinkKind._map[24] = "SetterFunction";
        SymbolLinkKind.SetterFunction = 24;
    })(TypeScript.SymbolLinkKind || (TypeScript.SymbolLinkKind = {}));
    var SymbolLinkKind = TypeScript.SymbolLinkKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullDeclID = 0;
    TypeScript.lastBoundPullDeclId = 0;
    var PullDecl = (function () {
        function PullDecl(declName, declType, declFlags, span, scriptName) {
            this.symbol = null;
            this.declGroups = {};
            this.signatureSymbol = null;
            this.childDecls = [];
            this.typeParameters = [];
            this.childDeclTypeCache = new TypeScript.BlockIntrinsics();
            this.childDeclValueCache = new TypeScript.BlockIntrinsics();
            this.childDeclTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.declID = TypeScript.pullDeclID++;
            this.declFlags = TypeScript.PullElementFlags.None;
            this.diagnostics = null;
            this.parentDecl = null;
            this.synthesizedValDecl = null;
            this.declName = declName;
            this.declType = declType;
            this.declFlags = declFlags;
            this.span = span;
            this.scriptName = scriptName;
        }
        PullDecl.prototype.getDeclID = function () {
            return this.declID;
        };
        PullDecl.prototype.getName = function () {
            return this.declName;
        };
        PullDecl.prototype.getKind = function () {
            return this.declType;
        };
        PullDecl.prototype.setSymbol = function (symbol) {
            this.symbol = symbol;
        };
        PullDecl.prototype.getSymbol = function () {
            return this.symbol;
        };
        PullDecl.prototype.setSignatureSymbol = function (signature) {
            this.signatureSymbol = signature;
        };
        PullDecl.prototype.getSignatureSymbol = function () {
            return this.signatureSymbol;
        };
        PullDecl.prototype.getFlags = function () {
            return this.declFlags;
        };
        PullDecl.prototype.setFlags = function (flags) {
            this.declFlags = flags;
        };
        PullDecl.prototype.getSpan = function () {
            return this.span;
        };
        PullDecl.prototype.setSpan = function (span) {
            this.span = span;
        };
        PullDecl.prototype.getScriptName = function () {
            return this.scriptName;
        };
        PullDecl.prototype.setValueDecl = function (valDecl) {
            this.synthesizedValDecl = valDecl;
        };
        PullDecl.prototype.getValueDecl = function () {
            return this.synthesizedValDecl;
        };
        PullDecl.prototype.isEqual = function (other) {
            return (this.declName == other.declName) && (this.declType == other.declType) && (this.declFlags == other.declFlags) && (this.scriptName == other.scriptName) && (this.span.start() == other.span.start()) && (this.span.end() == other.span.end());
        };
        PullDecl.prototype.getParentDecl = function () {
            return this.parentDecl;
        };
        PullDecl.prototype.setParentDecl = function (parentDecl) {
            this.parentDecl = parentDecl;
        };
        PullDecl.prototype.addDiagnostic = function (diagnostic) {
            if (!this.diagnostics) {
                this.diagnostics = [];
            }
            this.diagnostics[this.diagnostics.length] = diagnostic;
        };
        PullDecl.prototype.getDiagnostics = function () {
            return this.diagnostics;
        };
        PullDecl.prototype.setErrors = function (diagnostics) {
            if (diagnostics) {
                this.diagnostics = [];
                for(var i = 0; i < diagnostics.length; i++) {
                    diagnostics[i].adjustOffset(this.span.start());
                    this.diagnostics[this.diagnostics.length] = diagnostics[i];
                }
            }
        };
        PullDecl.prototype.resetErrors = function () {
            this.diagnostics = [];
        };
        PullDecl.prototype.getChildDeclCache = function (declKind) {
            return declKind === TypeScript.PullElementKind.TypeParameter ? this.childDeclTypeParameterCache : TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeType) ? this.childDeclTypeCache : this.childDeclValueCache;
        };
        PullDecl.prototype.addChildDecl = function (childDecl) {
            if (childDecl.getKind() === TypeScript.PullElementKind.TypeParameter) {
                this.typeParameters[this.typeParameters.length] = childDecl;
            } else {
                this.childDecls[this.childDecls.length] = childDecl;
            }
            var declName = childDecl.getName();
            var cache = this.getChildDeclCache(childDecl.getKind());
            var childrenOfName = cache[declName];
            if (!childrenOfName) {
                childrenOfName = [];
            }
            childrenOfName.push(childDecl);
            cache[declName] = childrenOfName;
        };
        PullDecl.prototype.searchChildDecls = function (declName, isType) {
            var cache = isType ? this.childDeclTypeCache : this.childDeclValueCache;
            var cacheVal = cache[declName];
            if (cacheVal) {
                return cacheVal;
            } else {
                if (isType) {
                    cacheVal = this.childDeclTypeParameterCache[declName];
                    if (cacheVal) {
                        return cacheVal;
                    }
                }
                return [];
            }
        };
        PullDecl.prototype.getChildDecls = function () {
            return this.childDecls;
        };
        PullDecl.prototype.getTypeParameters = function () {
            return this.typeParameters;
        };
        PullDecl.prototype.addVariableDeclToGroup = function (decl) {
            var declGroup = this.declGroups[decl.getName()];
            if (declGroup) {
                declGroup.addDecl(decl);
            } else {
                declGroup = new PullDeclGroup(decl.getName());
                declGroup.addDecl(decl);
                this.declGroups[decl.getName()] = declGroup;
            }
        };
        PullDecl.prototype.getVariableDeclGroups = function () {
            var declGroups = [];
            for(var declName in this.declGroups) {
                declGroups[declGroups.length] = (this.declGroups[declName]).getDecls();
            }
            return declGroups;
        };
        return PullDecl;
    })();
    TypeScript.PullDecl = PullDecl;    
    var PullDeclGroup = (function () {
        function PullDeclGroup(name) {
            this.name = name;
            this._decls = [];
        }
        PullDeclGroup.prototype.addDecl = function (decl) {
            if (decl.getName() == this.name) {
                this._decls[this._decls.length] = decl;
            }
        };
        PullDeclGroup.prototype.getDecls = function () {
            return this._decls;
        };
        return PullDeclGroup;
    })();
    TypeScript.PullDeclGroup = PullDeclGroup;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullSymbolID = 0;
    TypeScript.lastBoundPullSymbolID = 0;
    TypeScript.globalTyvarID = 0;
    var PullSymbol = (function () {
        function PullSymbol(name, declKind) {
            this.pullSymbolID = TypeScript.pullSymbolID++;
            this.outgoingLinks = new TypeScript.LinkList();
            this.incomingLinks = new TypeScript.LinkList();
            this.declarations = new TypeScript.LinkList();
            this.cachedPathIDs = {};
            this.cachedContainerLink = null;
            this.cachedTypeLink = null;
            this.hasBeenResolved = false;
            this.isOptional = false;
            this.inResolution = false;
            this.isSynthesized = false;
            this.isBound = false;
            this.rebindingID = 0;
            this.isVarArg = false;
            this.isSpecialized = false;
            this.isBeingSpecialized = false;
            this.typeChangeUpdateVersion = -1;
            this.addUpdateVersion = -1;
            this.removeUpdateVersion = -1;
            this.docComments = null;
            this.isPrinting = false;
            this.name = name;
            this.declKind = declKind;
        }
        PullSymbol.prototype.getSymbolID = function () {
            return this.pullSymbolID;
        };
        PullSymbol.prototype.isType = function () {
            return (this.declKind & TypeScript.PullElementKind.SomeType) != 0;
        };
        PullSymbol.prototype.isSignature = function () {
            return (this.declKind & TypeScript.PullElementKind.SomeSignature) != 0;
        };
        PullSymbol.prototype.isArray = function () {
            return (this.declKind & TypeScript.PullElementKind.Array) != 0;
        };
        PullSymbol.prototype.isPrimitive = function () {
            return this.declKind == TypeScript.PullElementKind.Primitive;
        };
        PullSymbol.prototype.isAccessor = function () {
            return false;
        };
        PullSymbol.prototype.isAlias = function () {
            return false;
        };
        PullSymbol.prototype.isContainer = function () {
            return false;
        };
        PullSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            return this.name;
        };
        PullSymbol.prototype.getKind = function () {
            return this.declKind;
        };
        PullSymbol.prototype.setKind = function (declType) {
            this.declKind = declType;
        };
        PullSymbol.prototype.setIsOptional = function () {
            this.isOptional = true;
        };
        PullSymbol.prototype.getIsOptional = function () {
            return this.isOptional;
        };
        PullSymbol.prototype.getIsVarArg = function () {
            return this.isVarArg;
        };
        PullSymbol.prototype.setIsVarArg = function () {
            this.isVarArg = true;
        };
        PullSymbol.prototype.setIsSynthesized = function () {
            this.isSynthesized = true;
        };
        PullSymbol.prototype.getIsSynthesized = function () {
            return this.isSynthesized;
        };
        PullSymbol.prototype.setIsSpecialized = function () {
            this.isSpecialized = true;
            this.isBeingSpecialized = false;
        };
        PullSymbol.prototype.getIsSpecialized = function () {
            return this.isSpecialized;
        };
        PullSymbol.prototype.currentlyBeingSpecialized = function () {
            return this.isBeingSpecialized;
        };
        PullSymbol.prototype.setIsBeingSpecialized = function () {
            this.isBeingSpecialized = true;
        };
        PullSymbol.prototype.setIsBound = function (rebindingID) {
            this.isBound = true;
            this.rebindingID = rebindingID;
        };
        PullSymbol.prototype.getRebindingID = function () {
            return this.rebindingID;
        };
        PullSymbol.prototype.getIsBound = function () {
            return this.isBound;
        };
        PullSymbol.prototype.addCacheID = function (cacheID) {
            if (!this.cachedPathIDs[cacheID]) {
                this.cachedPathIDs[cacheID] = true;
            }
        };
        PullSymbol.prototype.invalidateCachedIDs = function (cache) {
            for(var id in this.cachedPathIDs) {
                if (cache[id]) {
                    cache[id] = undefined;
                }
            }
        };
        PullSymbol.prototype.addDeclaration = function (decl) {
            TypeScript.Debug.assert(!!decl);
            this.declarations.addItem(decl);
        };
        PullSymbol.prototype.getDeclarations = function () {
            return this.declarations.find(function (d) {
                return d;
            });
        };
        PullSymbol.prototype.removeDeclaration = function (decl) {
            this.declarations.remove(function (d) {
                return d === decl;
            });
        };
        PullSymbol.prototype.updateDeclarations = function (map, context) {
            this.declarations.update(map, context);
        };
        PullSymbol.prototype.addOutgoingLink = function (linkTo, kind) {
            var link = new TypeScript.PullSymbolLink(this, linkTo, kind);
            this.outgoingLinks.addItem(link);
            linkTo.incomingLinks.addItem(link);
            return link;
        };
        PullSymbol.prototype.findOutgoingLinks = function (p) {
            return this.outgoingLinks.find(p);
        };
        PullSymbol.prototype.findIncomingLinks = function (p) {
            return this.incomingLinks.find(p);
        };
        PullSymbol.prototype.removeOutgoingLink = function (link) {
            if (link) {
                this.outgoingLinks.remove(function (p) {
                    return p === link;
                });
                if (link.end.incomingLinks) {
                    link.end.incomingLinks.remove(function (p) {
                        return p === link;
                    });
                }
            }
        };
        PullSymbol.prototype.updateOutgoingLinks = function (map, context) {
            if (this.outgoingLinks) {
                this.outgoingLinks.update(map, context);
            }
        };
        PullSymbol.prototype.updateIncomingLinks = function (map, context) {
            if (this.incomingLinks) {
                this.incomingLinks.update(map, context);
            }
        };
        PullSymbol.prototype.removeAllLinks = function () {
            var _this = this;
            this.updateOutgoingLinks(function (item) {
                return _this.removeOutgoingLink(item);
            }, null);
            this.updateIncomingLinks(function (item) {
                return item.start.removeOutgoingLink(item);
            }, null);
        };
        PullSymbol.prototype.setContainer = function (containerSymbol) {
            var link = this.addOutgoingLink(containerSymbol, TypeScript.SymbolLinkKind.ContainedBy);
            this.cachedContainerLink = link;
            containerSymbol.addContainedByLink(link);
        };
        PullSymbol.prototype.getContainer = function () {
            if (this.cachedContainerLink) {
                return this.cachedContainerLink.end;
            }
            var containerList = this.findOutgoingLinks(function (link) {
                return link.kind == TypeScript.SymbolLinkKind.ContainedBy;
            });
            if (containerList.length) {
                this.cachedContainerLink = containerList[0];
                return this.cachedContainerLink.end;
            }
            return null;
        };
        PullSymbol.prototype.unsetContainer = function () {
            if (this.cachedContainerLink) {
                this.removeOutgoingLink(this.cachedContainerLink);
            } else {
                var containerList = this.findOutgoingLinks(function (link) {
                    return link.kind == TypeScript.SymbolLinkKind.ContainedBy;
                });
                if (containerList.length) {
                    this.removeOutgoingLink(containerList[0]);
                }
            }
            this.invalidate();
        };
        PullSymbol.prototype.setType = function (typeRef) {
            if (this.cachedTypeLink) {
                this.unsetType();
            }
            var link = this.addOutgoingLink(typeRef, TypeScript.SymbolLinkKind.TypedAs);
            this.cachedTypeLink = link;
        };
        PullSymbol.prototype.getType = function () {
            if (this.cachedTypeLink) {
                return this.cachedTypeLink.end;
            }
            var typeList = this.findOutgoingLinks(function (link) {
                return link.kind == TypeScript.SymbolLinkKind.TypedAs;
            });
            if (typeList.length) {
                this.cachedTypeLink = typeList[0];
                return this.cachedTypeLink.end;
            }
            return null;
        };
        PullSymbol.prototype.unsetType = function () {
            var foundType = false;
            if (this.cachedTypeLink) {
                this.removeOutgoingLink(this.cachedTypeLink);
                foundType = true;
            } else {
                var typeList = this.findOutgoingLinks(function (link) {
                    return link.kind == TypeScript.SymbolLinkKind.TypedAs;
                });
                if (typeList.length) {
                    this.removeOutgoingLink(typeList[0]);
                }
                foundType = true;
            }
            if (foundType) {
                this.invalidate();
            }
        };
        PullSymbol.prototype.isTyped = function () {
            return this.getType() != null;
        };
        PullSymbol.prototype.setResolved = function () {
            this.hasBeenResolved = true;
            this.inResolution = false;
        };
        PullSymbol.prototype.isResolved = function () {
            return this.hasBeenResolved;
        };
        PullSymbol.prototype.startResolving = function () {
            this.inResolution = true;
        };
        PullSymbol.prototype.isResolving = function () {
            return this.inResolution;
        };
        PullSymbol.prototype.setUnresolved = function () {
            this.hasBeenResolved = false;
            this.isBound = false;
        };
        PullSymbol.prototype.invalidate = function () {
            this.docComments = null;
            this.hasBeenResolved = false;
            this.isBound = false;
            this.declarations.update(function (pullDecl) {
                return pullDecl.resetErrors();
            }, null);
        };
        PullSymbol.prototype.hasFlag = function (flag) {
            var declarations = this.getDeclarations();
            for(var i = 0, n = declarations.length; i < n; i++) {
                if ((declarations[i].getFlags() & flag) !== TypeScript.PullElementFlags.None) {
                    return true;
                }
            }
            return false;
        };
        PullSymbol.prototype.allDeclsHaveFlag = function (flag) {
            var declarations = this.getDeclarations();
            for(var i = 0, n = declarations.length; i < n; i++) {
                if (!((declarations[i].getFlags() & flag) !== TypeScript.PullElementFlags.None)) {
                    return false;
                }
            }
            return true;
        };
        PullSymbol.prototype.pathToRoot = function () {
            var path = [];
            var node = this;
            while(node) {
                if (node.isType()) {
                    var associatedContainerSymbol = (node).getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                node = node.getContainer();
            }
            return path;
        };
        PullSymbol.prototype.findCommonAncestorPath = function (b) {
            var aPath = this.pathToRoot();
            if (aPath.length == 1) {
                return aPath;
            }
            var bPath;
            if (b) {
                bPath = b.pathToRoot();
            } else {
                return aPath;
            }
            var commonNodeIndex = -1;
            for(var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for(var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode == bNode) {
                        commonNodeIndex = i;
                        break;
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }
            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            } else {
                return aPath;
            }
        };
        PullSymbol.prototype.toString = function (useConstraintInName) {
            var str = this.getNameAndTypeName();
            return str;
        };
        PullSymbol.prototype.getPrettyNameInScope = function (scopeSymbol) {
            var scopedName = this.getName(scopeSymbol);
            if (this.getKind() == TypeScript.PullElementKind.DynamicModule) {
                if (!TypeScript.isQuoted(scopedName) && scopedName == this.getName()) {
                    return "";
                }
            }
            return scopedName;
        };
        PullSymbol.prototype.getNamePartForFullName = function (scopeSymbol) {
            if (this.getKind() == TypeScript.PullElementKind.DynamicModule) {
                return this.getPrettyNameInScope(scopeSymbol);
            } else {
                return this.getName(scopeSymbol, true);
            }
        };
        PullSymbol.prototype.fullName = function (scopeSymbol) {
            var path = this.pathToRoot();
            var fullName = "";
            for(var i = 1; i < path.length; i++) {
                var scopedName = path[i].getNamePartForFullName(scopeSymbol);
                if (!scopedName) {
                    break;
                }
                if (scopedName === "") {
                    break;
                }
                fullName = scopedName + "." + fullName;
            }
            fullName = fullName + this.getNamePartForFullName(scopeSymbol);
            return fullName;
        };
        PullSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            var path = this.findCommonAncestorPath(scopeSymbol);
            var fullName = "";
            for(var i = 1; i < path.length; i++) {
                var kind = path[i].getKind();
                if (kind == TypeScript.PullElementKind.Container) {
                    fullName = path[i].getName() + "." + fullName;
                } else if (kind == TypeScript.PullElementKind.DynamicModule) {
                    var scopedName = path[i].getPrettyNameInScope(scopeSymbol);
                    if (scopedName) {
                        fullName = scopedName + "." + fullName;
                    }
                    break;
                } else {
                    break;
                }
            }
            fullName = fullName + this.getName(scopeSymbol, useConstraintInName);
            return fullName;
        };
        PullSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName) {
            var name = this.getScopedName(scopeSymbol, useConstraintInName);
            return TypeScript.MemberName.create(name);
        };
        PullSymbol.prototype.getTypeName = function (scopeSymbol, getPrettyTypeName) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        };
        PullSymbol.prototype.getTypeNameEx = function (scopeSymbol, getPrettyTypeName) {
            var type = this.getType();
            if (type) {
                var memberName = getPrettyTypeName ? this.getTypeNameForFunctionSignature("", scopeSymbol, getPrettyTypeName) : null;
                if (!memberName) {
                    memberName = type.getScopedNameEx(scopeSymbol, false, getPrettyTypeName);
                }
                return memberName;
            }
            return TypeScript.MemberName.create("");
        };
        PullSymbol.prototype.getTypeNameForFunctionSignature = function (prefix, scopeSymbol, getPrettyTypeName) {
            var type = this.getType();
            if (type && !type.isNamedTypeSymbol() && this.declKind != TypeScript.PullElementKind.Property && this.declKind != TypeScript.PullElementKind.Variable && this.declKind != TypeScript.PullElementKind.Parameter) {
                var signatures = type.getCallSignatures();
                var typeName = new TypeScript.MemberNameArray();
                var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, prefix, false, false, scopeSymbol, getPrettyTypeName);
                typeName.addAll(signatureName);
                return typeName;
            }
            return null;
        };
        PullSymbol.prototype.getNameAndTypeName = function (scopeSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        };
        PullSymbol.prototype.getNameAndTypeNameEx = function (scopeSymbol) {
            var type = this.getType();
            var nameEx = this.getScopedNameEx(scopeSymbol);
            if (type) {
                var nameStr = nameEx.toString() + (this.getIsOptional() ? "?" : "");
                var memberName = this.getTypeNameForFunctionSignature(nameStr, scopeSymbol);
                if (!memberName) {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    memberName = TypeScript.MemberName.create(typeNameEx, nameStr + ": ", "");
                }
                return memberName;
            }
            return nameEx;
        };
        PullSymbol.getTypeParameterString = function getTypeParameterString(typars, scopeSymbol) {
            var typarString = "";
            if (typars && typars.length) {
                typarString = "<";
                for(var i = 0; i < typars.length; i++) {
                    if (i) {
                        typarString += ", ";
                    }
                    typarString += typars[i].getScopedNameEx(scopeSymbol, true).toString();
                }
                typarString += ">";
            }
            return typarString;
        };
        PullSymbol.getIsExternallyVisible = function getIsExternallyVisible(symbol, fromIsExternallyVisibleSymbol, inIsExternallyVisibleSymbols) {
            if (inIsExternallyVisibleSymbols) {
                for(var i = 0; i < inIsExternallyVisibleSymbols.length; i++) {
                    if (inIsExternallyVisibleSymbols[i] == symbol) {
                        return true;
                    }
                }
            } else {
                inIsExternallyVisibleSymbols = [];
            }
            if (fromIsExternallyVisibleSymbol == symbol) {
                return true;
            }
            inIsExternallyVisibleSymbols = inIsExternallyVisibleSymbols.concat(fromIsExternallyVisibleSymbol);
            return symbol.isExternallyVisible(inIsExternallyVisibleSymbols);
        };
        PullSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var kind = this.getKind();
            if (kind == TypeScript.PullElementKind.Primitive) {
                return true;
            }
            if (this.isType()) {
                var associatedContainerSymbol = (this).getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    return PullSymbol.getIsExternallyVisible(associatedContainerSymbol, this, inIsExternallyVisibleSymbols);
                }
            }
            if (this.hasFlag(TypeScript.PullElementFlags.Private)) {
                return false;
            }
            var container = this.getContainer();
            if (container == null) {
                return true;
            }
            if (!this.hasFlag(TypeScript.PullElementFlags.Exported) && kind != TypeScript.PullElementKind.Property && kind != TypeScript.PullElementKind.Method) {
                return false;
            }
            return PullSymbol.getIsExternallyVisible(container, this, inIsExternallyVisibleSymbols);
        };
        return PullSymbol;
    })();
    TypeScript.PullSymbol = PullSymbol;    
    var PullExpressionSymbol = (function (_super) {
        __extends(PullExpressionSymbol, _super);
        function PullExpressionSymbol() {
            _super.call(this, "", TypeScript.PullElementKind.Expression);
            this.contributingSymbols = [];
        }
        PullExpressionSymbol.prototype.addContributingSymbol = function (symbol) {
            var link = this.addOutgoingLink(symbol, TypeScript.SymbolLinkKind.ContributesToExpression);
            this.contributingSymbols[this.contributingSymbols.length] = symbol;
        };
        PullExpressionSymbol.prototype.getContributingSymbols = function () {
            return this.contributingSymbols;
        };
        return PullExpressionSymbol;
    })(PullSymbol);
    TypeScript.PullExpressionSymbol = PullExpressionSymbol;    
    var PullSignatureSymbol = (function (_super) {
        __extends(PullSignatureSymbol, _super);
        function PullSignatureSymbol(kind) {
            _super.call(this, "", kind);
            this.parameterLinks = null;
            this.typeParameterLinks = null;
            this.returnTypeLink = null;
            this.hasOptionalParam = false;
            this.nonOptionalParamCount = 0;
            this.hasVarArgs = false;
            this.specializationCache = {};
            this.memberTypeParameterNameCache = null;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;
        }
        PullSignatureSymbol.prototype.isDefinition = function () {
            return false;
        };
        PullSignatureSymbol.prototype.hasVariableParamList = function () {
            return this.hasVarArgs;
        };
        PullSignatureSymbol.prototype.setHasVariableParamList = function () {
            this.hasVarArgs = true;
        };
        PullSignatureSymbol.prototype.setHasGenericParameter = function () {
            this.hasAGenericParameter = true;
        };
        PullSignatureSymbol.prototype.hasGenericParameter = function () {
            return this.hasAGenericParameter;
        };
        PullSignatureSymbol.prototype.isGeneric = function () {
            return this.hasAGenericParameter || (this.typeParameterLinks && this.typeParameterLinks.length != 0);
        };
        PullSignatureSymbol.prototype.addParameter = function (parameter, isOptional) {
            if (typeof isOptional === "undefined") { isOptional = false; }
            if (!this.parameterLinks) {
                this.parameterLinks = [];
            }
            var link = this.addOutgoingLink(parameter, TypeScript.SymbolLinkKind.Parameter);
            this.parameterLinks[this.parameterLinks.length] = link;
            this.hasOptionalParam = isOptional;
            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        };
        PullSignatureSymbol.prototype.addSpecialization = function (signature, typeArguments) {
            if (typeArguments && typeArguments.length) {
                this.specializationCache[getIDForTypeSubstitutions(typeArguments)] = signature;
            }
        };
        PullSignatureSymbol.prototype.getSpecialization = function (typeArguments) {
            if (typeArguments) {
                var sig = this.specializationCache[getIDForTypeSubstitutions(typeArguments)];
                if (sig) {
                    return sig;
                }
            }
            return null;
        };
        PullSignatureSymbol.prototype.addTypeParameter = function (parameter) {
            if (!this.typeParameterLinks) {
                this.typeParameterLinks = [];
            }
            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
            }
            var link = this.addOutgoingLink(parameter, TypeScript.SymbolLinkKind.TypeParameter);
            this.typeParameterLinks[this.typeParameterLinks.length] = link;
            this.memberTypeParameterNameCache[link.end.getName()] = link.end;
        };
        PullSignatureSymbol.prototype.getNonOptionalParameterCount = function () {
            return this.nonOptionalParamCount;
        };
        PullSignatureSymbol.prototype.setReturnType = function (returnType) {
            if (returnType) {
                if (this.returnTypeLink) {
                    this.removeOutgoingLink(this.returnTypeLink);
                }
                this.returnTypeLink = this.addOutgoingLink(returnType, TypeScript.SymbolLinkKind.ReturnType);
            }
        };
        PullSignatureSymbol.prototype.getParameters = function () {
            var params = [];
            if (this.parameterLinks) {
                for(var i = 0; i < this.parameterLinks.length; i++) {
                    params[params.length] = this.parameterLinks[i].end;
                }
            }
            return params;
        };
        PullSignatureSymbol.prototype.getTypeParameters = function () {
            var params = [];
            if (this.typeParameterLinks) {
                for(var i = 0; i < this.typeParameterLinks.length; i++) {
                    params[params.length] = this.typeParameterLinks[i].end;
                }
            }
            return params;
        };
        PullSignatureSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;
            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
                if (this.typeParameterLinks) {
                    for(var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }
            memberSymbol = this.memberTypeParameterNameCache[name];
            return memberSymbol;
        };
        PullSignatureSymbol.prototype.removeParameter = function (parameterSymbol) {
            var paramLink;
            if (this.parameterLinks) {
                for(var i = 0; i < this.parameterLinks.length; i++) {
                    if (parameterSymbol == this.parameterLinks[i].end) {
                        paramLink = this.parameterLinks[i];
                        this.removeOutgoingLink(paramLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullSignatureSymbol.prototype.mimicSignature = function (signature) {
            var typeParameters = signature.getTypeParameters();
            var typeParameter;
            if (typeParameters) {
                for(var i = 0; i < typeParameters.length; i++) {
                    this.addTypeParameter(typeParameters[i]);
                }
            }
            var parameters = signature.getParameters();
            var parameter;
            if (parameters) {
                for(var j = 0; j < parameters.length; j++) {
                    parameter = new PullSymbol(parameters[j].getName(), TypeScript.PullElementKind.Parameter);
                    parameter.addDeclaration(parameters[j].getDeclarations()[0]);
                    if (parameters[j].getIsOptional()) {
                        parameter.setIsOptional();
                    }
                    if (parameters[j].getIsVarArg()) {
                        parameter.setIsVarArg();
                        this.setHasVariableParamList();
                    }
                    this.addParameter(parameter);
                }
            }
        };
        PullSignatureSymbol.prototype.getReturnType = function () {
            if (this.returnTypeLink) {
                return this.returnTypeLink.end;
            } else {
                var rtl = this.findOutgoingLinks(function (p) {
                    return p.kind == TypeScript.SymbolLinkKind.ReturnType;
                });
                if (rtl.length) {
                    this.returnTypeLink = rtl[0];
                    return this.returnTypeLink.end;
                }
                return null;
            }
        };
        PullSignatureSymbol.prototype.invalidate = function () {
            this.parameterLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.Parameter;
            });
            this.nonOptionalParamCount = 0;
            this.hasOptionalParam = false;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;
            if (this.parameterLinks) {
                for(var i = 0; i < this.parameterLinks.length; i++) {
                    this.parameterLinks[i].end.invalidate();
                    if (!this.parameterLinks[i].end.getIsOptional()) {
                        this.nonOptionalParamCount++;
                    } else {
                        this.hasOptionalParam;
                        break;
                    }
                }
            }
            _super.prototype.invalidate.call(this);
        };
        PullSignatureSymbol.prototype.isStringConstantOverloadSignature = function () {
            if (this.stringConstantOverload === undefined) {
                var params = this.getParameters();
                this.stringConstantOverload = false;
                for(var i = 0; i < params.length; i++) {
                    var paramType = params[i].getType();
                    if (paramType && paramType.isPrimitive() && (paramType).isStringConstant()) {
                        this.stringConstantOverload = true;
                    }
                }
            }
            return this.stringConstantOverload;
        };
        PullSignatureSymbol.getSignatureTypeMemberName = function getSignatureTypeMemberName(candidateSignature, signatures, scopeSymbol) {
            var allMemberNames = new TypeScript.MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, "", false, false, scopeSymbol, true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        };
        PullSignatureSymbol.getSignaturesTypeNameEx = function getSignaturesTypeNameEx(signatures, prefix, shortform, brackets, scopeSymbol, getPrettyTypeName, candidateSignature) {
            var result = [];
            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }
            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                candidateSignature = null;
            }
            for(var i = 0; i < len; i++) {
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }
                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }
                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }
            if (getPrettyTypeName && result.length && len > 1) {
                var lastMemberName = result[result.length - 1];
                for(var i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = " (+ " + (foundDefinition ? len - 2 : len - 1) + " overload(s))";
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }
            return result;
        };
        PullSignatureSymbol.prototype.toString = function (useConstraintInName) {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), false, false).toString();
            return s;
        };
        PullSignatureSymbol.prototype.getSignatureTypeNameEx = function (prefix, shortform, brackets, scopeSymbol) {
            var builder = new TypeScript.MemberNameArray();
            var typeParameters = this.getTypeParameters();
            var typeParameterString = PullSymbol.getTypeParameterString(typeParameters, scopeSymbol);
            if (brackets) {
                builder.prefix = prefix + typeParameterString + "[";
            } else {
                builder.prefix = prefix + typeParameterString + "(";
            }
            var params = this.getParameters();
            var paramLen = params.length;
            for(var i = 0; i < paramLen; i++) {
                var paramType = params[i].getType();
                var typeString = paramType ? ": " : "";
                var paramIsVarArg = params[i].getIsVarArg();
                var varArgPrefix = paramIsVarArg ? "..." : "";
                var optionalString = (!paramIsVarArg && params[i].getIsOptional()) ? "?" : "";
                builder.add(TypeScript.MemberName.create(varArgPrefix + params[i].getScopedNameEx(scopeSymbol).toString() + optionalString + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }
            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                } else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            } else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                } else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }
            var returnType = this.getReturnType();
            if (returnType) {
                builder.add(returnType.getScopedNameEx(scopeSymbol));
            } else {
                builder.add(TypeScript.MemberName.create("any"));
            }
            return builder;
        };
        return PullSignatureSymbol;
    })(PullSymbol);
    TypeScript.PullSignatureSymbol = PullSignatureSymbol;    
    var PullTypeSymbol = (function (_super) {
        __extends(PullTypeSymbol, _super);
        function PullTypeSymbol() {
            _super.apply(this, arguments);

            this.memberLinks = null;
            this.typeParameterLinks = null;
            this.specializationLinks = null;
            this.containedByLinks = null;
            this.memberNameCache = null;
            this.memberTypeNameCache = null;
            this.memberTypeParameterNameCache = null;
            this.containedMemberCache = null;
            this.typeArguments = null;
            this.specializedTypeCache = null;
            this.memberCache = null;
            this.implementedTypeLinks = null;
            this.extendedTypeLinks = null;
            this.callSignatureLinks = null;
            this.constructSignatureLinks = null;
            this.indexSignatureLinks = null;
            this.arrayType = null;
            this.hasGenericSignature = false;
            this.knownBaseTypeCount = 0;
            this.invalidatedSpecializations = false;
            this.associatedContainerTypeSymbol = null;
        }
        PullTypeSymbol.prototype.getKnownBaseTypeCount = function () {
            return this.knownBaseTypeCount;
        };
        PullTypeSymbol.prototype.resetKnownBaseTypeCount = function () {
            this.knownBaseTypeCount = 0;
        };
        PullTypeSymbol.prototype.incrementKnownBaseCount = function () {
            this.knownBaseTypeCount++;
        };
        PullTypeSymbol.prototype.isType = function () {
            return true;
        };
        PullTypeSymbol.prototype.isClass = function () {
            return false;
        };
        PullTypeSymbol.prototype.hasMembers = function () {
            var thisHasMembers = this.memberLinks && this.memberLinks.length != 0;
            if (thisHasMembers) {
                return true;
            }
            var parents = this.getExtendedTypes();
            for(var i = 0; i < parents.length; i++) {
                if (parents[i].hasMembers()) {
                    return true;
                }
            }
            return false;
        };
        PullTypeSymbol.prototype.isFunction = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeParameter = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeVariable = function () {
            return false;
        };
        PullTypeSymbol.prototype.isError = function () {
            return false;
        };
        PullTypeSymbol.prototype.setHasGenericSignature = function () {
            this.hasGenericSignature = true;
        };
        PullTypeSymbol.prototype.getHasGenericSignature = function () {
            return this.hasGenericSignature;
        };
        PullTypeSymbol.prototype.setAssociatedContainerType = function (type) {
            this.associatedContainerTypeSymbol = type;
        };
        PullTypeSymbol.prototype.getAssociatedContainerType = function () {
            return this.associatedContainerTypeSymbol;
        };
        PullTypeSymbol.prototype.getType = function () {
            return this;
        };
        PullTypeSymbol.prototype.getArrayType = function () {
            return this.arrayType;
        };
        PullTypeSymbol.prototype.getElementType = function () {
            var arrayOfLinks = this.findOutgoingLinks(function (link) {
                return link.kind == TypeScript.SymbolLinkKind.ArrayOf;
            });
            if (arrayOfLinks.length) {
                return arrayOfLinks[0].end;
            }
            return null;
        };
        PullTypeSymbol.prototype.setArrayType = function (arrayType) {
            this.arrayType = arrayType;
            arrayType.addOutgoingLink(this, TypeScript.SymbolLinkKind.ArrayOf);
        };
        PullTypeSymbol.prototype.addContainedByLink = function (containedByLink) {
            if (!this.containedByLinks) {
                this.containedByLinks = [];
            }
            if (!this.containedMemberCache) {
                this.containedMemberCache = new TypeScript.BlockIntrinsics();
            }
            this.containedByLinks[this.containedByLinks.length] = containedByLink;
            this.containedMemberCache[containedByLink.start.getName()] = containedByLink.start;
        };
        PullTypeSymbol.prototype.findContainedMember = function (name) {
            if (!this.containedByLinks) {
                this.containedByLinks = this.findIncomingLinks(function (psl) {
                    return psl.kind == TypeScript.SymbolLinkKind.ContainedBy;
                });
                this.containedMemberCache = new TypeScript.BlockIntrinsics();
                for(var i = 0; i < this.containedByLinks.length; i++) {
                    this.containedMemberCache[this.containedByLinks[i].start.getName()] = this.containedByLinks[i].start;
                }
            }
            return this.containedMemberCache[name];
        };
        PullTypeSymbol.prototype.addMember = function (memberSymbol, linkKind, doNotChangeContainer) {
            var link = this.addOutgoingLink(memberSymbol, linkKind);
            if (!doNotChangeContainer) {
                memberSymbol.setContainer(this);
            }
            if (!this.memberCache) {
                this.memberCache = [];
            }
            if (!this.memberNameCache) {
                this.populateMemberCache();
            }
            if (!this.memberLinks) {
                this.memberLinks = [];
            }
            if (!memberSymbol.isType()) {
                this.memberLinks[this.memberLinks.length] = link;
                this.memberCache[this.memberCache.length] = memberSymbol;
                if (!this.memberNameCache) {
                    this.populateMemberCache();
                }
                this.memberNameCache[memberSymbol.getName()] = memberSymbol;
            } else {
                if ((memberSymbol).isTypeParameter()) {
                    if (!this.typeParameterLinks) {
                        this.typeParameterLinks = [];
                    }
                    if (!this.memberTypeParameterNameCache) {
                        this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
                    }
                    this.typeParameterLinks[this.typeParameterLinks.length] = link;
                    this.memberTypeParameterNameCache[memberSymbol.getName()] = memberSymbol;
                } else {
                    if (!this.memberTypeNameCache) {
                        this.memberTypeNameCache = new TypeScript.BlockIntrinsics();
                    }
                    this.memberLinks[this.memberLinks.length] = link;
                    this.memberTypeNameCache[memberSymbol.getName()] = memberSymbol;
                    this.memberCache[this.memberCache.length] = memberSymbol;
                }
            }
        };
        PullTypeSymbol.prototype.removeMember = function (memberSymbol) {
            var memberLink;
            var child;
            var links = (memberSymbol.isType() && (memberSymbol).isTypeParameter()) ? this.typeParameterLinks : this.memberLinks;
            if (links) {
                for(var i = 0; i < links.length; i++) {
                    if (memberSymbol == links[i].end) {
                        memberLink = links[i];
                        child = memberLink.end;
                        child.unsetContainer();
                        this.removeOutgoingLink(memberLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullTypeSymbol.prototype.getMembers = function () {
            if (this.memberCache) {
                return this.memberCache;
            } else {
                var members = [];
                if (this.memberLinks) {
                    for(var i = 0; i < this.memberLinks.length; i++) {
                        members[members.length] = this.memberLinks[i].end;
                    }
                }
                if (members.length) {
                    this.memberCache = members;
                }
                return members;
            }
        };
        PullTypeSymbol.prototype.getTypeParameters = function () {
            var members = [];
            if (this.typeParameterLinks) {
                for(var i = 0; i < this.typeParameterLinks.length; i++) {
                    members[members.length] = this.typeParameterLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.isGeneric = function () {
            return (this.typeParameterLinks && this.typeParameterLinks.length != 0) || this.hasGenericSignature || (this.typeArguments && this.typeArguments.length);
        };
        PullTypeSymbol.prototype.isFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }
            if (this.typeParameterLinks && this.typeArguments) {
                if (!this.typeArguments.length || this.typeArguments.length < this.typeParameterLinks.length) {
                    return false;
                }
                for(var i = 0; i < this.typeArguments.length; i++) {
                    if (!this.typeArguments[i].isFixed()) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };
        PullTypeSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return;
            }
            if (!this.specializedTypeCache) {
                this.specializedTypeCache = new TypeScript.BlockIntrinsics();
            }
            if (!this.specializationLinks) {
                this.specializationLinks = [];
            }
            this.specializationLinks[this.specializationLinks.length] = this.addOutgoingLink(specializedVersionOfThisType, TypeScript.SymbolLinkKind.SpecializedTo);
            this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
        };
        PullTypeSymbol.prototype.getSpecialization = function (substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return null;
            }
            if (!this.specializedTypeCache) {
                this.specializedTypeCache = new TypeScript.BlockIntrinsics();
                return null;
            }
            var specialization = this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)];
            if (!specialization) {
                return null;
            }
            return specialization;
        };
        PullTypeSymbol.prototype.getKnownSpecializations = function () {
            var specializations = [];
            if (this.specializedTypeCache) {
                for(var specializationID in this.specializedTypeCache) {
                    if (this.specializedTypeCache[specializationID]) {
                        specializations[specializations.length] = this.specializedTypeCache[specializationID];
                    }
                }
            }
            return specializations;
        };
        PullTypeSymbol.prototype.invalidateSpecializations = function () {
            if (this.invalidatedSpecializations) {
                return;
            }
            var specializations = this.getKnownSpecializations();
            for(var i = 0; i < specializations.length; i++) {
                specializations[i].invalidate();
            }
            if (this.specializationLinks && this.specializationLinks.length) {
                for(var i = 0; i < this.specializationLinks.length; i++) {
                    this.removeOutgoingLink(this.specializationLinks[i]);
                }
            }
            this.specializedTypeCache = null;
            this.invalidatedSpecializations = true;
        };
        PullTypeSymbol.prototype.removeSpecialization = function (specializationType) {
            if (this.specializationLinks && this.specializationLinks.length) {
                for(var i = 0; i < this.specializationLinks.length; i++) {
                    if (this.specializationLinks[i].end == specializationType) {
                        this.removeOutgoingLink(this.specializationLinks[i]);
                        break;
                    }
                }
            }
            if (this.specializedTypeCache) {
                for(var specializationID in this.specializedTypeCache) {
                    if (this.specializedTypeCache[specializationID] == specializationType) {
                        this.specializedTypeCache[specializationID] = undefined;
                    }
                }
            }
        };
        PullTypeSymbol.prototype.getTypeArguments = function () {
            return this.typeArguments;
        };
        PullTypeSymbol.prototype.setTypeArguments = function (typeArgs) {
            this.typeArguments = typeArgs;
        };
        PullTypeSymbol.prototype.addCallSignature = function (callSignature) {
            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }
            var link = this.addOutgoingLink(callSignature, TypeScript.SymbolLinkKind.CallSignature);
            this.callSignatureLinks[this.callSignatureLinks.length] = link;
            if (callSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };
        PullTypeSymbol.prototype.addCallSignatures = function (callSignatures) {
            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }
            for(var i = 0; i < callSignatures.length; i++) {
                this.addCallSignature(callSignatures[i]);
            }
        };
        PullTypeSymbol.prototype.addConstructSignature = function (constructSignature) {
            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }
            var link = this.addOutgoingLink(constructSignature, TypeScript.SymbolLinkKind.ConstructSignature);
            this.constructSignatureLinks[this.constructSignatureLinks.length] = link;
            if (constructSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };
        PullTypeSymbol.prototype.addConstructSignatures = function (constructSignatures) {
            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }
            for(var i = 0; i < constructSignatures.length; i++) {
                this.addConstructSignature(constructSignatures[i]);
            }
        };
        PullTypeSymbol.prototype.addIndexSignature = function (indexSignature) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }
            var link = this.addOutgoingLink(indexSignature, TypeScript.SymbolLinkKind.IndexSignature);
            this.indexSignatureLinks[this.indexSignatureLinks.length] = link;
            if (indexSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };
        PullTypeSymbol.prototype.addIndexSignatures = function (indexSignatures) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }
            for(var i = 0; i < indexSignatures.length; i++) {
                this.addIndexSignature(indexSignatures[i]);
            }
        };
        PullTypeSymbol.prototype.hasOwnCallSignatures = function () {
            return !!this.callSignatureLinks;
        };
        PullTypeSymbol.prototype.getCallSignatures = function () {
            var members = [];
            if (this.callSignatureLinks) {
                for(var i = 0; i < this.callSignatureLinks.length; i++) {
                    members[members.length] = this.callSignatureLinks[i].end;
                }
            } else {
                var extendedTypes = this.getExtendedTypes();
                for(var i = 0; i < extendedTypes.length; i++) {
                    if (extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    members = extendedTypes[i].getCallSignatures();
                    if (members.length) {
                        break;
                    }
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.hasOwnConstructSignatures = function () {
            return !!this.constructSignatureLinks;
        };
        PullTypeSymbol.prototype.getConstructSignatures = function () {
            var members = [];
            if (this.constructSignatureLinks) {
                for(var i = 0; i < this.constructSignatureLinks.length; i++) {
                    members[members.length] = this.constructSignatureLinks[i].end;
                }
            } else {
                var extendedTypes = this.getExtendedTypes();
                for(var i = 0; i < extendedTypes.length; i++) {
                    if (extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    members = extendedTypes[i].getConstructSignatures();
                    if (members.length) {
                        break;
                    }
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.hasOwnIndexSignatures = function () {
            return !!this.indexSignatureLinks;
        };
        PullTypeSymbol.prototype.getIndexSignatures = function () {
            var members = [];
            if (this.indexSignatureLinks) {
                for(var i = 0; i < this.indexSignatureLinks.length; i++) {
                    members[members.length] = this.indexSignatureLinks[i].end;
                }
            } else {
                var extendedTypes = this.getExtendedTypes();
                for(var i = 0; i < extendedTypes.length; i++) {
                    if (extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    members = extendedTypes[i].getIndexSignatures();
                    if (members.length) {
                        break;
                    }
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.removeCallSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;
            if (this.callSignatureLinks) {
                for(var i = 0; i < this.callSignatureLinks.length; i++) {
                    if (signature == this.callSignatureLinks[i].end) {
                        signatureLink = this.callSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }
            if (invalidate) {
                this.invalidate();
            }
        };
        PullTypeSymbol.prototype.recomputeCallSignatures = function () {
            this.callSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.CallSignature;
            });
        };
        PullTypeSymbol.prototype.removeConstructSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;
            if (this.constructSignatureLinks) {
                for(var i = 0; i < this.constructSignatureLinks.length; i++) {
                    if (signature == this.constructSignatureLinks[i].end) {
                        signatureLink = this.constructSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }
            if (invalidate) {
                this.invalidate();
            }
        };
        PullTypeSymbol.prototype.recomputeConstructSignatures = function () {
            this.constructSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.ConstructSignature;
            });
        };
        PullTypeSymbol.prototype.removeIndexSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;
            if (this.indexSignatureLinks) {
                for(var i = 0; i < this.indexSignatureLinks.length; i++) {
                    if (signature == this.indexSignatureLinks[i].end) {
                        signatureLink = this.indexSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }
            if (invalidate) {
                this.invalidate();
            }
        };
        PullTypeSymbol.prototype.recomputeIndexSignatures = function () {
            this.indexSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.IndexSignature;
            });
        };
        PullTypeSymbol.prototype.addImplementedType = function (interfaceType) {
            if (!this.implementedTypeLinks) {
                this.implementedTypeLinks = [];
            }
            var link = this.addOutgoingLink(interfaceType, TypeScript.SymbolLinkKind.Implements);
            this.implementedTypeLinks[this.implementedTypeLinks.length] = link;
        };
        PullTypeSymbol.prototype.getImplementedTypes = function () {
            var members = [];
            if (this.implementedTypeLinks) {
                for(var i = 0; i < this.implementedTypeLinks.length; i++) {
                    members[members.length] = this.implementedTypeLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.removeImplementedType = function (implementedType) {
            var typeLink;
            if (this.implementedTypeLinks) {
                for(var i = 0; i < this.implementedTypeLinks.length; i++) {
                    if (implementedType == this.implementedTypeLinks[i].end) {
                        typeLink = this.implementedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullTypeSymbol.prototype.addExtendedType = function (extendedType) {
            if (!this.extendedTypeLinks) {
                this.extendedTypeLinks = [];
            }
            var link = this.addOutgoingLink(extendedType, TypeScript.SymbolLinkKind.Extends);
            this.extendedTypeLinks[this.extendedTypeLinks.length] = link;
        };
        PullTypeSymbol.prototype.getExtendedTypes = function () {
            var members = [];
            if (this.extendedTypeLinks) {
                for(var i = 0; i < this.extendedTypeLinks.length; i++) {
                    members[members.length] = this.extendedTypeLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.hasBase = function (potentialBase) {
            if (this == potentialBase) {
                return true;
            }
            var extendedTypes = this.getExtendedTypes();
            for(var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase)) {
                    return true;
                }
            }
            var implementedTypes = this.getImplementedTypes();
            for(var i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase)) {
                    return true;
                }
            }
            return false;
        };
        PullTypeSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            if (baseType.isError()) {
                return false;
            }
            var thisIsClass = this.isClass();
            if (isExtendedType) {
                if (thisIsClass) {
                    return baseType.getKind() == TypeScript.PullElementKind.Class;
                }
            } else {
                if (!thisIsClass) {
                    return false;
                }
            }
            return !!(baseType.getKind() & (TypeScript.PullElementKind.Interface | TypeScript.PullElementKind.Class));
        };
        PullTypeSymbol.prototype.removeExtendedType = function (extendedType) {
            var typeLink;
            if (this.extendedTypeLinks) {
                for(var i = 0; i < this.extendedTypeLinks.length; i++) {
                    if (extendedType == this.extendedTypeLinks[i].end) {
                        typeLink = this.extendedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullTypeSymbol.prototype.findMember = function (name, lookInParent) {
            if (typeof lookInParent === "undefined") { lookInParent = true; }
            var memberSymbol;
            if (!this.memberNameCache) {
                this.populateMemberCache();
            }
            memberSymbol = this.memberNameCache[name];
            if (!lookInParent) {
                return memberSymbol;
            } else if (memberSymbol) {
                return memberSymbol;
            }
            if (!memberSymbol && this.extendedTypeLinks) {
                for(var i = 0; i < this.extendedTypeLinks.length; i++) {
                    memberSymbol = (this.extendedTypeLinks[i].end).findMember(name);
                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }
            return this.findNestedType(name);
        };
        PullTypeSymbol.prototype.findNestedType = function (name, kind) {
            if (typeof kind === "undefined") { kind = TypeScript.PullElementKind.None; }
            var memberSymbol;
            if (!this.memberTypeNameCache) {
                this.populateMemberTypeCache();
            }
            memberSymbol = this.memberTypeNameCache[name];
            if (memberSymbol && kind != TypeScript.PullElementKind.None) {
                memberSymbol = ((memberSymbol.getKind() & kind) != 0) ? memberSymbol : null;
            }
            return memberSymbol;
        };
        PullTypeSymbol.prototype.populateMemberCache = function () {
            if (!this.memberNameCache) {
                this.memberNameCache = new TypeScript.BlockIntrinsics();
                this.memberCache = [];
                if (this.memberLinks) {
                    for(var i = 0; i < this.memberLinks.length; i++) {
                        this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                        this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                    }
                }
            }
        };
        PullTypeSymbol.prototype.populateMemberTypeCache = function () {
            if (!this.memberTypeNameCache) {
                this.memberTypeNameCache = new TypeScript.BlockIntrinsics();
                var setAll = false;
                if (!this.memberCache) {
                    this.memberCache = [];
                    this.memberNameCache = new TypeScript.BlockIntrinsics();
                    setAll = true;
                }
                if (this.memberLinks) {
                    for(var i = 0; i < this.memberLinks.length; i++) {
                        if (this.memberLinks[i].end.isType()) {
                            this.memberTypeNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        } else if (setAll) {
                            this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        }
                    }
                }
            }
        };
        PullTypeSymbol.prototype.getAllMembers = function (searchDeclKind, includePrivate) {
            var allMembers = [];
            var i = 0;
            var j = 0;
            var m = 0;
            var n = 0;
            if (!this.memberCache) {
                this.populateMemberCache();
            }
            if (!this.memberTypeNameCache) {
                this.populateMemberTypeCache();
            }
            if (!this.memberNameCache) {
                this.populateMemberCache();
            }
            for(var i = 0, n = this.memberCache.length; i < n; i++) {
                var member = this.memberCache[i];
                if ((member.getKind() & searchDeclKind) && (includePrivate || !member.hasFlag(TypeScript.PullElementFlags.Private))) {
                    allMembers[allMembers.length] = member;
                }
            }
            if (this.extendedTypeLinks) {
                for(var i = 0, n = this.extendedTypeLinks.length; i < n; i++) {
                    var extendedMembers = (this.extendedTypeLinks[i].end).getAllMembers(searchDeclKind, includePrivate);
                    for(var j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!this.memberNameCache[extendedMember.getName()]) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }
            return allMembers;
        };
        PullTypeSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;
            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
                if (this.typeParameterLinks) {
                    for(var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }
            memberSymbol = this.memberTypeParameterNameCache[name];
            return memberSymbol;
        };
        PullTypeSymbol.prototype.cleanTypeParameters = function () {
            if (this.typeParameterLinks) {
                for(var i = 0; i < this.typeParameterLinks.length; i++) {
                    this.removeOutgoingLink(this.typeParameterLinks[i]);
                }
            }
            this.typeParameterLinks = null;
            this.memberTypeParameterNameCache = null;
        };
        PullTypeSymbol.prototype.setResolved = function () {
            this.invalidatedSpecializations = true;
            _super.prototype.setResolved.call(this);
        };
        PullTypeSymbol.prototype.invalidate = function () {
            this.memberNameCache = null;
            this.memberCache = null;
            this.memberTypeNameCache = null;
            this.containedMemberCache = null;
            this.invalidatedSpecializations = false;
            this.containedByLinks = null;
            this.memberLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.PrivateMember || psl.kind == TypeScript.SymbolLinkKind.PublicMember;
            });
            this.typeParameterLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.TypeParameter;
            });
            this.callSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.CallSignature;
            });
            this.constructSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.ConstructSignature;
            });
            this.indexSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.IndexSignature;
            });
            this.implementedTypeLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.Implements;
            });
            this.extendedTypeLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == TypeScript.SymbolLinkKind.Extends;
            });
            this.knownBaseTypeCount = 0;
            _super.prototype.invalidate.call(this);
        };
        PullTypeSymbol.prototype.getNamePartForFullName = function (scopeSymbol) {
            var name = _super.prototype.getNamePartForFullName.call(this, scopeSymbol);
            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }
            var typarString = PullSymbol.getTypeParameterString(typars, this);
            return name + typarString;
        };
        PullTypeSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getScopedName.call(this, scopeSymbol, useConstraintInName);
            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }
            var typarString = PullSymbol.getTypeParameterString(typars, this);
            return name + typarString;
        };
        PullTypeSymbol.prototype.isNamedTypeSymbol = function () {
            var kind = this.getKind();
            if (kind == TypeScript.PullElementKind.Primitive || kind == TypeScript.PullElementKind.Class || kind == TypeScript.PullElementKind.Container || kind == TypeScript.PullElementKind.DynamicModule || kind == TypeScript.PullElementKind.Enum || kind == TypeScript.PullElementKind.TypeParameter || ((kind == TypeScript.PullElementKind.Interface || kind == TypeScript.PullElementKind.ObjectType) && this.getName() != "")) {
                return true;
            }
            return false;
        };
        PullTypeSymbol.prototype.toString = function (useConstraintInName) {
            var s = this.getScopedNameEx(null, useConstraintInName).toString();
            return s;
        };
        PullTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName) {
            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(true, scopeSymbol, getPrettyTypeName);
            }
            return _super.prototype.getScopedNameEx.call(this, scopeSymbol, useConstraintInName, getPrettyTypeName);
        };
        PullTypeSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length == 0 && constructSignatures.length == 0 && callSignatures.length > 1;
        };
        PullTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();
            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                var allMemberNames = new TypeScript.MemberNameArray();
                var curlies = !topLevel || indexSignatures.length != 0;
                var delim = "; ";
                for(var i = 0; i < members.length; i++) {
                    var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);
                    if (memberTypeName.isArray() && (memberTypeName).delim == delim) {
                        allMemberNames.addAll((memberTypeName).entries);
                    } else {
                        allMemberNames.add(memberTypeName);
                    }
                    curlies = true;
                }
                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();
                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                if (signatureCount != 0 || members.length != 0) {
                    var useShortFormSignature = !curlies && (signatureCount == 1);
                    var signatureMemberName;
                    if (callSignatures.length > 0) {
                        signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, "", useShortFormSignature, false, scopeSymbol, getPrettyFunctionOverload);
                        allMemberNames.addAll(signatureMemberName);
                    }
                    if (constructSignatures.length > 0) {
                        signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, false, scopeSymbol);
                        allMemberNames.addAll(signatureMemberName);
                    }
                    if (indexSignatures.length > 0) {
                        signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, "", useShortFormSignature, true, scopeSymbol);
                        allMemberNames.addAll(signatureMemberName);
                    }
                    if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                        allMemberNames.prefix = "{ ";
                        allMemberNames.suffix = "}";
                        allMemberNames.delim = delim;
                    } else if (allMemberNames.entries.length > 1) {
                        allMemberNames.delim = delim;
                    }
                    return allMemberNames;
                }
            }
            return TypeScript.MemberName.create("{}");
        };
        PullTypeSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var isVisible = _super.prototype.isExternallyVisible.call(this, inIsExternallyVisibleSymbols);
            if (isVisible) {
                var typars = this.getTypeArguments();
                if (!typars || !typars.length) {
                    typars = this.getTypeParameters();
                }
                if (typars) {
                    for(var i = 0; i < typars.length; i++) {
                        isVisible = PullSymbol.getIsExternallyVisible(typars[i], this, inIsExternallyVisibleSymbols);
                        if (!isVisible) {
                            break;
                        }
                    }
                }
            }
            return isVisible;
        };
        PullTypeSymbol.prototype.setType = function (type) {
            TypeScript.Debug.assert(false, "tried to set type of type");
        };
        return PullTypeSymbol;
    })(PullSymbol);
    TypeScript.PullTypeSymbol = PullTypeSymbol;    
    var PullPrimitiveTypeSymbol = (function (_super) {
        __extends(PullPrimitiveTypeSymbol, _super);
        function PullPrimitiveTypeSymbol(name) {
            _super.call(this, name, TypeScript.PullElementKind.Primitive);
        }
        PullPrimitiveTypeSymbol.prototype.isResolved = function () {
            return true;
        };
        PullPrimitiveTypeSymbol.prototype.isStringConstant = function () {
            return false;
        };
        PullPrimitiveTypeSymbol.prototype.isFixed = function () {
            return true;
        };
        PullPrimitiveTypeSymbol.prototype.invalidate = function () {
        };
        return PullPrimitiveTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullPrimitiveTypeSymbol = PullPrimitiveTypeSymbol;    
    var PullStringConstantTypeSymbol = (function (_super) {
        __extends(PullStringConstantTypeSymbol, _super);
        function PullStringConstantTypeSymbol(name) {
            _super.call(this, name);
        }
        PullStringConstantTypeSymbol.prototype.isStringConstant = function () {
            return true;
        };
        return PullStringConstantTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullStringConstantTypeSymbol = PullStringConstantTypeSymbol;    
    var PullErrorTypeSymbol = (function (_super) {
        __extends(PullErrorTypeSymbol, _super);
        function PullErrorTypeSymbol(diagnostic, delegateType) {
            _super.call(this, "error");
            this.diagnostic = diagnostic;
            this.delegateType = delegateType;
        }
        PullErrorTypeSymbol.prototype.isError = function () {
            return true;
        };
        PullErrorTypeSymbol.prototype.getDiagnostic = function () {
            return this.diagnostic;
        };
        PullErrorTypeSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            return this.delegateType.getName(scopeSymbol, useConstraintInName);
        };
        PullErrorTypeSymbol.prototype.toString = function () {
            return this.delegateType.toString();
        };
        return PullErrorTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullErrorTypeSymbol = PullErrorTypeSymbol;    
    var PullClassTypeSymbol = (function (_super) {
        __extends(PullClassTypeSymbol, _super);
        function PullClassTypeSymbol(name) {
            _super.call(this, name, TypeScript.PullElementKind.Class);
            this.constructorMethod = null;
            this.hasDefaultConstructor = false;
        }
        PullClassTypeSymbol.prototype.isClass = function () {
            return true;
        };
        PullClassTypeSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (typeof hasOne === "undefined") { hasOne = true; }
            this.hasDefaultConstructor = hasOne;
        };
        PullClassTypeSymbol.prototype.getHasDefaultConstructor = function () {
            return this.hasDefaultConstructor;
        };
        PullClassTypeSymbol.prototype.getConstructorMethod = function () {
            return this.constructorMethod;
        };
        PullClassTypeSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            this.constructorMethod = constructorMethod;
        };
        PullClassTypeSymbol.prototype.invalidate = function () {
            if (this.constructorMethod) {
                this.constructorMethod.invalidate();
            }
            _super.prototype.invalidate.call(this);
        };
        return PullClassTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullClassTypeSymbol = PullClassTypeSymbol;    
    var PullContainerTypeSymbol = (function (_super) {
        __extends(PullContainerTypeSymbol, _super);
        function PullContainerTypeSymbol(name, kind) {
            if (typeof kind === "undefined") { kind = TypeScript.PullElementKind.Container; }
            _super.call(this, name, kind);
            this.instanceSymbol = null;
        }
        PullContainerTypeSymbol.prototype.isContainer = function () {
            return true;
        };
        PullContainerTypeSymbol.prototype.setInstanceSymbol = function (symbol) {
            this.instanceSymbol = symbol;
        };
        PullContainerTypeSymbol.prototype.getInstanceSymbol = function () {
            return this.instanceSymbol;
        };
        PullContainerTypeSymbol.prototype.invalidate = function () {
            if (this.instanceSymbol) {
                this.instanceSymbol.invalidate();
            }
            _super.prototype.invalidate.call(this);
        };
        PullContainerTypeSymbol.prototype.findAliasedType = function (decls) {
            for(var i = 0; i < decls.length; i++) {
                var childDecls = decls[i].getChildDecls();
                for(var j = 0; j < childDecls.length; j++) {
                    if (childDecls[j].getKind() == TypeScript.PullElementKind.TypeAlias) {
                        var symbol = childDecls[j].getSymbol();
                        if (symbol.getType() == this) {
                            return symbol;
                        }
                    }
                }
            }
            return null;
        };
        PullContainerTypeSymbol.prototype.getAliasedSymbol = function (scopeSymbol) {
            var scopePath = scopeSymbol.pathToRoot();
            if (scopePath.length && scopePath[scopePath.length - 1].getKind() == TypeScript.PullElementKind.DynamicModule) {
                var decls = scopePath[scopePath.length - 1].getDeclarations();
                var symbol = this.findAliasedType(decls);
                return symbol;
            }
            return null;
        };
        PullContainerTypeSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            if (scopeSymbol && this.getKind() == TypeScript.PullElementKind.DynamicModule) {
                var symbol = this.getAliasedSymbol(scopeSymbol);
                if (symbol) {
                    return symbol.getName();
                }
            }
            return _super.prototype.getName.call(this);
        };
        return PullContainerTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullContainerTypeSymbol = PullContainerTypeSymbol;    
    var PullTypeAliasSymbol = (function (_super) {
        __extends(PullTypeAliasSymbol, _super);
        function PullTypeAliasSymbol(name) {
            _super.call(this, name, TypeScript.PullElementKind.TypeAlias);
            this.typeAliasLink = null;
            this.isUsedAsValue = false;
            this.typeUsedExternally = false;
        }
        PullTypeAliasSymbol.prototype.isAlias = function () {
            return true;
        };
        PullTypeAliasSymbol.prototype.isContainer = function () {
            return true;
        };
        PullTypeAliasSymbol.prototype.setAliasedType = function (type) {
            if (this.typeAliasLink) {
                this.removeOutgoingLink(this.typeAliasLink);
            }
            this.typeAliasLink = this.addOutgoingLink(type, TypeScript.SymbolLinkKind.Aliases);
        };
        PullTypeAliasSymbol.prototype.getType = function () {
            if (this.typeAliasLink) {
                return this.typeAliasLink.end;
            }
            return null;
        };
        PullTypeAliasSymbol.prototype.setType = function (type) {
            this.setAliasedType(type);
        };
        PullTypeAliasSymbol.prototype.setIsUsedAsValue = function () {
            this.isUsedAsValue = true;
        };
        PullTypeAliasSymbol.prototype.getIsUsedAsValue = function () {
            return this.isUsedAsValue;
        };
        PullTypeAliasSymbol.prototype.setIsTypeUsedExternally = function () {
            this.typeUsedExternally = true;
        };
        PullTypeAliasSymbol.prototype.getTypeUsedExternally = function () {
            return this.typeUsedExternally;
        };
        PullTypeAliasSymbol.prototype.getMembers = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getMembers();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.getCallSignatures = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getCallSignatures();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.getConstructSignatures = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getConstructSignatures();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.getIndexSignatures = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getIndexSignatures();
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.findMember = function (name) {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).findMember(name);
            }
            return null;
        };
        PullTypeAliasSymbol.prototype.findNestedType = function (name) {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).findNestedType(name);
            }
            return null;
        };
        PullTypeAliasSymbol.prototype.getAllMembers = function (searchDeclKind, includePrivate) {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getAllMembers(searchDeclKind, includePrivate);
            }
            return [];
        };
        PullTypeAliasSymbol.prototype.invalidate = function () {
            this.isUsedAsValue = false;
            _super.prototype.invalidate.call(this);
        };
        return PullTypeAliasSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeAliasSymbol = PullTypeAliasSymbol;    
    var PullDefinitionSignatureSymbol = (function (_super) {
        __extends(PullDefinitionSignatureSymbol, _super);
        function PullDefinitionSignatureSymbol() {
            _super.apply(this, arguments);

        }
        PullDefinitionSignatureSymbol.prototype.isDefinition = function () {
            return true;
        };
        return PullDefinitionSignatureSymbol;
    })(PullSignatureSymbol);
    TypeScript.PullDefinitionSignatureSymbol = PullDefinitionSignatureSymbol;    
    var PullFunctionTypeSymbol = (function (_super) {
        __extends(PullFunctionTypeSymbol, _super);
        function PullFunctionTypeSymbol() {
            _super.call(this, "", TypeScript.PullElementKind.FunctionType);
            this.definitionSignature = null;
        }
        PullFunctionTypeSymbol.prototype.isFunction = function () {
            return true;
        };
        PullFunctionTypeSymbol.prototype.invalidate = function () {
            var callSignatures = this.getCallSignatures();
            if (callSignatures.length) {
                for(var i = 0; i < callSignatures.length; i++) {
                    callSignatures[i].invalidate();
                }
            }
            this.definitionSignature = null;
            _super.prototype.invalidate.call(this);
        };
        PullFunctionTypeSymbol.prototype.addSignature = function (signature) {
            this.addCallSignature(signature);
            if (signature.isDefinition()) {
                this.definitionSignature = signature;
            }
        };
        PullFunctionTypeSymbol.prototype.getDefinitionSignature = function () {
            return this.definitionSignature;
        };
        return PullFunctionTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullFunctionTypeSymbol = PullFunctionTypeSymbol;    
    var PullConstructorTypeSymbol = (function (_super) {
        __extends(PullConstructorTypeSymbol, _super);
        function PullConstructorTypeSymbol() {
            _super.call(this, "", TypeScript.PullElementKind.ConstructorType);
            this.definitionSignature = null;
        }
        PullConstructorTypeSymbol.prototype.isFunction = function () {
            return true;
        };
        PullConstructorTypeSymbol.prototype.isConstructor = function () {
            return true;
        };
        PullConstructorTypeSymbol.prototype.invalidate = function () {
            this.definitionSignature = null;
            _super.prototype.invalidate.call(this);
        };
        PullConstructorTypeSymbol.prototype.addSignature = function (signature) {
            this.addConstructSignature(signature);
            if (signature.isDefinition()) {
                this.definitionSignature = signature;
            }
        };
        PullConstructorTypeSymbol.prototype.addTypeParameter = function (typeParameter, doNotChangeContainer) {
            this.addMember(typeParameter, TypeScript.SymbolLinkKind.TypeParameter, doNotChangeContainer);
            var constructSignatures = this.getConstructSignatures();
            for(var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        };
        PullConstructorTypeSymbol.prototype.getDefinitionSignature = function () {
            return this.definitionSignature;
        };
        return PullConstructorTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullConstructorTypeSymbol = PullConstructorTypeSymbol;    
    var PullTypeParameterSymbol = (function (_super) {
        __extends(PullTypeParameterSymbol, _super);
        function PullTypeParameterSymbol(name) {
            _super.call(this, name, TypeScript.PullElementKind.TypeParameter);
            this.constraintLink = null;
        }
        PullTypeParameterSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeParameterSymbol.prototype.isFixed = function () {
            return false;
        };
        PullTypeParameterSymbol.prototype.setConstraint = function (constraintType) {
            if (this.constraintLink) {
                this.removeOutgoingLink(this.constraintLink);
            }
            this.constraintLink = this.addOutgoingLink(constraintType, TypeScript.SymbolLinkKind.TypeConstraint);
        };
        PullTypeParameterSymbol.prototype.getConstraint = function () {
            if (this.constraintLink) {
                return this.constraintLink.end;
            }
            return null;
        };
        PullTypeParameterSymbol.prototype.isGeneric = function () {
            return true;
        };
        PullTypeParameterSymbol.prototype.fullName = function (scopeSymbol) {
            var name = this.getName(scopeSymbol);
            var container = this.getContainer();
            if (container) {
                var containerName = container.fullName(scopeSymbol);
                name = name + " in " + containerName;
            }
            return name;
        };
        PullTypeParameterSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getName.call(this, scopeSymbol);
            if (this.isPrinting) {
                return name;
            }
            this.isPrinting = true;
            if (useConstraintInName && this.constraintLink) {
                name += " extends " + this.constraintLink.end.toString();
            }
            this.isPrinting = false;
            return name;
        };
        PullTypeParameterSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var constraint = this.getConstraint();
            if (constraint) {
                return PullSymbol.getIsExternallyVisible(constraint, this, inIsExternallyVisibleSymbols);
            }
            return true;
        };
        return PullTypeParameterSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeParameterSymbol = PullTypeParameterSymbol;    
    var PullTypeVariableSymbol = (function (_super) {
        __extends(PullTypeVariableSymbol, _super);
        function PullTypeVariableSymbol(name) {
            _super.call(this, name);
            this.tyvarID = TypeScript.globalTyvarID++;
        }
        PullTypeVariableSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeVariableSymbol.prototype.isTypeVariable = function () {
            return true;
        };
        return PullTypeVariableSymbol;
    })(PullTypeParameterSymbol);
    TypeScript.PullTypeVariableSymbol = PullTypeVariableSymbol;    
    var PullAccessorSymbol = (function (_super) {
        __extends(PullAccessorSymbol, _super);
        function PullAccessorSymbol(name) {
            _super.call(this, name, TypeScript.PullElementKind.Property);
            this.getterSymbolLink = null;
            this.setterSymbolLink = null;
        }
        PullAccessorSymbol.prototype.isAccessor = function () {
            return true;
        };
        PullAccessorSymbol.prototype.setSetter = function (setter) {
            this.setterSymbolLink = this.addOutgoingLink(setter, TypeScript.SymbolLinkKind.SetterFunction);
        };
        PullAccessorSymbol.prototype.getSetter = function () {
            var setter = null;
            if (this.setterSymbolLink) {
                setter = this.setterSymbolLink.end;
            }
            return setter;
        };
        PullAccessorSymbol.prototype.removeSetter = function () {
            if (this.setterSymbolLink) {
                this.removeOutgoingLink(this.setterSymbolLink);
            }
        };
        PullAccessorSymbol.prototype.setGetter = function (getter) {
            this.getterSymbolLink = this.addOutgoingLink(getter, TypeScript.SymbolLinkKind.GetterFunction);
        };
        PullAccessorSymbol.prototype.getGetter = function () {
            var getter = null;
            if (this.getterSymbolLink) {
                getter = this.getterSymbolLink.end;
            }
            return getter;
        };
        PullAccessorSymbol.prototype.removeGetter = function () {
            if (this.getterSymbolLink) {
                this.removeOutgoingLink(this.getterSymbolLink);
            }
        };
        PullAccessorSymbol.prototype.invalidate = function () {
            if (this.getterSymbolLink) {
                this.getterSymbolLink.end.invalidate();
            }
            if (this.setterSymbolLink) {
                this.setterSymbolLink.end.invalidate();
            }
            _super.prototype.invalidate.call(this);
        };
        return PullAccessorSymbol;
    })(PullSymbol);
    TypeScript.PullAccessorSymbol = PullAccessorSymbol;    
    var PullArrayTypeSymbol = (function (_super) {
        __extends(PullArrayTypeSymbol, _super);
        function PullArrayTypeSymbol() {
            _super.call(this, "Array", TypeScript.PullElementKind.Array);
            this.elementType = null;
        }
        PullArrayTypeSymbol.prototype.isArray = function () {
            return true;
        };
        PullArrayTypeSymbol.prototype.getElementType = function () {
            return this.elementType;
        };
        PullArrayTypeSymbol.prototype.isGeneric = function () {
            return true;
        };
        PullArrayTypeSymbol.prototype.setElementType = function (type) {
            this.elementType = type;
        };
        PullArrayTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName) {
            var elementMemberName = this.elementType ? this.elementType.getScopedNameEx(scopeSymbol, false, getPrettyTypeName) : TypeScript.MemberName.create("any");
            return TypeScript.MemberName.create(elementMemberName, "", "[]");
        };
        PullArrayTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var elementMemberName = this.elementType ? this.elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName) : TypeScript.MemberName.create("any");
            return TypeScript.MemberName.create(elementMemberName, "", "[]");
        };
        return PullArrayTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullArrayTypeSymbol = PullArrayTypeSymbol;    
    function specializeToArrayType(typeToReplace, typeToSpecializeTo, resolver, context) {
        var arrayInterfaceType = resolver.getCachedArrayType();
        if (!arrayInterfaceType || (arrayInterfaceType.getKind() & TypeScript.PullElementKind.Interface) == 0) {
            return null;
        }
        if (arrayInterfaceType.isGeneric()) {
            var enclosingDecl = arrayInterfaceType.getDeclarations()[0];
            return specializeType(arrayInterfaceType, [
                typeToSpecializeTo
            ], resolver, enclosingDecl, context);
        }
        if (typeToSpecializeTo.getArrayType()) {
            return typeToSpecializeTo.getArrayType();
        }
        var newArrayType = new PullArrayTypeSymbol();
        newArrayType.addDeclaration(arrayInterfaceType.getDeclarations()[0]);
        typeToSpecializeTo.setArrayType(newArrayType);
        newArrayType.addOutgoingLink(typeToSpecializeTo, TypeScript.SymbolLinkKind.ArrayOf);
        var field = null;
        var newField = null;
        var fieldType = null;
        var method = null;
        var methodType = null;
        var newMethod = null;
        var newMethodType = null;
        var signatures = null;
        var newSignature = null;
        var parameters = null;
        var newParameter = null;
        var parameterType = null;
        var returnType = null;
        var newReturnType = null;
        var members = arrayInterfaceType.getMembers();
        for(var i = 0; i < members.length; i++) {
            resolver.resolveDeclaredSymbol(members[i], null, context);
            if (members[i].getKind() == TypeScript.PullElementKind.Method) {
                method = members[i];
                resolver.resolveDeclaredSymbol(method, null, context);
                methodType = method.getType();
                newMethod = new PullSymbol(method.getName(), TypeScript.PullElementKind.Method);
                newMethodType = new PullFunctionTypeSymbol();
                newMethod.setType(newMethodType);
                newMethod.addDeclaration(method.getDeclarations()[0]);
                signatures = methodType.getCallSignatures();
                for(var j = 0; j < signatures.length; j++) {
                    newSignature = new PullSignatureSymbol(TypeScript.PullElementKind.CallSignature);
                    newSignature.addDeclaration(signatures[j].getDeclarations()[0]);
                    parameters = signatures[j].getParameters();
                    returnType = signatures[j].getReturnType();
                    if (returnType == typeToReplace) {
                        newSignature.setReturnType(typeToSpecializeTo);
                    } else {
                        newSignature.setReturnType(returnType);
                    }
                    for(var k = 0; k < parameters.length; k++) {
                        newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());
                        parameterType = parameters[k].getType();
                        if (parameterType === null) {
                            continue;
                        }
                        if (parameterType == typeToReplace) {
                            newParameter.setType(typeToSpecializeTo);
                        } else {
                            newParameter.setType(parameterType);
                        }
                        newSignature.addParameter(newParameter);
                    }
                    newMethodType.addSignature(newSignature);
                }
                newArrayType.addMember(newMethod, TypeScript.SymbolLinkKind.PublicMember);
            } else {
                field = members[i];
                newField = new PullSymbol(field.getName(), field.getKind());
                newField.addDeclaration(field.getDeclarations()[0]);
                fieldType = field.getType();
                if (fieldType == typeToReplace) {
                    newField.setType(typeToSpecializeTo);
                } else {
                    newField.setType(fieldType);
                }
                newArrayType.addMember(newField, TypeScript.SymbolLinkKind.PublicMember);
            }
        }
        newArrayType.addOutgoingLink(arrayInterfaceType, TypeScript.SymbolLinkKind.ArrayType);
        return newArrayType;
    }
    TypeScript.specializeToArrayType = specializeToArrayType;
    TypeScript.nSpecializationsCreated = 0;
    function specializeType(typeToSpecialize, typeArguments, resolver, enclosingDecl, context, ast) {
        if (typeToSpecialize.isPrimitive() || !typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }
        if (typeToSpecialize.currentlyBeingSpecialized()) {
            return typeToSpecialize;
        }
        var searchForExistingSpecialization = typeArguments != null;
        if (typeArguments == null || (context.specializingToAny && typeArguments.length)) {
            typeArguments = [];
        }
        if (typeToSpecialize.isTypeParameter()) {
            if (context.specializingToAny) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            var substitution = context.findSpecializationForType(typeToSpecialize);
            if (substitution != typeToSpecialize) {
                return substitution;
            }
            if (typeArguments && typeArguments.length) {
                return typeArguments[0];
            }
            return typeToSpecialize;
        }
        if (typeToSpecialize.isArray()) {
            var newElementType = null;
            if (!context.specializingToAny) {
                var elementType = (typeToSpecialize).getElementType();
                newElementType = specializeType(elementType, typeArguments, resolver, enclosingDecl, context, ast);
            } else {
                newElementType = resolver.semanticInfoChain.anyTypeSymbol;
            }
            var newArrayType = specializeType(resolver.getCachedArrayType(), [
                newElementType
            ], resolver, enclosingDecl, context);
            return newArrayType;
        }
        var typeParameters = typeToSpecialize.getTypeParameters();
        var isArray = typeToSpecialize == resolver.getCachedArrayType() || typeToSpecialize.isArray();
        var newType = null;
        var newTypeDecl = typeToSpecialize.getDeclarations()[0];
        var rootType = (typeToSpecialize.getKind() & (TypeScript.PullElementKind.Class | TypeScript.PullElementKind.Interface)) ? newTypeDecl.getSymbol().getType() : typeToSpecialize;
        if (searchForExistingSpecialization) {
            if (!typeArguments.length || context.specializingToAny) {
                for(var i = 0; i < typeParameters.length; i++) {
                    typeArguments[typeArguments.length] = resolver.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (isArray) {
                newType = typeArguments[0].getArrayType();
            } else if (typeArguments.length) {
                newType = rootType.getSpecialization(typeArguments);
            }
            if (!newType && !typeParameters.length && context.specializingToAny) {
                newType = rootType.getSpecialization([
                    resolver.semanticInfoChain.anyTypeSymbol
                ]);
            }
        } else {
            var knownTypeArguments = typeToSpecialize.getTypeArguments();
            var typesToReplace = knownTypeArguments ? knownTypeArguments : typeParameters;
            for(var i = 0; i < typesToReplace.length; i++) {
                substitution = context.findSpecializationForType(typesToReplace[i]);
                typeArguments[i] = substitution != null ? substitution : typesToReplace[i];
            }
            newType = rootType.getSpecialization(typeArguments);
        }
        if (newType) {
            if (!newType.isResolved() && !newType.currentlyBeingSpecialized()) {
                typeToSpecialize.invalidateSpecializations();
            } else {
                return newType;
            }
        }
        var prevInSpecialization = context.inSpecialization;
        TypeScript.nSpecializationsCreated++;
        newType = typeToSpecialize.isClass() ? new PullClassTypeSymbol(typeToSpecialize.getName()) : isArray ? new PullArrayTypeSymbol() : typeToSpecialize.isTypeParameter() ? new PullTypeVariableSymbol(typeToSpecialize.getName()) : new PullTypeSymbol(typeToSpecialize.getName(), typeToSpecialize.getKind());
        newType.addDeclaration(newTypeDecl);
        newType.setIsBeingSpecialized();
        newType.setTypeArguments(typeArguments);
        rootType.addSpecialization(newType, typeArguments);
        if (isArray) {
            (newType).setElementType(typeArguments[0]);
            typeArguments[0].setArrayType(newType);
        }
        var typeReplacementMap = {};
        for(var i = 0; i < typeParameters.length; i++) {
            if (typeParameters[i] != typeArguments[i]) {
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            newType.addMember(typeParameters[i], TypeScript.SymbolLinkKind.TypeParameter, true);
        }
        var extendedTypesToSpecialize = typeToSpecialize.getExtendedTypes();
        var typeDecl;
        var typeAST;
        var unitPath;
        if (extendedTypesToSpecialize.length) {
            typeDecl = typeToSpecialize.getDeclarations()[0];
            typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(typeDecl.getScriptName());
            context.pushTypeSpecializationCache(typeReplacementMap);
            var extendTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.extendsList.members[0], 0), typeDecl, context);
            resolver.setUnitPath(unitPath);
            context.popTypeSpecializationCache();
            newType.addExtendedType(extendTypeSymbol);
        }
        var implementedTypesToSpecialize = typeToSpecialize.getImplementedTypes();
        if (implementedTypesToSpecialize.length) {
            typeDecl = typeToSpecialize.getDeclarations()[0];
            typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(typeDecl.getScriptName());
            context.pushTypeSpecializationCache(typeReplacementMap);
            var implementedTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.implementsList.members[0], 0), typeDecl, context);
            resolver.setUnitPath(unitPath);
            context.popTypeSpecializationCache();
            newType.addImplementedType(implementedTypeSymbol);
        }
        var callSignatures = typeToSpecialize.getCallSignatures();
        var constructSignatures = typeToSpecialize.getConstructSignatures();
        var indexSignatures = typeToSpecialize.getIndexSignatures();
        var members = typeToSpecialize.getMembers();
        var newSignature;
        var signature;
        var decl = null;
        var decls = null;
        var declAST = null;
        var parameters;
        var newParameters;
        var returnType = null;
        for(var i = 0; i < callSignatures.length; i++) {
            signature = callSignatures[i];
            if (signature.currentlyBeingSpecialized()) {
                newType.addCallSignature(signature);
                continue;
            }
            context.pushTypeSpecializationCache(typeReplacementMap);
            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());
            newSignature = new PullSignatureSymbol(signature.getKind());
            newSignature.mimicSignature(signature);
            declAST = resolver.semanticInfoChain.getASTForDecl(decl);
            decl.setSignatureSymbol(newSignature);
            resolver.resolveAST(declAST, false, newTypeDecl, context);
            decl.setSignatureSymbol(signature);
            parameters = signature.getParameters();
            newParameters = newSignature.getParameters();
            for(var p = 0; p < parameters.length; p++) {
                newParameters[p].setType(parameters[p].getType());
            }
            newSignature.setResolved();
            resolver.setUnitPath(unitPath);
            returnType = newSignature.getReturnType();
            if (!returnType) {
                newSignature.setReturnType(signature.getReturnType());
            }
            signature.setIsBeingSpecialized();
            newSignature.addDeclaration(decl);
            newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
            signature.setIsSpecialized();
            context.popTypeSpecializationCache();
            if (!newSignature) {
                context.inSpecialization = prevInSpecialization;
                TypeScript.Debug.assert(false, "returning from call");
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            newType.addCallSignature(newSignature);
            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }
        for(var i = 0; i < constructSignatures.length; i++) {
            signature = constructSignatures[i];
            context.pushTypeSpecializationCache(typeReplacementMap);
            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());
            newSignature = new PullSignatureSymbol(signature.getKind());
            newSignature.mimicSignature(signature);
            declAST = resolver.semanticInfoChain.getASTForDecl(decl);
            decl.setSignatureSymbol(newSignature);
            resolver.resolveAST(declAST, false, newTypeDecl, context);
            decl.setSignatureSymbol(signature);
            parameters = signature.getParameters();
            newParameters = newSignature.getParameters();
            for(var p = 0; p < parameters.length; p++) {
                newParameters[p].setType(parameters[p].getType());
            }
            newSignature.setResolved();
            resolver.setUnitPath(unitPath);
            returnType = newSignature.getReturnType();
            if (!returnType) {
                newSignature.setReturnType(signature.getReturnType());
            }
            signature.setIsBeingSpecialized();
            newSignature.addDeclaration(decl);
            newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
            signature.setIsSpecialized();
            context.popTypeSpecializationCache();
            if (!newSignature) {
                context.inSpecialization = prevInSpecialization;
                TypeScript.Debug.assert(false, "returning from construct");
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            newType.addConstructSignature(newSignature);
            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }
        for(var i = 0; i < indexSignatures.length; i++) {
            signature = indexSignatures[i];
            context.pushTypeSpecializationCache(typeReplacementMap);
            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());
            newSignature = new PullSignatureSymbol(signature.getKind());
            newSignature.mimicSignature(signature);
            declAST = resolver.semanticInfoChain.getASTForDecl(decl);
            decl.setSignatureSymbol(newSignature);
            resolver.resolveAST(declAST, false, newTypeDecl, context);
            decl.setSignatureSymbol(signature);
            parameters = signature.getParameters();
            newParameters = newSignature.getParameters();
            for(var p = 0; p < parameters.length; p++) {
                newParameters[p].setType(parameters[p].getType());
            }
            newSignature.setResolved();
            resolver.setUnitPath(unitPath);
            returnType = newSignature.getReturnType();
            if (!returnType) {
                newSignature.setReturnType(signature.getReturnType());
            }
            signature.setIsBeingSpecialized();
            newSignature.addDeclaration(decl);
            newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
            signature.setIsSpecialized();
            context.popTypeSpecializationCache();
            if (!newSignature) {
                context.inSpecialization = prevInSpecialization;
                TypeScript.Debug.assert(false, "returning from index");
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            newType.addIndexSignature(newSignature);
            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }
        var field = null;
        var newField = null;
        var fieldType = null;
        var newFieldType = null;
        var replacementType = null;
        var fieldSignatureSymbol = null;
        for(var i = 0; i < members.length; i++) {
            field = members[i];
            field.setIsBeingSpecialized();
            decls = field.getDeclarations();
            newField = new PullSymbol(field.getName(), field.getKind());
            for(var j = 0; j < decls.length; j++) {
                newField.addDeclaration(decls[j]);
            }
            if (field.getIsOptional()) {
                newField.setIsOptional();
            }
            if (!field.isResolved()) {
                resolver.resolveDeclaredSymbol(field, newTypeDecl, context);
            }
            fieldType = field.getType();
            if (!fieldType) {
                fieldType = newType;
            }
            replacementType = typeReplacementMap[fieldType.getSymbolID().toString()];
            if (replacementType) {
                newField.setType(replacementType);
            } else {
                if (fieldType.isGeneric() && !fieldType.isFixed()) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(decls[0].getScriptName());
                    context.pushTypeSpecializationCache(typeReplacementMap);
                    newFieldType = specializeType(fieldType, typeArguments, resolver, newTypeDecl, context, ast);
                    resolver.setUnitPath(unitPath);
                    context.popTypeSpecializationCache();
                    newField.setType(newFieldType);
                } else {
                    newField.setType(fieldType);
                }
            }
            field.setIsSpecialized();
            newType.addMember(newField, (field.hasFlag(TypeScript.PullElementFlags.Private)) ? TypeScript.SymbolLinkKind.PrivateMember : TypeScript.SymbolLinkKind.PublicMember);
        }
        if (typeToSpecialize.isClass()) {
            var constructorMethod = (typeToSpecialize).getConstructorMethod();
            var newConstructorMethod = new PullSymbol(constructorMethod.getName(), TypeScript.PullElementKind.ConstructorMethod);
            var newConstructorType = specializeType(constructorMethod.getType(), typeArguments, resolver, newTypeDecl, context, ast);
            newConstructorMethod.setType(newConstructorType);
            var constructorDecls = constructorMethod.getDeclarations();
            for(var i = 0; i < constructorDecls.length; i++) {
                newConstructorMethod.addDeclaration(constructorDecls[i]);
                newConstructorType.addDeclaration(constructorDecls[i]);
            }
            (newType).setConstructorMethod(newConstructorMethod);
        }
        newType.setIsSpecialized();
        newType.setResolved();
        context.inSpecialization = prevInSpecialization;
        return newType;
    }
    TypeScript.specializeType = specializeType;
    function specializeSignature(signature, skipLocalTypeParameters, typeReplacementMap, typeArguments, resolver, enclosingDecl, context, ast) {
        if (signature.currentlyBeingSpecialized()) {
            return signature;
        }
        var newSignature = signature.getSpecialization(typeArguments);
        if (newSignature) {
            return newSignature;
        }
        signature.setIsBeingSpecialized();
        var prevInSpecialization = context.inSpecialization;
        context.inSpecialization = true;
        newSignature = new PullSignatureSymbol(signature.getKind());
        newSignature.addDeclaration(signature.getDeclarations()[0]);
        if (signature.hasVariableParamList()) {
            newSignature.setHasVariableParamList();
        }
        if (signature.hasGenericParameter()) {
            newSignature.setHasGenericParameter();
        }
        signature.addSpecialization(newSignature, typeArguments);
        var parameters = signature.getParameters();
        var typeParameters = signature.getTypeParameters();
        var returnType = signature.getReturnType();
        for(var i = 0; i < typeParameters.length; i++) {
            newSignature.addTypeParameter(typeParameters[i]);
        }
        if (signature.hasGenericParameter()) {
            newSignature.setHasGenericParameter();
        }
        var newParameter;
        var newParameterType;
        var newParameterElementType;
        var parameterType;
        var replacementParameterType;
        var localTypeParameters = {};
        var localSkipMap = {};
        if (skipLocalTypeParameters) {
            for(var i = 0; i < typeParameters.length; i++) {
                localTypeParameters[typeParameters[i].getName()] = true;
                localSkipMap[typeParameters[i].getSymbolID().toString()] = typeParameters[i];
            }
        }
        context.pushTypeSpecializationCache(typeReplacementMap);
        if (skipLocalTypeParameters) {
            context.pushTypeSpecializationCache(localSkipMap);
        }
        var newReturnType = (!localTypeParameters[returnType.getName()]) ? specializeType(returnType, typeArguments, resolver, enclosingDecl, context, ast) : returnType;
        if (skipLocalTypeParameters) {
            context.popTypeSpecializationCache();
        }
        context.popTypeSpecializationCache();
        newSignature.setReturnType(newReturnType);
        for(var k = 0; k < parameters.length; k++) {
            newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());
            newParameter.addDeclaration(parameters[k].getDeclarations()[0]);
            parameterType = parameters[k].getType();
            context.pushTypeSpecializationCache(typeReplacementMap);
            if (skipLocalTypeParameters) {
                context.pushTypeSpecializationCache(localSkipMap);
            }
            newParameterType = !localTypeParameters[parameterType.getName()] ? specializeType(parameterType, typeArguments, resolver, enclosingDecl, context, ast) : parameterType;
            if (skipLocalTypeParameters) {
                context.popTypeSpecializationCache();
            }
            context.popTypeSpecializationCache();
            if (parameters[k].getIsOptional()) {
                newParameter.setIsOptional();
            }
            newParameter.setType(newParameterType);
            newSignature.addParameter(newParameter, newParameter.getIsOptional());
        }
        signature.setIsSpecialized();
        context.inSpecialization = prevInSpecialization;
        return newSignature;
    }
    TypeScript.specializeSignature = specializeSignature;
    function getIDForTypeSubstitutions(types) {
        var substitution = "";
        for(var i = 0; i < types.length; i++) {
            substitution += types[i].getSymbolID().toString() + "#";
        }
        return substitution;
    }
    TypeScript.getIDForTypeSubstitutions = getIDForTypeSubstitutions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBindingContext = (function () {
        function PullSymbolBindingContext(semanticInfoChain, scriptName) {
            this.semanticInfoChain = semanticInfoChain;
            this.scriptName = scriptName;
            this.parentChain = [];
            this.declPath = [];
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.semanticInfo = this.semanticInfoChain.getUnit(this.scriptName);
        }
        PullSymbolBindingContext.prototype.getParent = function (n) {
            if (typeof n === "undefined") { n = 0; }
            return this.parentChain ? this.parentChain[this.parentChain.length - 1 - n] : null;
        };
        PullSymbolBindingContext.prototype.getDeclPath = function () {
            return this.declPath;
        };
        PullSymbolBindingContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.getName();
            }
        };
        PullSymbolBindingContext.prototype.popParent = function () {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        };
        return PullSymbolBindingContext;
    })();
    TypeScript.PullSymbolBindingContext = PullSymbolBindingContext;    
    TypeScript.time_in_findSymbol = 0;
    function findSymbolInContext(name, declKind, context, typeLookupPath) {
        var startTime = new Date().getTime();
        var contextSymbolPath = context.getDeclPath();
        var nestedSymbolPath = [];
        var copyOfContextSymbolPath = [];
        var symbol = null;
        var endTime;
        if (typeLookupPath.length) {
            for(var i = 0; i < typeLookupPath.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
            }
            nestedSymbolPath[nestedSymbolPath.length] = name;
            while(nestedSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);
                if (symbol) {
                    endTime = new Date().getTime();
                    TypeScript.time_in_findSymbol += endTime - startTime;
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = name;
            }
        }
        if (contextSymbolPath.length) {
            for(var i = 0; i < contextSymbolPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
            }
            for(var i = 0; i < typeLookupPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
            }
            copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
            while(copyOfContextSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);
                if (symbol) {
                    endTime = new Date().getTime();
                    TypeScript.time_in_findSymbol += endTime - startTime;
                    return symbol;
                }
                copyOfContextSymbolPath.length -= 2;
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
            }
        }
        symbol = context.semanticInfoChain.findSymbol([
            name
        ], declKind);
        endTime = new Date().getTime();
        TypeScript.time_in_findSymbol += endTime - startTime;
        return symbol;
    }
    TypeScript.findSymbolInContext = findSymbolInContext;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CandidateInferenceInfo = (function () {
        function CandidateInferenceInfo() {
            this.typeParameter = null;
            this.isFixed = false;
            this.inferenceCandidates = [];
        }
        CandidateInferenceInfo.prototype.addCandidate = function (candidate) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        };
        return CandidateInferenceInfo;
    })();
    TypeScript.CandidateInferenceInfo = CandidateInferenceInfo;    
    var ArgumentInferenceContext = (function () {
        function ArgumentInferenceContext() {
            this.inferenceCache = {};
            this.candidateCache = {};
        }
        ArgumentInferenceContext.prototype.alreadyRelatingTypes = function (objectType, parameterType) {
            var comboID = (objectType.getSymbolID() << 16) | parameterType.getSymbolID();
            if (this.inferenceCache[comboID]) {
                return true;
            } else {
                this.inferenceCache[comboID] = true;
                return false;
            }
        };
        ArgumentInferenceContext.prototype.getInferenceInfo = function (param) {
            var info = this.candidateCache[param.getSymbolID().toString()];
            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.getSymbolID().toString()] = info;
            }
            return info;
        };
        ArgumentInferenceContext.prototype.addCandidateForInference = function (param, candidate, fix) {
            var info = this.getInferenceInfo(param);
            if (candidate) {
                info.addCandidate(candidate);
            }
            if (!info.isFixed) {
                info.isFixed = fix;
            }
        };
        ArgumentInferenceContext.prototype.getInferenceCandidates = function () {
            var inferenceCandidates = [];
            var info;
            var val;
            for(var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];
                for(var i = 0; i < info.inferenceCandidates.length; i++) {
                    val = {};
                    val[info.typeParameter.getSymbolID().toString()] = info.inferenceCandidates[i];
                    inferenceCandidates[inferenceCandidates.length] = val;
                }
            }
            return inferenceCandidates;
        };
        ArgumentInferenceContext.prototype.inferArgumentTypes = function (resolver, context) {
            var info = null;
            var collection;
            var bestCommonType;
            var results = [];
            var unfit = false;
            for(var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];
                if (!info.inferenceCandidates.length) {
                    continue;
                }
                collection = {
                    getLength: function () {
                        return info.inferenceCandidates.length;
                    },
                    setTypeAtIndex: function (index, type) {
                    },
                    getTypeAtIndex: function (index) {
                        return info.inferenceCandidates[index].getType();
                    }
                };
                bestCommonType = resolver.findBestCommonType(info.inferenceCandidates[0], null, collection, true, context, new TypeScript.TypeComparisonInfo());
                if (!bestCommonType) {
                    bestCommonType = resolver.semanticInfoChain.undefinedTypeSymbol;
                }
                if (bestCommonType == resolver.semanticInfoChain.undefinedTypeSymbol) {
                    unfit = true;
                }
                results[results.length] = {
                    param: info.typeParameter,
                    type: bestCommonType
                };
            }
            return {
                results: results,
                unfit: unfit
            };
        };
        return ArgumentInferenceContext;
    })();
    TypeScript.ArgumentInferenceContext = ArgumentInferenceContext;    
    var PullContextualTypeContext = (function () {
        function PullContextualTypeContext(contextualType, provisional, substitutions) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.substitutions = substitutions;
            this.provisionallyTypedSymbols = [];
            this.provisionalDiagnostic = [];
        }
        PullContextualTypeContext.prototype.recordProvisionallyTypedSymbol = function (symbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        };
        PullContextualTypeContext.prototype.invalidateProvisionallyTypedSymbols = function () {
            for(var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].invalidate();
            }
        };
        PullContextualTypeContext.prototype.postDiagnostic = function (error) {
            this.provisionalDiagnostic[this.provisionalDiagnostic.length] = error;
        };
        PullContextualTypeContext.prototype.hadProvisionalErrors = function () {
            return this.provisionalDiagnostic.length > 0;
        };
        return PullContextualTypeContext;
    })();
    TypeScript.PullContextualTypeContext = PullContextualTypeContext;    
    var PullTypeResolutionContext = (function () {
        function PullTypeResolutionContext(emitting) {
            if (typeof emitting === "undefined") { emitting = false; }
            this.emitting = emitting;
            this.contextStack = [];
            this.typeSpecializationStack = [];
            this.genericASTResolutionStack = [];
            this.resolvingTypeReference = false;
            this.resolveAggressively = false;
            this.searchTypeSpace = false;
            this.specializingToAny = false;
            this.inSpecialization = false;
            this.suppressErrors = false;
            this.inBaseTypeResolution = false;
        }
        PullTypeResolutionContext.prototype.pushContextualType = function (type, provisional, substitutions) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        };
        PullTypeResolutionContext.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();
            tc.invalidateProvisionallyTypedSymbols();
            return tc;
        };
        PullTypeResolutionContext.prototype.findSubstitution = function (type) {
            var substitution = null;
            if (this.contextStack.length) {
                for(var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.getSymbolID().toString()];
                        if (substitution) {
                            break;
                        }
                    }
                }
            }
            return substitution;
        };
        PullTypeResolutionContext.prototype.getContextualType = function () {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];
            if (context) {
                var type = context.contextualType;
                if (type.isTypeParameter() && (type).getConstraint()) {
                    type = (type).getConstraint();
                }
                var substitution = this.findSubstitution(type);
                return substitution ? substitution : type;
            }
            return null;
        };
        PullTypeResolutionContext.prototype.inProvisionalResolution = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };
        PullTypeResolutionContext.prototype.isInBaseTypeResolution = function () {
            return this.inBaseTypeResolution;
        };
        PullTypeResolutionContext.prototype.startBaseTypeResolution = function () {
            var wasInBaseTypeResoltion = this.inBaseTypeResolution;
            this.inBaseTypeResolution = true;
            return wasInBaseTypeResoltion;
        };
        PullTypeResolutionContext.prototype.doneBaseTypeResolution = function (wasInBaseTypeResolution) {
            this.inBaseTypeResolution = wasInBaseTypeResolution;
        };
        PullTypeResolutionContext.prototype.setTypeInContext = function (symbol, type) {
            var substitution = this.findSubstitution(type);
            symbol.setType(substitution ? substitution : type);
            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        };
        PullTypeResolutionContext.prototype.pushTypeSpecializationCache = function (cache) {
            this.typeSpecializationStack[this.typeSpecializationStack.length] = cache;
        };
        PullTypeResolutionContext.prototype.popTypeSpecializationCache = function () {
            if (this.typeSpecializationStack.length) {
                this.typeSpecializationStack.length--;
            }
        };
        PullTypeResolutionContext.prototype.findSpecializationForType = function (type) {
            var specialization = null;
            for(var i = this.typeSpecializationStack.length - 1; i >= 0; i--) {
                specialization = (this.typeSpecializationStack[i])[type.getSymbolID().toString()];
                if (specialization) {
                    return specialization;
                }
            }
            return type;
        };
        PullTypeResolutionContext.prototype.postError = function (offset, length, fileName, message, enclosingDecl, addToDecl) {
            if (typeof addToDecl === "undefined") { addToDecl = false; }
            if (this.emitting) {
                return;
            }
            var diagnostic = new TypeScript.PullDiagnostic(offset, length, fileName, message);
            if (this.inProvisionalResolution()) {
                (this.contextStack[this.contextStack.length - 1]).postDiagnostic(diagnostic);
            } else if (!this.suppressErrors && enclosingDecl && addToDecl) {
                enclosingDecl.addDiagnostic(diagnostic);
            }
            return diagnostic;
        };
        PullTypeResolutionContext.prototype.startResolvingTypeArguments = function (ast) {
            this.genericASTResolutionStack[this.genericASTResolutionStack.length] = ast;
        };
        PullTypeResolutionContext.prototype.isResolvingTypeArguments = function (ast) {
            for(var i = 0; i < this.genericASTResolutionStack.length; i++) {
                if (this.genericASTResolutionStack[i].getID() == ast.getID()) {
                    return true;
                }
            }
            return false;
        };
        PullTypeResolutionContext.prototype.doneResolvingTypeArguments = function () {
            this.genericASTResolutionStack.length--;
        };
        return PullTypeResolutionContext;
    })();
    TypeScript.PullTypeResolutionContext = PullTypeResolutionContext;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullResolutionDataCache = (function () {
        function PullResolutionDataCache() {
            this.cacheSize = 16;
            this.rdCache = [];
            this.nextUp = 0;
            for(var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: i
                };
            }
        }
        PullResolutionDataCache.prototype.getResolutionData = function () {
            var rd = null;
            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }
            if (rd == null) {
                this.cacheSize++;
                rd = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }
            this.nextUp++;
            return rd;
        };
        PullResolutionDataCache.prototype.returnResolutionData = function (rd) {
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;
            this.nextUp = rd.id;
        };
        return PullResolutionDataCache;
    })();
    TypeScript.PullResolutionDataCache = PullResolutionDataCache;    
    var PullAdditionalCallResolutionData = (function () {
        function PullAdditionalCallResolutionData() {
            this.targetSymbol = null;
            this.targetTypeSymbol = null;
            this.resolvedSignatures = null;
            this.candidateSignature = null;
            this.actualParametersContextTypeSymbols = null;
        }
        return PullAdditionalCallResolutionData;
    })();
    TypeScript.PullAdditionalCallResolutionData = PullAdditionalCallResolutionData;    
    var PullTypeResolver = (function () {
        function PullTypeResolver(compilationSettings, semanticInfoChain, unitPath) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.unitPath = unitPath;
            this.cachedArrayInterfaceType = null;
            this.cachedNumberInterfaceType = null;
            this.cachedStringInterfaceType = null;
            this.cachedBooleanInterfaceType = null;
            this.cachedObjectInterfaceType = null;
            this.cachedFunctionInterfaceType = null;
            this.cachedIArgumentsInterfaceType = null;
            this.cachedRegExpInterfaceType = null;
            this.cachedFunctionArgumentsSymbol = null;
            this.assignableCache = {};
            this.subtypeCache = {};
            this.identicalCache = {};
            this.resolutionDataCache = new PullResolutionDataCache();
            this.currentUnit = null;
            this.cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", [], TypeScript.PullElementKind.Interface);
            this.cachedNumberInterfaceType = this.getSymbolFromDeclPath("Number", [], TypeScript.PullElementKind.Interface);
            this.cachedStringInterfaceType = this.getSymbolFromDeclPath("String", [], TypeScript.PullElementKind.Interface);
            this.cachedBooleanInterfaceType = this.getSymbolFromDeclPath("Boolean", [], TypeScript.PullElementKind.Interface);
            this.cachedObjectInterfaceType = this.getSymbolFromDeclPath("Object", [], TypeScript.PullElementKind.Interface);
            this.cachedFunctionInterfaceType = this.getSymbolFromDeclPath("Function", [], TypeScript.PullElementKind.Interface);
            this.cachedIArgumentsInterfaceType = this.getSymbolFromDeclPath("IArguments", [], TypeScript.PullElementKind.Interface);
            this.cachedRegExpInterfaceType = this.getSymbolFromDeclPath("RegExp", [], TypeScript.PullElementKind.Interface);
            this.cachedFunctionArgumentsSymbol = new TypeScript.PullSymbol("arguments", TypeScript.PullElementKind.Variable);
            this.cachedFunctionArgumentsSymbol.setType(this.cachedIArgumentsInterfaceType ? this.cachedIArgumentsInterfaceType : this.semanticInfoChain.anyTypeSymbol);
            this.cachedFunctionArgumentsSymbol.setResolved();
            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }
        PullTypeResolver.prototype.getUnitPath = function () {
            return this.unitPath;
        };
        PullTypeResolver.prototype.setUnitPath = function (unitPath) {
            this.unitPath = unitPath;
            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        };
        PullTypeResolver.prototype.getDeclForAST = function (ast, unitPath) {
            return this.semanticInfoChain.getDeclForAST(ast, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.getSymbolForAST = function (ast, context, unitPath) {
            return this.semanticInfoChain.getSymbolForAST(ast, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.setSymbolForAST = function (ast, symbol, context, unitPath) {
            if (context && (context.inProvisionalResolution() || context.inSpecialization)) {
                return;
            }
            this.semanticInfoChain.setSymbolForAST(ast, symbol, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.getASTForSymbol = function (symbol, unitPath) {
            return this.semanticInfoChain.getASTForSymbol(symbol, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.getASTForDecl = function (decl) {
            return this.semanticInfoChain.getASTForDecl(decl);
        };
        PullTypeResolver.prototype.getCachedArrayType = function () {
            return this.cachedArrayInterfaceType;
        };
        PullTypeResolver.prototype.getNewErrorTypeSymbol = function (diagnostic) {
            return new TypeScript.PullErrorTypeSymbol(diagnostic, this.semanticInfoChain.anyTypeSymbol);
        };
        PullTypeResolver.prototype.getPathToDecl = function (decl) {
            if (!decl) {
                return [];
            }
            var decls = [];
            var searchDecls = this.semanticInfoChain.getUnit(decl.getScriptName()).getTopLevelDecls();
            var spanToFind = decl.getSpan();
            var candidateSpan = null;
            var searchKinds = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeFunction | TypeScript.PullElementKind.SomeBlock;
            var found = false;
            while(true) {
                found = false;
                for(var i = 0; i < searchDecls.length; i++) {
                    candidateSpan = searchDecls[i].getSpan();
                    if (spanToFind.start() >= candidateSpan.start() && spanToFind.end() <= candidateSpan.end()) {
                        if (searchDecls[i].getKind() & searchKinds) {
                            if (!(searchDecls[i].getKind() & TypeScript.PullElementKind.ObjectLiteral)) {
                                decls[decls.length] = searchDecls[i];
                            }
                            searchDecls = searchDecls[i].getChildDecls();
                            found = true;
                        }
                    }
                }
                if (!found) {
                    break;
                }
            }
            var parent = decl.getParentDecl();
            if (decls.length && (decl.getKind() & (TypeScript.PullElementKind.SomeFunction | TypeScript.PullElementKind.ObjectType | TypeScript.PullElementKind.FunctionType | TypeScript.PullElementKind.ConstructorType)) && (decls[decls.length - 1] != decl)) {
                if (parent && decls[decls.length - 1] != parent && !(parent.getKind() & TypeScript.PullElementKind.ObjectLiteral)) {
                    decls[decls.length] = parent;
                }
                decls[decls.length] = decl;
            }
            return decls;
        };
        PullTypeResolver.prototype.getEnclosingDecl = function (decl) {
            var declPath = this.getPathToDecl(decl);
            if (!declPath.length) {
                return null;
            } else if (declPath.length > 1 && declPath[declPath.length - 1] == decl) {
                return declPath[declPath.length - 2];
            } else {
                return declPath[declPath.length - 1];
            }
        };
        PullTypeResolver.prototype.findSymbolForPath = function (pathToName, enclosingDecl, declKind) {
            if (!pathToName.length) {
                return null;
            }
            var symbolName = pathToName[pathToName.length - 1];
            var contextDeclPath = this.getPathToDecl(enclosingDecl);
            var contextSymbolPath = [];
            var nestedSymbolPath = [];
            for(var i = 0; i < pathToName.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = pathToName[i];
            }
            var symbol = null;
            while(nestedSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);
                if (symbol) {
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = symbolName;
            }
            for(var i = 0; i < contextDeclPath.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = contextDeclPath[i].getName();
            }
            for(var i = 0; i < pathToName.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = pathToName[i];
            }
            while(contextSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(contextSymbolPath, declKind);
                if (symbol) {
                    return symbol;
                }
                contextSymbolPath.length -= 2;
                contextSymbolPath[contextSymbolPath.length] = symbolName;
            }
            symbol = this.semanticInfoChain.findSymbol([
                symbolName
            ], declKind);
            return symbol;
        };
        PullTypeResolver.prototype.getSymbolFromDeclPath = function (symbolName, declPath, declSearchKind) {
            var symbol = null;
            var decl = null;
            var childDecls;
            var declSymbol = null;
            var declMembers;
            var pathDeclKind;
            var valDecl = null;
            var kind;
            var instanceSymbol = null;
            var instanceType = null;
            for(var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();
                if (decl.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
                if (pathDeclKind & (TypeScript.PullElementKind.Container | TypeScript.PullElementKind.DynamicModule)) {
                    childDecls = decl.searchChildDecls(symbolName, (declSearchKind & TypeScript.PullElementKind.SomeType) !== 0);
                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }
                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        childDecls = decl.searchChildDecls(symbolName, true);
                        if (childDecls.length) {
                            valDecl = childDecls[0];
                            if (valDecl) {
                                return valDecl.getSymbol();
                            }
                        }
                        valDecl = decl.getValueDecl();
                        if (valDecl) {
                            decl = valDecl;
                        }
                    }
                    declSymbol = decl.getSymbol().getType();
                    declMembers = declSymbol.getMembers();
                    for(var j = 0; j < declMembers.length; j++) {
                        if (declMembers[j].getName() == symbolName) {
                            kind = declMembers[j].getKind();
                            if ((kind & declSearchKind) != 0) {
                                return declMembers[j];
                            }
                        }
                    }
                } else if ((declSearchKind & TypeScript.PullElementKind.SomeType) || !(pathDeclKind & TypeScript.PullElementKind.Class)) {
                    childDecls = decl.searchChildDecls(symbolName, (declSearchKind & TypeScript.PullElementKind.SomeType) !== 0);
                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }
                }
            }
            symbol = this.semanticInfoChain.findSymbol([
                symbolName
            ], declSearchKind);
            return symbol;
        };
        PullTypeResolver.prototype.getVisibleSymbolsFromDeclPath = function (declPath) {
            var symbols = [];
            var decl = null;
            var childDecls;
            var pathDeclKind;
            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeValue;
            var parameters;
            for(var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();
                var declSymbol = decl.getSymbol();
                var declKind = decl.getKind();
                if (declKind !== TypeScript.PullElementKind.Class && declKind !== TypeScript.PullElementKind.Interface) {
                    this.addSymbolsFromDecls(decl.getChildDecls(), declSearchKind, symbols);
                }
                switch(declKind) {
                    case TypeScript.PullElementKind.Container:
                    case TypeScript.PullElementKind.DynamicModule:
                        var members = [];
                        if (declSymbol) {
                            members = declSymbol.getMembers();
                        }
                        var instanceSymbol = (declSymbol).getInstanceSymbol();
                        var searchTypeSymbol = instanceSymbol && instanceSymbol.getType();
                        if (searchTypeSymbol) {
                            members = members.concat(searchTypeSymbol.getMembers());
                        }
                        for(var j = 0; j < members.length; j++) {
                            if ((members[j].getKind() & declSearchKind) != 0) {
                                symbols.push(members[j]);
                            }
                        }
                        break;
                    case TypeScript.PullElementKind.Class:
                    case TypeScript.PullElementKind.Interface:
                        if (declSymbol && declSymbol.isGeneric()) {
                            parameters = declSymbol.getTypeParameters();
                            for(var k = 0; k < parameters.length; k++) {
                                symbols.push(parameters[k]);
                            }
                        }
                        break;
                    case TypeScript.PullElementKind.Function:
                    case TypeScript.PullElementKind.ConstructorMethod:
                    case TypeScript.PullElementKind.Method:
                    case TypeScript.PullElementKind.FunctionExpression:
                        if (declSymbol) {
                            var functionType = declSymbol.getType();
                            if (functionType.getHasGenericSignature()) {
                                var signatures = (pathDeclKind == TypeScript.PullElementKind.ConstructorMethod) ? functionType.getConstructSignatures() : functionType.getCallSignatures();
                                if (signatures && signatures.length) {
                                    for(var j = 0; j < signatures.length; j++) {
                                        var signature = signatures[j];
                                        if (signature.isGeneric()) {
                                            parameters = signature.getTypeParameters();
                                            for(var k = 0; k < parameters.length; k++) {
                                                symbols.push(parameters[k]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                }
            }
            var units = this.semanticInfoChain.units;
            for(var i = 0, n = units.length; i < n; i++) {
                var unit = units[i];
                if (unit === this.currentUnit && declPath.length != 0) {
                    continue;
                }
                var topLevelDecls = unit.getTopLevelDecls();
                if (topLevelDecls.length) {
                    for(var j = 0, m = topLevelDecls.length; j < m; j++) {
                        var topLevelDecl = topLevelDecls[j];
                        if (topLevelDecl.getKind() === TypeScript.PullElementKind.Script || topLevelDecl.getKind() === TypeScript.PullElementKind.Global) {
                            this.addSymbolsFromDecls(topLevelDecl.getChildDecls(), declSearchKind, symbols);
                        }
                    }
                }
            }
            return symbols;
        };
        PullTypeResolver.prototype.addSymbolsFromDecls = function (decls, declSearchKind, symbols) {
            if (decls.length) {
                for(var i = 0, n = decls.length; i < n; i++) {
                    if (decls[i].getKind() & declSearchKind) {
                        var symbol = decls[i].getSymbol();
                        if (symbol) {
                            symbols.push(symbol);
                        }
                    }
                }
            }
        };
        PullTypeResolver.prototype.getVisibleSymbols = function (enclosingDecl, context) {
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            if (enclosingDecl && !declPath.length) {
                declPath = [
                    enclosingDecl
                ];
            }
            return this.getVisibleSymbolsFromDeclPath(declPath);
        };
        PullTypeResolver.prototype.getVisibleContextSymbols = function (enclosingDecl, context) {
            var contextualTypeSymbol = context.getContextualType();
            if (!contextualTypeSymbol || this.isAnyOrEquivalent(contextualTypeSymbol)) {
                return null;
            }
            var members;
            if (context.searchTypeSpace) {
                members = contextualTypeSymbol.getAllMembers(TypeScript.PullElementKind.SomeType, false);
            } else {
                members = contextualTypeSymbol.getAllMembers(TypeScript.PullElementKind.SomeValue, false);
            }
            return members;
        };
        PullTypeResolver.prototype.getVisibleMembersFromExpression = function (expression, enclosingDecl, context) {
            var lhs = this.resolveStatementOrExpression(expression, false, enclosingDecl, context);
            var lhsType = lhs.getType();
            if (!lhsType) {
                return null;
            }
            if (this.isAnyOrEquivalent(lhsType)) {
                return null;
            }
            var includePrivate = false;
            var containerSymbol = lhsType;
            if (containerSymbol.getKind() === TypeScript.PullElementKind.ConstructorType) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].getReturnType();
            }
            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = this.getPathToDecl(enclosingDecl);
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for(var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (declPath.indexOf(declaration) >= 0) {
                            includePrivate = true;
                            break;
                        }
                    }
                }
            }
            if (context.searchTypeSpace) {
                return lhsType.getAllMembers(TypeScript.PullElementKind.SomeType, includePrivate);
            } else {
                var members = [];
                if (lhsType.isTypeParameter()) {
                    var constraint = (lhsType).getConstraint();
                    if (constraint) {
                        lhsType = constraint;
                        members = lhsType.getAllMembers(TypeScript.PullElementKind.SomeValue, false);
                    }
                } else {
                    if (lhsType == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                        lhsType = this.cachedNumberInterfaceType;
                    } else if (lhsType == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                        lhsType = this.cachedStringInterfaceType;
                    } else if (lhsType == this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType) {
                        lhsType = this.cachedBooleanInterfaceType;
                    }
                    if (!lhsType.isResolved()) {
                        var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);
                        if (potentiallySpecializedType != lhsType) {
                            if (!lhs.isType()) {
                                context.setTypeInContext(lhs, potentiallySpecializedType);
                            }
                            lhsType = potentiallySpecializedType;
                        }
                    }
                    members = lhsType.getAllMembers(TypeScript.PullElementKind.SomeValue, includePrivate);
                    if (lhsType.isContainer()) {
                        var associatedInstance = (lhsType).getInstanceSymbol();
                        if (associatedInstance) {
                            var instanceType = associatedInstance.getType();
                            var instanceMembers = instanceType.getAllMembers(TypeScript.PullElementKind.SomeValue, includePrivate);
                            members = members.concat(instanceMembers);
                        }
                    }
                }
                if ((lhsType.getKind() == TypeScript.PullElementKind.Enum) && this.cachedNumberInterfaceType) {
                    members = members.concat(this.cachedNumberInterfaceType.getAllMembers(TypeScript.PullElementKind.SomeValue, false));
                } else if (lhsType.getCallSignatures().length && this.cachedFunctionInterfaceType) {
                    members = members.concat(this.cachedFunctionInterfaceType.getAllMembers(TypeScript.PullElementKind.SomeValue, false));
                }
                return members;
            }
        };
        PullTypeResolver.prototype.isAnyOrEquivalent = function (type) {
            return (type == this.semanticInfoChain.anyTypeSymbol) || type.isError();
        };
        PullTypeResolver.prototype.isTypeArgumentOrWrapper = function (type) {
            if (!type) {
                return false;
            }
            if (!type.isGeneric()) {
                return false;
            }
            if (type.isTypeParameter()) {
                return true;
            }
            if (type.isArray()) {
                return this.isTypeArgumentOrWrapper((type).getElementType());
            }
            var typeArguments = type.getTypeArguments();
            if (typeArguments) {
                for(var i = 0; i < typeArguments.length; i++) {
                    if (this.isTypeArgumentOrWrapper(typeArguments[i])) {
                        return true;
                    }
                }
            } else {
                return true;
            }
            return false;
        };
        PullTypeResolver.prototype.findTypeSymbolForDynamicModule = function (idText, currentFileName, search) {
            var originalIdText = idText;
            var symbol = search(idText);
            if (symbol === null) {
                if (!symbol) {
                    idText = TypeScript.swapQuotes(originalIdText);
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }
                if (!symbol && !TypeScript.isRelative(originalIdText)) {
                    idText = originalIdText;
                    var strippedIdText = TypeScript.stripQuotes(idText);
                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));
                    while(symbol === null && path != "") {
                        idText = TypeScript.normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);
                        if (symbol === null) {
                            idText = TypeScript.changePathToDTS(idText);
                            symbol = search(idText);
                        }
                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            } else {
                                path = TypeScript.normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }
            return symbol;
        };
        PullTypeResolver.prototype.resolveDeclaration = function (declAST, context, enclosingDecl) {
            switch(declAST.nodeType) {
                case TypeScript.NodeType.Script:
                    return null;
                case TypeScript.NodeType.ModuleDeclaration:
                    return this.resolveModuleDeclaration(declAST, context);
                case TypeScript.NodeType.InterfaceDeclaration:
                    return this.resolveInterfaceDeclaration(declAST, context);
                case TypeScript.NodeType.ClassDeclaration:
                    return this.resolveClassDeclaration(declAST, context);
                case TypeScript.NodeType.FunctionDeclaration: {
                    var funcDecl = declAST;
                    if (funcDecl.isGetAccessor()) {
                        return this.resolveGetAccessorDeclaration(funcDecl, context);
                    } else if (funcDecl.isSetAccessor()) {
                        return this.resolveSetAccessorDeclaration(funcDecl, context);
                    } else {
                        return this.resolveFunctionDeclaration(declAST, context);
                    }
                }
                case TypeScript.NodeType.VariableDeclarator:
                case TypeScript.NodeType.Parameter:
                    return this.resolveVariableDeclaration(declAST, context, enclosingDecl);
                case TypeScript.NodeType.TypeParameter:
                    return this.resolveTypeParameterDeclaration(declAST, context);
                case TypeScript.NodeType.ImportDeclaration:
                    return this.resolveImportDeclaration(declAST, context);
                case TypeScript.NodeType.ObjectLiteralExpression:
                    return this.resolveObjectLiteralExpression(declAST, false, enclosingDecl, context);
                default:
                    throw new Error("Invalid declaration type");
            }
        };
        PullTypeResolver.prototype.resolveDeclaredSymbol = function (symbol, enclosingDecl, context) {
            if (!symbol || symbol.isResolved()) {
                return symbol;
            }
            if (symbol.isResolving()) {
                if (!symbol.currentlyBeingSpecialized()) {
                    if (!symbol.isType()) {
                        symbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                    return symbol;
                }
            }
            var thisUnit = this.unitPath;
            var decls = symbol.getDeclarations();
            var ast = null;
            for(var i = 0; i < decls.length; i++) {
                var decl = decls[i];
                ast = this.semanticInfoChain.getASTForDecl(decl);
                if (!ast || ast.nodeType == TypeScript.NodeType.Member) {
                    this.setUnitPath(thisUnit);
                    return symbol;
                }
                this.setUnitPath(decl.getScriptName());
                this.resolveDeclaration(ast, context, enclosingDecl);
            }
            var typeArgs = symbol.isType() ? (symbol).getTypeArguments() : null;
            if (typeArgs && typeArgs.length) {
                var typeParameters = (symbol).getTypeParameters();
                var typeCache = {};
                for(var i = 0; i < typeParameters.length; i++) {
                    typeCache[typeParameters[i].getSymbolID().toString()] = typeArgs[i];
                }
                context.pushTypeSpecializationCache(typeCache);
                var specializedSymbol = TypeScript.specializeType((symbol), typeArgs, this, enclosingDecl, context, ast);
                context.popTypeSpecializationCache();
                symbol = specializedSymbol;
            }
            this.setUnitPath(thisUnit);
            return symbol;
        };
        PullTypeResolver.prototype.resolveModuleDeclaration = function (ast, context) {
            var containerSymbol = this.getSymbolForAST(ast, context, this.unitPath);
            if (containerSymbol.isResolved()) {
                return containerSymbol;
            }
            containerSymbol.setResolved();
            var containerDecl = this.getDeclForAST(ast);
            if (containerDecl.getKind() != TypeScript.PullElementKind.Enum) {
                var instanceSymbol = containerSymbol.getInstanceSymbol();
                if (instanceSymbol) {
                    this.resolveDeclaredSymbol(instanceSymbol, containerDecl.getParentDecl(), context);
                }
            }
            return containerSymbol;
        };
        PullTypeResolver.prototype.resolveReferenceTypeDeclaration = function (typeDeclAST, context) {
            var typeDecl = this.getDeclForAST(typeDeclAST);
            var enclosingDecl = this.getEnclosingDecl(typeDecl);
            var typeDeclSymbol = typeDecl.getSymbol();
            var typeDeclIsClass = typeDeclAST.nodeType == TypeScript.NodeType.ClassDeclaration;
            var hasVisited = this.getSymbolForAST(typeDeclAST, context) != null;
            if ((typeDeclSymbol.isResolved() && hasVisited) || (typeDeclSymbol.isResolving() && !context.isInBaseTypeResolution())) {
                return typeDeclSymbol;
            }
            typeDeclSymbol.startResolving();
            if (!typeDeclSymbol.isResolved()) {
                var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
                for(var i = 0; i < typeDeclTypeParameters.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclTypeParameters[i], typeDecl, context);
                }
            }
            var wasInBaseTypeResolution = context.startBaseTypeResolution();
            if (!typeDeclIsClass && !hasVisited && typeDeclSymbol.isResolved()) {
                typeDeclSymbol.resetKnownBaseTypeCount();
            }
            if (typeDeclAST.extendsList) {
                for(var i = typeDeclSymbol.getKnownBaseTypeCount(); i < typeDeclAST.extendsList.members.length; i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var parentType = this.resolveTypeReference(new TypeScript.TypeReference(typeDeclAST.extendsList.members[i], 0), typeDecl, context);
                    if (typeDeclSymbol.isValidBaseKind(parentType, true)) {
                        var resolvedParentType = parentType;
                        if (parentType.isGeneric() && parentType.isResolved() && !parentType.getIsSpecialized()) {
                            parentType = this.specializeTypeToAny(parentType, enclosingDecl, context);
                        }
                        if (!typeDeclSymbol.hasBase(parentType)) {
                            this.setSymbolForAST(typeDeclAST.extendsList.members[i], resolvedParentType, context);
                            typeDeclSymbol.addExtendedType(parentType);
                        }
                    }
                }
            }
            if (typeDeclAST.implementsList && typeDeclIsClass) {
                var extendsCount = typeDeclAST.extendsList ? typeDeclAST.extendsList.members.length : 0;
                for(var i = typeDeclSymbol.getKnownBaseTypeCount(); (i - extendsCount) < typeDeclAST.implementsList.members.length; i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var implementedType = this.resolveTypeReference(new TypeScript.TypeReference(typeDeclAST.implementsList.members[i - extendsCount], 0), typeDecl, context);
                    if (typeDeclSymbol.isValidBaseKind(implementedType, false)) {
                        var resolvedImplementedType = implementedType;
                        if (implementedType.isGeneric() && implementedType.isResolved() && !implementedType.getIsSpecialized()) {
                            implementedType = this.specializeTypeToAny(implementedType, enclosingDecl, context);
                        }
                        if (!typeDeclSymbol.hasBase(implementedType)) {
                            this.setSymbolForAST(typeDeclAST.implementsList.members[i - extendsCount], resolvedImplementedType, context);
                            typeDeclSymbol.addImplementedType(implementedType);
                        }
                    }
                }
            }
            context.doneBaseTypeResolution(wasInBaseTypeResolution);
            if (wasInBaseTypeResolution) {
                return typeDeclSymbol;
            }
            if (!typeDeclSymbol.isResolved()) {
                var typeDeclMembers = typeDeclSymbol.getMembers();
                for(var i = 0; i < typeDeclMembers.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclMembers[i], typeDecl, context);
                }
                if (!typeDeclIsClass) {
                    var callSignatures = typeDeclSymbol.getCallSignatures();
                    for(var i = 0; i < callSignatures.length; i++) {
                        this.resolveDeclaredSymbol(callSignatures[i], typeDecl, context);
                    }
                    var constructSignatures = typeDeclSymbol.getConstructSignatures();
                    for(var i = 0; i < constructSignatures.length; i++) {
                        this.resolveDeclaredSymbol(constructSignatures[i], typeDecl, context);
                    }
                    var indexSignatures = typeDeclSymbol.getIndexSignatures();
                    for(var i = 0; i < indexSignatures.length; i++) {
                        this.resolveDeclaredSymbol(indexSignatures[i], typeDecl, context);
                    }
                }
            }
            this.setSymbolForAST(typeDeclAST.name, typeDeclSymbol, context);
            this.setSymbolForAST(typeDeclAST, typeDeclSymbol, context);
            typeDeclSymbol.setResolved();
            return typeDeclSymbol;
        };
        PullTypeResolver.prototype.resolveClassDeclaration = function (classDeclAST, context) {
            var classDecl = this.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol();
            if (classDeclSymbol.isResolved()) {
                return classDeclSymbol;
            }
            this.resolveReferenceTypeDeclaration(classDeclAST, context);
            if (!classDeclSymbol.isResolved()) {
                return classDeclSymbol;
            }
            var constructorMethod = classDeclSymbol.getConstructorMethod();
            if (constructorMethod) {
                var constructorTypeSymbol = constructorMethod.getType();
                var constructSignatures = constructorTypeSymbol.getConstructSignatures();
                if (!constructSignatures.length) {
                    var constructorSignature;
                    var extendedTypes = classDeclSymbol.getExtendedTypes();
                    var parentType = extendedTypes.length ? extendedTypes[0] : null;
                    if (parentType) {
                        var parentClass = parentType;
                        var parentConstructor = parentClass.getConstructorMethod();
                        var parentConstructorType = parentConstructor.getType();
                        var parentConstructSignatures = parentConstructorType.getConstructSignatures();
                        var parentConstructSignature;
                        var parentParameters;
                        for(var i = 0; i < parentConstructSignatures.length; i++) {
                            parentConstructSignature = parentConstructSignatures[i];
                            parentParameters = parentConstructSignature.getParameters();
                            constructorSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
                            constructorSignature.setReturnType(classDeclSymbol);
                            for(var j = 0; j < parentParameters.length; j++) {
                                constructorSignature.addParameter(parentParameters[j], parentParameters[j].getIsOptional());
                            }
                            constructorTypeSymbol.addConstructSignature(constructorSignature);
                            constructorSignature.addDeclaration(classDecl);
                        }
                    } else {
                        constructorSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
                        constructorSignature.setReturnType(classDeclSymbol);
                        constructorTypeSymbol.addConstructSignature(constructorSignature);
                        constructorSignature.addDeclaration(classDecl);
                    }
                }
                var constructorMembers = constructorTypeSymbol.getMembers();
                this.resolveDeclaredSymbol(constructorMethod, classDecl, context);
                for(var i = 0; i < constructorMembers.length; i++) {
                    this.resolveDeclaredSymbol(constructorMembers[i], classDecl, context);
                }
            }
            return classDeclSymbol;
        };
        PullTypeResolver.prototype.resolveInterfaceDeclaration = function (interfaceDeclAST, context) {
            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();
            this.resolveReferenceTypeDeclaration(interfaceDeclAST, context);
            return interfaceDeclSymbol;
        };
        PullTypeResolver.prototype.resolveImportDeclaration = function (importStatementAST, context) {
            var _this = this;
            var importDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol();
            var aliasName = importStatementAST.id.text;
            var aliasedType = null;
            if (importDeclSymbol.isResolved()) {
                return importDeclSymbol;
            }
            importDeclSymbol.startResolving();
            if (importStatementAST.alias.nodeType == TypeScript.NodeType.TypeRef) {
                aliasedType = this.resolveTypeReference(importStatementAST.alias, enclosingDecl, context);
            } else if (importStatementAST.alias.nodeType == TypeScript.NodeType.Name) {
                var text = (importStatementAST.alias).actualText;
                if (!TypeScript.isQuoted(text)) {
                    aliasedType = this.resolveTypeReference(new TypeScript.TypeReference(importStatementAST.alias, 0), enclosingDecl, context);
                } else {
                    var modPath = (importStatementAST.alias).text;
                    var declPath = this.getPathToDecl(enclosingDecl);
                    importStatementAST.isDynamicImport = true;
                    aliasedType = this.findTypeSymbolForDynamicModule(modPath, importDecl.getScriptName(), function (s) {
                        return _this.getSymbolFromDeclPath(s, declPath, TypeScript.PullElementKind.SomeType);
                    });
                    if (aliasedType) {
                        this.currentUnit.addDynamicModuleImport(importDeclSymbol);
                    } else {
                        importDecl.addDiagnostic(new TypeScript.PullDiagnostic(importStatementAST.minChar, importStatementAST.getLength(), this.currentUnit.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unable_to_resolve_external_module__0_, [
                            modPath
                        ])));
                        aliasedType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
            }
            if (aliasedType) {
                if (!aliasedType.isContainer()) {
                    importDecl.addDiagnostic(new TypeScript.PullDiagnostic(importStatementAST.minChar, importStatementAST.getLength(), this.currentUnit.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Module_cannot_be_aliased_to_a_non_module_type, null)));
                }
                importDeclSymbol.setAliasedType(aliasedType);
                importDeclSymbol.setResolved();
                this.setSymbolForAST(importStatementAST.alias, aliasedType, context);
            }
            return importDeclSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionTypeSignature = function (funcDeclAST, enclosingDecl, context) {
            var funcDeclSymbol = this.getSymbolForAST(funcDeclAST, context, this.unitPath);
            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                declCollectionContext.scriptName = this.unitPath;
                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }
                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                var functionDecl = this.getDeclForAST(funcDeclAST);
                var binder = new TypeScript.PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                if (functionDecl.getKind() == TypeScript.PullElementKind.ConstructorType) {
                    binder.bindConstructorTypeDeclarationToPullSymbol(functionDecl);
                } else {
                    binder.bindFunctionTypeDeclarationToPullSymbol(functionDecl);
                }
                funcDeclSymbol = functionDecl.getSymbol();
            }
            var signature = funcDeclSymbol.getKind() == TypeScript.PullElementKind.ConstructorType ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, enclosingDecl, context);
                signature.setReturnType(returnTypeSymbol);
                if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                    signature.setHasGenericParameter();
                    if (funcDeclSymbol) {
                        funcDeclSymbol.getType().setHasGenericSignature();
                    }
                }
            } else {
                signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
            }
            if (funcDeclAST.arguments) {
                for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(funcDeclAST.arguments.members[i], null, signature, enclosingDecl, context);
                }
            }
            if (signature.hasGenericParameter()) {
                if (funcDeclSymbol) {
                    funcDeclSymbol.getType().setHasGenericSignature();
                }
            }
            funcDeclSymbol.setResolved();
            return funcDeclSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionTypeSignatureParameter = function (argDeclAST, contextParam, signature, enclosingDecl, context) {
            var paramSymbol = this.getSymbolForAST(argDeclAST, context, this.unitPath);
            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);
                if (paramSymbol.getIsVarArg() && !typeRef.isArray()) {
                    var diagnostic = context.postError(argDeclAST.minChar, argDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.VarArgs_must_be_array_types, null), enclosingDecl);
                    context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(diagnostic));
                } else {
                    context.setTypeInContext(paramSymbol, typeRef);
                }
                if (this.isTypeArgumentOrWrapper(typeRef)) {
                    signature.setHasGenericParameter();
                }
            } else {
                if (paramSymbol.getIsVarArg()) {
                    diagnostic = context.postError(argDeclAST.minChar, argDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.VarArgs_must_be_array_types, null), enclosingDecl);
                    context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(diagnostic));
                } else if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }
            paramSymbol.setResolved();
        };
        PullTypeResolver.prototype.resolveFunctionExpressionParameter = function (argDeclAST, contextParam, enclosingDecl, context) {
            var paramSymbol = this.getSymbolForAST(argDeclAST, context);
            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);
                if (paramSymbol.getIsVarArg() && !typeRef.isArray()) {
                    var diagnostic = context.postError(argDeclAST.minChar, argDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.VarArgs_must_be_array_types, null), enclosingDecl);
                    context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(diagnostic));
                } else {
                    context.setTypeInContext(paramSymbol, typeRef);
                }
            } else {
                if (paramSymbol.getIsVarArg()) {
                    diagnostic = context.postError(argDeclAST.minChar, argDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.VarArgs_must_be_array_types, null), enclosingDecl);
                    context.setTypeInContext(paramSymbol, this.getNewErrorTypeSymbol(diagnostic));
                } else if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }
            paramSymbol.setResolved();
        };
        PullTypeResolver.prototype.resolveInterfaceTypeReference = function (interfaceDeclAST, enclosingDecl, context) {
            var interfaceSymbol = this.getSymbolForAST(interfaceDeclAST, context, this.unitPath);
            if (!interfaceSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                declCollectionContext.scriptName = this.unitPath;
                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }
                TypeScript.getAstWalkerFactory().walk(interfaceDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
                var binder = new TypeScript.PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindObjectTypeDeclarationToPullSymbol(interfaceDecl);
                interfaceSymbol = interfaceDecl.getSymbol();
            }
            if (interfaceDeclAST.members) {
                var memberSymbol = null;
                var typeMembers = interfaceDeclAST.members;
                for(var i = 0; i < typeMembers.members.length; i++) {
                    memberSymbol = this.getSymbolForAST(typeMembers.members[i], context, this.unitPath);
                    this.resolveDeclaredSymbol(memberSymbol, enclosingDecl, context);
                }
            }
            interfaceSymbol.setResolved();
            return interfaceSymbol;
        };
        PullTypeResolver.prototype.resolveTypeReference = function (typeRef, enclosingDecl, context) {
            if (!typeRef) {
                return null;
            }
            var previousResolutionSymbol = this.getSymbolForAST(typeRef, context);
            if (previousResolutionSymbol) {
                return previousResolutionSymbol;
            }
            var typeDeclSymbol = null;
            var prevResolvingTypeReference = context.resolvingTypeReference;
            var diagnostic = null;
            if (typeRef.term.nodeType == TypeScript.NodeType.Name) {
                var typeName = typeRef.term;
                context.resolvingTypeReference = true;
                typeDeclSymbol = this.resolveTypeNameExpression(typeName, enclosingDecl, context);
                context.resolvingTypeReference = prevResolvingTypeReference;
                if (typeDeclSymbol.isError()) {
                    return typeDeclSymbol;
                }
            } else if (typeRef.term.nodeType == TypeScript.NodeType.FunctionDeclaration) {
                typeDeclSymbol = this.resolveFunctionTypeSignature(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType == TypeScript.NodeType.InterfaceDeclaration) {
                typeDeclSymbol = this.resolveInterfaceTypeReference(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType == TypeScript.NodeType.GenericType) {
                typeDeclSymbol = this.resolveGenericTypeReference(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType == TypeScript.NodeType.MemberAccessExpression) {
                var dottedName = typeRef.term;
                prevResolvingTypeReference = context.resolvingTypeReference;
                typeDeclSymbol = this.resolveDottedTypeNameExpression(dottedName, enclosingDecl, context);
                context.resolvingTypeReference = prevResolvingTypeReference;
                if (typeDeclSymbol.isError()) {
                    return typeDeclSymbol;
                }
            } else if (typeRef.term.nodeType == TypeScript.NodeType.StringLiteral) {
                typeDeclSymbol = new TypeScript.PullStringConstantTypeSymbol((typeRef.term).text);
            }
            if (!typeDeclSymbol) {
                diagnostic = context.postError(typeRef.term.minChar, typeRef.term.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unable_to_resolve_type, null), enclosingDecl);
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            if (typeRef.arrayCount) {
                var arraySymbol = typeDeclSymbol.getArrayType();
                if (!arraySymbol) {
                    if (!this.cachedArrayInterfaceType) {
                        this.cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), TypeScript.PullElementKind.Interface);
                    }
                    if (this.cachedArrayInterfaceType && !this.cachedArrayInterfaceType.isResolved()) {
                        this.resolveDeclaredSymbol(this.cachedArrayInterfaceType, enclosingDecl, context);
                    }
                    arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, typeDeclSymbol, this, context);
                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                if (this.cachedArrayInterfaceType && typeRef.arrayCount > 1) {
                    var arity = typeRef.arrayCount - 1;
                    var existingArraySymbol = null;
                    while(arity) {
                        existingArraySymbol = arraySymbol.getArrayType();
                        if (!existingArraySymbol) {
                            arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, arraySymbol, this, context);
                        } else {
                            arraySymbol = existingArraySymbol;
                        }
                        arity--;
                    }
                }
                typeDeclSymbol = arraySymbol;
            }
            this.setSymbolForAST(typeRef, typeDeclSymbol, context);
            return typeDeclSymbol;
        };
        PullTypeResolver.prototype.resolveVariableDeclaration = function (varDecl, context, enclosingDecl) {
            var decl = this.getDeclForAST(varDecl);
            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;
            var hadError = false;
            if (declSymbol.isResolved()) {
                return declSymbol.getType();
            }
            if (declSymbol.isResolving()) {
                declSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                declSymbol.setResolved();
                return this.semanticInfoChain.anyTypeSymbol;
            }
            declSymbol.startResolving();
            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;
            var diagnostic = null;
            if (varDecl.typeExpr) {
                var typeExprSymbol = this.resolveTypeReference(varDecl.typeExpr, wrapperDecl, context);
                if (!typeExprSymbol) {
                    diagnostic = context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unable_to_resolve_type_of__0_, [
                        varDecl.id.actualText
                    ]), decl);
                    declSymbol.setType(this.getNewErrorTypeSymbol(diagnostic));
                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                    hadError = true;
                } else {
                    if (typeExprSymbol.isNamedTypeSymbol() && typeExprSymbol.isGeneric() && !typeExprSymbol.isTypeParameter() && typeExprSymbol.isResolved() && !typeExprSymbol.getIsSpecialized()) {
                        typeExprSymbol = this.specializeTypeToAny(typeExprSymbol, enclosingDecl, context);
                    }
                    if (declSymbol.getIsVarArg() && !typeExprSymbol.isArray()) {
                        diagnostic = context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.VarArgs_must_be_array_types, null), decl);
                        typeExprSymbol = this.getNewErrorTypeSymbol(diagnostic);
                        hadError = true;
                    } else {
                        if (typeExprSymbol.isContainer()) {
                            var instanceSymbol = (typeExprSymbol.getType()).getInstanceSymbol();
                            if (!instanceSymbol) {
                                diagnostic = context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type__0__, [
                                    typeExprSymbol.toString()
                                ]), decl);
                                typeExprSymbol = this.getNewErrorTypeSymbol(diagnostic);
                                hadError = true;
                            } else {
                                typeExprSymbol = instanceSymbol.getType();
                            }
                        }
                        context.setTypeInContext(declSymbol, typeExprSymbol);
                        if (declParameterSymbol) {
                            declParameterSymbol.setType(typeExprSymbol);
                        }
                        if ((varDecl.nodeType == TypeScript.NodeType.Parameter) && enclosingDecl && ((typeExprSymbol.isGeneric() && !typeExprSymbol.isArray()) || this.isTypeArgumentOrWrapper(typeExprSymbol))) {
                            var signature = enclosingDecl.getSignatureSymbol();
                            if (signature) {
                                signature.setHasGenericParameter();
                            }
                        }
                    }
                }
            } else if (declSymbol.getIsVarArg()) {
                diagnostic = context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.VarArgs_must_be_array_types, null), decl);
                typeExprSymbol = this.getNewErrorTypeSymbol(diagnostic);
                context.setTypeInContext(declSymbol, typeExprSymbol);
                hadError = true;
            } else if (varDecl.init) {
                var initExprSymbol = this.resolveStatementOrExpression(varDecl.init, false, wrapperDecl, context);
                if (!initExprSymbol) {
                    diagnostic = context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unable_to_resolve_type_of__0_, [
                        varDecl.id.actualText
                    ]), decl);
                    context.setTypeInContext(declSymbol, this.getNewErrorTypeSymbol(diagnostic));
                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                    hadError = true;
                } else {
                    context.setTypeInContext(declSymbol, this.widenType(initExprSymbol.getType()));
                    initExprSymbol.addOutgoingLink(declSymbol, TypeScript.SymbolLinkKind.ProvidesInferredType);
                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, initExprSymbol.getType());
                        initExprSymbol.addOutgoingLink(declParameterSymbol, TypeScript.SymbolLinkKind.ProvidesInferredType);
                    }
                }
            } else if (declSymbol.getKind() == TypeScript.PullElementKind.Container) {
                instanceSymbol = (declSymbol).getInstanceSymbol();
                var instanceType = instanceSymbol.getType();
                if (instanceType) {
                    context.setTypeInContext(declSymbol, instanceType);
                } else {
                    context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            } else {
                context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);
                if (declParameterSymbol) {
                    declParameterSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }
            }
            if (!hadError) {
                declSymbol.setResolved();
                if (declParameterSymbol) {
                    declParameterSymbol.setResolved();
                }
            }
            return declSymbol;
        };
        PullTypeResolver.prototype.resolveTypeParameterDeclaration = function (typeParameterAST, context) {
            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = typeParameterDecl.getSymbol();
            if (typeParameterSymbol.isResolved() || typeParameterSymbol.isResolving()) {
                return typeParameterSymbol;
            }
            typeParameterSymbol.startResolving();
            if (typeParameterAST.constraint) {
                var enclosingDecl = this.getEnclosingDecl(typeParameterDecl);
                var constraintTypeSymbol = this.resolveTypeReference(typeParameterAST.constraint, enclosingDecl, context);
                if (!constraintTypeSymbol) {
                    context.postError(typeParameterAST.minChar, typeParameterAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unable_to_resolve_type_parameter_constraint, null), enclosingDecl, true);
                } else if (constraintTypeSymbol.isPrimitive()) {
                    context.postError(typeParameterAST.constraint.minChar, typeParameterAST.constraint.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_parameter_constraint_may_not_be_a_primitive_type, null), enclosingDecl, true);
                } else {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }
            typeParameterSymbol.setResolved();
            return typeParameterSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionBodyReturnTypes = function (funcDeclAST, signature, useContextualType, enclosingDecl, context) {
            var _this = this;
            var returnStatements = [];
            var enclosingDeclStack = [
                enclosingDecl
            ];
            var preFindReturnExpressionTypes = function (ast, parent, walker) {
                var go = true;
                switch(ast.nodeType) {
                    case TypeScript.NodeType.FunctionDeclaration:
                        go = false;
                        break;
                    case TypeScript.NodeType.ReturnStatement:
                        var returnStatement = ast;
                        returnStatements[returnStatements.length] = {
                            returnStatement: returnStatement,
                            enclosingDecl: enclosingDeclStack[enclosingDeclStack.length - 1]
                        };
                        go = false;
                        break;
                    case TypeScript.NodeType.CatchClause:
                    case TypeScript.NodeType.WithStatement:
                        enclosingDeclStack[enclosingDeclStack.length] = _this.getDeclForAST(ast);
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = go;
                return ast;
            };
            var postFindReturnExpressionEnclosingDecls = function (ast, parent, walker) {
                switch(ast.nodeType) {
                    case TypeScript.NodeType.CatchClause:
                    case TypeScript.NodeType.WithStatement:
                        enclosingDeclStack.length--;
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = true;
                return ast;
            };
            TypeScript.getAstWalkerFactory().walk(funcDeclAST.block, preFindReturnExpressionTypes, postFindReturnExpressionEnclosingDecls);
            if (!returnStatements.length) {
                if (useContextualType) {
                    var contextualType = this.widenType(context.getContextualType());
                    signature.setReturnType(contextualType);
                    var isVoidOrAny = this.isAnyOrEquivalent(contextualType) || contextualType == this.semanticInfoChain.voidTypeSymbol;
                    if (!isVoidOrAny) {
                        context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Function_declared_a_non_void_return_type__but_has_no_return_expression, null), enclosingDecl, true);
                    }
                } else {
                    signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
                }
            } else {
                var returnExpressionSymbols = [];
                var returnType;
                for(var i = 0; i < returnStatements.length; i++) {
                    if (returnStatements[i].returnStatement.returnExpression) {
                        returnType = this.resolveStatementOrExpression(returnStatements[i].returnStatement.returnExpression, useContextualType, returnStatements[i].enclosingDecl, context).getType();
                        if (returnType.isError()) {
                            signature.setReturnType(returnType);
                            return;
                        }
                        returnExpressionSymbols[returnExpressionSymbols.length] = returnType;
                    }
                }
                if (!returnExpressionSymbols.length) {
                    signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
                } else {
                    var collection = {
                        getLength: function () {
                            return returnExpressionSymbols.length;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return returnExpressionSymbols[index].getType();
                        }
                    };
                    returnType = this.findBestCommonType(returnExpressionSymbols[0], null, collection, true, context, new TypeScript.TypeComparisonInfo());
                    signature.setReturnType(returnType ? this.widenType(returnType) : this.semanticInfoChain.anyTypeSymbol);
                    for(var i = 0; i < returnExpressionSymbols.length; i++) {
                        returnExpressionSymbols[i].addOutgoingLink(signature, TypeScript.SymbolLinkKind.ProvidesInferredType);
                    }
                }
            }
        };
        PullTypeResolver.prototype.resolveFunctionDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var funcSymbol = funcDecl.getSymbol();
            var signature = funcDecl.getSignatureSymbol();
            var hadError = false;
            var isConstructor = funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.ConstructMember);
            if (signature) {
                if (signature.isResolved()) {
                    return funcSymbol;
                }
                if (isConstructor && !signature.isResolving()) {
                    var classAST = funcDeclAST.classDecl;
                    if (classAST) {
                        var classDecl = this.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol();
                        if (!classSymbol.isResolved() && !classSymbol.isResolving()) {
                            this.resolveDeclaredSymbol(classSymbol, this.getEnclosingDecl(classDecl), context);
                        }
                    }
                }
                var diagnostic;
                if (signature.isResolving()) {
                    if (funcDeclAST.returnTypeAnnotation) {
                        var returnTypeRef = funcDeclAST.returnTypeAnnotation;
                        var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);
                        if (!returnTypeSymbol) {
                            diagnostic = context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null), funcDecl);
                            signature.setReturnType(this.getNewErrorTypeSymbol(diagnostic));
                            hadError = true;
                        } else {
                            if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                                signature.setHasGenericParameter();
                                if (funcSymbol) {
                                    funcSymbol.getType().setHasGenericSignature();
                                }
                            }
                            signature.setReturnType(returnTypeSymbol);
                            if (isConstructor && returnTypeSymbol == this.semanticInfoChain.voidTypeSymbol) {
                                context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of__void_, null), funcDecl, true);
                            }
                        }
                    } else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                    signature.setResolved();
                    return funcSymbol;
                }
                signature.startResolving();
                if (funcDeclAST.arguments) {
                    for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }
                if (signature.isGeneric()) {
                    if (funcSymbol) {
                        funcSymbol.getType().setHasGenericSignature();
                    }
                }
                if (funcDeclAST.returnTypeAnnotation) {
                    returnTypeRef = funcDeclAST.returnTypeAnnotation;
                    returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);
                    if (!returnTypeSymbol) {
                        diagnostic = context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null), funcDecl);
                        signature.setReturnType(this.getNewErrorTypeSymbol(diagnostic));
                        hadError = true;
                    } else {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.setHasGenericParameter();
                            if (funcSymbol) {
                                funcSymbol.getType().setHasGenericSignature();
                            }
                        }
                        signature.setReturnType(returnTypeSymbol);
                        if (isConstructor && returnTypeSymbol == this.semanticInfoChain.voidTypeSymbol) {
                            context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of__void_, null), funcDecl, true);
                        }
                    }
                } else if (!funcDeclAST.isConstructor) {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, new TypeScript.PullTypeResolutionContext());
                    }
                }
                if (!hadError) {
                    signature.setResolved();
                }
            }
            return funcSymbol;
        };
        PullTypeResolver.prototype.resolveGetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();
            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = getterSymbol.getType();
            var signature = getterTypeSymbol.getCallSignatures()[0];
            var hadError = false;
            var diagnostic;
            if (signature) {
                if (signature.isResolved()) {
                    return accessorSymbol;
                }
                if (signature.isResolving()) {
                    signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    signature.setResolved();
                    return accessorSymbol;
                }
                signature.startResolving();
                if (funcDeclAST.arguments) {
                    for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }
                if (signature.hasGenericParameter()) {
                    if (getterSymbol) {
                        getterTypeSymbol.setHasGenericSignature();
                    }
                }
                if (funcDeclAST.returnTypeAnnotation) {
                    var returnTypeRef = funcDeclAST.returnTypeAnnotation;
                    var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);
                    if (!returnTypeSymbol) {
                        diagnostic = context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null), funcDecl);
                        signature.setReturnType(this.getNewErrorTypeSymbol(diagnostic));
                        hadError = true;
                    } else {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.setHasGenericParameter();
                            if (getterSymbol) {
                                getterTypeSymbol.setHasGenericSignature();
                            }
                        }
                        signature.setReturnType(returnTypeSymbol);
                    }
                } else {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, new TypeScript.PullTypeResolutionContext());
                    }
                }
                if (!hadError) {
                    signature.setResolved();
                }
            }
            var accessorType = signature.getReturnType();
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterType = setter.getType();
                var setterSig = setterType.getCallSignatures()[0];
                if (setterSig.isResolved()) {
                    var setterParameters = setterSig.getParameters();
                    if (setterParameters.length) {
                        var setterParameter = setterParameters[0];
                        var setterParameterType = setterParameter.getType();
                        if (!this.typesAreIdentical(accessorType, setterParameterType)) {
                            diagnostic = context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._get__and__set__accessor_must_have_the_same_type, null), this.getEnclosingDecl(funcDecl));
                            accessorSymbol.setType(this.getNewErrorTypeSymbol(diagnostic));
                        }
                    }
                } else {
                    accessorSymbol.setType(accessorType);
                }
            } else {
                accessorSymbol.setType(accessorType);
            }
            return accessorSymbol;
        };
        PullTypeResolver.prototype.resolveSetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();
            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = setterSymbol.getType();
            var signature = setterTypeSymbol.getCallSignatures()[0];
            var hadError = false;
            if (signature) {
                if (signature.isResolved()) {
                    return accessorSymbol;
                }
                if (signature.isResolving()) {
                    signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    signature.setResolved();
                    return accessorSymbol;
                }
                signature.startResolving();
                if (funcDeclAST.arguments) {
                    for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }
                if (signature.hasGenericParameter()) {
                    if (setterSymbol) {
                        setterTypeSymbol.setHasGenericSignature();
                    }
                }
                if (!hadError) {
                    signature.setResolved();
                }
            }
            var parameters = signature.getParameters();
            if (parameters.length) {
                var accessorType = parameters[0].getType();
                var getter = accessorSymbol.getGetter();
                if (getter) {
                    var getterType = getter.getType();
                    var getterSig = getterType.getCallSignatures()[0];
                    if (getterSig.isResolved()) {
                        var getterReturnType = getterSig.getReturnType();
                        if (!this.typesAreIdentical(accessorType, getterReturnType)) {
                            if (this.isAnyOrEquivalent(accessorType)) {
                                accessorSymbol.setType(getterReturnType);
                                if (!accessorType.isError()) {
                                    parameters[0].setType(getterReturnType);
                                }
                            } else {
                                var diagnostic = context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._get__and__set__accessor_must_have_the_same_type, null), this.getEnclosingDecl(funcDecl));
                                accessorSymbol.setType(this.getNewErrorTypeSymbol(diagnostic));
                            }
                        }
                    } else {
                        accessorSymbol.setType(accessorType);
                    }
                } else {
                    accessorSymbol.setType(accessorType);
                }
            }
            return accessorSymbol;
        };
        PullTypeResolver.prototype.resolveAST = function (ast, isTypedAssignment, enclosingDecl, context) {
            switch(ast.nodeType) {
                case TypeScript.NodeType.ModuleDeclaration:
                case TypeScript.NodeType.InterfaceDeclaration:
                case TypeScript.NodeType.ClassDeclaration:
                case TypeScript.NodeType.VariableDeclarator:
                case TypeScript.NodeType.Parameter:
                    return this.resolveDeclaration(ast, context, enclosingDecl);
                case TypeScript.NodeType.FunctionDeclaration:
                    if (isTypedAssignment || ((ast).getFunctionFlags() & TypeScript.FunctionFlags.IsFunctionExpression)) {
                        return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
                    } else {
                        return this.resolveDeclaration(ast, context, enclosingDecl);
                    }
                default:
                    return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
            }
        };
        PullTypeResolver.prototype.resolveStatementOrExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            switch(expressionAST.nodeType) {
                case TypeScript.NodeType.Name:
                    if (context.searchTypeSpace) {
                        return this.resolveTypeNameExpression(expressionAST, enclosingDecl, context);
                    } else {
                        return this.resolveNameExpression(expressionAST, enclosingDecl, context);
                    }
                case TypeScript.GenericType:
                    return this.resolveGenericTypeReference(expressionAST, enclosingDecl, context);
                case TypeScript.NodeType.MemberAccessExpression:
                    if (context.searchTypeSpace) {
                        return this.resolveDottedTypeNameExpression(expressionAST, enclosingDecl, context);
                    } else {
                        return this.resolveDottedNameExpression(expressionAST, enclosingDecl, context);
                    }
                case TypeScript.NodeType.FunctionDeclaration: {
                    var funcDecl = expressionAST;
                    if (funcDecl.isGetAccessor()) {
                        return this.resolveGetAccessorDeclaration(funcDecl, context);
                    } else if (funcDecl.isSetAccessor()) {
                        return this.resolveSetAccessorDeclaration(funcDecl, context);
                    } else {
                        return this.resolveFunctionExpression(funcDecl, isTypedAssignment, enclosingDecl, context);
                    }
                }
                case TypeScript.NodeType.ObjectLiteralExpression:
                    return this.resolveObjectLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.ArrayLiteralExpression:
                    return this.resolveArrayLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.ThisExpression:
                    return this.resolveThisExpression(expressionAST, enclosingDecl, context);
                case TypeScript.NodeType.SuperExpression:
                    return this.resolveSuperExpression(expressionAST, enclosingDecl, context);
                case TypeScript.NodeType.InvocationExpression:
                    return this.resolveCallExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.ObjectCreationExpression:
                    return this.resolveNewExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.CastExpression:
                    return this.resolveTypeAssertionExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.TypeRef:
                    return this.resolveTypeReference(expressionAST, enclosingDecl, context);
                case TypeScript.NodeType.NumericLiteral:
                    return this.semanticInfoChain.numberTypeSymbol;
                case TypeScript.NodeType.StringLiteral:
                    return this.semanticInfoChain.stringTypeSymbol;
                case TypeScript.NodeType.NullLiteral:
                    return this.semanticInfoChain.nullTypeSymbol;
                case TypeScript.NodeType.TrueLiteral:
                case TypeScript.NodeType.FalseLiteral:
                    return this.semanticInfoChain.booleanTypeSymbol;
                case TypeScript.NodeType.VoidExpression:
                    return this.semanticInfoChain.voidTypeSymbol;
                case TypeScript.NodeType.AssignmentExpression:
                    return this.resolveAssignmentStatement(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.LogicalNotExpression:
                case TypeScript.NodeType.NotEqualsWithTypeConversionExpression:
                case TypeScript.NodeType.EqualsWithTypeConversionExpression:
                case TypeScript.NodeType.EqualsExpression:
                case TypeScript.NodeType.NotEqualsExpression:
                case TypeScript.NodeType.LessThanExpression:
                case TypeScript.NodeType.LessThanOrEqualExpression:
                case TypeScript.NodeType.GreaterThanOrEqualExpression:
                case TypeScript.NodeType.GreaterThanExpression:
                    return this.semanticInfoChain.booleanTypeSymbol;
                case TypeScript.NodeType.AddExpression:
                case TypeScript.NodeType.AddAssignmentExpression:
                    return this.resolveArithmeticExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.SubtractAssignmentExpression:
                case TypeScript.NodeType.MultiplyAssignmentExpression:
                case TypeScript.NodeType.DivideAssignmentExpression:
                case TypeScript.NodeType.ModuloAssignmentExpression:
                case TypeScript.NodeType.OrAssignmentExpression:
                case TypeScript.NodeType.AndAssignmentExpression:
                case TypeScript.NodeType.BitwiseNotExpression:
                case TypeScript.NodeType.SubtractExpression:
                case TypeScript.NodeType.MultiplyExpression:
                case TypeScript.NodeType.DivideExpression:
                case TypeScript.NodeType.ModuloExpression:
                case TypeScript.NodeType.BitwiseOrExpression:
                case TypeScript.NodeType.BitwiseAndExpression:
                case TypeScript.NodeType.PlusExpression:
                case TypeScript.NodeType.NegateExpression:
                case TypeScript.NodeType.PostIncrementExpression:
                case TypeScript.NodeType.PreIncrementExpression:
                case TypeScript.NodeType.PostDecrementExpression:
                case TypeScript.NodeType.PreDecrementExpression:
                    return this.semanticInfoChain.numberTypeSymbol;
                case TypeScript.NodeType.LeftShiftExpression:
                case TypeScript.NodeType.SignedRightShiftExpression:
                case TypeScript.NodeType.UnsignedRightShiftExpression:
                case TypeScript.NodeType.LeftShiftAssignmentExpression:
                case TypeScript.NodeType.SignedRightShiftAssignmentExpression:
                case TypeScript.NodeType.UnsignedRightShiftAssignmentExpression:
                    return this.semanticInfoChain.numberTypeSymbol;
                case TypeScript.NodeType.ElementAccessExpression:
                    return this.resolveIndexExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.LogicalOrExpression:
                    return this.resolveLogicalOrExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.LogicalAndExpression:
                    return this.resolveLogicalAndExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.TypeOfExpression:
                    return this.semanticInfoChain.stringTypeSymbol;
                case TypeScript.NodeType.ThrowStatement:
                    return this.semanticInfoChain.voidTypeSymbol;
                case TypeScript.NodeType.DeleteExpression:
                    return this.semanticInfoChain.booleanTypeSymbol;
                case TypeScript.NodeType.ConditionalExpression:
                    return this.resolveConditionalExpression(expressionAST, enclosingDecl, context);
                case TypeScript.NodeType.RegularExpressionLiteral:
                    return this.cachedRegExpInterfaceType ? this.cachedRegExpInterfaceType : this.semanticInfoChain.anyTypeSymbol;
                case TypeScript.NodeType.ParenthesizedExpression:
                    return this.resolveParenthesizedExpression(expressionAST, enclosingDecl, context);
                case TypeScript.NodeType.ExpressionStatement:
                    return this.resolveExpressionStatement(expressionAST, isTypedAssignment, enclosingDecl, context);
                case TypeScript.NodeType.InstanceOfExpression:
                    return this.semanticInfoChain.booleanTypeSymbol;
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.isNameOrMemberAccessExpression = function (ast) {
            var checkAST = ast;
            while(checkAST) {
                if (checkAST.nodeType == TypeScript.NodeType.ExpressionStatement) {
                    checkAST = (checkAST).expression;
                } else if (checkAST.nodeType == TypeScript.NodeType.ParenthesizedExpression) {
                    checkAST = (checkAST).expression;
                } else if (checkAST.nodeType == TypeScript.NodeType.Name) {
                    return true;
                } else if (checkAST.nodeType == TypeScript.NodeType.MemberAccessExpression) {
                    return true;
                } else {
                    return false;
                }
            }
        };
        PullTypeResolver.prototype.resolveNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var nameSymbol = this.getSymbolForAST(nameAST, context);
            if (nameSymbol) {
                if (!nameSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
                }
                return nameSymbol;
            }
            var id = nameAST.text;
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            if (enclosingDecl && !declPath.length) {
                declPath = [
                    enclosingDecl
                ];
            }
            nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);
            if (!nameSymbol) {
                nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
                if (nameSymbol && (nameSymbol.isPrimitive() && nameSymbol != this.semanticInfoChain.undefinedTypeSymbol && nameSymbol != this.semanticInfoChain.nullTypeSymbol)) {
                    nameSymbol = null;
                }
            }
            if (!nameSymbol && id === "arguments" && enclosingDecl && (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction)) {
                nameSymbol = this.cachedFunctionArgumentsSymbol;
            }
            if (!nameSymbol) {
                var diagnostic = context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_find_symbol__0_, [
                    id
                ]), enclosingDecl);
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }
            this.setSymbolForAST(nameAST, nameSymbol, context);
            return nameSymbol;
        };
        PullTypeResolver.prototype.resolveDottedNameExpression = function (dottedNameAST, enclosingDecl, context) {
            if ((dottedNameAST.operand2).isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var nameSymbol = this.getSymbolForAST(dottedNameAST, context);
            if (nameSymbol) {
                if (!nameSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
                }
                return nameSymbol;
            }
            var rhsName = (dottedNameAST.operand2).text;
            var lhs = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);
            var lhsType = lhs.getType();
            var diagnostic;
            if (lhs.isAlias()) {
                (lhs).setIsUsedAsValue();
            }
            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }
            if (!lhsType) {
                diagnostic = context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name__0_, [
                    rhsName
                ]), enclosingDecl);
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            if (lhsType == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                lhsType = this.cachedNumberInterfaceType;
            } else if (lhsType == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                lhsType = this.cachedStringInterfaceType;
            } else if (lhsType == this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType) {
                lhsType = this.cachedBooleanInterfaceType;
            }
            if (!lhsType.isResolved()) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);
                if (potentiallySpecializedType != lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }
                    lhsType = potentiallySpecializedType;
                }
            }
            if (rhsName == "prototype") {
                if (lhsType.isClass()) {
                    return lhsType;
                } else {
                    var classInstanceType = lhsType.getAssociatedContainerType();
                    if (classInstanceType && classInstanceType.isClass()) {
                        return classInstanceType;
                    }
                }
            }
            if (!(lhs.isType() && (lhs).isClass() && this.isNameOrMemberAccessExpression(dottedNameAST.operand1)) && !nameSymbol) {
                nameSymbol = lhsType.findMember(rhsName);
            }
            if (!nameSymbol) {
                if (lhsType.isClass()) {
                    var staticType = (lhsType).getConstructorMethod().getType();
                    nameSymbol = staticType.findMember(rhsName);
                    if (!nameSymbol) {
                        nameSymbol = lhsType.findMember(rhsName);
                    }
                } else if ((lhsType.getKind() == TypeScript.PullElementKind.Enum) && this.cachedNumberInterfaceType) {
                    lhsType = this.cachedNumberInterfaceType;
                    nameSymbol = lhsType.findMember(rhsName);
                } else if (lhsType.getCallSignatures().length && this.cachedFunctionInterfaceType) {
                    lhsType = this.cachedFunctionInterfaceType;
                    nameSymbol = lhsType.findMember(rhsName);
                } else if (lhsType.isTypeParameter()) {
                    var constraint = (lhsType).getConstraint();
                    if (constraint) {
                        nameSymbol = constraint.findMember(rhsName);
                    }
                } else if (lhsType.isContainer()) {
                    var associatedInstance = (lhsType).getInstanceSymbol();
                    if (associatedInstance) {
                        var instanceType = associatedInstance.getType();
                        nameSymbol = instanceType.findMember(rhsName);
                    }
                } else {
                    var associatedType = lhsType.getAssociatedContainerType();
                    if (associatedType) {
                        nameSymbol = associatedType.findMember(rhsName);
                    }
                }
                if (!nameSymbol && !lhsType.isPrimitive() && this.cachedObjectInterfaceType) {
                    nameSymbol = this.cachedObjectInterfaceType.findMember(rhsName);
                }
                if (!nameSymbol) {
                    diagnostic = context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_find_dotted_name__0_, [
                        rhsName
                    ]), enclosingDecl);
                    return this.getNewErrorTypeSymbol(diagnostic);
                }
            }
            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }
            this.setSymbolForAST(dottedNameAST, nameSymbol, context);
            this.setSymbolForAST(dottedNameAST.operand2, nameSymbol, context);
            return nameSymbol;
        };
        PullTypeResolver.prototype.resolveTypeNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var typeNameSymbol = this.getSymbolForAST(nameAST, context);
            if (typeNameSymbol) {
                if (!typeNameSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
                }
                return typeNameSymbol;
            }
            var id = nameAST.text;
            if (id == "any") {
                typeNameSymbol = this.semanticInfoChain.anyTypeSymbol;
            } else if (id == "string") {
                typeNameSymbol = this.semanticInfoChain.stringTypeSymbol;
            } else if (id == "number") {
                typeNameSymbol = this.semanticInfoChain.numberTypeSymbol;
            } else if (id == "bool") {
                if (this.compilationSettings.disallowBool && !this.currentUnit.getProperties().unitContainsBool) {
                    this.currentUnit.getProperties().unitContainsBool = true;
                    diagnostic = context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Use_of_deprecated__bool__type__Use__boolean__instead, []), enclosingDecl, true);
                }
                typeNameSymbol = this.semanticInfoChain.booleanTypeSymbol;
            } else if (id == "boolean") {
                typeNameSymbol = this.semanticInfoChain.booleanTypeSymbol;
            } else if (id == "null") {
                typeNameSymbol = this.semanticInfoChain.nullTypeSymbol;
            } else if (id == "undefined") {
                typeNameSymbol = this.semanticInfoChain.undefinedTypeSymbol;
            } else if (id == "void") {
                typeNameSymbol = this.semanticInfoChain.voidTypeSymbol;
            } else if (id == "_element") {
                typeNameSymbol = this.semanticInfoChain.elementTypeSymbol;
            } else {
                var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
                var diagnostic;
                if (enclosingDecl && !declPath.length) {
                    declPath = [
                        enclosingDecl
                    ];
                }
                typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
                if (!typeNameSymbol) {
                    diagnostic = context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_find_symbol__0_, [
                        id
                    ]), enclosingDecl);
                    return this.getNewErrorTypeSymbol(diagnostic);
                }
                if (typeNameSymbol.isTypeParameter()) {
                    if (enclosingDecl && (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction) && (enclosingDecl.getFlags() & TypeScript.PullElementFlags.Static)) {
                        var parentDecl = typeNameSymbol.getDeclarations()[0];
                        if (parentDecl != enclosingDecl) {
                            diagnostic = context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Static_methods_may_not_reference_class_type_parameters, null), enclosingDecl);
                            typeNameSymbol = this.getNewErrorTypeSymbol(diagnostic);
                            this.setSymbolForAST(nameAST, typeNameSymbol, context);
                            return typeNameSymbol;
                        }
                    }
                }
                typeNameSymbol = context.findSpecializationForType(typeNameSymbol);
            }
            if (!typeNameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
            }
            if (typeNameSymbol.isType()) {
                this.setSymbolForAST(nameAST, typeNameSymbol, context);
            }
            return typeNameSymbol;
        };
        PullTypeResolver.prototype.resolveGenericTypeReference = function (genericTypeAST, enclosingDecl, context) {
            var genericTypeSymbol = null;
            var diagnostic;
            var prevSearchTypeSpace = context.searchTypeSpace;
            context.searchTypeSpace = true;
            genericTypeSymbol = this.resolveStatementOrExpression(genericTypeAST.name, false, enclosingDecl, context).getType();
            context.searchTypeSpace = prevSearchTypeSpace;
            if (genericTypeSymbol.isError()) {
                return genericTypeSymbol;
            }
            if (!genericTypeSymbol.isResolving() && !genericTypeSymbol.isResolved()) {
                this.resolveDeclaredSymbol(genericTypeSymbol, enclosingDecl, context);
            }
            var typeArgs = [];
            var typeArg = null;
            if (!context.isResolvingTypeArguments(genericTypeAST)) {
                context.startResolvingTypeArguments(genericTypeAST);
                if (genericTypeAST.typeArguments && genericTypeAST.typeArguments.members.length) {
                    for(var i = 0; i < genericTypeAST.typeArguments.members.length; i++) {
                        typeArg = this.resolveTypeReference(genericTypeAST.typeArguments.members[i], enclosingDecl, context);
                        if (typeArg.isError()) {
                            return typeArg;
                        }
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
                context.doneResolvingTypeArguments();
            }
            var typeParameters = genericTypeSymbol.getTypeParameters();
            if (typeArgs.length && typeArgs.length != typeParameters.length) {
                diagnostic = context.postError(genericTypeAST.minChar, genericTypeAST.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Generic_type__0__requires_1_type_argument_s_, [
                    genericTypeSymbol.toString(), 
                    genericTypeSymbol.getTypeParameters().length
                ]), enclosingDecl);
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            var specializedSymbol = TypeScript.specializeType(genericTypeSymbol, typeArgs, this, enclosingDecl, context, genericTypeAST);
            var typeConstraint = null;
            var upperBound = null;
            for(var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                typeArg = typeArgs[iArg];
                typeConstraint = typeParameters[iArg].getConstraint();
                if (typeConstraint) {
                    if (typeArg.isTypeParameter()) {
                        upperBound = (typeArg).getConstraint();
                        if (upperBound) {
                            typeArg = upperBound;
                        }
                    }
                    if (typeArg.isResolving()) {
                        return specializedSymbol;
                    }
                    if (!this.sourceIsAssignableToTarget(typeArg, typeConstraint, context)) {
                        context.postError(genericTypeAST.minChar, genericTypeAST.getLength(), this.getUnitPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_, [
                            typeArg.toString(true), 
                            typeConstraint.toString(true), 
                            typeParameters[iArg].toString(true)
                        ]), enclosingDecl, true);
                    }
                }
            }
            return specializedSymbol;
        };
        PullTypeResolver.prototype.resolveDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            if ((dottedNameAST.operand2).isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var childTypeSymbol = this.getSymbolForAST(dottedNameAST, context);
            if (childTypeSymbol) {
                if (!childTypeSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(childTypeSymbol, enclosingDecl, context);
                }
                return childTypeSymbol;
            }
            var diagnostic;
            var rhsName = (dottedNameAST.operand2).text;
            var prevSearchTypeSpace = context.searchTypeSpace;
            context.searchTypeSpace = true;
            var lhs = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);
            context.searchTypeSpace = prevSearchTypeSpace;
            var lhsType = lhs.getType();
            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }
            if (!lhsType) {
                diagnostic = context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name__0_, [
                    rhsName
                ]), enclosingDecl);
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            childTypeSymbol = lhsType.findNestedType(rhsName);
            if (!childTypeSymbol && enclosingDecl) {
                var parentDecl = enclosingDecl;
                while(parentDecl) {
                    if (parentDecl.getKind() & TypeScript.PullElementKind.SomeContainer) {
                        break;
                    }
                    parentDecl = parentDecl.getParentDecl();
                }
                if (parentDecl) {
                    var enclosingSymbolType = parentDecl.getSymbol().getType();
                    if (enclosingSymbolType == lhsType) {
                        childTypeSymbol = lhsType.findContainedMember(rhsName);
                    }
                }
            }
            if (!childTypeSymbol) {
                diagnostic = context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_find_dotted_name__0_, [
                    rhsName
                ]), enclosingDecl);
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            if (!childTypeSymbol.isResolved()) {
                this.resolveDeclaredSymbol(childTypeSymbol, enclosingDecl, context);
            }
            this.setSymbolForAST(dottedNameAST, childTypeSymbol, context);
            return childTypeSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionExpression = function (funcDeclAST, isTypedAssignment, enclosingDecl, context) {
            var functionDecl = this.getDeclForAST(funcDeclAST);
            var funcDeclSymbol = null;
            if (functionDecl) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved()) {
                    return funcDeclSymbol;
                }
            }
            var shouldContextuallyType = isTypedAssignment;
            var assigningFunctionTypeSymbol = null;
            var assigningFunctionSignature = null;
            if (funcDeclAST.returnTypeAnnotation) {
                shouldContextuallyType = false;
            }
            if (shouldContextuallyType && funcDeclAST.arguments) {
                for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if ((funcDeclAST.arguments.members[i]).typeExpr) {
                        shouldContextuallyType = false;
                        break;
                    }
                }
            }
            if (shouldContextuallyType) {
                assigningFunctionTypeSymbol = context.getContextualType();
                if (assigningFunctionTypeSymbol) {
                    this.resolveDeclaredSymbol(assigningFunctionTypeSymbol, enclosingDecl, context);
                    if (assigningFunctionTypeSymbol) {
                        assigningFunctionSignature = assigningFunctionTypeSymbol.getCallSignatures()[0];
                    }
                }
            }
            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                declCollectionContext.scriptName = this.unitPath;
                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }
                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                functionDecl = this.getDeclForAST(funcDeclAST);
                var binder = new TypeScript.PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionExpressionToPullSymbol(functionDecl);
                funcDeclSymbol = functionDecl.getSymbol();
            }
            var signature = funcDeclSymbol.getType().getCallSignatures()[0];
            if (funcDeclAST.arguments) {
                var contextParams = [];
                var contextParam = null;
                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.getParameters();
                }
                for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if ((i < contextParams.length) && !contextParams[i].getIsVarArg()) {
                        contextParam = contextParams[i];
                    } else if (contextParams.length && contextParams[contextParams.length - 1].getIsVarArg()) {
                        contextParam = (contextParams[contextParams.length - 1].getType()).getElementType();
                    }
                    this.resolveFunctionExpressionParameter(funcDeclAST.arguments.members[i], contextParam, functionDecl, context);
                }
            }
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, functionDecl, context);
                signature.setReturnType(returnTypeSymbol);
            } else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.getReturnType();
                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, true, functionDecl, context);
                        context.popContextualType();
                    } else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                } else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, functionDecl, context);
                }
            }
            if (assigningFunctionTypeSymbol) {
                funcDeclSymbol.addOutgoingLink(assigningFunctionTypeSymbol, TypeScript.SymbolLinkKind.ContextuallyTypedAs);
            }
            funcDeclSymbol.setResolved();
            return funcDeclSymbol;
        };
        PullTypeResolver.prototype.resolveThisExpression = function (ast, enclosingDecl, context) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var previousResolutionSymbol = this.getSymbolForAST(ast, context);
            if (previousResolutionSymbol) {
                return previousResolutionSymbol;
            }
            var enclosingDeclKind = enclosingDecl.getKind();
            var diagnostic = null;
            if (enclosingDeclKind == TypeScript.PullElementKind.Container) {
                diagnostic = new TypeScript.PullDiagnostic(ast.minChar, ast.getLength(), this.currentUnit.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._this__cannot_be_referenced_within_module_bodies, null));
                return this.getNewErrorTypeSymbol(diagnostic);
            } else if (!(enclosingDeclKind & (TypeScript.PullElementKind.SomeFunction | TypeScript.PullElementKind.Script | TypeScript.PullElementKind.SomeBlock))) {
                diagnostic = new TypeScript.PullDiagnostic(ast.minChar, ast.getLength(), this.currentUnit.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._this__must_only_be_used_inside_a_function_or_script_context, null));
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            var declPath = this.getPathToDecl(enclosingDecl);
            if (declPath.length) {
                for(var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.getKind();
                    var declFlags = decl.getFlags();
                    if (declFlags & TypeScript.PullElementFlags.Static) {
                        this.setSymbolForAST(ast, this.semanticInfoChain.anyTypeSymbol, context);
                        return this.semanticInfoChain.anyTypeSymbol;
                    }
                    if (declKind == TypeScript.PullElementKind.FunctionExpression && !TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.FatArrow)) {
                        this.setSymbolForAST(ast, this.semanticInfoChain.anyTypeSymbol, context);
                        return this.semanticInfoChain.anyTypeSymbol;
                    }
                    if (declKind == TypeScript.PullElementKind.Function) {
                        this.setSymbolForAST(ast, this.semanticInfoChain.anyTypeSymbol, context);
                        return this.semanticInfoChain.anyTypeSymbol;
                    }
                    if (declKind == TypeScript.PullElementKind.Class) {
                        var classSymbol = decl.getSymbol();
                        this.setSymbolForAST(ast, classSymbol, context);
                        return classSymbol;
                    }
                }
            }
            this.setSymbolForAST(ast, this.semanticInfoChain.anyTypeSymbol, context);
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveSuperExpression = function (ast, enclosingDecl, context) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            var decl;
            var declFlags;
            var classSymbol = null;
            if (declPath.length) {
                for(var i = declPath.length - 1; i >= 0; i--) {
                    decl = declPath[i];
                    declFlags = decl.getFlags();
                    if (decl.getKind() == TypeScript.PullElementKind.FunctionExpression && !(declFlags & TypeScript.PullElementFlags.FatArrow)) {
                        break;
                    } else if (declFlags & TypeScript.PullElementFlags.Static) {
                        break;
                    } else if (decl.getKind() == TypeScript.PullElementKind.Class) {
                        classSymbol = decl.getSymbol();
                        break;
                    }
                }
            }
            if (classSymbol) {
                var parents = classSymbol.getExtendedTypes();
                if (parents.length) {
                    return parents[0];
                }
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveObjectLiteralExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var previousResolutionSymbol = this.getSymbolForAST(expressionAST, context);
            if (previousResolutionSymbol) {
                return previousResolutionSymbol;
            }
            var typeSymbol = this.getSymbolForAST(expressionAST, context);
            var span;
            if (typeSymbol && typeSymbol.isResolved()) {
                return typeSymbol.getType();
            }
            var objectLitAST = expressionAST;
            span = TypeScript.TextSpan.fromBounds(objectLitAST.minChar, objectLitAST.limChar);
            var objectLitDecl = new TypeScript.PullDecl("", TypeScript.PullElementKind.ObjectLiteral, TypeScript.PullElementFlags.None, span, this.unitPath);
            if (enclosingDecl) {
                objectLitDecl.setParentDecl(enclosingDecl);
            }
            this.currentUnit.setDeclForAST(objectLitAST, objectLitDecl);
            this.currentUnit.setASTForDecl(objectLitDecl, objectLitAST);
            typeSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.Interface);
            typeSymbol.addDeclaration(objectLitDecl);
            objectLitDecl.setSymbol(typeSymbol);
            var memberDecls = objectLitAST.operand;
            var contextualType = null;
            if (isTypedAssignment) {
                contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);
            }
            if (memberDecls) {
                var binex;
                var id;
                var text;
                var idText;
                var memberSymbol;
                var memberExprType;
                var assigningSymbol = null;
                var acceptedContextualType = false;
                for(var i = 0, len = memberDecls.members.length; i < len; i++) {
                    binex = memberDecls.members[i];
                    id = binex.operand1;
                    if (id.nodeType == TypeScript.NodeType.Name) {
                        text = (id).text;
                    } else if (id.nodeType == TypeScript.NodeType.StringLiteral) {
                        idText = (id).text;
                        text = idText.substring(1, idText.length - 1);
                    } else {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }
                    span = TypeScript.TextSpan.fromBounds(binex.minChar, binex.limChar);
                    var decl = new TypeScript.PullDecl(text, TypeScript.PullElementKind.Property, TypeScript.PullElementFlags.Public, span, this.unitPath);
                    objectLitDecl.addChildDecl(decl);
                    decl.setParentDecl(objectLitDecl);
                    this.semanticInfoChain.getUnit(this.unitPath).setDeclForAST(binex, decl);
                    this.semanticInfoChain.getUnit(this.unitPath).setASTForDecl(decl, binex);
                    memberSymbol = new TypeScript.PullSymbol(text, TypeScript.PullElementKind.Property);
                    memberSymbol.addDeclaration(decl);
                    decl.setSymbol(memberSymbol);
                    if (contextualType) {
                        assigningSymbol = contextualType.findMember(text);
                        if (assigningSymbol) {
                            this.resolveDeclaredSymbol(assigningSymbol, enclosingDecl, context);
                            context.pushContextualType(assigningSymbol.getType(), context.inProvisionalResolution(), null);
                            acceptedContextualType = true;
                        }
                    }
                    if (binex.operand2.nodeType == TypeScript.NodeType.FunctionDeclaration) {
                        var funcDeclAST = binex.operand2;
                        if (funcDeclAST.isAccessor()) {
                            var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                            var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                            declCollectionContext.scriptName = this.unitPath;
                            declCollectionContext.pushParent(objectLitDecl);
                            TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                            var functionDecl = this.getDeclForAST(funcDeclAST);
                            var binder = new TypeScript.PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);
                            binder.setUnit(this.unitPath);
                            binder.pushParent(typeSymbol, objectLitDecl);
                            if (funcDeclAST.isGetAccessor()) {
                                binder.bindGetAccessorDeclarationToPullSymbol(functionDecl);
                            } else {
                                binder.bindSetAccessorDeclarationToPullSymbol(functionDecl);
                            }
                        }
                    }
                    memberExprType = this.resolveStatementOrExpression(binex.operand2, assigningSymbol != null, enclosingDecl, context);
                    if (acceptedContextualType) {
                        context.popContextualType();
                        acceptedContextualType = false;
                    }
                    context.setTypeInContext(memberSymbol, this.widenType(memberExprType.getType()));
                    memberSymbol.setResolved();
                    this.setSymbolForAST(binex.operand1, memberSymbol, context);
                    typeSymbol.addMember(memberSymbol, TypeScript.SymbolLinkKind.PublicMember);
                }
            }
            typeSymbol.setResolved();
            this.setSymbolForAST(expressionAST, typeSymbol, context);
            return typeSymbol;
        };
        PullTypeResolver.prototype.resolveArrayLiteralExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var previousResolutionSymbol = this.getSymbolForAST(expressionAST, context);
            if (previousResolutionSymbol) {
                return previousResolutionSymbol;
            }
            var arrayLit = expressionAST;
            var elements = arrayLit.operand;
            var elementType = this.semanticInfoChain.anyTypeSymbol;
            var elementTypes = [];
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var contextualType = null;
            comparisonInfo.onlyCaptureFirstError = true;
            if (isTypedAssignment) {
                contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);
                if (contextualType.isArray()) {
                    contextualType = contextualType.getElementType();
                }
                context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
            }
            if (elements) {
                for(var i = 0; i < elements.members.length; i++) {
                    elementTypes[elementTypes.length] = this.resolveStatementOrExpression(elements.members[i], isTypedAssignment, enclosingDecl, context).getType();
                }
                if (isTypedAssignment) {
                    context.popContextualType();
                }
                if (elementTypes.length) {
                    elementType = elementTypes[0];
                }
                var collection = {
                    getLength: function () {
                        return elements.members.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        elementTypes[index] = type;
                    },
                    getTypeAtIndex: function (index) {
                        return elementTypes[index];
                    }
                };
                elementType = this.findBestCommonType(elementType, contextualType, collection, false, context, comparisonInfo);
                if (elementType == this.semanticInfoChain.undefinedTypeSymbol || elementType == this.semanticInfoChain.nullTypeSymbol) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (!elementType) {
                elementType = this.semanticInfoChain.anyTypeSymbol;
            } else if (contextualType) {
                if (this.sourceIsAssignableToTarget(elementType, contextualType, context)) {
                    elementType = contextualType;
                }
            }
            var arraySymbol = elementType.getArrayType();
            if (!arraySymbol) {
                if (!this.cachedArrayInterfaceType) {
                    this.cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), TypeScript.PullElementKind.Interface);
                }
                if (this.cachedArrayInterfaceType && !this.cachedArrayInterfaceType.isResolved()) {
                    this.resolveDeclaredSymbol(this.cachedArrayInterfaceType, enclosingDecl, context);
                }
                arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, elementType, this, context);
                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            this.setSymbolForAST(expressionAST, arraySymbol, context);
            return arraySymbol;
        };
        PullTypeResolver.prototype.resolveIndexExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var previousResolutionSymbol = this.getSymbolForAST(expressionAST, context);
            if (previousResolutionSymbol) {
                return previousResolutionSymbol;
            }
            var indexType = this.resolveStatementOrExpression((expressionAST).operand1, isTypedAssignment, enclosingDecl, context).getType();
            if (indexType.isError()) {
                return indexType;
            }
            var elementType = indexType.getElementType();
            if (elementType) {
                this.setSymbolForAST(expressionAST, elementType, context);
                return elementType;
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveBitwiseOperator = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                return this.semanticInfoChain.numberTypeSymbol;
            } else if ((leftType == this.semanticInfoChain.booleanTypeSymbol) && (rightType == this.semanticInfoChain.booleanTypeSymbol)) {
                return this.semanticInfoChain.booleanTypeSymbol;
            } else if (this.isAnyOrEquivalent(leftType)) {
                if ((this.isAnyOrEquivalent(rightType) || (rightType == this.semanticInfoChain.numberTypeSymbol) || (rightType == this.semanticInfoChain.booleanTypeSymbol))) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (this.isAnyOrEquivalent(rightType)) {
                if ((leftType == this.semanticInfoChain.numberTypeSymbol) || (leftType == this.semanticInfoChain.booleanTypeSymbol)) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveArithmeticExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            if (this.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }
            leftType = this.widenType(leftType);
            rightType = this.widenType(rightType);
            if (expressionAST.nodeType == TypeScript.NodeType.AddExpression || expressionAST.nodeType == TypeScript.NodeType.AddAssignmentExpression) {
                if (leftType == this.semanticInfoChain.stringTypeSymbol || rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                } else if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else if (this.isAnyOrEquivalent(leftType) || this.isAnyOrEquivalent(rightType)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
        };
        PullTypeResolver.prototype.resolveLogicalOrExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            if (this.isAnyOrEquivalent(leftType) || this.isAnyOrEquivalent(rightType)) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (leftType == this.semanticInfoChain.booleanTypeSymbol) {
                if (rightType == this.semanticInfoChain.booleanTypeSymbol) {
                    return this.semanticInfoChain.booleanTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (leftType == this.semanticInfoChain.numberTypeSymbol) {
                if (rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (leftType == this.semanticInfoChain.stringTypeSymbol) {
                if (rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context)) {
                return rightType;
            } else if (this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                return leftType;
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveLogicalAndExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            return rightType;
        };
        PullTypeResolver.prototype.resolveConditionalExpression = function (trinex, enclosingDecl, context) {
            var previousResolutionSymbol = this.getSymbolForAST(trinex, context);
            if (previousResolutionSymbol) {
                return previousResolutionSymbol;
            }
            var condType = this.resolveAST(trinex.operand1, false, enclosingDecl, context).getType();
            var leftType = this.resolveAST(trinex.operand2, false, enclosingDecl, context).getType();
            var rightType = this.resolveAST(trinex.operand3, false, enclosingDecl, context).getType();
            if (this.typesAreIdentical(leftType, rightType)) {
                return leftType;
            }
            var collection = {
                getLength: function () {
                    return 2;
                },
                setTypeAtIndex: function (index, type) {
                },
                getTypeAtIndex: function (index) {
                    return rightType;
                }
            };
            var bct = this.findBestCommonType(leftType, null, collection, false, context);
            if (bct) {
                this.setSymbolForAST(trinex, bct, context);
                return bct;
            }
            var diagnostic = context.postError(trinex.minChar, trinex.getLength(), this.getUnitPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_, [
                leftType.toString(false), 
                rightType.toString(false)
            ]), enclosingDecl);
            return this.getNewErrorTypeSymbol(diagnostic);
        };
        PullTypeResolver.prototype.resolveParenthesizedExpression = function (ast, enclosingDecl, context) {
            return this.resolveAST(ast.expression, false, enclosingDecl, context);
        };
        PullTypeResolver.prototype.resolveExpressionStatement = function (ast, isTypedAssignment, enclosingDecl, context) {
            return this.resolveAST(ast.expression, isTypedAssignment, enclosingDecl, context);
        };
        PullTypeResolver.prototype.resolveCallExpression = function (callEx, isTypedAssignment, enclosingDecl, context, additionalResults) {
            if (!additionalResults) {
                var previousResolutionSymbol = this.getSymbolForAST(callEx, context);
                if (previousResolutionSymbol) {
                    return previousResolutionSymbol;
                }
            }
            var diagnostic;
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context);
            var targetTypeSymbol = targetSymbol.getType();
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.setSymbolForAST(callEx, this.semanticInfoChain.anyTypeSymbol, context);
                return targetTypeSymbol;
            }
            var isSuperCall = false;
            if (callEx.target.nodeType == TypeScript.NodeType.SuperExpression) {
                isSuperCall = true;
                if (targetTypeSymbol.isClass()) {
                    targetSymbol = (targetTypeSymbol).getConstructorMethod();
                    targetTypeSymbol = targetSymbol.getType();
                } else {
                    diagnostic = context.postError(callEx.minChar, callEx.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Calls_to__super__are_only_valid_inside_a_class, null), enclosingDecl);
                    return this.getNewErrorTypeSymbol(diagnostic);
                }
            }
            var signatures = isSuperCall ? (targetTypeSymbol).getConstructSignatures() : (targetTypeSymbol).getCallSignatures();
            var typeArgs = null;
            var typeReplacementMap = null;
            var couldNotFindGenericOverload = false;
            if (callEx.typeArguments) {
                typeArgs = [];
                var typeArg = null;
                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    for(var i = 0; i < callEx.typeArguments.members.length; i++) {
                        typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
            }
            if (targetTypeSymbol.isGeneric()) {
                var resolvedSignatures = [];
                var inferredTypeArgs;
                var specializedSignature;
                var typeParameters;
                var typeConstraint = null;
                for(var i = 0; i < signatures.length; i++) {
                    typeParameters = signatures[i].getTypeParameters();
                    if (signatures[i].isGeneric() && typeParameters.length) {
                        if (typeArgs) {
                            inferredTypeArgs = typeArgs;
                        } else if (callEx.arguments) {
                            inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], callEx.arguments, new TypeScript.TypeComparisonInfo(), enclosingDecl, context);
                        }
                        if (inferredTypeArgs) {
                            typeReplacementMap = {};
                            if (inferredTypeArgs.length) {
                                if (inferredTypeArgs.length < typeParameters.length) {
                                    continue;
                                }
                                for(var j = 0; j < typeParameters.length; j++) {
                                    typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];
                                    typeConstraint = typeParameters[j].getConstraint();
                                    if (typeConstraint) {
                                        if (typeConstraint.isTypeParameter()) {
                                            context.pushTypeSpecializationCache(typeReplacementMap);
                                            typeConstraint = TypeScript.specializeType(typeConstraint, inferredTypeArgs, this, enclosingDecl, context);
                                            context.popTypeSpecializationCache();
                                        }
                                        if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                            context.postError(callEx.target.minChar, callEx.target.getLength(), this.getUnitPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_, [
                                                inferredTypeArgs[j].toString(true), 
                                                typeConstraint.toString(true), 
                                                typeParameters[j].toString(true)
                                            ]), enclosingDecl, true);
                                        }
                                    }
                                }
                            } else {
                                for(j = 0; j < typeParameters.length; j++) {
                                    inferredTypeArgs[inferredTypeArgs.length] = this.semanticInfoChain.anyTypeSymbol;
                                }
                            }
                            specializedSignature = TypeScript.specializeSignature(signatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);
                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                    } else {
                        resolvedSignatures[resolvedSignatures.length] = signatures[i];
                    }
                }
                if (signatures.length && !resolvedSignatures.length) {
                    couldNotFindGenericOverload = true;
                }
                signatures = resolvedSignatures;
            }
            if (!signatures.length && !couldNotFindGenericOverload) {
                if (this.cachedFunctionInterfaceType && this.sourceIsSubtypeOfTarget(targetTypeSymbol, this.cachedFunctionInterfaceType, context)) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
                diagnostic = context.postError(callEx.minChar, callEx.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unable_to_invoke_type_with_no_call_signatures, null), enclosingDecl);
                return this.getNewErrorTypeSymbol(diagnostic);
            }
            var signature = this.resolveOverloads(callEx, signatures, enclosingDecl, callEx.typeArguments != null, context);
            var errorCondition = null;
            if (!signature) {
                diagnostic = context.postError(callEx.minChar, callEx.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_select_overload_for__call__expression, null), enclosingDecl);
                errorCondition = this.getNewErrorTypeSymbol(diagnostic);
                if (!signatures.length) {
                    return errorCondition;
                }
                signature = signatures[0];
                if (callEx.arguments) {
                    for(var k = 0, n = callEx.arguments.members.length; k < n; k++) {
                        var arg = callEx.arguments.members[k];
                        var argSymbol = this.getSymbolForAST(arg, context);
                        if (argSymbol) {
                            var argType = argSymbol.getType();
                            if (arg.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                                if (!this.canApplyContextualTypeToFunction(argType, arg, true)) {
                                    continue;
                                }
                            }
                            argSymbol.invalidate();
                        }
                    }
                }
            }
            var returnType = signature.getReturnType();
            var actualParametersContextTypeSymbols = [];
            if (callEx.arguments) {
                var len = callEx.arguments.members.length;
                var params = signature.getParameters();
                var contextualType = null;
                var signatureDecl = signature.getDeclarations()[0];
                for(var i = 0; i < len; i++) {
                    if (params.length && i < signature.getNonOptionalParameterCount()) {
                        if (typeReplacementMap) {
                            context.pushTypeSpecializationCache(typeReplacementMap);
                        }
                        this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                        if (typeReplacementMap) {
                            context.popTypeSpecializationCache();
                        }
                        contextualType = params[i].getType();
                    } else if (params.length) {
                        contextualType = params[params.length - 1].getType();
                        if (contextualType.isArray()) {
                            contextualType = contextualType.getElementType();
                        }
                    }
                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        actualParametersContextTypeSymbols[i] = contextualType;
                    }
                    this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);
                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }
            if (additionalResults) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.targetTypeSymbol = targetTypeSymbol;
                additionalResults.resolvedSignatures = signatures;
                additionalResults.candidateSignature = signature;
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
            }
            if (errorCondition) {
                return errorCondition;
            }
            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }
            this.setSymbolForAST(callEx, returnType, context);
            return returnType;
        };
        PullTypeResolver.prototype.resolveNewExpression = function (callEx, isTypedAssignment, enclosingDecl, context, additionalResults) {
            if (!additionalResults) {
                var previousResolutionSymbol = this.getSymbolForAST(callEx, context);
                if (previousResolutionSymbol) {
                    return previousResolutionSymbol;
                }
            }
            var returnType = null;
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context);
            var diagnostic;
            var targetTypeSymbol = targetSymbol.isType() ? targetSymbol : targetSymbol.getType();
            if (targetTypeSymbol.isClass()) {
                targetTypeSymbol = (targetTypeSymbol).getConstructorMethod().getType();
            }
            var constructSignatures = targetTypeSymbol.getConstructSignatures();
            var typeArgs = null;
            var typeReplacementMap = null;
            var usedCallSignaturesInstead = false;
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.setSymbolForAST(callEx, targetTypeSymbol, context);
                return targetTypeSymbol;
            }
            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;
            }
            if (constructSignatures.length) {
                if (callEx.typeArguments) {
                    typeArgs = [];
                    var typeArg = null;
                    if (callEx.typeArguments && callEx.typeArguments.members.length) {
                        for(var i = 0; i < callEx.typeArguments.members.length; i++) {
                            typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context);
                            typeArgs[i] = context.findSpecializationForType(typeArg);
                        }
                    }
                }
                if (targetTypeSymbol.isGeneric()) {
                    var resolvedSignatures = [];
                    var inferredTypeArgs;
                    var specializedSignature;
                    var typeParameters;
                    var typeConstraint = null;
                    for(var i = 0; i < constructSignatures.length; i++) {
                        if (constructSignatures[i].isGeneric()) {
                            if (typeArgs) {
                                inferredTypeArgs = typeArgs;
                            } else if (callEx.arguments) {
                                inferredTypeArgs = this.inferArgumentTypesForSignature(constructSignatures[i], callEx.arguments, new TypeScript.TypeComparisonInfo(), enclosingDecl, context);
                            }
                            if (inferredTypeArgs) {
                                typeParameters = constructSignatures[i].getTypeParameters();
                                typeReplacementMap = {};
                                if (inferredTypeArgs.length) {
                                    if (inferredTypeArgs.length < typeParameters.length) {
                                        continue;
                                    }
                                    for(var j = 0; j < typeParameters.length; j++) {
                                        typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];
                                        typeConstraint = typeParameters[j].getConstraint();
                                        if (typeConstraint) {
                                            if (typeConstraint.isTypeParameter()) {
                                                context.pushTypeSpecializationCache(typeReplacementMap);
                                                typeConstraint = TypeScript.specializeType(typeConstraint, inferredTypeArgs, this, enclosingDecl, context);
                                                context.popTypeSpecializationCache();
                                            }
                                            if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                                context.postError(callEx.target.minChar, callEx.target.getLength(), this.getUnitPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_, [
                                                    inferredTypeArgs[j].toString(true), 
                                                    typeConstraint.toString(true), 
                                                    typeParameters[j].toString(true)
                                                ]), enclosingDecl, true);
                                            }
                                        }
                                    }
                                } else {
                                    for(j = 0; j < typeParameters.length; j++) {
                                        inferredTypeArgs[inferredTypeArgs.length] = this.semanticInfoChain.anyTypeSymbol;
                                    }
                                }
                                specializedSignature = TypeScript.specializeSignature(constructSignatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);
                                if (specializedSignature) {
                                    resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                                }
                            }
                        } else {
                            resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                        }
                    }
                    constructSignatures = resolvedSignatures;
                }
                var signature = this.resolveOverloads(callEx, constructSignatures, enclosingDecl, callEx.typeArguments != null, context);
                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = constructSignatures;
                    additionalResults.candidateSignature = signature;
                    additionalResults.actualParametersContextTypeSymbols = [];
                }
                var errorCondition = null;
                if (!signature) {
                    diagnostic = context.postError(callEx.minChar, callEx.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_select_overload_for__new__expression, null), enclosingDecl);
                    errorCondition = this.getNewErrorTypeSymbol(diagnostic);
                    if (!constructSignatures.length) {
                        return errorCondition;
                    }
                    signature = constructSignatures[0];
                    if (callEx.arguments) {
                        for(var k = 0, n = callEx.arguments.members.length; k < n; k++) {
                            var arg = callEx.arguments.members[k];
                            var argSymbol = this.getSymbolForAST(arg, context);
                            if (argSymbol) {
                                var argType = argSymbol.getType();
                                if (arg.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                                    if (!this.canApplyContextualTypeToFunction(argType, arg, true)) {
                                        continue;
                                    }
                                }
                                argSymbol.invalidate();
                            }
                        }
                    }
                }
                returnType = signature.getReturnType();
                if (returnType && !signature.isGeneric() && returnType.isGeneric() && !returnType.getIsSpecialized()) {
                    if (typeArgs && typeArgs.length) {
                        returnType = TypeScript.specializeType(returnType, typeArgs, this, enclosingDecl, context, callEx);
                    } else {
                        returnType = this.specializeTypeToAny(returnType, enclosingDecl, context);
                    }
                }
                if (usedCallSignaturesInstead) {
                    if (returnType != this.semanticInfoChain.voidTypeSymbol) {
                        diagnostic = context.postError(callEx.minChar, callEx.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_used_in_a__new__expression_must_have_a__void__return_type, null), enclosingDecl);
                        return this.getNewErrorTypeSymbol(diagnostic);
                    } else {
                        returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                if (!returnType) {
                    returnType = signature.getReturnType();
                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }
                var actualParametersContextTypeSymbols = [];
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var params = signature.getParameters();
                    var contextualType = null;
                    var signatureDecl = signature.getDeclarations()[0];
                    for(var i = 0; i < len; i++) {
                        if (params.length && i < params.length) {
                            if (typeReplacementMap) {
                                context.pushTypeSpecializationCache(typeReplacementMap);
                            }
                            this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                            if (typeReplacementMap) {
                                context.popTypeSpecializationCache();
                            }
                            contextualType = params[i].getType();
                        } else if (params.length) {
                            contextualType = params[params.length - 1].getType();
                            if (contextualType.isArray()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                            actualParametersContextTypeSymbols[i] = contextualType;
                        }
                        this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);
                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }
                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = constructSignatures;
                    additionalResults.candidateSignature = signature;
                    additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
                }
                if (errorCondition) {
                    return errorCondition;
                }
                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }
                this.setSymbolForAST(callEx, returnType, context);
                return returnType;
            } else if (targetTypeSymbol.isClass()) {
                this.setSymbolForAST(callEx, returnType, context);
                return returnType;
            }
            diagnostic = context.postError(callEx.minChar, callEx.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid__new__expression, null), enclosingDecl);
            return this.getNewErrorTypeSymbol(diagnostic);
        };
        PullTypeResolver.prototype.resolveTypeAssertionExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var assertionExpression = expressionAST;
            var typeReference = this.resolveTypeReference(assertionExpression.castTerm, enclosingDecl, context);
            if (context.resolveAggressively && assertionExpression.operand.nodeType !== TypeScript.NodeType.ParenthesizedExpression) {
                context.pushContextualType(typeReference, context.inProvisionalResolution(), null);
                this.resolveStatementOrExpression(assertionExpression.operand, true, enclosingDecl, context);
                context.popContextualType();
            }
            return typeReference;
        };
        PullTypeResolver.prototype.resolveAssignmentStatement = function (statementAST, isTypedAssignment, enclosingDecl, context) {
            var previousResolutionSymbol = this.getSymbolForAST(statementAST, context);
            if (previousResolutionSymbol) {
                return previousResolutionSymbol;
            }
            var binex = statementAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            this.resolveStatementOrExpression(binex.operand2, true, enclosingDecl, context);
            context.popContextualType();
            this.setSymbolForAST(statementAST, leftType, context);
            return leftType;
        };
        PullTypeResolver.prototype.resolveBoundDecls = function (decl, context) {
            if (!decl) {
                return;
            }
            switch(decl.getKind()) {
                case TypeScript.PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for(var i = 0; i < childDecls.length; i++) {
                        this.resolveBoundDecls(childDecls[i], context);
                    }
                    break;
                case TypeScript.PullElementKind.DynamicModule:
                case TypeScript.PullElementKind.Container:
                    var moduleDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveModuleDeclaration(moduleDecl, context);
                    break;
                case TypeScript.PullElementKind.Interface:
                    var interfaceDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveInterfaceDeclaration(interfaceDecl, context);
                    break;
                case TypeScript.PullElementKind.Class:
                    var classDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveClassDeclaration(classDecl, context);
                    break;
                case TypeScript.PullElementKind.Method:
                case TypeScript.PullElementKind.Function:
                    var funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveFunctionDeclaration(funcDecl, context);
                    break;
                case TypeScript.PullElementKind.GetAccessor:
                    funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveGetAccessorDeclaration(funcDecl, context);
                    break;
                case TypeScript.PullElementKind.SetAccessor:
                    funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveSetAccessorDeclaration(funcDecl, context);
                    break;
                case TypeScript.PullElementKind.Property:
                case TypeScript.PullElementKind.Variable:
                case TypeScript.PullElementKind.Parameter:
                    var varDecl = this.semanticInfoChain.getASTForDecl(decl);
                    if (varDecl) {
                        this.resolveVariableDeclaration(varDecl, context);
                    }
                    break;
            }
        };
        PullTypeResolver.prototype.mergeOrdered = function (a, b, acceptVoid, context, comparisonInfo) {
            if (this.isAnyOrEquivalent(a) || this.isAnyOrEquivalent(b)) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (a == b) {
                return a;
            } else if ((b == this.semanticInfoChain.nullTypeSymbol) && a != this.semanticInfoChain.nullTypeSymbol) {
                return a;
            } else if ((a == this.semanticInfoChain.nullTypeSymbol) && (b != this.semanticInfoChain.nullTypeSymbol)) {
                return b;
            } else if (acceptVoid && (b == this.semanticInfoChain.voidTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            } else if (acceptVoid && (a == this.semanticInfoChain.voidTypeSymbol) && (b != this.semanticInfoChain.voidTypeSymbol)) {
                return b;
            } else if ((b == this.semanticInfoChain.undefinedTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            } else if ((a == this.semanticInfoChain.undefinedTypeSymbol) && (b != this.semanticInfoChain.undefinedTypeSymbol)) {
                return b;
            } else if (a.isTypeParameter() && !b.isTypeParameter()) {
                return b;
            } else if (!a.isTypeParameter() && b.isTypeParameter()) {
                return a;
            } else if (a.isArray() && b.isArray()) {
                if (a.getElementType() == b.getElementType()) {
                    return a;
                } else {
                    var mergedET = this.mergeOrdered(a.getElementType(), b.getElementType(), acceptVoid, context, comparisonInfo);
                    if (mergedET) {
                        var mergedArrayType = mergedET.getArrayType();
                        if (!mergedArrayType) {
                            mergedArrayType = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, mergedET, this, context);
                        }
                        return mergedArrayType;
                    }
                }
            } else if (this.sourceIsSubtypeOfTarget(a, b, context, comparisonInfo)) {
                return b;
            } else if (this.sourceIsSubtypeOfTarget(b, a, context, comparisonInfo)) {
                return a;
            }
            return null;
        };
        PullTypeResolver.prototype.widenType = function (type) {
            if (type == this.semanticInfoChain.undefinedTypeSymbol || type == this.semanticInfoChain.nullTypeSymbol || type.isError()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            return type;
        };
        PullTypeResolver.prototype.isNullOrUndefinedType = function (type) {
            return type == this.semanticInfoChain.nullTypeSymbol || type == this.semanticInfoChain.undefinedTypeSymbol;
        };
        PullTypeResolver.prototype.findBestCommonType = function (initialType, targetType, collection, acceptVoid, context, comparisonInfo) {
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;
            if (targetType) {
                if (bestCommonType) {
                    bestCommonType = this.mergeOrdered(bestCommonType, targetType, acceptVoid, context);
                } else {
                    bestCommonType = targetType;
                }
            }
            var convergenceType = bestCommonType;
            while(nlastChecked < len) {
                for(var i = 0; i < len; i++) {
                    if (i == nlastChecked) {
                        continue;
                    }
                    if (convergenceType && (bestCommonType = this.mergeOrdered(convergenceType, collection.getTypeAtIndex(i), acceptVoid, context, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }
                    if (bestCommonType == null || this.isAnyOrEquivalent(bestCommonType)) {
                        break;
                    } else if (targetType) {
                        collection.setTypeAtIndex(i, targetType);
                    }
                }
                if (convergenceType && bestCommonType) {
                    break;
                }
                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }
            return acceptVoid ? bestCommonType : (bestCommonType == this.semanticInfoChain.voidTypeSymbol ? null : bestCommonType);
        };
        PullTypeResolver.prototype.typesAreIdentical = function (t1, t2, val) {
            if (t1 == t2) {
                return true;
            }
            if (!t1 || !t2) {
                return false;
            }
            if (val && t1.isPrimitive() && (t1).isStringConstant() && t2 == this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType == TypeScript.NodeType.StringLiteral) && (TypeScript.stripQuotes((val).text) == TypeScript.stripQuotes(t1.getName()));
            }
            if (val && t2.isPrimitive() && (t2).isStringConstant() && t2 == this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType == TypeScript.NodeType.StringLiteral) && (TypeScript.stripQuotes((val).text) == TypeScript.stripQuotes(t2.getName()));
            }
            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }
            if (t1.isClass()) {
                return false;
            }
            if (t1.isError() && t2.isError()) {
                return true;
            }
            var comboId = (t2.getSymbolID() << 16) | t1.getSymbolID();
            if (this.identicalCache[comboId] != undefined) {
                return true;
            }
            if ((t1.getKind() & TypeScript.PullElementKind.Enum) || (t2.getKind() & TypeScript.PullElementKind.Enum)) {
                return false;
            }
            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.getElementType(), t2.getElementType());
                if (ret) {
                    this.identicalCache[comboId] = true;
                } else {
                    this.identicalCache[comboId] = undefined;
                }
                return ret;
            }
            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }
            this.identicalCache[comboId] = false;
            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getMembers();
                var t2Members = t2.getMembers();
                if (t1Members.length != t2Members.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }
                var t1MemberSymbol = null;
                var t2MemberSymbol = null;
                var t1MemberType = null;
                var t2MemberType = null;
                for(var iMember = 0; iMember < t1Members.length; iMember++) {
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = t2.findMember(t1MemberSymbol.getName());
                    if (!t2MemberSymbol || (t1MemberSymbol.getIsOptional() != t2MemberSymbol.getIsOptional())) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.getSymbolID() << 16) | t1MemberType.getSymbolID()] != undefined)) {
                        continue;
                    }
                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            } else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();
            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();
            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();
            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            this.identicalCache[comboId] = true;
            return true;
        };
        PullTypeResolver.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 == sg2) {
                return true;
            }
            if (!sg1 || !sg2) {
                return false;
            }
            if (sg1.length != sg2.length) {
                return false;
            }
            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;
            for(var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];
                for(var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];
                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }
                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.signaturesAreIdentical = function (s1, s2) {
            if (s1.hasVariableParamList() != s2.hasVariableParamList()) {
                return false;
            }
            if (s1.getNonOptionalParameterCount() != s2.getNonOptionalParameterCount()) {
                return false;
            }
            var s1Params = s1.getParameters();
            var s2Params = s2.getParameters();
            if (s1Params.length != s2Params.length) {
                return false;
            }
            if (!this.typesAreIdentical(s1.getReturnType(), s2.getReturnType())) {
                return false;
            }
            for(var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdentical(s1Params[iParam].getType(), s2Params[iParam].getType())) {
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.substituteUpperBoundForType = function (type) {
            if (!type || !type.isTypeParameter()) {
                return type;
            }
            var constraint = (type).getConstraint();
            if (constraint) {
                return this.substituteUpperBoundForType(constraint);
            }
            return type;
        };
        PullTypeResolver.prototype.sourceIsSubtypeOfTarget = function (source, target, context, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceMembersAreSubtypeOfTargetMembers = function (source, target, context, comparisonInfo) {
            return this.sourceMembersAreRelatableToTargetMembers(source, target, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourcePropertyIsSubtypeOfTargetProperty = function (source, target, sourceProp, targetProp, context, comparisonInfo) {
            return this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceCallSignaturesAreSubtypeOfTargetCallSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.typeIsSubtypeOfFunction = function (source, context) {
            var callSignatures = source.getCallSignatures();
            if (callSignatures.length) {
                return true;
            }
            var constructSignatures = source.getConstructSignatures();
            if (constructSignatures.length) {
                return true;
            }
            if (this.cachedFunctionInterfaceType) {
                return this.sourceIsSubtypeOfTarget(source, this.cachedFunctionInterfaceType, context);
            }
            return false;
        };
        PullTypeResolver.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.signatureIsSubtypeOfTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceIsAssignableToTarget = function (source, target, context, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.signatureIsAssignableToTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            source = this.substituteUpperBoundForType(source);
            target = this.substituteUpperBoundForType(target);
            if (source == target) {
                return true;
            }
            if (!(source && target)) {
                return true;
            }
            var comboId = (source.getSymbolID() << 16) | target.getSymbolID();
            if (comparisonCache[comboId] != undefined) {
                return true;
            }
            if (assignableTo) {
                if (this.isAnyOrEquivalent(source) || this.isAnyOrEquivalent(target)) {
                    return true;
                }
                if (source == this.semanticInfoChain.stringTypeSymbol && target.isPrimitive() && (target).isStringConstant()) {
                    return comparisonInfo && comparisonInfo.stringConstantVal && (comparisonInfo.stringConstantVal.nodeType == TypeScript.NodeType.StringLiteral) && (TypeScript.stripQuotes((comparisonInfo.stringConstantVal).text) == TypeScript.stripQuotes(target.getName()));
                }
            } else {
                if (this.isAnyOrEquivalent(target)) {
                    return true;
                }
                if (target == this.semanticInfoChain.stringTypeSymbol && source.isPrimitive() && (source).isStringConstant()) {
                    return true;
                }
            }
            if (source.isPrimitive() && (source).isStringConstant() && target.isPrimitive() && (target).isStringConstant()) {
                return TypeScript.stripQuotes(source.getName()) == TypeScript.stripQuotes(target.getName());
            }
            if (source == this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }
            if ((source == this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }
            if (target == this.semanticInfoChain.numberTypeSymbol && (source.getKind() & TypeScript.PullElementKind.Enum)) {
                return true;
            }
            if (source == this.semanticInfoChain.numberTypeSymbol && (target.getKind() & TypeScript.PullElementKind.Enum)) {
                return true;
            }
            if ((source.getKind() & TypeScript.PullElementKind.Enum) || (target.getKind() & TypeScript.PullElementKind.Enum)) {
                return false;
            }
            if (source.isArray() && target.isArray()) {
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.getElementType(), target.getElementType(), assignableTo, comparisonCache, context, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                } else {
                    comparisonCache[comboId] = undefined;
                }
                return ret;
            }
            if (target.isTypeParameter()) {
                return true;
            }
            if (source.isPrimitive() && target.isPrimitive()) {
                return false;
            } else if (source.isPrimitive() != target.isPrimitive()) {
                if (!target.isPrimitive()) {
                    if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                        if (!this.cachedNumberInterfaceType.isResolved()) {
                            this.resolveDeclaredSymbol(this.cachedNumberInterfaceType, null, context);
                        }
                        source = this.cachedNumberInterfaceType;
                    } else if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                        if (!this.cachedStringInterfaceType.isResolved()) {
                            this.resolveDeclaredSymbol(this.cachedStringInterfaceType, null, context);
                        }
                        source = this.cachedStringInterfaceType;
                    } else if (source == this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType) {
                        if (!this.cachedBooleanInterfaceType.isResolved()) {
                            this.resolveDeclaredSymbol(this.cachedBooleanInterfaceType, null, context);
                        }
                        source = this.cachedBooleanInterfaceType;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            comparisonCache[comboId] = false;
            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }
            if (this.cachedObjectInterfaceType && target == this.cachedObjectInterfaceType) {
                return true;
            }
            if (this.cachedFunctionInterfaceType && (source.getCallSignatures().length || source.getConstructSignatures().length) && target == this.cachedFunctionInterfaceType) {
                return true;
            }
            if (target.hasMembers() && !this.sourceMembersAreRelatableToTargetMembers(source, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }
            if (!this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }
            if (!this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }
            if (!this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }
            comparisonCache[comboId] = true;
            return true;
        };
        PullTypeResolver.prototype.sourceMembersAreRelatableToTargetMembers = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetProps = target.getAllMembers(TypeScript.PullElementKind.SomeValue, true);
            for(var itargetProp = 0; itargetProp < targetProps.length; itargetProp++) {
                var targetProp = targetProps[itargetProp];
                var sourceProp = source.findMember(targetProp.getName());
                if (!targetProp.isResolved()) {
                    this.resolveDeclaredSymbol(targetProp, null, context);
                }
                var targetPropType = targetProp.getType();
                if (!sourceProp) {
                    if (this.cachedObjectInterfaceType) {
                        sourceProp = this.cachedObjectInterfaceType.findMember(targetProp.getName());
                    }
                    if (!sourceProp) {
                        if (this.cachedFunctionInterfaceType && (targetPropType.getCallSignatures().length || targetPropType.getConstructSignatures().length)) {
                            sourceProp = this.cachedFunctionInterfaceType.findMember(targetProp.getName());
                        }
                        if (!sourceProp) {
                            if (!(targetProp.getIsOptional())) {
                                if (comparisonInfo) {
                                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.RequiredPropertyIsMissing;
                                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type__0__is_missing_property__1__from_type__2_, [
                                        source.toString(), 
                                        targetProp.getScopedNameEx().toString(), 
                                        target.toString()
                                    ]));
                                }
                                return false;
                            }
                            continue;
                        }
                    }
                }
                if (!this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo)) {
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.sourcePropertyIsRelatableToTargetProperty = function (source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetPropIsPrivate = targetProp.hasFlag(TypeScript.PullElementFlags.Private);
            var sourcePropIsPrivate = sourceProp.hasFlag(TypeScript.PullElementFlags.Private);
            if (targetPropIsPrivate != sourcePropIsPrivate) {
                if (comparisonInfo) {
                    if (targetPropIsPrivate) {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_, [
                            targetProp.getScopedNameEx().toString(), 
                            source.toString(), 
                            target.toString()
                        ]));
                    } else {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_, [
                            targetProp.getScopedNameEx().toString(), 
                            source.toString(), 
                            target.toString()
                        ]));
                    }
                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.InconsistantPropertyAccesibility;
                }
                return false;
            } else if (sourcePropIsPrivate && targetPropIsPrivate) {
                var targetDecl = targetProp.getDeclarations()[0];
                var sourceDecl = sourceProp.getDeclarations()[0];
                if (!targetDecl.isEqual(sourceDecl)) {
                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.InconsistantPropertyAccesibility;
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types__0__and__1__define_property__2__as_private, [
                        source.toString(), 
                        target.toString(), 
                        targetProp.getScopedNameEx().toString()
                    ]));
                    return false;
                }
            }
            if (!sourceProp.isResolved()) {
                this.resolveDeclaredSymbol(sourceProp, null, context);
            }
            var sourcePropType = sourceProp.getType();
            var targetPropType = targetProp.getType();
            if (targetPropType && sourcePropType && (comparisonCache[(sourcePropType.getSymbolID() << 16) | targetPropType.getSymbolID()] != undefined)) {
                return true;
            }
            var comparisonInfoPropertyTypeCheck = null;
            if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                comparisonInfoPropertyTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
            }
            if (!this.sourceIsRelatableToTarget(sourcePropType, targetPropType, assignableTo, comparisonCache, context, comparisonInfoPropertyTypeCheck)) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatiblePropertyTypes;
                    var message;
                    if (comparisonInfoPropertyTypeCheck && comparisonInfoPropertyTypeCheck.message) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3, [
                            targetProp.getScopedNameEx().toString(), 
                            source.toString(), 
                            target.toString(), 
                            comparisonInfoPropertyTypeCheck.message
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property__0__of_types__1__and__2__are_incompatible, [
                            targetProp.getScopedNameEx().toString(), 
                            source.toString(), 
                            target.toString()
                        ]);
                    }
                    comparisonInfo.addMessage(message);
                }
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.sourceCallSignaturesAreRelatableToTargetCallSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetCallSigs = target.getCallSignatures();
            if (targetCallSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
                }
                var sourceCallSigs = source.getCallSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types__0__and__1__are_incompatible__NL__2, [
                                    source.toString(), 
                                    target.toString(), 
                                    comparisonInfoSignatuesTypeCheck.message
                                ]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types__0__and__1__are_incompatible, [
                                    source.toString(), 
                                    target.toString()
                                ]);
                            }
                        } else {
                            var hasSig = targetCallSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetCallSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type__0__requires_a_call_signature__but_Type__1__lacks_one, [
                                hasSig, 
                                lacksSig
                            ]);
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.sourceConstructSignaturesAreRelatableToTargetConstructSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetConstructSigs = target.getConstructSignatures();
            if (targetConstructSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
                }
                var sourceConstructSigs = source.getConstructSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types__0__and__1__are_incompatible__NL__2, [
                                    source.toString(), 
                                    target.toString(), 
                                    comparisonInfoSignatuesTypeCheck.message
                                ]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types__0__and__1__are_incompatible, [
                                    source.toString(), 
                                    target.toString()
                                ]);
                            }
                        } else {
                            var hasSig = targetConstructSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetConstructSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type__0__requires_a_construct_signature__but_Type__1__lacks_one, [
                                hasSig, 
                                lacksSig
                            ]);
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.sourceIndexSignaturesAreRelatableToTargetIndexSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetIndexSigs = target.getIndexSignatures();
            if (targetIndexSigs.length) {
                var sourceIndexSigs = source.getIndexSignatures();
                var targetIndex = !targetIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : targetIndexSigs;
                var sourceIndex = !sourceIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : sourceIndexSigs;
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
                }
                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types__0__and__1__are_incompatible__NL__2, [
                                source.toString(), 
                                target.toString(), 
                                comparisonInfoSignatuesTypeCheck.message
                            ]);
                        } else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types__0__and__1__are_incompatible, [
                                source.toString(), 
                                target.toString()
                            ]);
                        }
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleSignatures;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, context, comparisonInfo) {
            if (sourceSG == targetSG) {
                return true;
            }
            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }
            var mSig = null;
            var nSig = null;
            var foundMatch = false;
            for(var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];
                for(var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, context, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }
                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, context, comparisonInfo) {
            var sourceParameters = sourceSig.getParameters();
            var targetParameters = targetSig.getParameters();
            if (!sourceParameters || !targetParameters) {
                return false;
            }
            var targetVarArgCount = targetSig.getNonOptionalParameterCount();
            var sourceVarArgCount = sourceSig.getNonOptionalParameterCount();
            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableParamList()) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signature_expects__0__or_fewer_parameters, [
                        targetVarArgCount
                    ]));
                }
                return false;
            }
            var sourceReturnType = sourceSig.getReturnType();
            var targetReturnType = targetSig.getReturnType();
            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleReturnTypes;
                    }
                    return false;
                }
            }
            var len = (sourceVarArgCount < targetVarArgCount && (sourceSig.hasVariableParamList() || (sourceParameters.length > sourceVarArgCount))) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";
            for(var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (iSource < sourceParameters.length && (!sourceSig.hasVariableParamList() || iSource < sourceVarArgCount)) {
                    sourceParamType = sourceParameters[iSource].getType();
                    sourceParamName = sourceParameters[iSource].getName();
                } else if (iSource == sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    if (sourceParamType.isArray()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].getName();
                }
                if (iTarget < targetParameters.length && iTarget < targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();
                    targetParamName = targetParameters[iTarget].getName();
                } else if (targetSig.hasVariableParamList() && iTarget == targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();
                    if (targetParamType.isArray()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].getName();
                }
                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, context, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, context, comparisonInfo))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeScript.TypeRelationshipFlags.IncompatibleParameterTypes;
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.resolveOverloads = function (application, group, enclosingDecl, haveTypeArgumentsAtCallSite, context) {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate = null;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var args = null;
            var target = null;
            var argSym;
            if (application.nodeType == TypeScript.NodeType.InvocationExpression || application.nodeType == TypeScript.NodeType.ObjectCreationExpression) {
                var callEx = application;
                args = callEx.arguments;
                target = callEx.target;
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    for(var i = 0; i < len; i++) {
                        argSym = this.resolveStatementOrExpression(callEx.arguments.members[i], false, enclosingDecl, context);
                        actuals[i] = argSym.getType();
                    }
                }
            } else if (application.nodeType == TypeScript.NodeType.ElementAccessExpression) {
                var binExp = application;
                target = binExp.operand1;
                args = new TypeScript.ASTList();
                args.members[0] = binExp.operand2;
                argSym = this.resolveStatementOrExpression(args.members[0], false, enclosingDecl, context);
                actuals[0] = argSym.getType();
            }
            var signature;
            var returnType;
            var candidateInfo;
            for(var j = 0, groupLen = group.length; j < groupLen; j++) {
                signature = group[j];
                if ((hasOverloads && signature.isDefinition()) || (haveTypeArgumentsAtCallSite && !signature.isGeneric())) {
                    continue;
                }
                returnType = signature.getReturnType();
                this.getCandidateSignatures(signature, actuals, args, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo);
            }
            if (exactCandidates.length == 0) {
                var applicableCandidates = this.getApplicableSignaturesFromCandidates(conversionCandidates, args, comparisonInfo, enclosingDecl, context);
                if (applicableCandidates.length > 0) {
                    candidateInfo = this.findMostApplicableSignature(applicableCandidates, args, enclosingDecl, context);
                    candidate = candidateInfo.sig;
                } else {
                    if (comparisonInfo.message) {
                        context.postError(application.minChar, application.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0, [
                            comparisonInfo.message
                        ]), enclosingDecl, true);
                    } else {
                        context.postError(application.minChar, application.getLength(), this.unitPath, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target, null), enclosingDecl, true);
                    }
                }
            } else {
                if (exactCandidates.length > 1) {
                    var applicableSigs = [];
                    for(var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = {
                            signature: exactCandidates[i],
                            hadProvisionalErrors: false
                        };
                    }
                    candidateInfo = this.findMostApplicableSignature(applicableSigs, args, enclosingDecl, context);
                    candidate = candidateInfo.sig;
                } else {
                    candidate = exactCandidates[0];
                }
            }
            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        };
        PullTypeResolver.prototype.getCandidateSignatures = function (signature, actuals, args, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo) {
            var parameters = signature.getParameters();
            var lowerBound = signature.getNonOptionalParameterCount();
            var upperBound = parameters.length;
            var formalLen = lowerBound;
            var acceptable = false;
            if ((actuals.length >= lowerBound) && (signature.hasVariableParamList() || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableParamList() ? parameters.length : actuals.length);
                acceptable = true;
            }
            var repeatType = null;
            if (acceptable) {
                if (signature.hasVariableParamList()) {
                    formalLen -= 1;
                    repeatType = parameters[formalLen].getType();
                    repeatType = repeatType.getElementType();
                    acceptable = actuals.length >= (formalLen < lowerBound ? formalLen : lowerBound);
                }
                var len = actuals.length;
                var exact = acceptable;
                var convert = acceptable;
                var typeA;
                var typeB;
                for(var i = 0; i < len; i++) {
                    if (i < formalLen) {
                        typeA = parameters[i].getType();
                    } else {
                        typeA = repeatType;
                    }
                    typeB = actuals[i];
                    if (typeA && !typeA.isResolved()) {
                        this.resolveDeclaredSymbol(typeA, enclosingDecl, context);
                    }
                    if (typeB && !typeB.isResolved()) {
                        this.resolveDeclaredSymbol(typeB, enclosingDecl, context);
                    }
                    if (!typeA || !typeB || !(this.typesAreIdentical(typeA, typeB, args.members[i]))) {
                        exact = false;
                    }
                    comparisonInfo.stringConstantVal = args.members[i];
                    if (!this.sourceIsAssignableToTarget(typeB, typeA, context, comparisonInfo)) {
                        convert = false;
                    }
                    comparisonInfo.stringConstantVal = null;
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                } else if (convert && (exactCandidates.length == 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        };
        PullTypeResolver.prototype.getApplicableSignaturesFromCandidates = function (candidateSignatures, args, comparisonInfo, enclosingDecl, context) {
            var applicableSigs = [];
            var memberType = null;
            var miss = false;
            var cxt = null;
            var hadProvisionalErrors = false;
            var parameters;
            var signature;
            var argSym;
            for(var i = 0; i < candidateSignatures.length; i++) {
                miss = false;
                signature = candidateSignatures[i];
                parameters = signature.getParameters();
                for(var j = 0; j < args.members.length; j++) {
                    if (j >= parameters.length) {
                        continue;
                    }
                    if (!parameters[j].isResolved()) {
                        this.resolveDeclaredSymbol(parameters[j], enclosingDecl, context);
                    }
                    memberType = parameters[j].getType();
                    if (signature.hasVariableParamList() && (j >= signature.getNonOptionalParameterCount() - 1) && memberType.isArray()) {
                        memberType = memberType.getElementType();
                    }
                    if (this.isAnyOrEquivalent(memberType)) {
                        continue;
                    } else if (args.members[j].nodeType == TypeScript.NodeType.FunctionDeclaration) {
                        if (this.cachedFunctionInterfaceType && memberType == this.cachedFunctionInterfaceType) {
                            continue;
                        }
                        argSym = this.resolveFunctionExpression(args.members[j], false, enclosingDecl, context);
                        if (!this.canApplyContextualTypeToFunction(memberType, args.members[j], true)) {
                            if (this.canApplyContextualTypeToFunction(memberType, args.members[j], false)) {
                                if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else {
                            context.pushContextualType(memberType, true, null);
                            argSym = this.resolveFunctionExpression(args.members[j], true, enclosingDecl, context);
                            if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type__0__to_argument__1__which_is_of_type__2_, [
                                        memberType.toString(), 
                                        (j + 1), 
                                        argSym.getTypeName()
                                    ]));
                                }
                                miss = true;
                            }
                            argSym.invalidate();
                            cxt = context.popContextualType();
                            hadProvisionalErrors = cxt.hadProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    } else if (args.members[j].nodeType == TypeScript.NodeType.ObjectLiteralExpression) {
                        if (this.cachedObjectInterfaceType && memberType == this.cachedObjectInterfaceType) {
                            continue;
                        }
                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveObjectLiteralExpression(args.members[j], true, enclosingDecl, context);
                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type__0__to_argument__1__which_is_of_type__2_, [
                                    memberType.toString(), 
                                    (j + 1), 
                                    argSym.getTypeName()
                                ]));
                            }
                            miss = true;
                        }
                        argSym.invalidate();
                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    } else if (args.members[j].nodeType == TypeScript.NodeType.ArrayLiteralExpression) {
                        if (this.cachedArrayInterfaceType && memberType == this.cachedArrayInterfaceType) {
                            continue;
                        }
                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveArrayLiteralExpression(args.members[j], true, enclosingDecl, context);
                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type__0__to_argument__1__which_is_of_type__2_, [
                                    memberType.toString(), 
                                    (j + 1), 
                                    argSym.getTypeName()
                                ]));
                            }
                            break;
                        }
                        argSym.invalidate();
                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                }
                if (j == args.members.length) {
                    applicableSigs[applicableSigs.length] = {
                        signature: candidateSignatures[i],
                        hadProvisionalErrors: hadProvisionalErrors
                    };
                }
                hadProvisionalErrors = false;
            }
            return applicableSigs;
        };
        PullTypeResolver.prototype.findMostApplicableSignature = function (signatures, args, enclosingDecl, context) {
            if (signatures.length == 1) {
                return {
                    sig: signatures[0].signature,
                    ambiguous: false
                };
            }
            var best = signatures[0];
            var Q = null;
            var AType = null;
            var PType = null;
            var QType = null;
            var ambiguous = false;
            var argSym;
            var bestParams;
            var qParams;
            for(var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                for(var i = 0; args && i < args.members.length; i++) {
                    argSym = this.resolveStatementOrExpression(args.members[i], false, enclosingDecl, context);
                    AType = argSym.getType();
                    argSym.invalidate();
                    bestParams = best.signature.getParameters();
                    qParams = Q.signature.getParameters();
                    PType = i < bestParams.length ? bestParams[i].getType() : bestParams[bestParams.length - 1].getType().getElementType();
                    QType = i < qParams.length ? qParams[i].getType() : qParams[qParams.length - 1].getType().getElementType();
                    if (this.typesAreIdentical(PType, QType) && !(QType.isPrimitive() && (QType).isStringConstant())) {
                        continue;
                    } else if (PType.isPrimitive() && (PType).isStringConstant() && args.members[i].nodeType == TypeScript.NodeType.StringLiteral && TypeScript.stripQuotes((args.members[i]).text) == TypeScript.stripQuotes((PType).getName())) {
                        break;
                    } else if (QType.isPrimitive() && (QType).isStringConstant() && args.members[i].nodeType == TypeScript.NodeType.StringLiteral && TypeScript.stripQuotes((args.members[i]).text) == TypeScript.stripQuotes((QType).getName())) {
                        best = Q;
                    } else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    } else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(PType, QType, context)) {
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(QType, PType, context)) {
                        best = Q;
                        break;
                    } else if (Q.hadProvisionalErrors) {
                        break;
                    } else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }
                if (!args || i == args.members.length) {
                    var collection = {
                        getLength: function () {
                            return 2;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return index ? Q.signature.getReturnType() : best.signature.getReturnType();
                        }
                    };
                    var bct = this.findBestCommonType(best.signature.getReturnType(), null, collection, true, context);
                    ambiguous = !bct;
                } else {
                    ambiguous = false;
                }
            }
            return {
                sig: best.signature,
                ambiguous: ambiguous
            };
        };
        PullTypeResolver.prototype.canApplyContextualTypeToFunction = function (candidateType, funcDecl, beStringent) {
            if (funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation) {
                return false;
            }
            beStringent = beStringent || (this.cachedFunctionInterfaceType == candidateType);
            if (!beStringent) {
                return true;
            }
            var signature = this.getSymbolForAST(funcDecl, null).getType().getCallSignatures()[0];
            var parameters = signature.getParameters();
            var paramLen = parameters.length;
            for(var i = 0; i < paramLen; i++) {
                var param = parameters[i];
                var argDecl = this.getASTForSymbol(param);
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }
            if (candidateType.getConstructSignatures().length && candidateType.getCallSignatures().length) {
                return false;
            }
            var candidateSigs = candidateType.getConstructSignatures().length ? candidateType.getConstructSignatures() : candidateType.getCallSignatures();
            if (!candidateSigs || candidateSigs.length > 1) {
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.inferArgumentTypesForSignature = function (signature, args, comparisonInfo, enclosingDecl, context) {
            var cxt = null;
            var hadProvisionalErrors = false;
            var argSym;
            var parameters = signature.getParameters();
            var typeParameters = signature.getTypeParameters();
            var argContext = new TypeScript.ArgumentInferenceContext();
            var parameterType = null;
            for(var i = 0; i < typeParameters.length; i++) {
                argContext.addCandidateForInference(typeParameters[i], null, false);
            }
            var substitutions;
            var inferenceCandidates;
            var inferenceCandidate;
            for(var i = 0; i < args.members.length; i++) {
                if (i >= parameters.length) {
                    break;
                }
                parameterType = parameters[i].getType();
                if (signature.hasVariableParamList() && (i >= signature.getNonOptionalParameterCount() - 1) && parameterType.isArray()) {
                    parameterType = parameterType.getElementType();
                }
                inferenceCandidates = argContext.getInferenceCandidates();
                substitutions = {};
                if (inferenceCandidates.length) {
                    for(var j = 0; j < inferenceCandidates.length; j++) {
                        inferenceCandidate = inferenceCandidates[j];
                        substitutions = inferenceCandidates[j];
                        context.pushContextualType(parameterType, true, substitutions);
                        argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);
                        this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);
                        cxt = context.popContextualType();
                        argSym.invalidate();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                    }
                } else {
                    context.pushContextualType(parameterType, true, {});
                    argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);
                    this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);
                    cxt = context.popContextualType();
                    argSym.invalidate();
                    hadProvisionalErrors = cxt.hadProvisionalErrors();
                }
            }
            hadProvisionalErrors = false;
            var inferenceResults = argContext.inferArgumentTypes(this, context);
            if (inferenceResults.unfit) {
                return null;
            }
            var resultTypes = [];
            var len = typeParameters.length < inferenceResults.results.length ? typeParameters.length : inferenceResults.results.length;
            for(var i = 0; i < len; i++) {
                resultTypes[resultTypes.length] = inferenceResults.results[i].type;
            }
            if (!args.members.length && !resultTypes.length && typeParameters.length) {
                for(var i = 0; i < typeParameters.length; i++) {
                    resultTypes[resultTypes.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            return resultTypes;
        };
        PullTypeResolver.prototype.relateTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            if (expressionType.isError()) {
                expressionType = this.semanticInfoChain.anyTypeSymbol;
            }
            if (parameterType == expressionType) {
                return;
            }
            if (parameterType.isTypeParameter()) {
                argContext.addCandidateForInference(parameterType, expressionType, shouldFix);
                return;
            }
            var parameterDeclarations = parameterType.getDeclarations();
            var expressionDeclarations = expressionType.getDeclarations();
            if (!parameterType.isArray() && parameterDeclarations.length && expressionDeclarations.length && parameterDeclarations[0].isEqual(expressionDeclarations[0]) && expressionType.isGeneric()) {
                var typeParameters = parameterType.getTypeParameters();
                var typeArguments = expressionType.getTypeArguments();
                if (!typeArguments) {
                    typeParameters = parameterType.getTypeArguments();
                    typeArguments = expressionType.getTypeParameters();
                }
                var hadRelation = false;
                if (typeParameters && typeArguments && typeParameters.length == typeArguments.length) {
                    for(var i = 0; i < typeParameters.length; i++) {
                        if (typeArguments[i] != typeParameters[i]) {
                            this.relateTypeToTypeParameters(typeArguments[i], typeParameters[i], shouldFix, argContext, enclosingDecl, context);
                            hadRelation = true;
                        }
                    }
                }
                if (hadRelation) {
                    return;
                }
            }
            var anyExpressionType = this.specializeTypeToAny(expressionType, enclosingDecl, context);
            var anyParameterType = this.specializeTypeToAny(parameterType, enclosingDecl, context);
            if (!this.sourceIsAssignableToTarget(anyExpressionType, anyParameterType, context)) {
                return;
            }
            if (expressionType.isArray() && parameterType.isArray()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
                return;
            }
            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        };
        PullTypeResolver.prototype.relateFunctionSignatureToTypeParameters = function (expressionSignature, parameterSignature, argContext, enclosingDecl, context) {
            var anyExpressionSignature = this.specializeSignatureToAny(expressionSignature, enclosingDecl, context);
            var anyParamExpressionSignature = this.specializeSignatureToAny(parameterSignature, enclosingDecl, context);
            if (!this.signatureIsAssignableToTarget(anyExpressionSignature, anyParamExpressionSignature, context)) {
                return;
            }
            var expressionParams = expressionSignature.getParameters();
            var expressionReturnType = expressionSignature.getReturnType();
            var parameterParams = parameterSignature.getParameters();
            var parameterReturnType = parameterSignature.getReturnType();
            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;
            for(var i = 0; i < len; i++) {
                this.relateTypeToTypeParameters(expressionParams[i].getType(), parameterParams[i].getType(), true, argContext, enclosingDecl, context);
            }
            this.relateTypeToTypeParameters(expressionReturnType, parameterReturnType, true, argContext, enclosingDecl, context);
        };
        PullTypeResolver.prototype.relateObjectTypeToTypeParameters = function (objectType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures;
            var parameterSignature;
            var objectMember;
            var objectSignatures;
            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }
            var objectTypeArguments = objectType.getTypeArguments();
            var parameterTypeParameters = parameterType.getTypeParameters();
            if (objectTypeArguments && (objectTypeArguments.length == parameterTypeParameters.length)) {
                for(var i = 0; i < objectTypeArguments.length; i++) {
                    argContext.addCandidateForInference(parameterTypeParameters[i], objectTypeArguments[i], shouldFix);
                }
            }
            for(var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = objectType.findMember(parameterTypeMembers[i].getName());
                if (objectMember) {
                    this.relateTypeToTypeParameters(objectMember.getType(), parameterTypeMembers[i].getType(), shouldFix, argContext, enclosingDecl, context);
                }
            }
            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();
            for(var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];
                for(var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();
            for(var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];
                for(var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
            parameterSignatures = parameterType.getIndexSignatures();
            objectSignatures = objectType.getIndexSignatures();
            for(var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];
                for(var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
        };
        PullTypeResolver.prototype.relateArrayTypeToTypeParameters = function (argArrayType, parameterArrayType, shouldFix, argContext, enclosingDecl, context) {
            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();
            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, enclosingDecl, context);
        };
        PullTypeResolver.prototype.specializeTypeToAny = function (typeToSpecialize, enclosingDecl, context) {
            var prevSpecialize = context.specializingToAny;
            context.specializingToAny = true;
            var type = TypeScript.specializeType(typeToSpecialize, [], this, enclosingDecl, context);
            context.specializingToAny = prevSpecialize;
            return type;
        };
        PullTypeResolver.prototype.specializeSignatureToAny = function (signatureToSpecialize, enclosingDecl, context) {
            var typeParameters = signatureToSpecialize.getTypeParameters();
            var typeReplacementMap = {};
            var typeArguments = [];
            for(var i = 0; i < typeParameters.length; i++) {
                typeArguments[i] = this.semanticInfoChain.anyTypeSymbol;
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            if (!typeArguments.length) {
                typeArguments[0] = this.semanticInfoChain.anyTypeSymbol;
            }
            var prevSpecialize = context.specializingToAny;
            context.specializingToAny = true;
            var sig = TypeScript.specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
            context.specializingToAny = prevSpecialize;
            return sig;
        };
        return PullTypeResolver;
    })();
    TypeScript.PullTypeResolver = PullTypeResolver;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullTypeCheckContext = (function () {
        function PullTypeCheckContext(compiler, script, scriptName) {
            this.compiler = compiler;
            this.script = script;
            this.scriptName = scriptName;
            this.enclosingDeclStack = [];
            this.enclosingDeclReturnStack = [];
            this.semanticInfo = null;
            this.inSuperConstructorCall = false;
            this.inSuperConstructorTarget = false;
            this.seenSuperConstructorCall = false;
        }
        PullTypeCheckContext.prototype.pushEnclosingDecl = function (decl) {
            this.enclosingDeclStack[this.enclosingDeclStack.length] = decl;
            this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length] = false;
        };
        PullTypeCheckContext.prototype.popEnclosingDecl = function () {
            this.enclosingDeclStack.length--;
            this.enclosingDeclReturnStack.length--;
        };
        PullTypeCheckContext.prototype.getEnclosingDecl = function (kind) {
            if (typeof kind === "undefined") { kind = TypeScript.PullElementKind.All; }
            for(var i = this.enclosingDeclStack.length - 1; i >= 0; i--) {
                var decl = this.enclosingDeclStack[i];
                if (decl.getKind() & kind) {
                    return decl;
                }
            }
            return null;
        };
        PullTypeCheckContext.prototype.getEnclosingNonLambdaDecl = function () {
            for(var i = this.enclosingDeclStack.length - 1; i >= 0; i--) {
                var decl = this.enclosingDeclStack[i];
                if (!(decl.getKind() == TypeScript.PullElementKind.FunctionExpression && (decl.getFlags() & TypeScript.PullElementFlags.FatArrow))) {
                    return decl;
                }
            }
            return null;
        };
        PullTypeCheckContext.prototype.getEnclosingClassDecl = function () {
            return this.getEnclosingDecl(TypeScript.PullElementKind.Class);
        };
        PullTypeCheckContext.prototype.getEnclosingDeclHasReturn = function () {
            return this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length - 1];
        };
        PullTypeCheckContext.prototype.setEnclosingDeclHasReturn = function () {
            return this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length - 1] = true;
        };
        return PullTypeCheckContext;
    })();
    TypeScript.PullTypeCheckContext = PullTypeCheckContext;    
    var PullTypeChecker = (function () {
        function PullTypeChecker(compilationSettings, semanticInfoChain) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.resolver = null;
            this.context = new TypeScript.PullTypeResolutionContext();
        }
        PullTypeChecker.globalPullTypeCheckPhase = 0;
        PullTypeChecker.prototype.setUnit = function (unitPath) {
            this.resolver = new TypeScript.PullTypeResolver(this.compilationSettings, this.semanticInfoChain, unitPath);
        };
        PullTypeChecker.prototype.getScriptDecl = function (fileName) {
            return this.semanticInfoChain.getUnit(fileName).getTopLevelDecls()[0];
        };
        PullTypeChecker.prototype.checkForResolutionError = function (typeSymbol, decl) {
            if (typeSymbol && typeSymbol.isError()) {
                decl.addDiagnostic((typeSymbol).getDiagnostic());
            }
        };
        PullTypeChecker.prototype.postError = function (offset, length, fileName, message, enclosingDecl) {
            enclosingDecl.addDiagnostic(new TypeScript.PullDiagnostic(offset, length, fileName, message));
        };
        PullTypeChecker.prototype.validateVariableDeclarationGroups = function (enclosingDecl, typeCheckContext) {
            var declGroups = enclosingDecl.getVariableDeclGroups();
            var decl;
            var firstSymbol;
            var symbol;
            var boundDeclAST;
            for(var i = 0; i < declGroups.length; i++) {
                for(var j = 0; j < declGroups[i].length; j++) {
                    decl = declGroups[i][j];
                    symbol = decl.getSymbol();
                    boundDeclAST = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolver.resolveDeclaration(boundDeclAST, this.context, enclosingDecl);
                    if (!j) {
                        firstSymbol = decl.getSymbol();
                        if (this.resolver.isAnyOrEquivalent(this.resolver.widenType(firstSymbol.getType()))) {
                            return;
                        }
                        continue;
                    }
                    if (!this.resolver.typesAreIdentical(symbol.getType(), firstSymbol.getType())) {
                        this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_, [
                            symbol.getName(), 
                            firstSymbol.getType().toString(), 
                            symbol.getType().toString()
                        ]), enclosingDecl);
                    }
                }
            }
        };
        PullTypeChecker.prototype.typeCheckAST = function (ast, typeCheckContext, inTypedAssignment) {
            if (typeof inTypedAssignment === "undefined") { inTypedAssignment = false; }
            if (!ast) {
                return null;
            }
            if (ast.typeCheckPhase >= PullTypeChecker.globalPullTypeCheckPhase) {
                return null;
            } else {
                ast.typeCheckPhase = PullTypeChecker.globalPullTypeCheckPhase;
            }
            switch(ast.nodeType) {
                case TypeScript.NodeType.List:
                    return this.typeCheckList(ast, typeCheckContext);
                case TypeScript.NodeType.VariableDeclarator:
                case TypeScript.NodeType.Parameter:
                    return this.typeCheckBoundDecl(ast, typeCheckContext);
                case TypeScript.NodeType.FunctionDeclaration:
                    return this.typeCheckFunction(ast, typeCheckContext, inTypedAssignment);
                case TypeScript.NodeType.ClassDeclaration:
                    return this.typeCheckClass(ast, typeCheckContext);
                case TypeScript.NodeType.InterfaceDeclaration:
                    return this.typeCheckInterface(ast, typeCheckContext);
                case TypeScript.NodeType.ModuleDeclaration:
                    return this.typeCheckModule(ast, typeCheckContext);
                case TypeScript.NodeType.AssignmentExpression:
                    return this.typeCheckAssignment(ast, typeCheckContext);
                case TypeScript.GenericType:
                    return this.typeCheckGenericType(ast, typeCheckContext);
                case TypeScript.NodeType.ObjectLiteralExpression:
                    return this.typeCheckObjectLiteral(ast, typeCheckContext, inTypedAssignment);
                case TypeScript.NodeType.ArrayLiteralExpression:
                    return this.typeCheckArrayLiteral(ast, typeCheckContext, inTypedAssignment);
                case TypeScript.NodeType.ThisExpression:
                    return this.typeCheckThisExpression(ast, typeCheckContext);
                case TypeScript.NodeType.SuperExpression:
                    return this.typeCheckSuper(ast, typeCheckContext);
                case TypeScript.NodeType.InvocationExpression:
                    return this.typeCheckCallExpression(ast, typeCheckContext);
                case TypeScript.NodeType.ObjectCreationExpression:
                    return this.typeCheckObjectCreationExpression(ast, typeCheckContext);
                case TypeScript.NodeType.CastExpression:
                    return this.typeCheckTypeAssertion(ast, typeCheckContext);
                case TypeScript.NodeType.TypeRef:
                    return this.typeCheckTypeReference(ast, typeCheckContext);
                case TypeScript.NodeType.NotEqualsWithTypeConversionExpression:
                case TypeScript.NodeType.EqualsWithTypeConversionExpression:
                case TypeScript.NodeType.EqualsExpression:
                case TypeScript.NodeType.NotEqualsExpression:
                case TypeScript.NodeType.LessThanExpression:
                case TypeScript.NodeType.LessThanOrEqualExpression:
                case TypeScript.NodeType.GreaterThanOrEqualExpression:
                case TypeScript.NodeType.GreaterThanExpression:
                    return this.typeCheckLogicalOperation(ast, typeCheckContext);
                case TypeScript.NodeType.CommaExpression:
                    return this.typeCheckCommaExpression(ast, typeCheckContext);
                case TypeScript.NodeType.AddExpression:
                case TypeScript.NodeType.AddAssignmentExpression:
                    return this.typeCheckBinaryAdditionOperation(ast, typeCheckContext);
                case TypeScript.NodeType.SubtractExpression:
                case TypeScript.NodeType.MultiplyExpression:
                case TypeScript.NodeType.DivideExpression:
                case TypeScript.NodeType.ModuloExpression:
                case TypeScript.NodeType.BitwiseOrExpression:
                case TypeScript.NodeType.BitwiseAndExpression:
                case TypeScript.NodeType.LeftShiftExpression:
                case TypeScript.NodeType.SignedRightShiftExpression:
                case TypeScript.NodeType.UnsignedRightShiftExpression:
                case TypeScript.NodeType.BitwiseExclusiveOrExpression:
                case TypeScript.NodeType.ExclusiveOrAssignmentExpression:
                case TypeScript.NodeType.LeftShiftAssignmentExpression:
                case TypeScript.NodeType.SignedRightShiftAssignmentExpression:
                case TypeScript.NodeType.UnsignedRightShiftAssignmentExpression:
                case TypeScript.NodeType.SubtractAssignmentExpression:
                case TypeScript.NodeType.MultiplyAssignmentExpression:
                case TypeScript.NodeType.DivideAssignmentExpression:
                case TypeScript.NodeType.ModuloAssignmentExpression:
                case TypeScript.NodeType.OrAssignmentExpression:
                case TypeScript.NodeType.AndAssignmentExpression:
                    return this.typeCheckBinaryArithmeticOperation(ast, typeCheckContext);
                case TypeScript.NodeType.PlusExpression:
                case TypeScript.NodeType.NegateExpression:
                case TypeScript.NodeType.BitwiseNotExpression:
                case TypeScript.NodeType.PostIncrementExpression:
                case TypeScript.NodeType.PreIncrementExpression:
                case TypeScript.NodeType.PostDecrementExpression:
                case TypeScript.NodeType.PreDecrementExpression:
                    return this.typeCheckUnaryArithmeticOperation(ast, typeCheckContext, inTypedAssignment);
                case TypeScript.NodeType.ElementAccessExpression:
                    return this.typeCheckElementAccessExpression(ast, typeCheckContext);
                case TypeScript.NodeType.LogicalNotExpression:
                    return this.typeCheckLogicalNotExpression(ast, typeCheckContext, inTypedAssignment);
                case TypeScript.NodeType.LogicalOrExpression:
                case TypeScript.NodeType.LogicalAndExpression:
                    return this.typeCheckLogicalAndOrExpression(ast, typeCheckContext);
                case TypeScript.NodeType.TypeOfExpression:
                    return this.typeCheckTypeOf(ast, typeCheckContext);
                case TypeScript.NodeType.ConditionalExpression:
                    return this.typeCheckConditionalExpression(ast, typeCheckContext);
                case TypeScript.NodeType.VoidExpression:
                    return this.typeCheckVoidExpression(ast, typeCheckContext);
                case TypeScript.NodeType.ThrowStatement:
                    return this.typeCheckThrowStatement(ast, typeCheckContext);
                case TypeScript.NodeType.DeleteExpression:
                    return this.typeCheckDeleteExpression(ast, typeCheckContext);
                case TypeScript.NodeType.RegularExpressionLiteral:
                    return this.typeCheckRegExpExpression(ast, typeCheckContext);
                case TypeScript.NodeType.InExpression:
                    return this.typeCheckInExpression(ast, typeCheckContext);
                case TypeScript.NodeType.InstanceOfExpression:
                    return this.typeCheckInstanceOfExpression(ast, typeCheckContext);
                case TypeScript.NodeType.ParenthesizedExpression:
                    return this.typeCheckParenthesizedExpression(ast, typeCheckContext);
                case TypeScript.NodeType.ForStatement:
                    return this.typeCheckForStatement(ast, typeCheckContext);
                case TypeScript.NodeType.ForInStatement:
                    return this.typeCheckForInStatement(ast, typeCheckContext);
                case TypeScript.NodeType.WhileStatement:
                    return this.typeCheckWhileStatement(ast, typeCheckContext);
                case TypeScript.NodeType.DoStatement:
                    return this.typeCheckDoStatement(ast, typeCheckContext);
                case TypeScript.NodeType.IfStatement:
                    return this.typeCheckIfStatement(ast, typeCheckContext);
                case TypeScript.NodeType.Block:
                    return this.typeCheckBlock(ast, typeCheckContext);
                case TypeScript.NodeType.VariableDeclaration:
                    return this.typeCheckVariableDeclaration(ast, typeCheckContext);
                case TypeScript.NodeType.VariableStatement:
                    return this.typeCheckVariableStatement(ast, typeCheckContext);
                case TypeScript.NodeType.WithStatement:
                    return this.typeCheckWithStatement(ast, typeCheckContext);
                case TypeScript.NodeType.TryStatement:
                    return this.typeCheckTryStatement(ast, typeCheckContext);
                case TypeScript.NodeType.CatchClause:
                    return this.typeCheckCatchClause(ast, typeCheckContext);
                case TypeScript.NodeType.ReturnStatement:
                    return this.typeCheckReturnStatement(ast, typeCheckContext);
                case TypeScript.NodeType.Name:
                    return this.typeCheckNameExpression(ast, typeCheckContext);
                case TypeScript.NodeType.MemberAccessExpression:
                    return this.typeCheckMemberAccessExpression(ast, typeCheckContext);
                case TypeScript.NodeType.SwitchStatement:
                    return this.typeCheckSwitchStatement(ast, typeCheckContext);
                case TypeScript.NodeType.ExpressionStatement:
                    return this.typeCheckExpressionStatement(ast, typeCheckContext, inTypedAssignment);
                case TypeScript.NodeType.CaseClause:
                    return this.typeCheckCaseClause(ast, typeCheckContext);
                case TypeScript.NodeType.NumericLiteral:
                    return this.semanticInfoChain.numberTypeSymbol;
                case TypeScript.NodeType.StringLiteral:
                    return this.semanticInfoChain.stringTypeSymbol;
                case TypeScript.NodeType.NullLiteral:
                    return this.semanticInfoChain.nullTypeSymbol;
                case TypeScript.NodeType.TrueLiteral:
                case TypeScript.NodeType.FalseLiteral:
                    return this.semanticInfoChain.booleanTypeSymbol;
                default:
                    break;
            }
            return null;
        };
        PullTypeChecker.prototype.typeCheckScript = function (script, scriptName, compiler) {
            var unit = this.semanticInfoChain.getUnit(scriptName);
            if (unit.getTypeChecked()) {
                return;
            }
            var typeCheckContext = new PullTypeCheckContext(compiler, script, scriptName);
            this.setUnit(scriptName);
            typeCheckContext.semanticInfo = typeCheckContext.compiler.semanticInfoChain.getUnit(typeCheckContext.scriptName);
            var scriptDecl = typeCheckContext.semanticInfo.getTopLevelDecls()[0];
            typeCheckContext.pushEnclosingDecl(scriptDecl);
            PullTypeChecker.globalPullTypeCheckPhase++;
            this.typeCheckAST(script.moduleElements, typeCheckContext);
            this.validateVariableDeclarationGroups(scriptDecl, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            unit.setTypeChecked();
        };
        PullTypeChecker.prototype.typeCheckList = function (list, typeCheckContext) {
            if (!list) {
                return null;
            }
            for(var i = 0; i < list.members.length; i++) {
                this.typeCheckAST(list.members[i], typeCheckContext);
            }
        };
        PullTypeChecker.prototype.typeCheckBoundDecl = function (ast, typeCheckContext) {
            var _this = this;
            var boundDeclAST = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var typeExprSymbol = null;
            if (boundDeclAST.typeExpr) {
                typeExprSymbol = this.typeCheckAST(boundDeclAST.typeExpr, typeCheckContext);
            }
            if (boundDeclAST.init) {
                if (typeExprSymbol) {
                    this.context.pushContextualType(typeExprSymbol, this.context.inProvisionalResolution(), null);
                }
                var initTypeSymbol = this.typeCheckAST(boundDeclAST.init, typeCheckContext, !!typeExprSymbol);
                if (typeExprSymbol) {
                    this.context.popContextualType();
                }
                if (typeExprSymbol && typeExprSymbol.isContainer()) {
                    var instanceTypeSymbol = (typeExprSymbol.getType()).getInstanceSymbol();
                    if (!instanceTypeSymbol) {
                        this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type, null), enclosingDecl);
                        typeExprSymbol = null;
                    } else {
                        typeExprSymbol = instanceTypeSymbol.getType();
                    }
                }
                if (initTypeSymbol && initTypeSymbol.isContainer()) {
                    instanceTypeSymbol = (initTypeSymbol.getType()).getInstanceSymbol();
                    if (!instanceTypeSymbol) {
                        this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type__0__, [
                            initTypeSymbol.toString()
                        ]), enclosingDecl);
                        initTypeSymbol = null;
                    } else {
                        initTypeSymbol = instanceTypeSymbol.getType();
                    }
                }
                if (initTypeSymbol && typeExprSymbol) {
                    var comparisonInfo = new TypeScript.TypeComparisonInfo();
                    var isAssignable = this.resolver.sourceIsAssignableToTarget(initTypeSymbol, typeExprSymbol, this.context, comparisonInfo);
                    if (!isAssignable) {
                        var message;
                        if (comparisonInfo.message) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1__NL__2, [
                                initTypeSymbol.toString(), 
                                typeExprSymbol.toString(), 
                                comparisonInfo.message
                            ]);
                        } else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1_, [
                                initTypeSymbol.toString(), 
                                typeExprSymbol.toString()
                            ]);
                        }
                        this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, message, enclosingDecl);
                    }
                }
            }
            var prevSupressErrors = this.context.suppressErrors;
            this.context.suppressErrors = true;
            var varTypeSymbol = this.resolver.resolveAST(boundDeclAST, false, enclosingDecl, this.context).getType();
            this.context.suppressErrors = prevSupressErrors;
            var decl = this.resolver.getDeclForAST(boundDeclAST);
            var declSymbol = decl.getSymbol();
            if (declSymbol.getKind() != TypeScript.PullElementKind.Parameter && (declSymbol.getKind() != TypeScript.PullElementKind.Property || declSymbol.getContainer().isNamedTypeSymbol())) {
                this.checkTypePrivacy(declSymbol, varTypeSymbol, function (typeSymbol) {
                    return _this.variablePrivacyErrorReporter(declSymbol, typeSymbol, typeCheckContext);
                });
            }
            return varTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckFunction = function (funcDeclAST, typeCheckContext, inTypedAssignment) {
            if (typeof inTypedAssignment === "undefined") { inTypedAssignment = false; }
            if (funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.ConstructMember)) {
                return this.typeCheckConstructor(funcDeclAST, typeCheckContext, inTypedAssignment);
            } else if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.IndexerMember)) {
                return this.typeCheckIndexer(funcDeclAST, typeCheckContext, inTypedAssignment);
            } else if (funcDeclAST.isAccessor()) {
                return this.typeCheckAccessor(funcDeclAST, typeCheckContext, inTypedAssignment);
            }
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var functionSymbol = this.resolver.resolveAST(funcDeclAST, inTypedAssignment, enclosingDecl, this.context);
            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            typeCheckContext.pushEnclosingDecl(functionDecl);
            this.typeCheckAST(funcDeclAST.block, typeCheckContext);
            var hasReturn = typeCheckContext.getEnclosingDeclHasReturn();
            this.validateVariableDeclarationGroups(functionDecl, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            var functionSignature = functionDecl.getSignatureSymbol();
            var parameters = functionSignature.getParameters();
            if (parameters.length) {
                for(var i = 0; i < parameters.length; i++) {
                    this.checkForResolutionError(parameters[i].getType(), enclosingDecl);
                }
            }
            var returnType = functionSignature.getReturnType();
            this.checkForResolutionError(returnType, enclosingDecl);
            if (funcDeclAST.block && funcDeclAST.returnTypeAnnotation != null && !hasReturn) {
                var isVoidOrAny = this.resolver.isAnyOrEquivalent(returnType) || returnType == this.semanticInfoChain.voidTypeSymbol;
                if (!isVoidOrAny && !(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType === TypeScript.NodeType.ThrowStatement)) {
                    var funcName = functionDecl.getName();
                    funcName = funcName ? "'" + funcName + "'" : "expression";
                    this.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Function__0__declared_a_non_void_return_type__but_has_no_return_expression, [
                        funcName
                    ]), typeCheckContext.getEnclosingDecl());
                }
            }
            this.typeCheckFunctionOverloads(funcDeclAST, typeCheckContext);
            this.checkFunctionTypePrivacy(funcDeclAST, inTypedAssignment, typeCheckContext);
            return functionSymbol ? functionSymbol.getType() : null;
        };
        PullTypeChecker.prototype.typeCheckFunctionOverloads = function (funcDecl, typeCheckContext) {
            var functionSignatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, typeCheckContext.semanticInfo);
            if (functionSignatureInfo.allSignatures.length == 1 || functionSignatureInfo.signature.isDefinition()) {
                return;
            }
            var signature = functionSignatureInfo.signature;
            var allSignatures = functionSignatureInfo.allSignatures;
            var funcSymbol = typeCheckContext.semanticInfo.getSymbolForAST(funcDecl);
            var definitionSignature = null;
            for(var i = allSignatures.length - 1; i >= 0; i--) {
                if (allSignatures[i].isDefinition()) {
                    definitionSignature = allSignatures[i];
                    break;
                }
            }
            var message;
            for(var i = 0; i < allSignatures.length; i++) {
                if (allSignatures[i] == signature) {
                    break;
                }
                if (this.resolver.signaturesAreIdentical(allSignatures[i], signature)) {
                    if (funcDecl.isConstructor) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_constructor_overload_signature, null);
                    } else if (funcDecl.isConstructMember()) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_overload_construct_signature, null);
                    } else if (funcDecl.isCallMember()) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_overload_call_signature, null);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_overload_signature_for__0_, [
                            funcSymbol.getScopedNameEx().toString()
                        ]);
                    }
                    this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
                    break;
                }
            }
            var isConstantOverloadSignature = signature.isStringConstantOverloadSignature();
            if (isConstantOverloadSignature) {
                var resolutionContext = new TypeScript.PullTypeResolutionContext();
                var foundSubtypeSignature = false;
                for(var i = 0; i < allSignatures.length; i++) {
                    if (allSignatures[i].isDefinition() || allSignatures[i] == signature) {
                        continue;
                    }
                    if (!allSignatures[i].isResolved()) {
                        this.resolver.resolveDeclaredSymbol(allSignatures[i], typeCheckContext.getEnclosingDecl(), resolutionContext);
                    }
                    if (this.resolver.signatureIsSubtypeOfTarget(signature, allSignatures[i], resolutionContext)) {
                        foundSubtypeSignature = true;
                        break;
                    }
                }
                if (!foundSubtypeSignature) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature, null);
                    this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
                }
            } else if (definitionSignature) {
                var comparisonInfo = new TypeScript.TypeComparisonInfo();
                var resolutionContext = new TypeScript.PullTypeResolutionContext();
                if (!definitionSignature.isResolved()) {
                    this.resolver.resolveDeclaredSymbol(definitionSignature, typeCheckContext.getEnclosingDecl(), resolutionContext);
                }
                if (!this.resolver.signatureIsAssignableToTarget(definitionSignature, signature, resolutionContext, comparisonInfo)) {
                    if (comparisonInfo.message) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition__NL__0, [
                            comparisonInfo.message
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition, null);
                    }
                    this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
                }
            }
            var signatureForVisibilityCheck = definitionSignature;
            if (!definitionSignature) {
                if (allSignatures[0] == signature) {
                    return;
                }
                signatureForVisibilityCheck = allSignatures[0];
            }
            if (!funcDecl.isConstructor && !funcDecl.isConstructMember() && signature != signatureForVisibilityCheck) {
                var errorCode;
                if (signatureForVisibilityCheck.hasFlag(TypeScript.PullElementFlags.Private) != signature.hasFlag(TypeScript.PullElementFlags.Private)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_public_or_private;
                } else if (signatureForVisibilityCheck.hasFlag(TypeScript.PullElementFlags.Exported) != signature.hasFlag(TypeScript.PullElementFlags.Exported)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_exported_or_local;
                } else if (signatureForVisibilityCheck.hasFlag(TypeScript.PullElementFlags.Ambient) != signature.hasFlag(TypeScript.PullElementFlags.Ambient)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_ambient_or_non_ambient;
                } else if (signatureForVisibilityCheck.hasFlag(TypeScript.PullElementFlags.Optional) != signature.hasFlag(TypeScript.PullElementFlags.Optional)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_optional_or_required;
                }
                if (errorCode) {
                    message = TypeScript.getDiagnosticMessage(errorCode, null);
                    this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
                }
            }
        };
        PullTypeChecker.prototype.typeCheckAccessor = function (ast, typeCheckContext, inTypedAssignment) {
            if (typeof inTypedAssignment === "undefined") { inTypedAssignment = false; }
            var funcDeclAST = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var accessorSymbol = this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context);
            this.checkForResolutionError(accessorSymbol.getType(), enclosingDecl);
            var isGetter = TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor);
            var isSetter = !isGetter;
            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();
            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            typeCheckContext.pushEnclosingDecl(functionDecl);
            this.typeCheckAST(funcDeclAST.block, typeCheckContext);
            var hasReturn = typeCheckContext.getEnclosingDeclHasReturn();
            this.validateVariableDeclarationGroups(functionDecl, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            var functionSignature = functionDecl.getSignatureSymbol();
            var parameters = functionSignature.getParameters();
            var returnType = functionSignature.getReturnType();
            this.checkForResolutionError(returnType, enclosingDecl);
            var funcNameAST = funcDeclAST.name;
            if (isGetter && !hasReturn) {
                if (!(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType === TypeScript.NodeType.ThrowStatement)) {
                    this.postError(funcNameAST.minChar, funcNameAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Getters_must_return_a_value, null), typeCheckContext.getEnclosingDecl());
                }
            }
            if (getter && setter) {
                var getterDecl = getter.getDeclarations()[0];
                var setterDecl = setter.getDeclarations()[0];
                var getterIsPrivate = getterDecl.getFlags() & TypeScript.PullElementFlags.Private;
                var setterIsPrivate = setterDecl.getFlags() & TypeScript.PullElementFlags.Private;
                if (getterIsPrivate != setterIsPrivate) {
                    this.postError(funcNameAST.minChar, funcNameAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility, null), typeCheckContext.getEnclosingDecl());
                }
            }
            this.checkFunctionTypePrivacy(funcDeclAST, inTypedAssignment, typeCheckContext);
            return null;
        };
        PullTypeChecker.prototype.typeCheckConstructor = function (funcDeclAST, typeCheckContext, inTypedAssignment) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var functionSymbol = this.resolver.resolveAST(funcDeclAST, inTypedAssignment, enclosingDecl, this.context);
            this.typeCheckAST(funcDeclAST.arguments, typeCheckContext, inTypedAssignment);
            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            typeCheckContext.seenSuperConstructorCall = false;
            typeCheckContext.pushEnclosingDecl(functionDecl);
            this.typeCheckAST(funcDeclAST.block, typeCheckContext);
            this.validateVariableDeclarationGroups(functionDecl, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            var constructorSignature = functionDecl.getSignatureSymbol();
            var parameters = constructorSignature.getParameters();
            if (parameters.length) {
                for(var i = 0, n = parameters.length; i < n; i++) {
                    this.checkForResolutionError(parameters[i].getType(), enclosingDecl);
                }
            }
            this.checkForResolutionError(constructorSignature.getReturnType(), enclosingDecl);
            if (functionDecl.getSignatureSymbol() && functionDecl.getSignatureSymbol().isDefinition() && this.enclosingClassIsDerived(typeCheckContext)) {
                if (!typeCheckContext.seenSuperConstructorCall) {
                    this.postError(funcDeclAST.minChar, 11, typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Constructors_for_derived_classes_must_contain_a__super__call, null), enclosingDecl);
                } else if (this.superCallMustBeFirstStatementInConstructor(functionDecl, enclosingDecl)) {
                    var firstStatement = this.getFirstStatementFromFunctionDeclAST(funcDeclAST);
                    if (!firstStatement || !this.isSuperCallNode(firstStatement)) {
                        this.postError(funcDeclAST.minChar, 11, typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties, null), enclosingDecl);
                    }
                }
            }
            this.typeCheckFunctionOverloads(funcDeclAST, typeCheckContext);
            this.checkFunctionTypePrivacy(funcDeclAST, inTypedAssignment, typeCheckContext);
            return functionSymbol ? functionSymbol.getType() : null;
        };
        PullTypeChecker.prototype.typeCheckIndexer = function (ast, typeCheckContext, inTypedAssignment) {
            if (typeof inTypedAssignment === "undefined") { inTypedAssignment = false; }
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context);
            var funcDeclAST = ast;
            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            typeCheckContext.pushEnclosingDecl(functionDecl);
            this.typeCheckAST(funcDeclAST.block, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            var indexSignature = functionDecl.getSignatureSymbol();
            var parameters = indexSignature.getParameters();
            if (parameters.length) {
                var parameterType = null;
                for(var i = 0; i < parameters.length; i++) {
                    this.checkForResolutionError(parameters[i].getType(), enclosingDecl);
                }
            }
            this.checkForResolutionError(indexSignature.getReturnType(), enclosingDecl);
            this.checkFunctionTypePrivacy(funcDeclAST, inTypedAssignment, typeCheckContext);
            return null;
        };
        PullTypeChecker.prototype.typeCheckIfTypeMemberPropertyOkToOverride = function (typeSymbol, extendedType, typeMember, extendedTypeMember, comparisonInfo) {
            if (!typeSymbol.isClass()) {
                return true;
            }
            var typeMemberKind = typeMember.getKind();
            var extendedMemberKind = extendedTypeMember.getKind();
            if (typeMemberKind == extendedMemberKind) {
                return true;
            }
            var errorCode;
            if (typeMemberKind == TypeScript.PullElementKind.Property) {
                if (typeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function;
                }
            } else if (typeMemberKind == TypeScript.PullElementKind.Method) {
                if (extendedTypeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property;
                }
            }
            var message = TypeScript.getDiagnosticMessage(errorCode, [
                typeSymbol.toString(), 
                typeMember.getScopedNameEx().toString(), 
                extendedType.toString()
            ]);
            comparisonInfo.addMessage(message);
            return false;
        };
        PullTypeChecker.prototype.typeCheckIfTypeExtendsType = function (typeDecl, typeSymbol, extendedType, typeCheckContext) {
            var typeMembers = typeSymbol.getMembers();
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var foundError = false;
            for(var i = 0; i < typeMembers.length; i++) {
                var propName = typeMembers[i].getName();
                var extendedTypeProp = extendedType.findMember(propName);
                if (extendedTypeProp) {
                    foundError = !this.typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.resolver.sourcePropertyIsSubtypeOfTargetProperty(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, resolutionContext, comparisonInfo);
                    }
                    if (foundError) {
                        break;
                    }
                }
            }
            if (!foundError && typeSymbol.hasOwnCallSignatures()) {
                foundError = !this.resolver.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }
            if (!foundError && typeSymbol.hasOwnConstructSignatures()) {
                foundError = !this.resolver.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }
            if (!foundError && typeSymbol.hasOwnIndexSignatures()) {
                foundError = !this.resolver.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }
            if (!foundError && typeSymbol.isClass()) {
                var typeConstructorType = (typeSymbol).getConstructorMethod().getType();
                var typeConstructorTypeMembers = typeConstructorType.getMembers();
                if (typeConstructorTypeMembers.length) {
                    var extendedConstructorType = (extendedType).getConstructorMethod().getType();
                    var comparisonInfoForPropTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
                    for(var i = 0; i < typeConstructorTypeMembers.length; i++) {
                        var propName = typeConstructorTypeMembers[i].getName();
                        var extendedConstructorTypeProp = extendedConstructorType.findMember(propName);
                        if (extendedConstructorTypeProp) {
                            if (!extendedConstructorTypeProp.isResolved()) {
                                var extendedClassAst = typeCheckContext.semanticInfo.getASTForSymbol(extendedType);
                                var extendedClassDecl = typeCheckContext.semanticInfo.getDeclForAST(extendedClassAst);
                                this.resolver.resolveDeclaredSymbol(extendedConstructorTypeProp, extendedClassDecl, resolutionContext);
                            }
                            var typeConstructorTypePropType = typeConstructorTypeMembers[i].getType();
                            var extendedConstructorTypePropType = extendedConstructorTypeProp.getType();
                            if (!this.resolver.sourceIsSubtypeOfTarget(typeConstructorTypePropType, extendedConstructorTypePropType, resolutionContext, comparisonInfoForPropTypeCheck)) {
                                var propMessage;
                                if (comparisonInfoForPropTypeCheck.message) {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3, [
                                        extendedConstructorTypeProp.getScopedNameEx().toString(), 
                                        typeSymbol.toString(), 
                                        extendedType.toString(), 
                                        comparisonInfoForPropTypeCheck.message
                                    ]);
                                } else {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property__0__of_class__1__and_class__2__are_incompatible, [
                                        extendedConstructorTypeProp.getScopedNameEx().toString(), 
                                        typeSymbol.toString(), 
                                        extendedType.toString()
                                    ]);
                                }
                                comparisonInfo.addMessage(propMessage);
                                foundError = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (foundError) {
                var errorCode;
                if (typeSymbol.isClass()) {
                    errorCode = TypeScript.DiagnosticCode.Class__0__cannot_extend_class__1__NL__2;
                } else {
                    if (extendedType.isClass()) {
                        errorCode = TypeScript.DiagnosticCode.Interface__0__cannot_extend_class__1__NL__2;
                    } else {
                        errorCode = TypeScript.DiagnosticCode.Interface__0__cannot_extend_interface__1__NL__2;
                    }
                }
                var message = TypeScript.getDiagnosticMessage(errorCode, [
                    typeSymbol.getScopedName(), 
                    extendedType.getScopedName(), 
                    comparisonInfo.message
                ]);
                this.postError(typeDecl.name.minChar, typeDecl.name.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
            }
        };
        PullTypeChecker.prototype.typeCheckIfClassImplementsType = function (classDecl, classSymbol, implementedType, typeCheckContext) {
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var foundError = !this.resolver.sourceMembersAreSubtypeOfTargetMembers(classSymbol, implementedType, resolutionContext, comparisonInfo);
            if (!foundError) {
                foundError = !this.resolver.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                if (!foundError) {
                    foundError = !this.resolver.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.resolver.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    }
                }
            }
            if (foundError) {
                var errorCode = implementedType.isClass() ? TypeScript.DiagnosticCode.Class__0__declares_class__1__but_does_not_implement_it__NL__2 : TypeScript.DiagnosticCode.Class__0__declares_interface__1__but_does_not_implement_it__NL__2;
                var message = TypeScript.getDiagnosticMessage(errorCode, [
                    classSymbol.getScopedName(), 
                    implementedType.getScopedName(), 
                    comparisonInfo.message
                ]);
                this.postError(classDecl.name.minChar, classDecl.name.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
            }
        };
        PullTypeChecker.prototype.typeCheckBase = function (typeDeclAst, typeSymbol, baseDeclAST, isExtendedType, typeCheckContext) {
            var _this = this;
            var typeDecl = typeCheckContext.semanticInfo.getDeclForAST(typeDeclAst);
            var contextForBaseTypeResolution = new TypeScript.PullTypeResolutionContext();
            var baseType = this.resolver.resolveTypeReference(new TypeScript.TypeReference(baseDeclAST, 0), typeDecl, contextForBaseTypeResolution);
            var typeDeclIsClass = typeSymbol.isClass();
            var message;
            if (!typeSymbol.isValidBaseKind(baseType, isExtendedType)) {
                if (baseType.isError()) {
                    message = (baseType).getDiagnostic().message();
                } else if (isExtendedType) {
                    if (typeDeclIsClass) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.A_class_may_only_extend_another_class, null);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.An_interface_may_only_extend_another_class_or_interface, null);
                    }
                } else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.A_class_may_only_implement_another_class_or_interface, null);
                }
                this.postError(baseDeclAST.minChar, baseDeclAST.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
                return;
            }
            if (baseType.hasBase(typeSymbol)) {
                message = TypeScript.getDiagnosticMessage(typeDeclIsClass ? TypeScript.DiagnosticCode.Class__0__is_recursively_referenced_as_a_base_type_of_itself : TypeScript.DiagnosticCode.Interface__0__is_recursively_referenced_as_a_base_type_of_itself, [
                    typeSymbol.getScopedName()
                ]);
                this.postError(typeDeclAst.name.minChar, typeDeclAst.name.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
                return;
            }
            if (isExtendedType) {
                this.typeCheckIfTypeExtendsType(typeDeclAst, typeSymbol, baseType, typeCheckContext);
            } else {
                this.typeCheckIfClassImplementsType(typeDeclAst, typeSymbol, baseType, typeCheckContext);
            }
            this.checkTypePrivacy(typeSymbol, baseType, function (errorTypeSymbol) {
                return _this.baseListPrivacyErrorReporter(typeDeclAst, typeSymbol, baseDeclAST, isExtendedType, errorTypeSymbol, typeCheckContext);
            });
        };
        PullTypeChecker.prototype.typeCheckBases = function (typeDeclAst, typeSymbol, typeCheckContext) {
            if (!typeDeclAst.extendsList && !typeDeclAst.implementsList) {
                return;
            }
            for(var i = 0; i < typeDeclAst.extendsList.members.length; i++) {
                this.typeCheckBase(typeDeclAst, typeSymbol, typeDeclAst.extendsList.members[i], true, typeCheckContext);
            }
            if (typeSymbol.isClass()) {
                for(var i = 0; i < typeDeclAst.implementsList.members.length; i++) {
                    this.typeCheckBase(typeDeclAst, typeSymbol, typeDeclAst.implementsList.members[i], false, typeCheckContext);
                }
            } else if (typeDeclAst.implementsList) {
                var message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.An_interface_may_not_implement_another_type, null);
                this.postError(typeDeclAst.implementsList.minChar, typeDeclAst.implementsList.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
            }
        };
        PullTypeChecker.prototype.typeCheckClass = function (ast, typeCheckContext) {
            var classAST = ast;
            var classSymbol = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.checkForResolutionError(classSymbol, typeCheckContext.getEnclosingDecl());
            var classDecl = typeCheckContext.semanticInfo.getDeclForAST(classAST);
            typeCheckContext.pushEnclosingDecl(classDecl);
            this.typeCheckAST(classAST.members, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            this.typeCheckBases(classAST, classSymbol, typeCheckContext);
            return classSymbol;
        };
        PullTypeChecker.prototype.typeCheckInterface = function (ast, typeCheckContext) {
            var interfaceAST = ast;
            var interfaceType = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.checkForResolutionError(interfaceType, typeCheckContext.getEnclosingDecl());
            var interfaceDecl = typeCheckContext.semanticInfo.getDeclForAST(interfaceAST);
            typeCheckContext.pushEnclosingDecl(interfaceDecl);
            this.typeCheckAST(interfaceAST.members, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            this.typeCheckBases(ast, interfaceType, typeCheckContext);
            return interfaceType;
        };
        PullTypeChecker.prototype.typeCheckModule = function (ast, typeCheckContext) {
            var moduleDeclAST = ast;
            var moduleType = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context);
            this.checkForResolutionError(moduleType, typeCheckContext.getEnclosingDecl());
            var moduleDecl = typeCheckContext.semanticInfo.getDeclForAST(moduleDeclAST);
            typeCheckContext.pushEnclosingDecl(moduleDecl);
            this.typeCheckAST(moduleDeclAST.members, typeCheckContext);
            this.validateVariableDeclarationGroups(moduleDecl, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            return moduleType;
        };
        PullTypeChecker.prototype.checkAssignability = function (ast, source, target, typeCheckContext) {
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var isAssignable = this.resolver.sourceIsAssignableToTarget(source, target, this.context, comparisonInfo);
            if (!isAssignable) {
                var message;
                if (comparisonInfo.message) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1__NL__2, [
                        source.toString(), 
                        target.toString(), 
                        comparisonInfo.message
                    ]);
                } else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1_, [
                        source.toString(), 
                        target.toString()
                    ]);
                }
                var enclosingDecl = typeCheckContext.getEnclosingDecl();
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, message, enclosingDecl);
            }
        };
        PullTypeChecker.prototype.isValidLHS = function (ast, expressionSymbol, isEnumInitializer) {
            var expressionTypeSymbol = expressionSymbol.getType();
            return isEnumInitializer || ast.nodeType == TypeScript.NodeType.ElementAccessExpression || this.resolver.isAnyOrEquivalent(expressionTypeSymbol) || ((!expressionSymbol.isType() || expressionTypeSymbol.isArray()) && (expressionSymbol.getKind() & TypeScript.PullElementKind.SomeLHS) != 0);
        };
        PullTypeChecker.prototype.typeCheckAssignment = function (binaryExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            this.typeCheckAST(binaryExpression.operand1, typeCheckContext, false);
            var leftExpr = this.resolver.resolveAST(binaryExpression.operand1, false, typeCheckContext.getEnclosingDecl(), this.context);
            var leftType = leftExpr.getType();
            this.checkForResolutionError(leftType, enclosingDecl);
            leftType = this.resolver.widenType(leftExpr.getType());
            this.context.pushContextualType(leftType, this.context.inProvisionalResolution(), null);
            var rightType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand2, typeCheckContext, true));
            this.context.popContextualType();
            if (!this.isValidLHS(binaryExpression.operand1, leftExpr, TypeScript.hasFlag(binaryExpression.getFlags(), TypeScript.ASTFlags.EnumInitializer))) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null), enclosingDecl);
            }
            this.checkAssignability(binaryExpression.operand1, rightType, leftType, typeCheckContext);
            return leftType;
        };
        PullTypeChecker.prototype.typeCheckGenericType = function (ast, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var genericType = this.resolver.resolveAST(ast, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(genericType, enclosingDecl);
            return genericType;
        };
        PullTypeChecker.prototype.typeCheckObjectLiteral = function (ast, typeCheckContext, inTypedAssignment) {
            if (typeof inTypedAssignment === "undefined") { inTypedAssignment = false; }
            var objectLitAST = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var objectLitType = this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context).getType();
            var memberDecls = objectLitAST.operand;
            var contextualType = this.context.getContextualType();
            var memberType;
            if (memberDecls) {
                var binex;
                var text;
                var member = null;
                for(var i = 0; i < memberDecls.members.length; i++) {
                    binex = memberDecls.members[i];
                    if (contextualType) {
                        if (binex.operand1.nodeType == TypeScript.NodeType.Name) {
                            text = (binex.operand1).text;
                        } else if (binex.operand1.nodeType == TypeScript.NodeType.StringLiteral) {
                            text = (binex.operand1).text;
                            text = text.substring(1, text.length - 1);
                        }
                        member = contextualType.findMember(text);
                        if (member) {
                            this.context.pushContextualType(member.getType(), this.context.inProvisionalResolution(), null);
                        }
                    }
                    this.typeCheckAST(binex.operand2, typeCheckContext, member != null);
                    if (member) {
                        this.context.popContextualType();
                        member = null;
                    }
                }
            }
            this.checkForResolutionError(objectLitType, enclosingDecl);
            return objectLitType;
        };
        PullTypeChecker.prototype.typeCheckArrayLiteral = function (ast, typeCheckContext, inTypedAssignment) {
            if (typeof inTypedAssignment === "undefined") { inTypedAssignment = false; }
            var arrayLiteralAST = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context).getType();
            var memberASTs = arrayLiteralAST.operand;
            var contextualType = this.context.getContextualType();
            var contextualMemberType = null;
            if (contextualType && contextualType.isArray()) {
                contextualMemberType = contextualType.getElementType();
            }
            if (memberASTs && memberASTs.members && memberASTs.members.length) {
                var elementTypes = [];
                if (contextualMemberType) {
                    this.context.pushContextualType(contextualMemberType, this.context.inProvisionalResolution(), null);
                }
                for(var i = 0; i < memberASTs.members.length; i++) {
                    elementTypes[elementTypes.length] = this.typeCheckAST(memberASTs.members[i], typeCheckContext, false);
                }
                if (contextualMemberType) {
                    this.context.popContextualType();
                    var collection = {
                        getLength: function () {
                            return elementTypes.length;
                        },
                        setTypeAtIndex: function (index, type) {
                            elementTypes[index] = type;
                        },
                        getTypeAtIndex: function (index) {
                            return elementTypes[index];
                        }
                    };
                    var comparisonInfo = new TypeScript.TypeComparisonInfo();
                    var elementType = this.resolver.findBestCommonType(elementTypes[0], contextualMemberType, collection, false, this.context, comparisonInfo);
                    if (!elementType) {
                        this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_of_array_literal_cannot_be_determined__Best_common_type_could_not_be_found_for_array_elements, null), enclosingDecl);
                    }
                }
            }
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };
        PullTypeChecker.prototype.enclosingClassIsDerived = function (typeCheckContext) {
            var enclosingClass = typeCheckContext.getEnclosingDecl(TypeScript.PullElementKind.Class);
            if (enclosingClass) {
                var classSymbol = enclosingClass.getSymbol();
                if (classSymbol.getExtendedTypes().length > 0) {
                    return true;
                }
            }
            return false;
        };
        PullTypeChecker.prototype.isSuperCallNode = function (node) {
            if (node && node.nodeType === TypeScript.NodeType.ExpressionStatement) {
                var expressionStatement = node;
                if (expressionStatement.expression && expressionStatement.expression.nodeType === TypeScript.NodeType.InvocationExpression) {
                    var callExpression = expressionStatement.expression;
                    if (callExpression.target && callExpression.target.nodeType === TypeScript.NodeType.SuperExpression) {
                        return true;
                    }
                }
            }
            return false;
        };
        PullTypeChecker.prototype.getFirstStatementFromFunctionDeclAST = function (funcDeclAST) {
            if (funcDeclAST.block && funcDeclAST.block.statements && funcDeclAST.block.statements.members) {
                return TypeScript.hasFlag(funcDeclAST.block.getFlags(), TypeScript.ASTFlags.StrictMode) ? funcDeclAST.block.statements.members[1] : funcDeclAST.block.statements.members[0];
            }
            return null;
        };
        PullTypeChecker.prototype.superCallMustBeFirstStatementInConstructor = function (enclosingConstructor, enclosingClass) {
            if (enclosingConstructor && enclosingClass) {
                var classSymbol = enclosingClass.getSymbol();
                if (classSymbol.getExtendedTypes().length === 0) {
                    return false;
                }
                var classMembers = classSymbol.getMembers();
                for(var i = 0, n1 = classMembers.length; i < n1; i++) {
                    var member = classMembers[i];
                    if (member.getKind() === TypeScript.PullElementKind.Property) {
                        var declarations = member.getDeclarations();
                        for(var j = 0, n2 = declarations.length; j < n2; j++) {
                            var declaration = declarations[j];
                            var ast = this.semanticInfoChain.getASTForDecl(declaration);
                            if (ast.nodeType === TypeScript.NodeType.Parameter) {
                                return true;
                            }
                            if (ast.nodeType === TypeScript.NodeType.VariableDeclarator) {
                                var variableDeclarator = ast;
                                if (variableDeclarator.init) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        PullTypeChecker.prototype.checkForThisCaptureInArrowFunction = function (thisExpressionAST, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var declPath = typeCheckContext.enclosingDeclStack;
            if (declPath.length) {
                var inFatArrow = false;
                for(var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.getKind();
                    var declFlags = decl.getFlags();
                    if (declKind === TypeScript.PullElementKind.FunctionExpression && TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.FatArrow)) {
                        inFatArrow = true;
                        continue;
                    }
                    if (inFatArrow) {
                        if (declKind === TypeScript.PullElementKind.Function || declKind === TypeScript.PullElementKind.Method || declKind === TypeScript.PullElementKind.ConstructorMethod || declKind === TypeScript.PullElementKind.GetAccessor || declKind === TypeScript.PullElementKind.SetAccessor || declKind === TypeScript.PullElementKind.FunctionExpression || declKind === TypeScript.PullElementKind.Class || declKind === TypeScript.PullElementKind.Container || declKind === TypeScript.PullElementKind.DynamicModule || declKind === TypeScript.PullElementKind.Script) {
                            decl.setFlags(decl.getFlags() | TypeScript.PullElementFlags.MustCaptureThis);
                            break;
                        }
                    }
                }
            }
        };
        PullTypeChecker.prototype.typeCheckThisExpression = function (thisExpressionAST, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var enclosingNonLambdaDecl = typeCheckContext.getEnclosingNonLambdaDecl();
            if (typeCheckContext.inSuperConstructorCall && this.superCallMustBeFirstStatementInConstructor(typeCheckContext.getEnclosingDecl(TypeScript.PullElementKind.ConstructorMethod), typeCheckContext.getEnclosingDecl(TypeScript.PullElementKind.Class))) {
                this.postError(thisExpressionAST.minChar, thisExpressionAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._this__may_not_be_referenced_in_current_location, null), enclosingDecl);
            } else if (enclosingNonLambdaDecl) {
                if (enclosingNonLambdaDecl.getKind() === TypeScript.PullElementKind.Class) {
                    this.postError(thisExpressionAST.minChar, thisExpressionAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._this__may_not_be_referenced_in_initializers_in_a_class_body, null), enclosingDecl);
                } else if (enclosingNonLambdaDecl.getKind() === TypeScript.PullElementKind.Container || enclosingNonLambdaDecl.getKind() === TypeScript.PullElementKind.DynamicModule) {
                    this.postError(thisExpressionAST.minChar, thisExpressionAST.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._this__cannot_be_referenced_within_module_bodies, null), enclosingDecl);
                }
            }
            this.checkForThisCaptureInArrowFunction(thisExpressionAST, typeCheckContext);
            var type = this.resolver.resolveAST(thisExpressionAST, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };
        PullTypeChecker.prototype.typeCheckSuper = function (ast, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var nonLambdaEnclosingDecl = typeCheckContext.getEnclosingNonLambdaDecl();
            var nonLambdaEnclosingDeclKind = nonLambdaEnclosingDecl.getKind();
            var inSuperConstructorTarget = typeCheckContext.inSuperConstructorTarget;
            var type = this.resolver.resolveAST(ast, false, enclosingDecl, this.context).getType();
            if (inSuperConstructorTarget && enclosingDecl.getKind() !== TypeScript.PullElementKind.ConstructorMethod) {
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors, null), enclosingDecl);
            } else if ((nonLambdaEnclosingDeclKind !== TypeScript.PullElementKind.Method && nonLambdaEnclosingDeclKind !== TypeScript.PullElementKind.GetAccessor && nonLambdaEnclosingDeclKind !== TypeScript.PullElementKind.SetAccessor && nonLambdaEnclosingDeclKind !== TypeScript.PullElementKind.ConstructorMethod) || ((nonLambdaEnclosingDecl.getFlags() & TypeScript.PullElementFlags.Static) !== 0)) {
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class, null), enclosingDecl);
            } else if (!this.enclosingClassIsDerived(typeCheckContext)) {
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._super__may_not_be_referenced_in_non_derived_classes, null), enclosingDecl);
            }
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };
        PullTypeChecker.prototype.typeCheckCallExpression = function (callExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var inSuperConstructorCall = (callExpression.target.nodeType === TypeScript.NodeType.SuperExpression);
            var callResolutionData = new TypeScript.PullAdditionalCallResolutionData();
            var resultType = this.resolver.resolveCallExpression(callExpression, false, enclosingDecl, this.context, callResolutionData).getType();
            this.checkForResolutionError(resultType, enclosingDecl);
            if (!resultType.isError()) {
                var savedInSuperConstructorTarget = typeCheckContext.inSuperConstructorTarget;
                if (inSuperConstructorCall) {
                    typeCheckContext.inSuperConstructorTarget = true;
                }
                this.typeCheckAST(callExpression.target, typeCheckContext);
                typeCheckContext.inSuperConstructorTarget = savedInSuperConstructorTarget;
            }
            if (inSuperConstructorCall && enclosingDecl.getKind() === TypeScript.PullElementKind.ConstructorMethod) {
                typeCheckContext.seenSuperConstructorCall = true;
            }
            var savedInSuperConstructorCall = typeCheckContext.inSuperConstructorCall;
            if (inSuperConstructorCall) {
                typeCheckContext.inSuperConstructorCall = true;
            }
            var contextTypes = callResolutionData.actualParametersContextTypeSymbols;
            if (callExpression.arguments) {
                var argumentASTs = callExpression.arguments.members;
                for(var i = 0, n = argumentASTs.length; i < n; i++) {
                    var argumentAST = argumentASTs[i];
                    if (contextTypes && contextTypes[i]) {
                        this.context.pushContextualType(contextTypes[i], this.context.inProvisionalResolution(), null);
                    }
                    this.typeCheckAST(argumentAST, typeCheckContext);
                    if (contextTypes && contextTypes[i]) {
                        this.context.popContextualType();
                    }
                }
            }
            typeCheckContext.inSuperConstructorCall = savedInSuperConstructorCall;
            return resultType;
        };
        PullTypeChecker.prototype.typeCheckObjectCreationExpression = function (callExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var callResolutionData = new TypeScript.PullAdditionalCallResolutionData();
            var resultType = this.resolver.resolveNewExpression(callExpression, false, enclosingDecl, this.context, callResolutionData).getType();
            this.checkForResolutionError(resultType, enclosingDecl);
            this.typeCheckAST(callExpression.typeArguments, typeCheckContext);
            var contextTypes = callResolutionData.actualParametersContextTypeSymbols;
            if (callExpression.arguments) {
                var argumentASTs = callExpression.arguments.members;
                for(var i = 0, n = argumentASTs.length; i < n; i++) {
                    var argumentAST = argumentASTs[i];
                    if (contextTypes && contextTypes[i]) {
                        this.context.pushContextualType(contextTypes[i], this.context.inProvisionalResolution(), null);
                    }
                    this.typeCheckAST(argumentAST, typeCheckContext);
                    if (contextTypes && contextTypes[i]) {
                        this.context.popContextualType();
                    }
                }
            }
            return resultType;
        };
        PullTypeChecker.prototype.typeCheckTypeAssertion = function (ast, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var returnType = this.resolver.resolveAST(ast, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(returnType, enclosingDecl);
            this.context.pushContextualType(returnType, this.context.inProvisionalResolution(), null);
            var exprType = this.typeCheckAST((ast).operand, typeCheckContext, true);
            this.context.popContextualType();
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var isAssignable = this.resolver.sourceIsAssignableToTarget(returnType, exprType, this.context, comparisonInfo) || this.resolver.sourceIsAssignableToTarget(exprType, returnType, this.context, comparisonInfo);
            if (!isAssignable) {
                var message;
                if (comparisonInfo.message) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1__NL__2, [
                        exprType.toString(), 
                        returnType.toString(), 
                        comparisonInfo.message
                    ]);
                } else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1_, [
                        exprType.toString(), 
                        returnType.toString()
                    ]);
                }
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, message, typeCheckContext.getEnclosingDecl());
            }
            return returnType;
        };
        PullTypeChecker.prototype.typeCheckLogicalOperation = function (ast, typeCheckContext) {
            var binex = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            var leftType = this.typeCheckAST(binex.operand1, typeCheckContext);
            var rightType = this.typeCheckAST(binex.operand2, typeCheckContext);
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            if (!this.resolver.sourceIsAssignableToTarget(leftType, rightType, this.context, comparisonInfo) && !this.resolver.sourceIsAssignableToTarget(rightType, leftType, this.context, comparisonInfo)) {
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Operator__0__cannot_be_applied_to_types__1__and__2_, [
                    binex.printLabel(), 
                    leftType.toString(), 
                    rightType.toString()
                ]), enclosingDecl);
            }
            return type;
        };
        PullTypeChecker.prototype.typeCheckLogicalAndOrExpression = function (ast, typeCheckContext) {
            var binex = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(ast, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            this.typeCheckAST(binex.operand1, typeCheckContext);
            this.typeCheckAST(binex.operand2, typeCheckContext);
            return type;
        };
        PullTypeChecker.prototype.typeCheckCommaExpression = function (ast, typeCheckContext) {
            var binex = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(ast, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            this.typeCheckAST(binex.operand1, typeCheckContext);
            this.typeCheckAST(binex.operand2, typeCheckContext);
            return type;
        };
        PullTypeChecker.prototype.typeCheckBinaryAdditionOperation = function (binaryExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(binaryExpression, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            var lhsType = this.typeCheckAST(binaryExpression.operand1, typeCheckContext);
            var rhsType = this.typeCheckAST(binaryExpression.operand2, typeCheckContext);
            if (lhsType.getKind() == TypeScript.PullElementKind.Enum) {
                lhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (lhsType == this.semanticInfoChain.nullTypeSymbol || lhsType == this.semanticInfoChain.undefinedTypeSymbol) {
                if (rhsType != this.semanticInfoChain.nullTypeSymbol && rhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    lhsType = rhsType;
                } else {
                    lhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (rhsType.getKind() == TypeScript.PullElementKind.Enum) {
                rhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (rhsType == this.semanticInfoChain.nullTypeSymbol || rhsType == this.semanticInfoChain.undefinedTypeSymbol) {
                if (lhsType != this.semanticInfoChain.nullTypeSymbol && lhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    rhsType = lhsType;
                } else {
                    rhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            var exprType = null;
            if (lhsType == this.semanticInfoChain.stringTypeSymbol || rhsType == this.semanticInfoChain.stringTypeSymbol) {
                exprType = this.semanticInfoChain.stringTypeSymbol;
            } else if (this.resolver.isAnyOrEquivalent(lhsType) || this.resolver.isAnyOrEquivalent(rhsType)) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            } else if (rhsType == this.semanticInfoChain.numberTypeSymbol && lhsType == this.semanticInfoChain.numberTypeSymbol) {
                exprType = this.semanticInfoChain.numberTypeSymbol;
            }
            if (exprType) {
                if (binaryExpression.nodeType === TypeScript.NodeType.AddAssignmentExpression) {
                    var lhsExpression = this.resolver.resolveAST(binaryExpression.operand1, false, typeCheckContext.getEnclosingDecl(), this.context);
                    if (!this.isValidLHS(binaryExpression.operand1, lhsExpression, TypeScript.hasFlag(binaryExpression.getFlags(), TypeScript.ASTFlags.EnumInitializer))) {
                        this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null), enclosingDecl);
                    }
                    this.checkAssignability(binaryExpression.operand1, exprType, lhsType, typeCheckContext);
                }
            } else {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid__addition__expression___types_do_not_agree, null), typeCheckContext.getEnclosingDecl());
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }
            return exprType;
        };
        PullTypeChecker.prototype.typeCheckBinaryArithmeticOperation = function (binaryExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(binaryExpression, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            var lhsType = this.typeCheckAST(binaryExpression.operand1, typeCheckContext);
            var rhsType = this.typeCheckAST(binaryExpression.operand2, typeCheckContext);
            var lhsIsFit = this.resolver.isAnyOrEquivalent(lhsType) || lhsType == this.semanticInfoChain.numberTypeSymbol || lhsType.getKind() == TypeScript.PullElementKind.Enum;
            var rhsIsFit = this.resolver.isAnyOrEquivalent(rhsType) || rhsType == this.semanticInfoChain.numberTypeSymbol || rhsType.getKind() == TypeScript.PullElementKind.Enum;
            if (!rhsIsFit) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type, null), typeCheckContext.getEnclosingDecl());
            }
            if (!lhsIsFit) {
                this.postError(binaryExpression.operand2.minChar, binaryExpression.operand2.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type, null), typeCheckContext.getEnclosingDecl());
            }
            if (rhsIsFit && lhsIsFit) {
                switch(binaryExpression.nodeType) {
                    case TypeScript.NodeType.LeftShiftAssignmentExpression:
                    case TypeScript.NodeType.SignedRightShiftAssignmentExpression:
                    case TypeScript.NodeType.UnsignedRightShiftAssignmentExpression:
                    case TypeScript.NodeType.SubtractAssignmentExpression:
                    case TypeScript.NodeType.MultiplyAssignmentExpression:
                    case TypeScript.NodeType.DivideAssignmentExpression:
                    case TypeScript.NodeType.ModuloAssignmentExpression:
                    case TypeScript.NodeType.OrAssignmentExpression:
                    case TypeScript.NodeType.AndAssignmentExpression:
                    case TypeScript.NodeType.ExclusiveOrAssignmentExpression:
                        var lhsExpression = this.resolver.resolveAST(binaryExpression.operand1, false, typeCheckContext.getEnclosingDecl(), this.context);
                        if (!this.isValidLHS(binaryExpression.operand1, lhsExpression, TypeScript.hasFlag(binaryExpression.getFlags(), TypeScript.ASTFlags.EnumInitializer))) {
                            this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null), enclosingDecl);
                        }
                        this.checkAssignability(binaryExpression.operand1, rhsType, lhsType, typeCheckContext);
                        break;
                }
            }
            return this.semanticInfoChain.numberTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckLogicalNotExpression = function (unaryExpression, typeCheckContext, inTypedAssignment) {
            this.typeCheckAST(unaryExpression.operand, typeCheckContext, inTypedAssignment);
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckUnaryArithmeticOperation = function (unaryExpression, typeCheckContext, inTypedAssignment) {
            var operandType = this.typeCheckAST(unaryExpression.operand, typeCheckContext, inTypedAssignment);
            switch(unaryExpression.nodeType) {
                case TypeScript.NodeType.PlusExpression:
                case TypeScript.NodeType.NegateExpression:
                case TypeScript.NodeType.BitwiseNotExpression:
                    return this.semanticInfoChain.numberTypeSymbol;
            }
            var operandIsFit = this.resolver.isAnyOrEquivalent(operandType) || operandType == this.semanticInfoChain.numberTypeSymbol || operandType.getKind() == TypeScript.PullElementKind.Enum;
            if (!operandIsFit) {
                this.postError(unaryExpression.operand.minChar, unaryExpression.operand.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type, null), typeCheckContext.getEnclosingDecl());
            }
            switch(unaryExpression.nodeType) {
                case TypeScript.NodeType.PostIncrementExpression:
                case TypeScript.NodeType.PreIncrementExpression:
                case TypeScript.NodeType.PostDecrementExpression:
                case TypeScript.NodeType.PreDecrementExpression:
                    var expression = this.resolver.resolveAST(unaryExpression.operand, false, typeCheckContext.getEnclosingDecl(), this.context);
                    if (!this.isValidLHS(unaryExpression.operand, expression, false)) {
                        this.postError(unaryExpression.operand.minChar, unaryExpression.operand.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer, null), typeCheckContext.getEnclosingDecl());
                    }
                    break;
            }
            return operandType;
        };
        PullTypeChecker.prototype.typeCheckElementAccessExpression = function (binaryExpression, typeCheckContext) {
            this.typeCheckAST(binaryExpression.operand1, typeCheckContext);
            this.typeCheckAST(binaryExpression.operand2, typeCheckContext);
            var type = this.resolver.resolveAST(binaryExpression, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.checkForResolutionError(type, typeCheckContext.getEnclosingDecl());
            return type;
        };
        PullTypeChecker.prototype.typeCheckTypeOf = function (ast, typeCheckContext) {
            this.typeCheckAST((ast).operand, typeCheckContext);
            return this.semanticInfoChain.stringTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckTypeReference = function (ast, typeCheckContext) {
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.checkForResolutionError(type, typeCheckContext.getEnclosingDecl());
            return type;
        };
        PullTypeChecker.prototype.typeCheckConditionalExpression = function (conditionalExpression, typeCheckContext) {
            this.typeCheckAST(conditionalExpression.operand1, typeCheckContext);
            this.typeCheckAST(conditionalExpression.operand2, typeCheckContext);
            this.typeCheckAST(conditionalExpression.operand3, typeCheckContext);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(conditionalExpression, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };
        PullTypeChecker.prototype.typeCheckThrowStatement = function (throwStatement, typeCheckContext) {
            this.typeCheckAST(throwStatement.expression, typeCheckContext);
            var type = this.resolver.resolveAST(throwStatement.expression, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.checkForResolutionError(type, typeCheckContext.getEnclosingDecl());
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckDeleteExpression = function (unaryExpression, typeCheckContext) {
            this.typeCheckAST(unaryExpression.operand, typeCheckContext);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(unaryExpression, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };
        PullTypeChecker.prototype.typeCheckVoidExpression = function (unaryExpression, typeCheckContext) {
            this.typeCheckAST(unaryExpression.operand, typeCheckContext);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveAST(unaryExpression, false, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };
        PullTypeChecker.prototype.typeCheckRegExpExpression = function (ast, typeCheckContext) {
            var type = this.resolver.resolveStatementOrExpression(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.checkForResolutionError(type, typeCheckContext.getEnclosingDecl());
            return type;
        };
        PullTypeChecker.prototype.typeCheckForStatement = function (forStatement, typeCheckContext) {
            this.typeCheckAST(forStatement.init, typeCheckContext);
            this.typeCheckAST(forStatement.cond, typeCheckContext);
            this.typeCheckAST(forStatement.body, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckForInStatement = function (ast, typeCheckContext) {
            var forInStatement = ast;
            var rhsType = this.resolver.widenType(this.typeCheckAST(forInStatement.obj, typeCheckContext));
            var lval = forInStatement.lval;
            if (lval.nodeType === TypeScript.NodeType.VariableDeclaration) {
                var declaration = forInStatement.lval;
                var varDecl = declaration.declarators.members[0];
                if (varDecl.typeExpr) {
                    this.postError(lval.minChar, lval.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation, null), typeCheckContext.getEnclosingDecl());
                }
            }
            var varSym = this.resolver.resolveAST(forInStatement.lval, false, typeCheckContext.getEnclosingDecl(), this.context);
            this.checkForResolutionError(varSym.getType(), typeCheckContext.getEnclosingDecl());
            var isStringOrAny = varSym.getType() == this.semanticInfoChain.stringTypeSymbol || this.resolver.isAnyOrEquivalent(varSym.getType());
            var isValidRHS = rhsType && (this.resolver.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());
            if (!isStringOrAny) {
                this.postError(lval.minChar, lval.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_, null), typeCheckContext.getEnclosingDecl());
            }
            if (!isValidRHS) {
                this.postError(forInStatement.obj.minChar, forInStatement.obj.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter, null), typeCheckContext.getEnclosingDecl());
            }
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckInExpression = function (binaryExpression, typeCheckContext) {
            var lhsType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand1, typeCheckContext));
            var rhsType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand2, typeCheckContext));
            var isStringOrAny = lhsType.getType() == this.semanticInfoChain.stringTypeSymbol || this.resolver.isAnyOrEquivalent(lhsType.getType());
            var isValidRHS = rhsType && (this.resolver.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());
            if (!isStringOrAny) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_, null), typeCheckContext.getEnclosingDecl());
            }
            if (!isValidRHS) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter, null), typeCheckContext.getEnclosingDecl());
            }
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckInstanceOfExpression = function (binaryExpression, typeCheckContext) {
            var lhsType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand1, typeCheckContext));
            var rhsType = this.typeCheckAST(binaryExpression.operand2, typeCheckContext);
            var isValidLHS = lhsType && (this.resolver.isAnyOrEquivalent(lhsType) || !lhsType.isPrimitive());
            var isValidRHS = rhsType && (this.resolver.isAnyOrEquivalent(rhsType) || rhsType.isClass() || this.resolver.typeIsSubtypeOfFunction(rhsType, this.context));
            if (!isValidLHS) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter, null), typeCheckContext.getEnclosingDecl());
            }
            if (!isValidRHS) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type, null), typeCheckContext.getEnclosingDecl());
            }
            return this.semanticInfoChain.booleanTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckParenthesizedExpression = function (parenthesizedExpression, typeCheckContext) {
            return this.typeCheckAST(parenthesizedExpression.expression, typeCheckContext);
        };
        PullTypeChecker.prototype.typeCheckWhileStatement = function (whileStatement, typeCheckContext) {
            this.typeCheckAST(whileStatement.cond, typeCheckContext);
            this.typeCheckAST(whileStatement.body, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckDoStatement = function (doStatement, typeCheckContext) {
            this.typeCheckAST(doStatement.cond, typeCheckContext);
            this.typeCheckAST(doStatement.body, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckIfStatement = function (ifStatement, typeCheckContext) {
            this.typeCheckAST(ifStatement.cond, typeCheckContext);
            this.typeCheckAST(ifStatement.thenBod, typeCheckContext);
            this.typeCheckAST(ifStatement.elseBod, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckBlock = function (block, typeCheckContext) {
            this.typeCheckAST(block.statements, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckVariableDeclaration = function (variableDeclaration, typeCheckContext) {
            this.typeCheckAST(variableDeclaration.declarators, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckVariableStatement = function (variableStatement, typeCheckContext) {
            this.typeCheckAST(variableStatement.declaration, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckWithStatement = function (withStatement, typeCheckContext) {
            this.postError(withStatement.expr.minChar, withStatement.expr.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.All_symbols_within_a__with__block_will_be_resolved_to__any__, null), typeCheckContext.getEnclosingDecl());
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckTryStatement = function (tryStatement, typeCheckContext) {
            this.typeCheckAST(tryStatement.tryBody, typeCheckContext);
            this.typeCheckAST(tryStatement.catchClause, typeCheckContext);
            this.typeCheckAST(tryStatement.finallyBody, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckCatchClause = function (catchClause, typeCheckContext) {
            var catchDecl = this.resolver.getDeclForAST(catchClause);
            typeCheckContext.pushEnclosingDecl(catchDecl);
            this.typeCheckAST(catchClause.body, typeCheckContext);
            typeCheckContext.popEnclosingDecl();
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckReturnStatement = function (returnAST, typeCheckContext) {
            typeCheckContext.setEnclosingDeclHasReturn();
            var returnExpr = returnAST.returnExpression;
            var returnType = this.typeCheckAST(returnExpr, typeCheckContext);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            if (enclosingDecl.getKind() == TypeScript.PullElementKind.SetAccessor && returnExpr) {
                this.postError(returnExpr.minChar, returnExpr.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Setters_may_not_return_a_value, null), typeCheckContext.getEnclosingDecl());
            }
            if (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction) {
                var signatureSymbol = enclosingDecl.getSignatureSymbol();
                var sigReturnType = signatureSymbol.getReturnType();
                if (returnType && sigReturnType) {
                    var comparisonInfo = new TypeScript.TypeComparisonInfo();
                    var upperBound = null;
                    if (returnType.isTypeParameter()) {
                        upperBound = (returnType).getConstraint();
                        if (upperBound) {
                            returnType = upperBound;
                        }
                    }
                    if (sigReturnType.isTypeParameter()) {
                        upperBound = (sigReturnType).getConstraint();
                        if (upperBound) {
                            sigReturnType = upperBound;
                        }
                    }
                    if (!returnType.isResolved()) {
                        this.resolver.resolveDeclaredSymbol(returnType, enclosingDecl, this.context);
                    }
                    if (!sigReturnType.isResolved()) {
                        this.resolver.resolveDeclaredSymbol(sigReturnType, enclosingDecl, this.context);
                    }
                    var isAssignable = this.resolver.sourceIsAssignableToTarget(returnType, sigReturnType, this.context, comparisonInfo);
                    if (!isAssignable) {
                        var message;
                        if (comparisonInfo.message) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1__NL__2, [
                                returnType.toString(), 
                                sigReturnType.toString(), 
                                comparisonInfo.message
                            ]);
                        } else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_convert__0__to__1_, [
                                returnType.toString(), 
                                sigReturnType.toString()
                            ]);
                        }
                        this.postError(returnExpr.minChar, returnExpr.getLength(), typeCheckContext.scriptName, message, enclosingDecl);
                    }
                }
            }
            return returnType;
        };
        PullTypeChecker.prototype.typeCheckNameExpression = function (ast, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolver.resolveNameExpression(ast, enclosingDecl, this.context).getType();
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };
        PullTypeChecker.prototype.typeCheckMemberAccessExpression = function (memberAccessExpression, typeCheckContext) {
            var expressionType = this.typeCheckAST(memberAccessExpression.operand1, typeCheckContext);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var resolvedName = this.resolver.resolveDottedNameExpression(memberAccessExpression, enclosingDecl, this.context);
            var type = resolvedName.getType();
            this.checkForResolutionError(type, enclosingDecl);
            if (expressionType && resolvedName && resolvedName.hasFlag(TypeScript.PullElementFlags.Private)) {
                if (expressionType.getKind() === TypeScript.PullElementKind.ConstructorType) {
                    expressionType = expressionType.getAssociatedContainerType();
                }
                if (expressionType.isClass()) {
                    var containingClass = typeCheckContext.getEnclosingClassDecl();
                    if (!containingClass || containingClass.getSymbol() !== expressionType) {
                        var name = memberAccessExpression.operand2;
                        this.postError(name.minChar, name.getLength(), typeCheckContext.scriptName, TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode._0_1__is_inaccessible, [
                            expressionType.toString(false), 
                            name.actualText
                        ]), enclosingDecl);
                    }
                }
            }
            return type;
        };
        PullTypeChecker.prototype.typeCheckSwitchStatement = function (switchStatement, typeCheckContext) {
            this.typeCheckAST(switchStatement.val, typeCheckContext);
            this.typeCheckAST(switchStatement.caseList, typeCheckContext);
            this.typeCheckAST(switchStatement.defaultCase, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.typeCheckExpressionStatement = function (ast, typeCheckContext, inTypedAssignment) {
            return this.typeCheckAST(ast.expression, typeCheckContext, inTypedAssignment);
        };
        PullTypeChecker.prototype.typeCheckCaseClause = function (caseClause, typeCheckContext) {
            this.typeCheckAST(caseClause.expr, typeCheckContext);
            this.typeCheckAST(caseClause.body, typeCheckContext);
            return this.semanticInfoChain.voidTypeSymbol;
        };
        PullTypeChecker.prototype.checkTypePrivacy = function (declSymbol, typeSymbol, privacyErrorReporter) {
            if (!typeSymbol || typeSymbol.getKind() == TypeScript.PullElementKind.Primitive) {
                return;
            }
            if (typeSymbol.isArray()) {
                this.checkTypePrivacy(declSymbol, (typeSymbol).getElementType(), privacyErrorReporter);
                return;
            }
            if (!typeSymbol.isNamedTypeSymbol()) {
                var members = typeSymbol.getMembers();
                for(var i = 0; i < members.length; i++) {
                    this.checkTypePrivacy(declSymbol, members[i].getType(), privacyErrorReporter);
                }
                this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getCallSignatures(), privacyErrorReporter);
                this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getConstructSignatures(), privacyErrorReporter);
                this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getIndexSignatures(), privacyErrorReporter);
                return;
            }
            if (declSymbol.isExternallyVisible()) {
                var typeSymbolIsVisible = typeSymbol.isExternallyVisible();
                if (typeSymbolIsVisible) {
                    var typeSymbolPath = typeSymbol.pathToRoot();
                    if (typeSymbolPath.length && typeSymbolPath[typeSymbolPath.length - 1].getKind() == TypeScript.PullElementKind.DynamicModule) {
                        var declSymbolPath = declSymbol.pathToRoot();
                        if (declSymbolPath.length && declSymbolPath[declSymbolPath.length - 1] != typeSymbolPath[typeSymbolPath.length - 1]) {
                            var aliasSymbol = (typeSymbolPath[typeSymbolPath.length - 1]).getAliasedSymbol(declSymbol);
                            if (aliasSymbol) {
                                TypeScript.CompilerDiagnostics.assert(aliasSymbol.getKind() == TypeScript.PullElementKind.TypeAlias, "dynamic module need to be referenced by type alias");
                                (aliasSymbol).setIsTypeUsedExternally();
                            } else {
                                typeSymbolIsVisible = false;
                            }
                        }
                    }
                }
                if (!typeSymbolIsVisible) {
                    privacyErrorReporter(typeSymbol);
                }
            }
        };
        PullTypeChecker.prototype.checkTypePrivacyOfSignatures = function (declSymbol, signatures, privacyErrorReporter) {
            for(var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (signatures.length && signature.isDefinition()) {
                    continue;
                }
                var typeParams = signature.getTypeParameters();
                for(var j = 0; j < typeParams.length; j++) {
                    this.checkTypePrivacy(declSymbol, typeParams[j], privacyErrorReporter);
                }
                var params = signature.getParameters();
                for(var j = 0; j < params.length; j++) {
                    var paramType = params[j].getType();
                    this.checkTypePrivacy(declSymbol, paramType, privacyErrorReporter);
                }
                var returnType = signature.getReturnType();
                this.checkTypePrivacy(declSymbol, returnType, privacyErrorReporter);
            }
        };
        PullTypeChecker.prototype.baseListPrivacyErrorReporter = function (declAST, declSymbol, baseAst, isExtendedType, typeSymbol, typeCheckContext) {
            var decl = this.resolver.getDeclForAST(declAST);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var message;
            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (declAST.nodeType == TypeScript.NodeType.ClassDeclaration) {
                    if (isExtendedType) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_class__0__extends_class_from_inaccessible_module__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_class__0__implements_interface_from_inaccessible_module__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_interface__0__extends_interface_from_inaccessible_module__1_, [
                        declSymbol.getName(), 
                        typeSymbolName
                    ]);
                }
            } else {
                if (declAST.nodeType == TypeScript.NodeType.ClassDeclaration) {
                    if (isExtendedType) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_class__0__extends_private_class__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_class__0__implements_private_interface__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_interface__0__extends_private_interface__1_, [
                        declSymbol.getName(), 
                        typeSymbolName
                    ]);
                }
            }
            this.context.postError(baseAst.minChar, baseAst.getLength(), typeCheckContext.scriptName, message, enclosingDecl, true);
        };
        PullTypeChecker.prototype.variablePrivacyErrorReporter = function (declSymbol, typeSymbol, typeCheckContext) {
            var declAST = this.resolver.getASTForSymbol(declSymbol);
            var decl = this.resolver.getDeclForAST(declAST);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var isProperty = declSymbol.getKind() == TypeScript.PullElementKind.Property;
            var isPropertyOfClass = false;
            var declParent = declSymbol.getContainer();
            if (declParent && (declParent.getKind() == TypeScript.PullElementKind.Class || declParent.getKind() == TypeScript.PullElementKind.ConstructorMethod)) {
                isPropertyOfClass = true;
            }
            var message;
            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (decl.getFlags() & TypeScript.PullElementFlags.Static) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_, [
                        declSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Public_property__0__of__exported_class_is_using_inaccessible_module__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property__0__of__exported_interface_is_using_inaccessible_module__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_variable__0__is_using_inaccessible_module__1_, [
                        declSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                }
            } else {
                if (decl.getFlags() & TypeScript.PullElementFlags.Static) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_, [
                        declSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Public_property__0__of__exported_class_has_or_is_using_private_type__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property__0__of__exported_interface_has_or_is_using_private_type__1_, [
                            declSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Exported_variable__0__has_or_is_using_private_type__1_, [
                        declSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                }
            }
            this.context.postError(declAST.minChar, declAST.getLength(), typeCheckContext.scriptName, message, enclosingDecl, true);
        };
        PullTypeChecker.prototype.checkFunctionTypePrivacy = function (funcDeclAST, inTypedAssignment, typeCheckContext) {
            var _this = this;
            if (inTypedAssignment || (funcDeclAST.getFunctionFlags() & TypeScript.FunctionFlags.IsFunctionExpression)) {
                return;
            }
            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            var functionSymbol = functionDecl.getSymbol();
            ;
            var functionSignature;
            var isGetter = funcDeclAST.isGetAccessor();
            var isSetter = funcDeclAST.isSetAccessor();
            if (isGetter || isSetter) {
                var accessorSymbol = functionSymbol;
                functionSignature = (isGetter ? accessorSymbol.getGetter() : accessorSymbol.getSetter()).getType().getCallSignatures()[0];
            } else {
                if (!functionSymbol) {
                    var parentDecl = functionDecl.getParentDecl();
                    functionSymbol = parentDecl.getSymbol();
                    if (functionSymbol && functionSymbol.isType() && !(functionSymbol).isNamedTypeSymbol()) {
                        return;
                    }
                }
                functionSignature = functionDecl.getSignatureSymbol();
            }
            if (!isGetter) {
                var funcParams = functionSignature.getParameters();
                for(var i = 0; i < funcParams.length; i++) {
                    this.checkTypePrivacy(functionSymbol, funcParams[i].getType(), function (typeSymbol) {
                        return _this.functionArgumentTypePrivacyErrorReporter(funcDeclAST, i, funcParams[i], typeSymbol, typeCheckContext);
                    });
                }
            }
            if (!isSetter) {
                this.checkTypePrivacy(functionSymbol, functionSignature.getReturnType(), function (typeSymbol) {
                    return _this.functionReturnTypePrivacyErrorReporter(funcDeclAST, functionSignature.getReturnType(), typeSymbol, typeCheckContext);
                });
            }
        };
        PullTypeChecker.prototype.functionArgumentTypePrivacyErrorReporter = function (declAST, argIndex, paramSymbol, typeSymbol, typeCheckContext) {
            var decl = this.resolver.getDeclForAST(declAST);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var isGetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor);
            var isSetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), TypeScript.FunctionFlags.SetAccessor);
            var isStatic = (decl.getFlags() & TypeScript.PullElementFlags.Static) == TypeScript.PullElementFlags.Static;
            var isMethod = decl.getKind() == TypeScript.PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.getKind() == TypeScript.PullElementKind.Class || declParent.getKind() == TypeScript.PullElementKind.ConstructorMethod)) {
                isMethodOfClass = true;
            }
            var message = null;
            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (declAST.isConstructor) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (isSetter) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else if (declAST.isConstructMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (declAST.isCallMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (isMethod) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else if (isMethodOfClass) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else if (!isGetter) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_exported_function_is_using_inaccessible_module__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                }
            } else {
                if (declAST.isConstructor) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (isSetter) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else if (declAST.isConstructMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (declAST.isCallMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                } else if (isMethod) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else if (isMethodOfClass) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_, [
                            paramSymbol.getScopedName(), 
                            typeSymbolName
                        ]);
                    }
                } else if (!isGetter && !declAST.isIndexerMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Parameter__0__of_exported_function_has_or_is_using_private_type__1_, [
                        paramSymbol.getScopedName(), 
                        typeSymbolName
                    ]);
                }
            }
            if (message) {
                this.context.postError(declAST.arguments.members[argIndex].minChar, declAST.arguments.members[argIndex].getLength(), typeCheckContext.scriptName, message, enclosingDecl, true);
            }
        };
        PullTypeChecker.prototype.functionReturnTypePrivacyErrorReporter = function (declAST, funcReturnType, typeSymbol, typeCheckContext) {
            var _this = this;
            var decl = this.resolver.getDeclForAST(declAST);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var isGetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor);
            var isSetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), TypeScript.FunctionFlags.SetAccessor);
            var isStatic = (decl.getFlags() & TypeScript.PullElementFlags.Static) == TypeScript.PullElementFlags.Static;
            var isMethod = decl.getKind() == TypeScript.PullElementKind.Method;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.getKind() == TypeScript.PullElementKind.Class || declParent.getKind() == TypeScript.PullElementKind.ConstructorMethod)) {
                isMethodOfClass = true;
            }
            var message = null;
            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (isGetter) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_, [
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_, [
                            typeSymbolName
                        ]);
                    }
                } else if (declAST.isConstructMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_, [
                        typeSymbolName
                    ]);
                } else if (declAST.isCallMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_, [
                        typeSymbolName
                    ]);
                } else if (declAST.isIndexerMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_, [
                        typeSymbolName
                    ]);
                } else if (isMethod) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_, [
                            typeSymbolName
                        ]);
                    } else if (isMethodOfClass) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_, [
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_, [
                            typeSymbolName
                        ]);
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_exported_function_is_using_inaccessible_module__0_, [
                        typeSymbolName
                    ]);
                }
            } else {
                if (isGetter) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_, [
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_, [
                            typeSymbolName
                        ]);
                    }
                } else if (declAST.isConstructMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_, [
                        typeSymbolName
                    ]);
                } else if (declAST.isCallMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_, [
                        typeSymbolName
                    ]);
                } else if (declAST.isIndexerMember()) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_, [
                        typeSymbolName
                    ]);
                } else if (isMethod) {
                    if (isStatic) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_, [
                            typeSymbolName
                        ]);
                    } else if (isMethodOfClass) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_, [
                            typeSymbolName
                        ]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_, [
                            typeSymbolName
                        ]);
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Return_type_of_exported_function_has_or_is_using_private_type__0_, [
                        typeSymbolName
                    ]);
                }
            }
            if (message) {
                var reportOnFuncDecl = false;
                var contextForReturnTypeResolution = new TypeScript.PullTypeResolutionContext();
                var returnExpressionSymbol;
                if (declAST.returnTypeAnnotation != null) {
                    var returnTypeRef = declAST.returnTypeAnnotation;
                    returnExpressionSymbol = this.resolver.resolveTypeReference(returnTypeRef, decl, contextForReturnTypeResolution);
                    if (returnExpressionSymbol == funcReturnType) {
                        this.context.postError(declAST.returnTypeAnnotation.minChar, declAST.returnTypeAnnotation.getLength(), typeCheckContext.scriptName, message, enclosingDecl, true);
                    }
                }
                if (declAST.block) {
                    var reportErrorOnReturnExpressions = function (ast, parent, walker) {
                        var go = true;
                        switch(ast.nodeType) {
                            case TypeScript.NodeType.FunctionDeclaration:
                                go = false;
                                break;
                            case TypeScript.NodeType.ReturnStatement:
                                var returnStatement = ast;
                                returnExpressionSymbol = _this.resolver.resolveStatementOrExpression(returnStatement.returnExpression, false, decl, contextForReturnTypeResolution).getType();
                                if (returnExpressionSymbol == funcReturnType) {
                                    _this.context.postError(returnStatement.minChar, returnStatement.getLength(), typeCheckContext.scriptName, message, enclosingDecl, true);
                                } else {
                                    reportOnFuncDecl = true;
                                }
                                go = false;
                                break;
                            default:
                                break;
                        }
                        walker.options.goChildren = go;
                        return ast;
                    };
                    TypeScript.getAstWalkerFactory().walk(declAST.block, reportErrorOnReturnExpressions);
                }
                if (reportOnFuncDecl) {
                    this.context.postError(declAST.minChar, declAST.getLength(), typeCheckContext.scriptName, message, enclosingDecl, true);
                }
            }
        };
        return PullTypeChecker;
    })();
    TypeScript.PullTypeChecker = PullTypeChecker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullDeclEdit) {
        PullDeclEdit._map = [];
        PullDeclEdit._map[0] = "NoChanges";
        PullDeclEdit.NoChanges = 0;
        PullDeclEdit._map[1] = "DeclAdded";
        PullDeclEdit.DeclAdded = 1;
        PullDeclEdit._map[2] = "DeclRemoved";
        PullDeclEdit.DeclRemoved = 2;
        PullDeclEdit._map[3] = "DeclChanged";
        PullDeclEdit.DeclChanged = 3;
    })(TypeScript.PullDeclEdit || (TypeScript.PullDeclEdit = {}));
    var PullDeclEdit = TypeScript.PullDeclEdit;
    var PullDeclDiff = (function () {
        function PullDeclDiff(oldDecl, newDecl, kind) {
            this.oldDecl = oldDecl;
            this.newDecl = newDecl;
            this.kind = kind;
        }
        return PullDeclDiff;
    })();
    TypeScript.PullDeclDiff = PullDeclDiff;    
    var PullDeclDiffer = (function () {
        function PullDeclDiffer(oldSemanticInfo, newSemanticInfo) {
            this.oldSemanticInfo = oldSemanticInfo;
            this.newSemanticInfo = newSemanticInfo;
            this.differences = [];
        }
        PullDeclDiffer.diffDecls = function diffDecls(oldDecl, oldSemanticInfo, newDecl, newSemanticInfo) {
            var declDiffer = new PullDeclDiffer(oldSemanticInfo, newSemanticInfo);
            declDiffer.diff(oldDecl, newDecl);
            return declDiffer.differences;
        };
        PullDeclDiffer.prototype.diff = function (oldDecl, newDecl) {
            TypeScript.Debug.assert(oldDecl.getName() === newDecl.getName());
            TypeScript.Debug.assert(oldDecl.getKind() === newDecl.getKind());
            var oldAST = this.oldSemanticInfo.getASTForDecl(oldDecl);
            var newAST = this.newSemanticInfo.getASTForDecl(newDecl);
            TypeScript.Debug.assert(oldAST !== undefined);
            TypeScript.Debug.assert(newAST !== undefined);
            if (oldAST === newAST) {
                return;
            }
            this.diff1(oldDecl, newDecl, oldAST, newAST, oldDecl.childDeclTypeCache, newDecl.childDeclTypeCache);
            this.diff1(oldDecl, newDecl, oldAST, newAST, oldDecl.childDeclTypeParameterCache, newDecl.childDeclTypeParameterCache);
            this.diff1(oldDecl, newDecl, oldAST, newAST, oldDecl.childDeclValueCache, newDecl.childDeclValueCache);
            if (!this.isEquivalent(oldAST, newAST)) {
                this.differences.push(new PullDeclDiff(oldDecl, newDecl, PullDeclEdit.DeclChanged));
            }
        };
        PullDeclDiffer.emptyDeclArray = [];
        PullDeclDiffer.prototype.diff1 = function (oldDecl, newDecl, oldAST, newAST, oldNameToDecls, newNameToDecls) {
            var oldChildrenOfName;
            var newChildrenOfName;
            var oldChild;
            var newChild;
            for(var name in oldNameToDecls) {
                oldChildrenOfName = oldNameToDecls[name] || PullDeclDiffer.emptyDeclArray;
                newChildrenOfName = newNameToDecls[name] || PullDeclDiffer.emptyDeclArray;
                for(var i = 0, n = oldChildrenOfName.length; i < n; i++) {
                    oldChild = oldChildrenOfName[i];
                    switch(oldChild.getKind()) {
                        case TypeScript.PullElementKind.FunctionExpression:
                        case TypeScript.PullElementKind.ObjectLiteral:
                        case TypeScript.PullElementKind.ObjectType:
                        case TypeScript.PullElementKind.FunctionType:
                        case TypeScript.PullElementKind.ConstructorType:
                            continue;
                    }
                    if (i < newChildrenOfName.length) {
                        newChild = newChildrenOfName[i];
                        if (oldChild.getKind() === newChild.getKind()) {
                            this.diff(oldChild, newChildrenOfName[i]);
                        } else {
                            this.differences.push(new PullDeclDiff(oldChild, null, PullDeclEdit.DeclRemoved));
                            this.differences.push(new PullDeclDiff(oldDecl, newChild, PullDeclEdit.DeclAdded));
                        }
                    } else {
                        this.differences.push(new PullDeclDiff(oldChild, null, PullDeclEdit.DeclRemoved));
                    }
                }
            }
            for(var name in newNameToDecls) {
                oldChildrenOfName = oldNameToDecls[name] || PullDeclDiffer.emptyDeclArray;
                newChildrenOfName = newNameToDecls[name] || PullDeclDiffer.emptyDeclArray;
                for(var i = oldChildrenOfName.length, n = newChildrenOfName.length; i < n; i++) {
                    newChild = newChildrenOfName[i];
                    this.differences.push(new PullDeclDiff(oldDecl, newChild, PullDeclEdit.DeclAdded));
                }
            }
        };
        PullDeclDiffer.prototype.isEquivalent = function (oldAST, newAST) {
            TypeScript.Debug.assert(oldAST !== null);
            TypeScript.Debug.assert(newAST !== null);
            TypeScript.Debug.assert(oldAST !== newAST);
            if (oldAST.nodeType !== newAST.nodeType || oldAST.getFlags() !== newAST.getFlags()) {
                return false;
            }
            switch(oldAST.nodeType) {
                case TypeScript.NodeType.ImportDeclaration:
                    return this.importDeclarationIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.ModuleDeclaration:
                    return this.moduleDeclarationIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.ClassDeclaration:
                    return this.classDeclarationIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.InterfaceDeclaration:
                    return this.interfaceDeclarationIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.Parameter:
                    return this.argumentDeclarationIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.VariableDeclarator:
                    return this.variableDeclarationIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.TypeParameter:
                    return this.typeParameterIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.FunctionDeclaration:
                    return this.functionDeclarationIsEquivalent(oldAST, newAST);
                case TypeScript.NodeType.Script:
                    return this.scriptIsEquivalent(oldAST, newAST);
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        PullDeclDiffer.prototype.importDeclarationIsEquivalent = function (decl1, decl2) {
            return TypeScript.structuralEqualsNotIncludingPosition(decl1.alias, decl2.alias);
        };
        PullDeclDiffer.prototype.typeDeclarationIsEquivalent = function (decl1, decl2) {
            return decl1.getVarFlags() === decl2.getVarFlags() && TypeScript.structuralEqualsNotIncludingPosition(decl1.typeParameters, decl2.typeParameters) && TypeScript.structuralEqualsNotIncludingPosition(decl1.extendsList, decl2.extendsList) && TypeScript.structuralEqualsNotIncludingPosition(decl1.implementsList, decl2.implementsList);
        };
        PullDeclDiffer.prototype.classDeclarationIsEquivalent = function (decl1, decl2) {
            return this.typeDeclarationIsEquivalent(decl1, decl2);
        };
        PullDeclDiffer.prototype.interfaceDeclarationIsEquivalent = function (decl1, decl2) {
            return this.typeDeclarationIsEquivalent(decl1, decl2);
        };
        PullDeclDiffer.prototype.typeParameterIsEquivalent = function (decl1, decl2) {
            return TypeScript.structuralEqualsNotIncludingPosition(decl1.constraint, decl2.constraint);
        };
        PullDeclDiffer.prototype.boundDeclarationIsEquivalent = function (decl1, decl2) {
            if (decl1.getVarFlags() === decl2.getVarFlags() && TypeScript.structuralEqualsNotIncludingPosition(decl1.typeExpr, decl2.typeExpr)) {
                if (decl1.typeExpr === null) {
                    return TypeScript.structuralEqualsNotIncludingPosition(decl1.init, decl2.init);
                } else {
                    return true;
                }
            }
            return false;
        };
        PullDeclDiffer.prototype.argumentDeclarationIsEquivalent = function (decl1, decl2) {
            return this.boundDeclarationIsEquivalent(decl1, decl2) && decl1.isOptional === decl2.isOptional;
        };
        PullDeclDiffer.prototype.variableDeclarationIsEquivalent = function (decl1, decl2) {
            return this.boundDeclarationIsEquivalent(decl1, decl2);
        };
        PullDeclDiffer.prototype.functionDeclarationIsEquivalent = function (decl1, decl2) {
            if (decl1.hint === decl2.hint && decl1.getFunctionFlags() === decl2.getFunctionFlags() && decl1.variableArgList === decl2.variableArgList && decl1.isConstructor === decl2.isConstructor && TypeScript.structuralEqualsNotIncludingPosition(decl1.returnTypeAnnotation, decl2.returnTypeAnnotation) && TypeScript.structuralEqualsNotIncludingPosition(decl1.typeArguments, decl2.typeArguments) && TypeScript.structuralEqualsNotIncludingPosition(decl1.arguments, decl2.arguments)) {
                if (decl1.returnTypeAnnotation === null) {
                    return TypeScript.structuralEqualsNotIncludingPosition(decl1.block, decl2.block);
                } else {
                    return true;
                }
            }
            return false;
        };
        PullDeclDiffer.prototype.scriptIsEquivalent = function (decl1, decl2) {
            return true;
        };
        PullDeclDiffer.prototype.moduleDeclarationIsEquivalent = function (decl1, decl2) {
            return decl1.getModuleFlags() === decl2.getModuleFlags() && decl2.prettyName === decl2.prettyName && TypeScript.ArrayUtilities.sequenceEquals(decl1.amdDependencies, decl2.amdDependencies, TypeScript.StringUtilities.stringEquals);
        };
        return PullDeclDiffer;
    })();
    TypeScript.PullDeclDiffer = PullDeclDiffer;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.declCacheHit = 0;
    TypeScript.declCacheMiss = 0;
    TypeScript.symbolCacheHit = 0;
    TypeScript.symbolCacheMiss = 0;
    var SemanticInfo = (function () {
        function SemanticInfo(compilationUnitPath) {
            this.topLevelDecls = [];
            this.astDeclMap = new TypeScript.DataMap();
            this.declASTMap = new TypeScript.DataMap();
            this.syntaxElementDeclMap = new TypeScript.DataMap();
            this.declSyntaxElementMap = new TypeScript.DataMap();
            this.declSymbolMap = new TypeScript.DataMap();
            this.astSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
            this.syntaxElementSymbolMap = new TypeScript.DataMap();
            this.symbolSyntaxElementMap = new TypeScript.DataMap();
            this.dynamicModuleImports = [];
            this.properties = new SemanticInfoProperties();
            this.hasBeenTypeChecked = false;
            this.compilationUnitPath = compilationUnitPath;
        }
        SemanticInfo.prototype.addTopLevelDecl = function (decl) {
            this.topLevelDecls[this.topLevelDecls.length] = decl;
        };
        SemanticInfo.prototype.setTypeChecked = function () {
            this.hasBeenTypeChecked = true;
        };
        SemanticInfo.prototype.getTypeChecked = function () {
            return this.hasBeenTypeChecked;
        };
        SemanticInfo.prototype.invalidate = function () {
            this.hasBeenTypeChecked = false;
        };
        SemanticInfo.prototype.getTopLevelDecls = function () {
            return this.topLevelDecls;
        };
        SemanticInfo.prototype.getPath = function () {
            return this.compilationUnitPath;
        };
        SemanticInfo.prototype.getDeclForAST = function (ast) {
            return this.astDeclMap.read(ast.getID().toString());
        };
        SemanticInfo.prototype.setDeclForAST = function (ast, decl) {
            this.astDeclMap.link(ast.getID().toString(), decl);
        };
        SemanticInfo.prototype.getDeclKey = function (decl) {
            var decl1 = decl;
            if (!decl1.__declKey) {
                decl1.__declKey = decl.getDeclID().toString() + "-" + decl.getKind().toString();
            }
            return decl1.__declKey;
        };
        SemanticInfo.prototype.getASTForDecl = function (decl) {
            return this.declASTMap.read(this.getDeclKey(decl));
        };
        SemanticInfo.prototype.setASTForDecl = function (decl, ast) {
            this.declASTMap.link(this.getDeclKey(decl), ast);
        };
        SemanticInfo.prototype.setSymbolForAST = function (ast, symbol) {
            this.astSymbolMap.link(ast.getID().toString(), symbol);
            this.symbolASTMap.link(symbol.getSymbolID().toString(), ast);
        };
        SemanticInfo.prototype.getSymbolForAST = function (ast) {
            return this.astSymbolMap.read(ast.getID().toString());
        };
        SemanticInfo.prototype.getASTForSymbol = function (symbol) {
            return this.symbolASTMap.read(symbol.getSymbolID().toString());
        };
        SemanticInfo.prototype.getSyntaxElementForDecl = function (decl) {
            return this.declSyntaxElementMap.read(this.getDeclKey(decl));
        };
        SemanticInfo.prototype.setSyntaxElementForDecl = function (decl, syntaxElement) {
            this.declSyntaxElementMap.link(this.getDeclKey(decl), syntaxElement);
        };
        SemanticInfo.prototype.getDeclForSyntaxElement = function (syntaxElement) {
            return this.syntaxElementDeclMap.read(TypeScript.Collections.identityHashCode(syntaxElement).toString());
        };
        SemanticInfo.prototype.setDeclForSyntaxElement = function (syntaxElement, decl) {
            this.syntaxElementDeclMap.link(TypeScript.Collections.identityHashCode(syntaxElement).toString(), decl);
        };
        SemanticInfo.prototype.getSyntaxElementForSymbol = function (symbol) {
            return this.symbolSyntaxElementMap.read(symbol.getSymbolID().toString());
        };
        SemanticInfo.prototype.getSymbolForSyntaxElement = function (syntaxElement) {
            return this.syntaxElementSymbolMap.read(TypeScript.Collections.identityHashCode(syntaxElement).toString());
        };
        SemanticInfo.prototype.setSymbolForSyntaxElement = function (syntaxElement, symbol) {
            this.syntaxElementSymbolMap.link(TypeScript.Collections.identityHashCode(syntaxElement).toString(), symbol);
            this.symbolSyntaxElementMap.link(symbol.getSymbolID().toString(), syntaxElement);
        };
        SemanticInfo.prototype.addDynamicModuleImport = function (importSymbol) {
            this.dynamicModuleImports[this.dynamicModuleImports.length] = importSymbol;
        };
        SemanticInfo.prototype.getDynamicModuleImports = function () {
            return this.dynamicModuleImports;
        };
        SemanticInfo.prototype.getDiagnostics = function (semanticErrors) {
            for(var i = 0; i < this.topLevelDecls.length; i++) {
                TypeScript.getDiagnosticsFromEnclosingDecl(this.topLevelDecls[i], semanticErrors);
            }
        };
        SemanticInfo.prototype.getProperties = function () {
            return this.properties;
        };
        return SemanticInfo;
    })();
    TypeScript.SemanticInfo = SemanticInfo;    
    var SemanticInfoProperties = (function () {
        function SemanticInfoProperties() {
            this.unitContainsBool = false;
        }
        return SemanticInfoProperties;
    })();
    TypeScript.SemanticInfoProperties = SemanticInfoProperties;    
    var SemanticInfoChain = (function () {
        function SemanticInfoChain() {
            this.units = [
                new SemanticInfo("")
            ];
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.unitCache = new TypeScript.BlockIntrinsics();
            this.anyTypeSymbol = null;
            this.booleanTypeSymbol = null;
            this.numberTypeSymbol = null;
            this.stringTypeSymbol = null;
            this.nullTypeSymbol = null;
            this.undefinedTypeSymbol = null;
            this.elementTypeSymbol = null;
            this.voidTypeSymbol = null;
            var span = new TypeScript.TextSpan(0, 0);
            var globalDecl = new TypeScript.PullDecl("", TypeScript.PullElementKind.Global, TypeScript.PullElementFlags.None, span, "");
            var globalInfo = this.units[0];
            globalInfo.addTopLevelDecl(globalDecl);
            this.anyTypeSymbol = this.addPrimitive("any", globalDecl);
            this.booleanTypeSymbol = this.addPrimitive("boolean", globalDecl);
            this.numberTypeSymbol = this.addPrimitive("number", globalDecl);
            this.stringTypeSymbol = this.addPrimitive("string", globalDecl);
            this.nullTypeSymbol = this.addPrimitive("null", globalDecl);
            this.undefinedTypeSymbol = this.addPrimitive("undefined", globalDecl);
            this.voidTypeSymbol = this.addPrimitive("void", globalDecl);
            this.elementTypeSymbol = this.addPrimitive("_element", globalDecl);
        }
        SemanticInfoChain.prototype.addPrimitive = function (name, globalDecl) {
            var span = new TypeScript.TextSpan(0, 0);
            var decl = new TypeScript.PullDecl(name, TypeScript.PullElementKind.Primitive, TypeScript.PullElementFlags.None, span, "");
            var symbol = new TypeScript.PullPrimitiveTypeSymbol(name);
            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);
            symbol.setResolved();
            globalDecl.addChildDecl(decl);
            return symbol;
        };
        SemanticInfoChain.prototype.addUnit = function (unit) {
            this.units[this.units.length] = unit;
            this.unitCache[unit.getPath()] = unit;
        };
        SemanticInfoChain.prototype.getUnit = function (compilationUnitPath) {
            for(var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() == compilationUnitPath) {
                    return this.units[i];
                }
            }
            return null;
        };
        SemanticInfoChain.prototype.updateUnit = function (oldUnit, newUnit) {
            for(var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() == oldUnit.getPath()) {
                    this.units[i] = newUnit;
                    this.unitCache[oldUnit.getPath()] = newUnit;
                    return;
                }
            }
        };
        SemanticInfoChain.prototype.collectAllTopLevelDecls = function () {
            var decls = [];
            var unitDecls;
            for(var i = 0; i < this.units.length; i++) {
                unitDecls = this.units[i].getTopLevelDecls();
                for(var j = 0; j < unitDecls.length; j++) {
                    decls[decls.length] = unitDecls[j];
                }
            }
            return decls;
        };
        SemanticInfoChain.prototype.getDeclPathCacheID = function (declPath, declKind) {
            var cacheID = "";
            for(var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }
            return cacheID + "#" + declKind.toString();
        };
        SemanticInfoChain.prototype.findDecls = function (declPath, declKind) {
            var cacheID = this.getDeclPathCacheID(declPath, declKind);
            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];
                if (cachedDecls && cachedDecls.length) {
                    TypeScript.declCacheHit++;
                    return cachedDecls;
                }
            }
            TypeScript.declCacheMiss++;
            var declsToSearch = this.collectAllTopLevelDecls();
            var decls = [];
            var path;
            var foundDecls = [];
            var keepSearching = (declKind & TypeScript.PullElementKind.Container) || (declKind & TypeScript.PullElementKind.Interface);
            for(var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = [];
                for(var j = 0; j < declsToSearch.length; j++) {
                    var kind = (i == declPath.length - 1) ? declKind : TypeScript.PullElementKind.SomeType;
                    foundDecls = declsToSearch[j].searchChildDecls(path, (kind & TypeScript.PullElementKind.SomeType) !== 0);
                    for(var k = 0; k < foundDecls.length; k++) {
                        decls[decls.length] = foundDecls[k];
                    }
                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }
                declsToSearch = decls;
                if (!declsToSearch) {
                    break;
                }
            }
            if (decls.length) {
                this.declCache[cacheID] = decls;
            }
            return decls;
        };
        SemanticInfoChain.prototype.findSymbol = function (declPath, declType) {
            var cacheID = this.getDeclPathCacheID(declPath, declType);
            if (declPath.length) {
                var cachedSymbol = this.symbolCache[cacheID];
                if (cachedSymbol) {
                    TypeScript.symbolCacheHit++;
                    return cachedSymbol;
                }
            }
            TypeScript.symbolCacheMiss++;
            var decls = this.findDecls(declPath, declType);
            var symbol = null;
            if (decls.length) {
                symbol = decls[0].getSymbol();
                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                    symbol.addCacheID(cacheID);
                }
            }
            return symbol;
        };
        SemanticInfoChain.prototype.update = function (compilationUnitPath) {
            this.declCache = new TypeScript.BlockIntrinsics();
            var unit = this.unitCache[compilationUnitPath];
            if (unit) {
                unit.invalidate();
            }
        };
        SemanticInfoChain.prototype.invalidateUnit = function (compilationUnitPath) {
            var unit = this.unitCache[compilationUnitPath];
            if (unit) {
                unit.invalidate();
            }
        };
        SemanticInfoChain.prototype.getDeclForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                return unit.getDeclForAST(ast);
            }
            return null;
        };
        SemanticInfoChain.prototype.getASTForDecl = function (decl) {
            var unit = this.unitCache[decl.getScriptName()];
            if (unit) {
                return unit.getASTForDecl(decl);
            }
            return null;
        };
        SemanticInfoChain.prototype.getSymbolForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                return unit.getSymbolForAST(ast);
            }
            return null;
        };
        SemanticInfoChain.prototype.getASTForSymbol = function (symbol, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                return unit.getASTForSymbol(symbol);
            }
            return null;
        };
        SemanticInfoChain.prototype.setSymbolForAST = function (ast, typeSymbol, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                unit.setSymbolForAST(ast, typeSymbol);
            }
        };
        SemanticInfoChain.prototype.removeSymbolFromCache = function (symbol) {
            var path = [
                symbol.getName()
            ];
            var kind = (symbol.getKind() & TypeScript.PullElementKind.SomeType) != 0 ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeValue;
            var kindID = this.getDeclPathCacheID(path, kind);
            var symID = this.getDeclPathCacheID(path, symbol.getKind());
            symbol.addCacheID(kindID);
            symbol.addCacheID(symID);
            symbol.invalidateCachedIDs(this.symbolCache);
        };
        SemanticInfoChain.prototype.postDiagnostics = function () {
            var errors = [];
            for(var i = 1; i < this.units.length; i++) {
                this.units[i].getDiagnostics(errors);
            }
            return errors;
        };
        return SemanticInfoChain;
    })();
    TypeScript.SemanticInfoChain = SemanticInfoChain;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclCollectionContext = (function () {
        function DeclCollectionContext(semanticInfo, scriptName) {
            if (typeof scriptName === "undefined") { scriptName = ""; }
            this.semanticInfo = semanticInfo;
            this.scriptName = scriptName;
            this.parentChain = [];
            this.foundValueDecl = false;
        }
        DeclCollectionContext.prototype.getParent = function () {
            return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
        };
        DeclCollectionContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
            }
        };
        DeclCollectionContext.prototype.popParent = function () {
            this.parentChain.length--;
        };
        return DeclCollectionContext;
    })();
    TypeScript.DeclCollectionContext = DeclCollectionContext;    
    function preCollectImportDecls(ast, parentAST, context) {
        var importDecl = ast;
        var declFlags = TypeScript.PullElementFlags.None;
        var span = TypeScript.TextSpan.fromBounds(importDecl.minChar, importDecl.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl(importDecl.id.text, TypeScript.PullElementKind.TypeAlias, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);
        return false;
    }
    TypeScript.preCollectImportDecls = preCollectImportDecls;
    function preCollectModuleDecls(ast, parentAST, context) {
        var moduleDecl = ast;
        var declFlags = TypeScript.PullElementFlags.None;
        var modName = (moduleDecl.name).text;
        var isDynamic = TypeScript.isQuoted(modName) || TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.IsDynamic);
        var kind = TypeScript.PullElementKind.Container;
        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.Ambient)) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.Exported)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), TypeScript.ModuleFlags.IsEnum)) {
            declFlags |= TypeScript.PullElementFlags.Enum;
            kind = TypeScript.PullElementKind.Enum;
        } else {
            kind = isDynamic ? TypeScript.PullElementKind.DynamicModule : TypeScript.PullElementKind.Container;
        }
        var span = TypeScript.TextSpan.fromBounds(moduleDecl.minChar, moduleDecl.limChar);
        var decl = new TypeScript.PullDecl(modName, kind, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);
        context.pushParent(decl);
        return true;
    }
    TypeScript.preCollectModuleDecls = preCollectModuleDecls;
    function preCollectClassDecls(classDecl, parentAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var constructorDeclKind = TypeScript.PullElementKind.Variable;
        if (TypeScript.hasFlag(classDecl.getVarFlags(), TypeScript.VariableFlags.Ambient)) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        if (TypeScript.hasFlag(classDecl.getVarFlags(), TypeScript.VariableFlags.Exported)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
            constructorDeclKind = TypeScript.PullElementKind.Property;
        }
        var span = TypeScript.TextSpan.fromBounds(classDecl.minChar, classDecl.limChar);
        var decl = new TypeScript.PullDecl(classDecl.name.text, TypeScript.PullElementKind.Class, declFlags, span, context.scriptName);
        var constructorDecl = new TypeScript.PullDecl(classDecl.name.text, constructorDeclKind, declFlags | TypeScript.PullElementFlags.ClassConstructorVariable, span, context.scriptName);
        decl.setValueDecl(constructorDecl);
        var parent = context.getParent();
        parent.addChildDecl(decl);
        parent.addChildDecl(constructorDecl);
        decl.setParentDecl(parent);
        constructorDecl.setParentDecl(parent);
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(classDecl, decl);
        context.semanticInfo.setASTForDecl(decl, classDecl);
        context.semanticInfo.setASTForDecl(constructorDecl, classDecl);
        return true;
    }
    TypeScript.preCollectClassDecls = preCollectClassDecls;
    function createObjectTypeDeclaration(interfaceDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("", TypeScript.PullElementKind.ObjectType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        return true;
    }
    TypeScript.createObjectTypeDeclaration = createObjectTypeDeclaration;
    function preCollectInterfaceDecls(interfaceDecl, parentAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        if (interfaceDecl.getFlags() & TypeScript.ASTFlags.TypeReference) {
            return createObjectTypeDeclaration(interfaceDecl, context);
        }
        if (TypeScript.hasFlag(interfaceDecl.getVarFlags(), TypeScript.VariableFlags.Exported)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);
        var decl = new TypeScript.PullDecl(interfaceDecl.name.text, TypeScript.PullElementKind.Interface, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        return true;
    }
    TypeScript.preCollectInterfaceDecls = preCollectInterfaceDecls;
    function preCollectParameterDecl(argDecl, parentAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        if (TypeScript.hasFlag(argDecl.getVarFlags(), TypeScript.VariableFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        } else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        if (TypeScript.hasFlag(argDecl.getFlags(), TypeScript.ASTFlags.OptionalName) || TypeScript.hasFlag(argDecl.id.getFlags(), TypeScript.ASTFlags.OptionalName)) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var span = TypeScript.TextSpan.fromBounds(argDecl.minChar, argDecl.limChar);
        var decl = new TypeScript.PullDecl(argDecl.id.text, TypeScript.PullElementKind.Parameter, declFlags, span, context.scriptName);
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);
        if (TypeScript.hasFlag(argDecl.getVarFlags(), TypeScript.VariableFlags.Property)) {
            var propDecl = new TypeScript.PullDecl(argDecl.id.text, TypeScript.PullElementKind.Property, declFlags, span, context.scriptName);
            propDecl.setValueDecl(decl);
            context.parentChain[context.parentChain.length - 2].addChildDecl(propDecl);
            propDecl.setParentDecl(context.parentChain[context.parentChain.length - 2]);
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setASTForDecl(propDecl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, propDecl);
        } else {
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, decl);
        }
        if (argDecl.typeExpr && ((argDecl.typeExpr).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (argDecl.typeExpr).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((argDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.preCollectParameterDecl = preCollectParameterDecl;
    function preCollectTypeParameterDecl(typeParameterDecl, parentAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var span = TypeScript.TextSpan.fromBounds(typeParameterDecl.minChar, typeParameterDecl.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl(typeParameterDecl.name.text, TypeScript.PullElementKind.TypeParameter, declFlags, span, context.scriptName);
        context.semanticInfo.setASTForDecl(decl, typeParameterDecl);
        context.semanticInfo.setDeclForAST(typeParameterDecl, decl);
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);
        if (typeParameterDecl.constraint && ((typeParameterDecl.constraint).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (typeParameterDecl.constraint).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((typeParameterDecl.constraint).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.preCollectTypeParameterDecl = preCollectTypeParameterDecl;
    function createPropertySignature(propertyDecl, context) {
        var declFlags = TypeScript.PullElementFlags.Public;
        var parent = context.getParent();
        var declType = parent.getKind() == TypeScript.PullElementKind.Enum ? TypeScript.PullElementKind.EnumMember : TypeScript.PullElementKind.Property;
        if (TypeScript.hasFlag(propertyDecl.id.getFlags(), TypeScript.ASTFlags.OptionalName)) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        if (TypeScript.hasFlag(propertyDecl.getVarFlags(), TypeScript.VariableFlags.Constant)) {
            declFlags |= TypeScript.PullElementFlags.Constant;
        }
        var span = TypeScript.TextSpan.fromBounds(propertyDecl.minChar, propertyDecl.limChar);
        var decl = new TypeScript.PullDecl(propertyDecl.id.text, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(propertyDecl, decl);
        context.semanticInfo.setASTForDecl(decl, propertyDecl);
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);
        if (propertyDecl.typeExpr && ((propertyDecl.typeExpr).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (propertyDecl.typeExpr).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((propertyDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.createPropertySignature = createPropertySignature;
    function createMemberVariableDeclaration(memberDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Property;
        if (TypeScript.hasFlag(memberDecl.getVarFlags(), TypeScript.VariableFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        } else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        if (TypeScript.hasFlag(memberDecl.getVarFlags(), TypeScript.VariableFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        var span = TypeScript.TextSpan.fromBounds(memberDecl.minChar, memberDecl.limChar);
        var decl = new TypeScript.PullDecl(memberDecl.id.text, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberDecl, decl);
        context.semanticInfo.setASTForDecl(decl, memberDecl);
        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);
        if (memberDecl.typeExpr && ((memberDecl.typeExpr).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (memberDecl.typeExpr).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((memberDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.createMemberVariableDeclaration = createMemberVariableDeclaration;
    function createVariableDeclaration(varDecl, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Variable;
        if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Ambient)) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Exported)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        var span = TypeScript.TextSpan.fromBounds(varDecl.minChar, varDecl.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl(varDecl.id.text, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(varDecl, decl);
        context.semanticInfo.setASTForDecl(decl, varDecl);
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);
        if (varDecl.typeExpr && ((varDecl.typeExpr).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (varDecl.typeExpr).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((varDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.createVariableDeclaration = createVariableDeclaration;
    function preCollectVarDecls(ast, parentAST, context) {
        var varDecl = ast;
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Variable;
        var isProperty = false;
        var isStatic = false;
        if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.ClassProperty)) {
            return createMemberVariableDeclaration(varDecl, context);
        } else if (TypeScript.hasFlag(varDecl.getVarFlags(), TypeScript.VariableFlags.Property)) {
            return createPropertySignature(varDecl, context);
        }
        return createVariableDeclaration(varDecl, context);
    }
    TypeScript.preCollectVarDecls = preCollectVarDecls;
    function createFunctionTypeDeclaration(functionTypeDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.FunctionType;
        var span = TypeScript.TextSpan.fromBounds(functionTypeDeclAST.minChar, functionTypeDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(functionTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionTypeDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (functionTypeDeclAST.returnTypeAnnotation && ((functionTypeDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (functionTypeDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((functionTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createFunctionTypeDeclaration = createFunctionTypeDeclaration;
    function createConstructorTypeDeclaration(constructorTypeDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.ConstructorType;
        var span = TypeScript.TextSpan.fromBounds(constructorTypeDeclAST.minChar, constructorTypeDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("{new}", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(constructorTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorTypeDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (constructorTypeDeclAST.returnTypeAnnotation && ((constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((constructorTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createConstructorTypeDeclaration = createConstructorTypeDeclaration;
    function createFunctionDeclaration(funcDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Function;
        if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Ambient)) {
            declFlags |= TypeScript.PullElementFlags.Ambient;
        }
        if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Exported)) {
            declFlags |= TypeScript.PullElementFlags.Exported;
        }
        if (!funcDeclAST.block) {
            declFlags |= TypeScript.PullElementFlags.Signature;
        }
        var span = TypeScript.TextSpan.fromBounds(funcDeclAST.minChar, funcDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl(funcDeclAST.name.text, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(funcDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, funcDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (funcDeclAST.returnTypeAnnotation && ((funcDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (funcDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((funcDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createFunctionDeclaration = createFunctionDeclaration;
    function createFunctionExpressionDeclaration(functionExpressionDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        if (TypeScript.hasFlag(functionExpressionDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.IsFatArrowFunction)) {
            declFlags |= TypeScript.PullElementFlags.FatArrow;
        }
        var span = TypeScript.TextSpan.fromBounds(functionExpressionDeclAST.minChar, functionExpressionDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("", TypeScript.PullElementKind.FunctionExpression, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(functionExpressionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionExpressionDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (functionExpressionDeclAST.returnTypeAnnotation && ((functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((functionExpressionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createFunctionExpressionDeclaration = createFunctionExpressionDeclaration;
    function createMemberFunctionDeclaration(memberFunctionDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.Method;
        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        } else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        if (!memberFunctionDeclAST.block) {
            declFlags |= TypeScript.PullElementFlags.Signature;
        }
        if (TypeScript.hasFlag(memberFunctionDeclAST.name.getFlags(), TypeScript.ASTFlags.OptionalName)) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        var span = TypeScript.TextSpan.fromBounds(memberFunctionDeclAST.minChar, memberFunctionDeclAST.limChar);
        var decl = new TypeScript.PullDecl(memberFunctionDeclAST.name.text, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberFunctionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, memberFunctionDeclAST);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (memberFunctionDeclAST.returnTypeAnnotation && ((memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((memberFunctionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createMemberFunctionDeclaration = createMemberFunctionDeclaration;
    function createIndexSignatureDeclaration(indexSignatureDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Signature | TypeScript.PullElementFlags.Index;
        var declType = TypeScript.PullElementKind.IndexSignature;
        var span = TypeScript.TextSpan.fromBounds(indexSignatureDeclAST.minChar, indexSignatureDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("[]", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(indexSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, indexSignatureDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (indexSignatureDeclAST.returnTypeAnnotation && ((indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((indexSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createIndexSignatureDeclaration = createIndexSignatureDeclaration;
    function createCallSignatureDeclaration(callSignatureDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Signature | TypeScript.PullElementFlags.Call;
        var declType = TypeScript.PullElementKind.CallSignature;
        var span = TypeScript.TextSpan.fromBounds(callSignatureDeclAST.minChar, callSignatureDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("()", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(callSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, callSignatureDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (callSignatureDeclAST.returnTypeAnnotation && ((callSignatureDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (callSignatureDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((callSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createCallSignatureDeclaration = createCallSignatureDeclaration;
    function createConstructSignatureDeclaration(constructSignatureDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Signature | TypeScript.PullElementFlags.Call;
        var declType = TypeScript.PullElementKind.ConstructSignature;
        var span = TypeScript.TextSpan.fromBounds(constructSignatureDeclAST.minChar, constructSignatureDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("new", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructSignatureDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (constructSignatureDeclAST.returnTypeAnnotation && ((constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((constructSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createConstructSignatureDeclaration = createConstructSignatureDeclaration;
    function createClassConstructorDeclaration(constructorDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Constructor;
        var declType = TypeScript.PullElementKind.ConstructorMethod;
        if (!constructorDeclAST.block) {
            declFlags |= TypeScript.PullElementFlags.Signature;
        }
        var span = TypeScript.TextSpan.fromBounds(constructorDeclAST.minChar, constructorDeclAST.limChar);
        var parent = context.getParent();
        if (parent) {
            var parentFlags = parent.getFlags();
            if (parentFlags & TypeScript.PullElementFlags.Exported) {
                declFlags |= TypeScript.PullElementFlags.Exported;
            }
        }
        var decl = new TypeScript.PullDecl(constructorDeclAST.name.text, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (constructorDeclAST.returnTypeAnnotation && ((constructorDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (constructorDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((constructorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createClassConstructorDeclaration = createClassConstructorDeclaration;
    function createGetAccessorDeclaration(getAccessorDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Public;
        var declType = TypeScript.PullElementKind.GetAccessor;
        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        if (TypeScript.hasFlag(getAccessorDeclAST.name.getFlags(), TypeScript.ASTFlags.OptionalName)) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        } else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        var span = TypeScript.TextSpan.fromBounds(getAccessorDeclAST.minChar, getAccessorDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl(getAccessorDeclAST.name.text, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(getAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, getAccessorDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        if (getAccessorDeclAST.returnTypeAnnotation && ((getAccessorDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.InterfaceDeclaration || (getAccessorDeclAST.returnTypeAnnotation).term.nodeType == TypeScript.NodeType.FunctionDeclaration)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((getAccessorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createGetAccessorDeclaration = createGetAccessorDeclaration;
    function createSetAccessorDeclaration(setAccessorDeclAST, context) {
        var declFlags = TypeScript.PullElementFlags.Public;
        var declType = TypeScript.PullElementKind.SetAccessor;
        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Static)) {
            declFlags |= TypeScript.PullElementFlags.Static;
        }
        if (TypeScript.hasFlag(setAccessorDeclAST.name.getFlags(), TypeScript.ASTFlags.OptionalName)) {
            declFlags |= TypeScript.PullElementFlags.Optional;
        }
        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), TypeScript.FunctionFlags.Private)) {
            declFlags |= TypeScript.PullElementFlags.Private;
        } else {
            declFlags |= TypeScript.PullElementFlags.Public;
        }
        var span = TypeScript.TextSpan.fromBounds(setAccessorDeclAST.minChar, setAccessorDeclAST.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl(setAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(setAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, setAccessorDeclAST);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        return true;
    }
    TypeScript.createSetAccessorDeclaration = createSetAccessorDeclaration;
    function preCollectCatchDecls(ast, parentAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.CatchBlock;
        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);
        var parent = context.getParent();
        if (parent && (parent.getKind() == TypeScript.PullElementKind.WithBlock || (parent.getFlags() & TypeScript.PullElementFlags.DeclaredInAWithBlock))) {
            declFlags |= TypeScript.PullElementFlags.DeclaredInAWithBlock;
        }
        var decl = new TypeScript.PullDecl("", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        return true;
    }
    TypeScript.preCollectCatchDecls = preCollectCatchDecls;
    function preCollectWithDecls(ast, parentAST, context) {
        var declFlags = TypeScript.PullElementFlags.None;
        var declType = TypeScript.PullElementKind.WithBlock;
        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);
        var parent = context.getParent();
        var decl = new TypeScript.PullDecl("", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }
        context.pushParent(decl);
        return true;
    }
    TypeScript.preCollectWithDecls = preCollectWithDecls;
    function preCollectFuncDecls(ast, parentAST, context) {
        var funcDecl = ast;
        if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), (TypeScript.FunctionFlags.IsFunctionExpression | TypeScript.FunctionFlags.IsFatArrowFunction))) {
            return createFunctionExpressionDeclaration(funcDecl, context);
        } else if (funcDecl.isConstructor) {
            return createClassConstructorDeclaration(funcDecl, context);
        } else if (funcDecl.isGetAccessor()) {
            return createGetAccessorDeclaration(funcDecl, context);
        } else if (funcDecl.isSetAccessor()) {
            return createSetAccessorDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ConstructMember)) {
            return TypeScript.hasFlag(funcDecl.getFlags(), TypeScript.ASTFlags.TypeReference) ? createConstructorTypeDeclaration(funcDecl, context) : createConstructSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.CallMember)) {
            return createCallSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.IndexerMember)) {
            return createIndexSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFlags(), TypeScript.ASTFlags.TypeReference)) {
            return createFunctionTypeDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.Method) || TypeScript.hasFlag(funcDecl.getFunctionFlags(), TypeScript.FunctionFlags.ClassMethod)) {
            return createMemberFunctionDeclaration(funcDecl, context);
        }
        return createFunctionDeclaration(funcDecl, context);
    }
    TypeScript.preCollectFuncDecls = preCollectFuncDecls;
    function preCollectDecls(ast, parentAST, walker) {
        var context = walker.state;
        var go = false;
        if (ast.nodeType == TypeScript.NodeType.Script) {
            var script = ast;
            var span = TypeScript.TextSpan.fromBounds(script.minChar, script.limChar);
            var decl = new TypeScript.PullDecl(context.scriptName, TypeScript.PullElementKind.Script, TypeScript.PullElementFlags.None, span, context.scriptName);
            context.semanticInfo.setDeclForAST(ast, decl);
            context.semanticInfo.setASTForDecl(decl, ast);
            context.pushParent(decl);
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.List) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.Block) {
            go = true;
        } else if (ast.nodeType === TypeScript.NodeType.VariableDeclaration) {
            go = true;
        } else if (ast.nodeType === TypeScript.NodeType.VariableStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.ModuleDeclaration) {
            go = preCollectModuleDecls(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.ClassDeclaration) {
            go = preCollectClassDecls(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.InterfaceDeclaration) {
            go = preCollectInterfaceDecls(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.Parameter) {
            go = preCollectParameterDecl(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.VariableDeclarator) {
            go = preCollectVarDecls(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.FunctionDeclaration) {
            go = preCollectFuncDecls(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.ImportDeclaration) {
            go = preCollectImportDecls(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.TypeParameter) {
            go = preCollectTypeParameterDecl(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.IfStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.ForStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.ForInStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.WhileStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.DoStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.CommaExpression) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.ReturnStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.SwitchStatement || ast.nodeType == TypeScript.NodeType.CaseClause) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.InvocationExpression) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.ObjectCreationExpression) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.TryStatement) {
            go = true;
        } else if (ast.nodeType == TypeScript.NodeType.CatchClause) {
            go = preCollectCatchDecls(ast, parentAST, context);
        } else if (ast.nodeType == TypeScript.NodeType.WithStatement) {
            go = preCollectWithDecls(ast, parentAST, context);
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.preCollectDecls = preCollectDecls;
    function isContainer(decl) {
        return decl.getKind() == TypeScript.PullElementKind.Container || decl.getKind() == TypeScript.PullElementKind.DynamicModule;
    }
    function getInitializationFlag(decl) {
        if (decl.getKind() & TypeScript.PullElementKind.Container) {
            return TypeScript.PullElementFlags.InitializedModule;
        } else if (decl.getKind() & TypeScript.PullElementKind.DynamicModule) {
            return TypeScript.PullElementFlags.InitializedDynamicModule;
        }
        return TypeScript.PullElementFlags.None;
    }
    function hasInitializationFlag(decl) {
        if (decl.getKind() & TypeScript.PullElementKind.Container) {
            return (decl.getFlags() & TypeScript.PullElementFlags.InitializedModule) !== 0;
        } else if (decl.getKind() & TypeScript.PullElementKind.DynamicModule) {
            return (decl.getFlags() & TypeScript.PullElementFlags.InitializedDynamicModule) !== 0;
        }
        return false;
    }
    function postCollectDecls(ast, parentAST, walker) {
        var context = walker.state;
        var parentDecl;
        var initFlag = TypeScript.PullElementFlags.None;
        if (ast.nodeType == TypeScript.NodeType.ModuleDeclaration) {
            var thisModule = context.getParent();
            context.popParent();
            parentDecl = context.getParent();
            if (hasInitializationFlag(thisModule)) {
                if (parentDecl && isContainer(parentDecl)) {
                    initFlag = getInitializationFlag(parentDecl);
                    parentDecl.setFlags(parentDecl.getFlags() | initFlag);
                }
                var valueDecl = new TypeScript.PullDecl(thisModule.getName(), TypeScript.PullElementKind.Variable, thisModule.getFlags(), thisModule.getSpan(), context.scriptName);
                thisModule.setValueDecl(valueDecl);
                context.semanticInfo.setASTForDecl(valueDecl, ast);
                if (parentDecl) {
                    parentDecl.addChildDecl(valueDecl);
                    valueDecl.setParentDecl(parentDecl);
                }
            }
        } else if (ast.nodeType == TypeScript.NodeType.ClassDeclaration) {
            context.popParent();
            parentDecl = context.getParent();
            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        } else if (ast.nodeType == TypeScript.NodeType.InterfaceDeclaration) {
            context.popParent();
        } else if (ast.nodeType == TypeScript.NodeType.FunctionDeclaration) {
            context.popParent();
            parentDecl = context.getParent();
            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        } else if (ast.nodeType == TypeScript.NodeType.VariableDeclarator) {
            parentDecl = context.getParent();
            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        } else if (ast.nodeType == TypeScript.NodeType.CatchClause) {
            parentDecl = context.getParent();
            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
            context.popParent();
        } else if (ast.nodeType == TypeScript.NodeType.WithStatement) {
            parentDecl = context.getParent();
            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
            context.popParent();
        }
        return ast;
    }
    TypeScript.postCollectDecls = postCollectDecls;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.globalBindingPhase = 0;
    var PullSymbolBinder = (function () {
        function PullSymbolBinder(compilationSettings, semanticInfoChain) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.parentChain = [];
            this.parentDeclChain = [];
            this.declPath = [];
            this.bindingPhase = TypeScript.globalBindingPhase++;
            this.staticClassMembers = [];
            this.functionTypeParameterCache = {};
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.startingSymbolForRebind = TypeScript.pullSymbolID;
        }
        PullSymbolBinder.prototype.findTypeParameterInCache = function (name) {
            return this.functionTypeParameterCache[name];
        };
        PullSymbolBinder.prototype.addTypeParameterToCache = function (typeParameter) {
            this.functionTypeParameterCache[typeParameter.getName()] = typeParameter;
        };
        PullSymbolBinder.prototype.resetTypeParameterCache = function () {
            this.functionTypeParameterCache = {};
        };
        PullSymbolBinder.prototype.setUnit = function (fileName) {
            this.semanticInfo = this.semanticInfoChain.getUnit(fileName);
        };
        PullSymbolBinder.prototype.getParent = function (returnInstanceType) {
            if (typeof returnInstanceType === "undefined") { returnInstanceType = false; }
            var parent = this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
            if (parent && parent.isContainer() && returnInstanceType) {
                var instanceSymbol = (parent).getInstanceSymbol();
                if (instanceSymbol) {
                    parent = instanceSymbol.getType();
                }
            }
            return parent;
        };
        PullSymbolBinder.prototype.getParentDecl = function () {
            return this.parentDeclChain.length ? this.parentDeclChain[this.parentDeclChain.length - 1] : null;
        };
        PullSymbolBinder.prototype.getDeclPath = function () {
            return this.declPath;
        };
        PullSymbolBinder.prototype.pushParent = function (parentType, parentDecl) {
            if (parentType) {
                this.parentChain[this.parentChain.length] = parentType;
                this.parentDeclChain[this.parentDeclChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentType.getName();
            }
        };
        PullSymbolBinder.prototype.popParent = function () {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.parentDeclChain.length--;
                this.declPath.length--;
            }
        };
        PullSymbolBinder.prototype.findSymbolInContext = function (name, declKind, typeLookupPath) {
            var startTime = new Date().getTime();
            var contextSymbolPath = this.getDeclPath();
            var nestedSymbolPath = [];
            var copyOfContextSymbolPath = [];
            var symbol = null;
            var endTime = 0;
            if (typeLookupPath.length) {
                for(var i = 0; i < typeLookupPath.length; i++) {
                    nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
                }
                nestedSymbolPath[nestedSymbolPath.length] = name;
                while(nestedSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);
                    if (symbol) {
                        endTime = new Date().getTime();
                        TypeScript.time_in_findSymbol += endTime - startTime;
                        return symbol;
                    }
                    nestedSymbolPath.length -= 2;
                    nestedSymbolPath[nestedSymbolPath.length] = name;
                }
            }
            if (contextSymbolPath.length) {
                for(var i = 0; i < contextSymbolPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
                }
                for(var i = 0; i < typeLookupPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
                }
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
                while(copyOfContextSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);
                    if (symbol) {
                        endTime = new Date().getTime();
                        TypeScript.time_in_findSymbol += endTime - startTime;
                        return symbol;
                    }
                    copyOfContextSymbolPath.length -= 2;
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
                }
            }
            symbol = this.semanticInfoChain.findSymbol([
                name
            ], declKind);
            endTime = new Date().getTime();
            TypeScript.time_in_findSymbol += endTime - startTime;
            return symbol;
        };
        PullSymbolBinder.prototype.symbolIsRedeclaration = function (sym) {
            var symID = sym.getSymbolID();
            return (symID > this.startingSymbolForRebind) || ((sym.getRebindingID() == this.bindingPhase) && (symID != this.startingSymbolForRebind));
        };
        PullSymbolBinder.prototype.bindModuleDeclarationToPullSymbol = function (moduleContainerDecl) {
            var modName = moduleContainerDecl.getName();
            var moduleContainerTypeSymbol = null;
            var moduleInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;
            var moduleInstanceDecl = moduleContainerDecl.getValueDecl();
            var moduleKind = moduleContainerDecl.getKind();
            var parent = this.getParent();
            var parentInstanceSymbol = this.getParent(true);
            var moduleAST = this.semanticInfo.getASTForDecl(moduleContainerDecl);
            var isExported = moduleContainerDecl.getFlags() & TypeScript.PullElementFlags.Exported;
            var createdNewSymbol = false;
            if (parent) {
                if (isExported) {
                    moduleContainerTypeSymbol = parent.findNestedType(modName, TypeScript.PullElementKind.SomeType);
                } else {
                    moduleContainerTypeSymbol = parent.findContainedMember(modName);
                }
            } else if (!isExported || moduleContainerDecl.getKind() == TypeScript.PullElementKind.DynamicModule) {
                moduleContainerTypeSymbol = this.findSymbolInContext(modName, TypeScript.PullElementKind.SomeType, []);
            }
            if (moduleContainerTypeSymbol && moduleContainerTypeSymbol.getKind() != moduleKind) {
                moduleContainerDecl.addDiagnostic(new TypeScript.PullDiagnostic(moduleAST.minChar, moduleAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    modName
                ])));
                moduleContainerTypeSymbol = null;
            }
            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            } else {
                moduleContainerTypeSymbol = new TypeScript.PullContainerTypeSymbol(modName, moduleKind);
                createdNewSymbol = true;
            }
            if (!moduleInstanceSymbol && (moduleContainerDecl.getFlags() & TypeScript.PullElementFlags.SomeInitializedModule)) {
                moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol(modName, TypeScript.PullElementKind.ObjectType);
                moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);
                moduleInstanceTypeSymbol.setAssociatedContainerType(moduleContainerTypeSymbol);
                moduleInstanceSymbol = new TypeScript.PullSymbol(modName, TypeScript.PullElementKind.Variable);
                moduleInstanceSymbol.setType(moduleInstanceTypeSymbol);
                moduleInstanceSymbol.addDeclaration(moduleContainerDecl);
                moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);
            } else if (moduleInstanceSymbol) {
                moduleInstanceSymbol.addDeclaration(moduleContainerDecl);
            }
            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST.name, moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST, moduleContainerTypeSymbol);
            if (createdNewSymbol) {
                if (parent) {
                    var linkKind = moduleContainerDecl.getFlags() & TypeScript.PullElementFlags.Exported ? TypeScript.SymbolLinkKind.PublicMember : TypeScript.SymbolLinkKind.PrivateMember;
                    if (linkKind == TypeScript.SymbolLinkKind.PublicMember) {
                        parent.addMember(moduleContainerTypeSymbol, linkKind);
                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            parentInstanceSymbol.addMember(moduleInstanceSymbol, linkKind);
                        }
                    } else {
                        moduleContainerTypeSymbol.setContainer(parent);
                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            moduleInstanceSymbol.setContainer(parentInstanceSymbol);
                        }
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = moduleContainerTypeSymbol.getDeclarations();
                var scriptName = moduleContainerDecl.getScriptName();
                for(var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        moduleContainerTypeSymbol.removeDeclaration(decls[i]);
                    }
                }
                if (moduleInstanceSymbol) {
                    decls = moduleInstanceSymbol.getDeclarations();
                    for(var i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceSymbol.removeDeclaration(decls[i]);
                        }
                    }
                    moduleInstanceTypeSymbol = moduleInstanceSymbol.getType();
                    decls = moduleInstanceTypeSymbol.getDeclarations();
                    for(var i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceTypeSymbol.removeDeclaration(decls[i]);
                        }
                    }
                    moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);
                    moduleInstanceSymbol.invalidate();
                }
                moduleContainerTypeSymbol.invalidate();
            }
            this.pushParent(moduleContainerTypeSymbol, moduleContainerDecl);
            var childDecls = moduleContainerDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
        };
        PullSymbolBinder.prototype.bindImportDeclaration = function (importDeclaration) {
            var declFlags = importDeclaration.getFlags();
            var declKind = importDeclaration.getKind();
            var importDeclAST = this.semanticInfo.getASTForDecl(importDeclaration);
            var isExported = false;
            var linkKind = TypeScript.SymbolLinkKind.PrivateMember;
            var importSymbol = null;
            var declName = importDeclaration.getName();
            var parentHadSymbol = false;
            var parent = this.getParent();
            if (parent) {
                importSymbol = parent.findMember(declName, false);
                if (!importSymbol) {
                    importSymbol = parent.findContainedMember(declName);
                    if (importSymbol) {
                        var declarations = importSymbol.getDeclarations();
                        if (declarations.length) {
                            var importSymbolParent = declarations[0].getParentDecl();
                            if ((importSymbolParent != importDeclaration.getParentDecl()) && (!this.reBindingAfterChange || (importSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                importSymbol = null;
                            }
                        }
                    }
                }
            } else if (!(importDeclaration.getFlags() & TypeScript.PullElementFlags.Exported)) {
                importSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, []);
            }
            if (importSymbol) {
                parentHadSymbol = true;
            }
            if (importSymbol && this.symbolIsRedeclaration(importSymbol)) {
                importDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(importDeclAST.minChar, importDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    declName
                ])));
                importSymbol = null;
            }
            if (this.reBindingAfterChange && importSymbol) {
                var decls = importSymbol.getDeclarations();
                var scriptName = importDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        importSymbol.removeDeclaration(decls[j]);
                    }
                }
                importSymbol.setUnresolved();
            }
            if (!importSymbol) {
                importSymbol = new TypeScript.PullTypeAliasSymbol(declName);
            }
            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);
            this.semanticInfo.setSymbolForAST(importDeclAST, importSymbol);
            if (parent && !parentHadSymbol) {
                if (declFlags & TypeScript.PullElementFlags.Exported) {
                    parent.addMember(importSymbol, TypeScript.SymbolLinkKind.PublicMember);
                } else {
                    importSymbol.setContainer(parent);
                }
            }
            importSymbol.setIsBound(this.bindingPhase);
        };
        PullSymbolBinder.prototype.bindEnumDeclarationToPullSymbol = function (enumDeclaration) {
            var enumName = enumDeclaration.getName();
            var enumSymbol = this.findSymbolInContext(enumName, TypeScript.PullElementKind.Enum, []);
            var enumAST = this.semanticInfo.getASTForDecl(enumDeclaration);
            var createdNewSymbol = false;
            var parent = this.getParent();
            if (parent) {
                enumSymbol = parent.findNestedType(enumName);
            } else if (!(enumDeclaration.getFlags() & TypeScript.PullElementFlags.Exported)) {
                enumSymbol = this.findSymbolInContext(enumName, TypeScript.PullElementKind.SomeType, []);
            }
            if (enumSymbol && (enumSymbol.getKind() != TypeScript.PullElementKind.Enum || !this.reBindingAfterChange || this.symbolIsRedeclaration(enumSymbol))) {
                enumDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(enumAST.minChar, enumAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    enumName
                ])));
                enumSymbol = null;
            }
            if (!enumSymbol) {
                enumSymbol = new TypeScript.PullTypeSymbol(enumName, TypeScript.PullElementKind.Enum);
                enumSymbol.addDeclaration(enumDeclaration);
                enumDeclaration.setSymbol(enumSymbol);
                createdNewSymbol = true;
            }
            enumSymbol.addDeclaration(enumDeclaration);
            enumDeclaration.setSymbol(enumSymbol);
            this.semanticInfo.setSymbolForAST(enumAST.name, enumSymbol);
            this.semanticInfo.setSymbolForAST(enumAST, enumSymbol);
            if (createdNewSymbol) {
                if (parent) {
                    var linkKind = enumDeclaration.getFlags() & TypeScript.PullElementFlags.Exported ? TypeScript.SymbolLinkKind.PublicMember : TypeScript.SymbolLinkKind.PrivateMember;
                    if (linkKind == TypeScript.SymbolLinkKind.PublicMember) {
                        parent.addMember(enumSymbol, linkKind);
                    } else {
                        enumSymbol.setContainer(parent);
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = enumSymbol.getDeclarations();
                var scriptName = enumDeclaration.getScriptName();
                for(var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        enumSymbol.removeDeclaration(decls[i]);
                    }
                }
                enumSymbol.invalidate();
            }
            this.pushParent(enumSymbol, enumDeclaration);
            var childDecls = enumDeclaration.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
            enumSymbol.setIsBound(this.bindingPhase);
        };
        PullSymbolBinder.prototype.cleanInterfaceSignatures = function (interfaceSymbol) {
            var callSigs = interfaceSymbol.getCallSignatures();
            var constructSigs = interfaceSymbol.getConstructSignatures();
            var indexSigs = interfaceSymbol.getIndexSignatures();
            for(var i = 0; i < callSigs.length; i++) {
                if (callSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    interfaceSymbol.removeCallSignature(callSigs[i], false);
                }
            }
            for(var i = 0; i < constructSigs.length; i++) {
                if (constructSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    interfaceSymbol.removeConstructSignature(constructSigs[i], false);
                }
            }
            for(var i = 0; i < indexSigs.length; i++) {
                if (indexSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    interfaceSymbol.removeIndexSignature(indexSigs[i], false);
                }
            }
            interfaceSymbol.recomputeCallSignatures();
            interfaceSymbol.recomputeConstructSignatures();
            interfaceSymbol.recomputeIndexSignatures();
        };
        PullSymbolBinder.prototype.cleanClassSignatures = function (classSymbol) {
            var callSigs = classSymbol.getCallSignatures();
            var constructSigs = classSymbol.getConstructSignatures();
            var indexSigs = classSymbol.getIndexSignatures();
            for(var i = 0; i < callSigs.length; i++) {
                classSymbol.removeCallSignature(callSigs[i], false);
            }
            for(var i = 0; i < constructSigs.length; i++) {
                classSymbol.removeConstructSignature(constructSigs[i], false);
            }
            for(var i = 0; i < indexSigs.length; i++) {
                classSymbol.removeIndexSignature(indexSigs[i], false);
            }
            classSymbol.recomputeCallSignatures();
            classSymbol.recomputeConstructSignatures();
            classSymbol.recomputeIndexSignatures();
            var constructorSymbol = classSymbol.getConstructorMethod();
            var constructorTypeSymbol = (constructorSymbol ? constructorSymbol.getType() : null);
            if (constructorTypeSymbol) {
                constructSigs = constructorTypeSymbol.getConstructSignatures();
                for(var i = 0; i < constructSigs.length; i++) {
                    constructorTypeSymbol.removeConstructSignature(constructSigs[i], false);
                }
                constructorTypeSymbol.recomputeConstructSignatures();
                constructorTypeSymbol.invalidate();
                constructorSymbol.invalidate();
            }
            classSymbol.invalidate();
        };
        PullSymbolBinder.prototype.bindClassDeclarationToPullSymbol = function (classDecl) {
            var className = classDecl.getName();
            var classSymbol = null;
            var constructorSymbol = null;
            var constructorTypeSymbol = null;
            var classAST = this.semanticInfo.getASTForDecl(classDecl);
            var parentHadSymbol = false;
            var parent = this.getParent();
            var cleanedPreviousDecls = false;
            var isExported = classDecl.getFlags() & TypeScript.PullElementFlags.Exported;
            var isGeneric = false;
            if (parent) {
                if (isExported) {
                    classSymbol = parent.findNestedType(className);
                    if (!classSymbol) {
                        classSymbol = parent.findMember(className, false);
                    }
                } else {
                    classSymbol = parent.findContainedMember(className);
                    if (classSymbol) {
                        var declarations = classSymbol.getDeclarations();
                        if (declarations.length) {
                            var classSymbolParent = declarations[0].getParentDecl();
                            if ((classSymbolParent != this.getParentDecl()) && (!this.reBindingAfterChange || (classSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                classSymbol = null;
                            }
                        }
                    }
                }
            } else {
                classSymbol = this.findSymbolInContext(className, TypeScript.PullElementKind.SomeType, []);
            }
            if (classSymbol && (classSymbol.getKind() != TypeScript.PullElementKind.Class || !this.reBindingAfterChange || this.symbolIsRedeclaration(classSymbol))) {
                classDecl.addDiagnostic(new TypeScript.PullDiagnostic(classAST.minChar, classAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    className
                ])));
                classSymbol = null;
            } else if (classSymbol) {
                parentHadSymbol = true;
            }
            var decls;
            if (this.reBindingAfterChange && classSymbol) {
                decls = classSymbol.getDeclarations();
                var scriptName = classDecl.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        classSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                constructorSymbol = classSymbol.getConstructorMethod();
                constructorTypeSymbol = constructorSymbol.getType();
                decls = constructorSymbol.getDeclarations();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        constructorSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                if (constructorSymbol.getIsSynthesized()) {
                    classSymbol.setConstructorMethod(null);
                }
                if (classSymbol.isGeneric()) {
                    isGeneric = true;
                    var specializations = classSymbol.getKnownSpecializations();
                    var specialization = null;
                    for(var i = 0; i < specializations.length; i++) {
                        specialization = specializations[i];
                        decls = specialization.getDeclarations();
                        for(var j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specialization.removeDeclaration(decls[j]);
                                cleanedPreviousDecls = true;
                            }
                        }
                        specialization.addDeclaration(classDecl);
                        specialization.setUnresolved();
                    }
                    classSymbol.cleanTypeParameters();
                    constructorTypeSymbol.cleanTypeParameters();
                }
                classSymbol.setUnresolved();
                constructorSymbol.setUnresolved();
                constructorTypeSymbol.setUnresolved();
            }
            if (!parentHadSymbol) {
                classSymbol = new TypeScript.PullClassTypeSymbol(className);
            }
            classSymbol.addDeclaration(classDecl);
            classDecl.setSymbol(classSymbol);
            this.semanticInfo.setSymbolForAST(classAST.name, classSymbol);
            this.semanticInfo.setSymbolForAST(classAST, classSymbol);
            if (parent && !parentHadSymbol) {
                var linkKind = classDecl.getFlags() & TypeScript.PullElementFlags.Exported ? TypeScript.SymbolLinkKind.PublicMember : TypeScript.SymbolLinkKind.PrivateMember;
                if (linkKind == TypeScript.SymbolLinkKind.PublicMember) {
                    parent.addMember(classSymbol, linkKind);
                } else {
                    classSymbol.setContainer(parent);
                }
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                this.cleanClassSignatures(classSymbol);
                if (isGeneric) {
                    specializations = classSymbol.getKnownSpecializations();
                    for(var i = 0; i < specializations.length; i++) {
                        this.cleanClassSignatures(specializations[i]);
                    }
                }
            }
            this.pushParent(classSymbol, classDecl);
            var childDecls = classDecl.getChildDecls();
            this.resetTypeParameterCache();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.resetTypeParameterCache();
            this.popParent();
            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = (constructorSymbol ? constructorSymbol.getType() : null);
            if (!constructorSymbol) {
                constructorSymbol = new TypeScript.PullSymbol(className, TypeScript.PullElementKind.ConstructorMethod);
                constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();
                constructorSymbol.setIsSynthesized();
                constructorSymbol.setType(constructorTypeSymbol);
                constructorSymbol.addDeclaration(classDecl);
                classSymbol.setConstructorMethod(constructorSymbol);
                constructorTypeSymbol.addDeclaration(classDecl);
                classSymbol.setHasDefaultConstructor();
                if (!classAST.extendsList || !classAST.extendsList.members.length) {
                    var constructorSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
                    constructorSignature.setReturnType(classSymbol);
                    constructorTypeSymbol.addConstructSignature(constructorSignature);
                    constructorSignature.addDeclaration(classDecl);
                }
            }
            constructorTypeSymbol.setAssociatedContainerType(classSymbol);
            if (this.staticClassMembers.length) {
                var member;
                var isPrivate = false;
                var memberMap = {};
                var memberDecl;
                var memberAST;
                for(var i = 0; i < this.staticClassMembers.length; i++) {
                    member = this.staticClassMembers[i];
                    if (memberMap[member.getName()]) {
                        memberDecl = member.getDeclarations()[0];
                        memberAST = this.semanticInfo.getASTForDecl(memberDecl);
                        memberDecl.addDiagnostic(new TypeScript.PullDiagnostic(memberAST.minChar, memberAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                            member.getName()
                        ])));
                    } else {
                        memberMap[member.getName()] = true;
                    }
                    isPrivate = member.hasFlag(TypeScript.PullElementFlags.Private);
                    constructorTypeSymbol.addMember(member, isPrivate ? TypeScript.SymbolLinkKind.PrivateMember : TypeScript.SymbolLinkKind.PublicMember);
                }
                this.staticClassMembers.length = 0;
            }
            var typeParameters = classDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = classSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    classSymbol.addMember(typeParameter, TypeScript.SymbolLinkKind.TypeParameter);
                    constructorTypeSymbol.addTypeParameter(typeParameter, true);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            classSymbol.setIsBound(this.bindingPhase);
        };
        PullSymbolBinder.prototype.bindInterfaceDeclarationToPullSymbol = function (interfaceDecl) {
            var interfaceName = interfaceDecl.getName();
            var interfaceSymbol = this.findSymbolInContext(interfaceName, TypeScript.PullElementKind.SomeType, []);
            var interfaceAST = this.semanticInfo.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent();
            if (parent) {
                interfaceSymbol = parent.findNestedType(interfaceName);
            } else if (!(interfaceDecl.getFlags() & TypeScript.PullElementFlags.Exported)) {
                interfaceSymbol = this.findSymbolInContext(interfaceName, TypeScript.PullElementKind.SomeType, []);
            }
            if (interfaceSymbol && (interfaceSymbol.getKind() != TypeScript.PullElementKind.Interface)) {
                interfaceDecl.addDiagnostic(new TypeScript.PullDiagnostic(interfaceAST.minChar, interfaceAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    interfaceName
                ])));
                interfaceSymbol = null;
            }
            if (!interfaceSymbol) {
                interfaceSymbol = new TypeScript.PullTypeSymbol(interfaceName, TypeScript.PullElementKind.Interface);
                createdNewSymbol = true;
            }
            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);
            if (createdNewSymbol) {
                if (parent) {
                    var linkKind = interfaceDecl.getFlags() & TypeScript.PullElementFlags.Exported ? TypeScript.SymbolLinkKind.PublicMember : TypeScript.SymbolLinkKind.PrivateMember;
                    if (linkKind == TypeScript.SymbolLinkKind.PublicMember) {
                        parent.addMember(interfaceSymbol, linkKind);
                    } else {
                        interfaceSymbol.setContainer(parent);
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = interfaceSymbol.getDeclarations();
                var scriptName = interfaceDecl.getScriptName();
                for(var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        interfaceSymbol.removeDeclaration(decls[i]);
                    }
                }
                if (interfaceSymbol.isGeneric()) {
                    var specializations = interfaceSymbol.getKnownSpecializations();
                    var specialization = null;
                    for(var i = 0; i < specializations.length; i++) {
                        specialization = specializations[i];
                        decls = specialization.getDeclarations();
                        for(var j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specialization.removeDeclaration(decls[j]);
                            }
                        }
                        specialization.addDeclaration(interfaceDecl);
                        this.cleanInterfaceSignatures(specialization);
                    }
                    interfaceSymbol.cleanTypeParameters();
                    interfaceSymbol.setUnresolved();
                }
                this.cleanInterfaceSignatures(interfaceSymbol);
            }
            this.pushParent(interfaceSymbol, interfaceDecl);
            var childDecls = interfaceDecl.getChildDecls();
            this.resetTypeParameterCache();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.resetTypeParameterCache();
            this.popParent();
            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    interfaceSymbol.addMember(typeParameter, TypeScript.SymbolLinkKind.TypeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindObjectTypeDeclarationToPullSymbol = function (objectDecl) {
            var objectSymbolAST = this.semanticInfo.getASTForDecl(objectDecl);
            var objectSymbol = new TypeScript.PullTypeSymbol("", TypeScript.PullElementKind.ObjectType);
            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);
            this.semanticInfo.setSymbolForAST(objectSymbolAST, objectSymbol);
            this.pushParent(objectSymbol, objectDecl);
            var childDecls = objectDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
            var typeParameters = objectDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = objectSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    objectSymbol.addMember(typeParameter, TypeScript.SymbolLinkKind.TypeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindConstructorTypeDeclarationToPullSymbol = function (constructorTypeDeclaration) {
            var declKind = constructorTypeDeclaration.getKind();
            var declFlags = constructorTypeDeclaration.getFlags();
            var constructorTypeAST = this.semanticInfo.getASTForDecl(constructorTypeDeclaration);
            var constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();
            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfo.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);
            var signature = new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructorTypeDeclaration), constructorTypeSymbol, signature);
            constructorTypeSymbol.addSignature(signature);
            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    constructorTypeSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindVariableDeclarationToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.getFlags();
            var declKind = variableDeclaration.getKind();
            var varDeclAST = this.semanticInfo.getASTForDecl(variableDeclaration);
            var isExported = false;
            var linkKind = TypeScript.SymbolLinkKind.PrivateMember;
            var variableSymbol = null;
            var declName = variableDeclaration.getName();
            var parentHadSymbol = false;
            var parent = this.getParent(true);
            var parentDecl = variableDeclaration.getParentDecl();
            var isImplicit = (declFlags & TypeScript.PullElementFlags.ImplicitVariable) != 0;
            if (parentDecl && !isImplicit) {
                parentDecl.addVariableDeclToGroup(variableDeclaration);
            }
            if (parent) {
                variableSymbol = parent.findMember(declName, false);
                if (!variableSymbol) {
                    variableSymbol = parent.findContainedMember(declName);
                    if (variableSymbol && !variableSymbol.getIsSynthesized()) {
                        var declarations = variableSymbol.getDeclarations();
                        if (declarations.length) {
                            var variableSymbolParent = declarations[0].getParentDecl();
                            if ((this.getParentDecl() != variableSymbolParent) && (!this.reBindingAfterChange || (variableSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                variableSymbol = null;
                            }
                        }
                    }
                }
            } else if (!(variableDeclaration.getFlags() & TypeScript.PullElementFlags.Exported)) {
                variableSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeValue, []);
            }
            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }
            var span;
            var decl;
            var decls;
            var ast;
            var members;
            if (variableSymbol && this.symbolIsRedeclaration(variableSymbol)) {
                if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) == 0) {
                    span = variableDeclaration.getSpan();
                    if (!parent || variableSymbol.getIsSynthesized()) {
                        variableDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(span.start(), span.length(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                            declName
                        ])));
                    }
                    variableSymbol = null;
                    parentHadSymbol = false;
                }
            } else if (variableSymbol && (variableSymbol.getKind() != TypeScript.PullElementKind.Variable) && !isImplicit) {
                span = variableDeclaration.getSpan();
                variableDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(span.start(), span.length(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    declName
                ])));
                variableSymbol = null;
                parentHadSymbol = false;
            }
            if (this.reBindingAfterChange && variableSymbol && !variableSymbol.isType()) {
                decls = variableSymbol.getDeclarations();
                var scriptName = variableDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        variableSymbol.removeDeclaration(decls[j]);
                    }
                }
                variableSymbol.invalidate();
            }
            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) == 0) {
                if (!variableSymbol) {
                    variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                }
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST.id, variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST, variableSymbol);
            } else if (!parentHadSymbol) {
                if ((declFlags & TypeScript.PullElementFlags.ClassConstructorVariable)) {
                    var classTypeSymbol = variableSymbol;
                    if (parent) {
                        members = parent.getMembers();
                        for(var i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].getKind() == TypeScript.PullElementKind.Class)) {
                                classTypeSymbol = members[i];
                                break;
                            }
                        }
                    }
                    if (!classTypeSymbol) {
                        classTypeSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, []);
                        if (classTypeSymbol && (classTypeSymbol.getKind() != TypeScript.PullElementKind.Class)) {
                            classTypeSymbol = null;
                        }
                    }
                    if (classTypeSymbol && classTypeSymbol.isClass()) {
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);
                        decls = classTypeSymbol.getDeclarations();
                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);
                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                        }
                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);
                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                } else if (declFlags & TypeScript.PullElementFlags.SomeInitializedModule) {
                    var moduleContainerTypeSymbol = null;
                    var moduleParent = this.getParent(false);
                    if (moduleParent) {
                        members = moduleParent.getMembers();
                        for(var i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = members[i];
                                break;
                            }
                        }
                    }
                    if (!moduleContainerTypeSymbol) {
                        moduleContainerTypeSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, []);
                        if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                            moduleContainerTypeSymbol = null;
                        }
                    }
                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);
                        decls = moduleContainerTypeSymbol.getDeclarations();
                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);
                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                        parentHadSymbol = true;
                    } else {
                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            } else {
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
            }
            if (parent && !parentHadSymbol) {
                if (declFlags & TypeScript.PullElementFlags.Exported) {
                    parent.addMember(variableSymbol, TypeScript.SymbolLinkKind.PublicMember);
                } else {
                    variableSymbol.setContainer(parent);
                }
            }
            variableSymbol.setIsBound(this.bindingPhase);
        };
        PullSymbolBinder.prototype.bindPropertyDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.getFlags();
            var declKind = propertyDeclaration.getKind();
            var propDeclAST = this.semanticInfo.getASTForDecl(propertyDeclaration);
            var isStatic = false;
            var isOptional = false;
            var isImplicit = (declFlags & TypeScript.PullElementFlags.ImplicitVariable) != 0;
            var linkKind = TypeScript.SymbolLinkKind.PublicMember;
            var propertySymbol = null;
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Static)) {
                isStatic = true;
            }
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Private)) {
                linkKind = TypeScript.SymbolLinkKind.PrivateMember;
            }
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Optional)) {
                isOptional = true;
            }
            var declName = propertyDeclaration.getName();
            var parentHadSymbol = false;
            var replaceProperty = false;
            var previousProperty = null;
            var parent = this.getParent(true);
            if (parent.isClass() && isStatic) {
                for(var i = 0; i < this.staticClassMembers.length; i++) {
                    if (this.staticClassMembers[i].getName() == declName) {
                        propertySymbol = this.staticClassMembers[i];
                        break;
                    }
                }
            } else {
                propertySymbol = parent.findMember(declName, false);
            }
            if (propertySymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(propertySymbol))) {
                if (!propertySymbol.isType() || !isImplicit || (!(propertySymbol).isClass() && isImplicit)) {
                    var span = propertyDeclaration.getSpan();
                    propertyDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(span.start(), span.length(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                        declName
                    ])));
                }
                propertySymbol = null;
            }
            if (propertySymbol) {
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && propertySymbol) {
                var decls = propertySymbol.getDeclarations();
                var scriptName = propertyDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        propertySymbol.removeDeclaration(decls[j]);
                    }
                }
                propertySymbol.setUnresolved();
            }
            var classTypeSymbol;
            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) == 0) {
                if (!parentHadSymbol) {
                    propertySymbol = new TypeScript.PullSymbol(declName, declKind);
                }
                propertySymbol.addDeclaration(propertyDeclaration);
                propertyDeclaration.setSymbol(propertySymbol);
                this.semanticInfo.setSymbolForAST(propDeclAST.id, propertySymbol);
                this.semanticInfo.setSymbolForAST(propDeclAST, propertySymbol);
            } else {
                if (parent) {
                    var members = parent.getMembers();
                    for(var i = 0; i < members.length; i++) {
                        if ((members[i].getName() == declName) && (members[i].getKind() == TypeScript.PullElementKind.Class)) {
                            classTypeSymbol = members[i];
                            break;
                        }
                    }
                }
                if (!classTypeSymbol) {
                    classTypeSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, []);
                    if (classTypeSymbol && (classTypeSymbol.getKind() != TypeScript.PullElementKind.Class)) {
                        classTypeSymbol = null;
                    }
                }
                if (classTypeSymbol) {
                    replaceProperty = propertySymbol && propertySymbol.getIsSynthesized();
                    if (replaceProperty) {
                        previousProperty = propertySymbol;
                    }
                    propertySymbol = classTypeSymbol.getConstructorMethod();
                    propertyDeclaration.setSymbol(propertySymbol);
                } else {
                    propertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }
            }
            if (isOptional) {
                propertySymbol.setIsOptional();
            }
            if (parent && !parentHadSymbol) {
                if (parent.isClass()) {
                    classTypeSymbol = parent;
                    if (isStatic) {
                        this.staticClassMembers[this.staticClassMembers.length] = propertySymbol;
                    } else {
                        classTypeSymbol.addMember(propertySymbol, linkKind);
                    }
                } else {
                    parent.addMember(propertySymbol, linkKind);
                }
            } else if (replaceProperty) {
                parent.removeMember(previousProperty);
                parent.addMember(propertySymbol, linkKind);
            }
            propertySymbol.setIsBound(this.bindingPhase);
        };
        PullSymbolBinder.prototype.bindParameterSymbols = function (funcDecl, funcType, signatureSymbol) {
            var parameters = [];
            var decl = null;
            var argDecl = null;
            var parameterSymbol = null;
            var isProperty = false;
            var params = new TypeScript.BlockIntrinsics();
            if (funcDecl.arguments) {
                for(var i = 0; i < funcDecl.arguments.members.length; i++) {
                    argDecl = funcDecl.arguments.members[i];
                    decl = this.semanticInfo.getDeclForAST(argDecl);
                    isProperty = TypeScript.hasFlag(argDecl.getVarFlags(), TypeScript.VariableFlags.Property);
                    parameterSymbol = new TypeScript.PullSymbol(argDecl.id.text, TypeScript.PullElementKind.Parameter);
                    if (funcDecl.variableArgList && i == funcDecl.arguments.members.length - 1) {
                        parameterSymbol.setIsVarArg();
                    }
                    if (decl.getFlags() & TypeScript.PullElementFlags.Optional) {
                        parameterSymbol.setIsOptional();
                    }
                    if (params[argDecl.id.text]) {
                        decl.addDiagnostic(new TypeScript.PullDiagnostic(argDecl.minChar, argDecl.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                            argDecl.id.actualText
                        ])));
                    } else {
                        params[argDecl.id.text] = true;
                    }
                    if (decl) {
                        parameterSymbol.addDeclaration(decl);
                        decl.setSymbol(parameterSymbol);
                        var valDecl = decl.getValueDecl();
                        if (valDecl) {
                            valDecl.setSymbol(parameterSymbol);
                            parameterSymbol.addDeclaration(valDecl);
                        }
                    }
                    this.semanticInfo.setSymbolForAST(argDecl.id, parameterSymbol);
                    this.semanticInfo.setSymbolForAST(argDecl, parameterSymbol);
                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.getIsOptional());
                    if (signatureSymbol.isDefinition()) {
                        parameterSymbol.setContainer(funcType);
                    }
                }
            }
        };
        PullSymbolBinder.prototype.bindFunctionDeclarationToPullSymbol = function (functionDeclaration) {
            var declKind = functionDeclaration.getKind();
            var declFlags = functionDeclaration.getFlags();
            var funcDeclAST = this.semanticInfo.getASTForDecl(functionDeclaration);
            var isExported = (declFlags & TypeScript.PullElementFlags.Exported) != 0;
            var funcName = functionDeclaration.getName();
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) != 0;
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;
            var functionSymbol = null;
            var functionTypeSymbol = null;
            if (parent) {
                functionSymbol = parent.findMember(funcName, false);
                if (!functionSymbol) {
                    functionSymbol = parent.findContainedMember(funcName);
                    if (functionSymbol) {
                        var declarations = functionSymbol.getDeclarations();
                        if (declarations.length) {
                            var funcSymbolParent = declarations[0].getParentDecl();
                            if ((this.getParentDecl() != funcSymbolParent) && (!this.reBindingAfterChange || (funcSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                functionSymbol = null;
                            }
                        }
                    }
                }
            } else if (!(functionDeclaration.getFlags() & TypeScript.PullElementFlags.Exported)) {
                functionSymbol = this.findSymbolInContext(funcName, TypeScript.PullElementKind.SomeValue, []);
            }
            if (functionSymbol && (functionSymbol.getKind() != TypeScript.PullElementKind.Function || (this.symbolIsRedeclaration(functionSymbol) && !isSignature && !functionSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.Signature)))) {
                functionDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    funcName
                ])));
                functionSymbol = null;
            }
            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.getType();
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && functionSymbol) {
                var decls = functionSymbol.getDeclarations();
                var scriptName = functionDeclaration.getScriptName();
                var isGeneric = functionTypeSymbol.isGeneric();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        functionSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                decls = functionTypeSymbol.getDeclarations();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        functionTypeSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                if (isGeneric) {
                    var specializations = functionTypeSymbol.getKnownSpecializations();
                    for(var i = 0; i < specializations.length; i++) {
                        decls = specializations[i].getDeclarations();
                        for(var j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specializations[i].removeDeclaration(decls[j]);
                                specializations[i].addDeclaration(functionDeclaration);
                                specializations[i].invalidate();
                                cleanedPreviousDecls = true;
                            }
                        }
                    }
                }
                functionSymbol.invalidate();
                functionTypeSymbol.invalidate();
            }
            if (!functionSymbol) {
                functionSymbol = new TypeScript.PullSymbol(funcName, TypeScript.PullElementKind.Function);
            }
            if (!functionTypeSymbol) {
                functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                functionSymbol.setType(functionTypeSymbol);
            }
            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);
            this.semanticInfo.setSymbolForAST(funcDeclAST.name, functionSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, functionSymbol);
            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol, TypeScript.SymbolLinkKind.PublicMember);
                } else {
                    functionSymbol.setContainer(parent);
                }
            }
            if (!isSignature) {
                this.pushParent(functionTypeSymbol, functionDeclaration);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = functionTypeSymbol.getCallSignatures();
                for(var i = 0; i < callSigs.length; i++) {
                    functionTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                functionSymbol.invalidate();
                functionTypeSymbol.invalidate();
                functionTypeSymbol.recomputeCallSignatures();
            }
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);
            if (funcDeclAST.variableArgList) {
                signature.setHasVariableParamList();
            }
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionDeclaration), functionTypeSymbol, signature);
            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            functionTypeSymbol.addSignature(signature);
            if (!isSignature) {
                var childDecls = functionDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
        };
        PullSymbolBinder.prototype.bindFunctionExpressionToPullSymbol = function (functionExpressionDeclaration) {
            var declKind = functionExpressionDeclaration.getKind();
            var declFlags = functionExpressionDeclaration.getFlags();
            var funcExpAST = this.semanticInfo.getASTForDecl(functionExpressionDeclaration);
            var functionSymbol = new TypeScript.PullSymbol(functionExpressionDeclaration.getName(), TypeScript.PullElementKind.Function);
            var functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
            functionSymbol.setType(functionTypeSymbol);
            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            functionTypeSymbol.addDeclaration(functionExpressionDeclaration);
            if (funcExpAST.name) {
                this.semanticInfo.setSymbolForAST(funcExpAST.name, functionSymbol);
            }
            this.semanticInfo.setSymbolForAST(funcExpAST, functionSymbol);
            this.pushParent(functionTypeSymbol, functionExpressionDeclaration);
            var signature = new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            if (funcExpAST.variableArgList) {
                signature.setHasVariableParamList();
            }
            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionExpressionDeclaration), functionTypeSymbol, signature);
            functionTypeSymbol.addSignature(signature);
            var childDecls = functionExpressionDeclaration.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
        };
        PullSymbolBinder.prototype.bindFunctionTypeDeclarationToPullSymbol = function (functionTypeDeclaration) {
            var declKind = functionTypeDeclaration.getKind();
            var declFlags = functionTypeDeclaration.getFlags();
            var funcTypeAST = this.semanticInfo.getASTForDecl(functionTypeDeclaration);
            var functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfo.setSymbolForAST(funcTypeAST, functionTypeSymbol);
            this.pushParent(functionTypeSymbol, functionTypeDeclaration);
            var signature = new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            if (funcTypeAST.variableArgList) {
                signature.setHasVariableParamList();
            }
            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionTypeDeclaration), functionTypeSymbol, signature);
            functionTypeSymbol.addSignature(signature);
            this.popParent();
        };
        PullSymbolBinder.prototype.bindMethodDeclarationToPullSymbol = function (methodDeclaration) {
            var declKind = methodDeclaration.getKind();
            var declFlags = methodDeclaration.getFlags();
            var methodAST = this.semanticInfo.getASTForDecl(methodDeclaration);
            var isPrivate = (declFlags & TypeScript.PullElementFlags.Private) != 0;
            var isStatic = (declFlags & TypeScript.PullElementFlags.Static) != 0;
            var isOptional = (declFlags & TypeScript.PullElementFlags.Optional) != 0;
            var methodName = methodDeclaration.getName();
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) != 0;
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;
            var methodSymbol = null;
            var methodTypeSymbol = null;
            var linkKind = isPrivate ? TypeScript.SymbolLinkKind.PrivateMember : TypeScript.SymbolLinkKind.PublicMember;
            if (parent.isClass() && isStatic) {
                for(var i = 0; i < this.staticClassMembers.length; i++) {
                    if (this.staticClassMembers[i].getName() == methodName) {
                        methodSymbol = this.staticClassMembers[i];
                        break;
                    }
                }
            } else {
                methodSymbol = parent.findMember(methodName, false);
            }
            if (methodSymbol && (methodSymbol.getKind() != TypeScript.PullElementKind.Method || (this.symbolIsRedeclaration(methodSymbol) && !isSignature && !methodSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.Signature)))) {
                methodDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(methodAST.minChar, methodAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                    methodName
                ])));
                methodSymbol = null;
            }
            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.getType();
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && methodSymbol) {
                var decls = methodSymbol.getDeclarations();
                var scriptName = methodDeclaration.getScriptName();
                var isGeneric = methodTypeSymbol.isGeneric();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        methodSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                decls = methodTypeSymbol.getDeclarations();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        methodTypeSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                if (isGeneric) {
                    var specializations = methodTypeSymbol.getKnownSpecializations();
                    for(var i = 0; i < specializations.length; i++) {
                        decls = specializations[i].getDeclarations();
                        for(var j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specializations[i].removeDeclaration(decls[j]);
                                specializations[i].addDeclaration(methodDeclaration);
                                specializations[i].invalidate();
                                cleanedPreviousDecls = true;
                            }
                        }
                    }
                }
                methodSymbol.invalidate();
                methodTypeSymbol.invalidate();
            }
            if (!methodSymbol) {
                methodSymbol = new TypeScript.PullSymbol(methodName, TypeScript.PullElementKind.Method);
            }
            if (!methodTypeSymbol) {
                methodTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                methodSymbol.setType(methodTypeSymbol);
            }
            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);
            this.semanticInfo.setSymbolForAST(methodAST.name, methodSymbol);
            this.semanticInfo.setSymbolForAST(methodAST, methodSymbol);
            if (isOptional) {
                methodSymbol.setIsOptional();
            }
            if (!parentHadSymbol) {
                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = methodSymbol;
                } else {
                    parent.addMember(methodSymbol, linkKind);
                }
            }
            if (!isSignature) {
                this.pushParent(methodTypeSymbol, methodDeclaration);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = methodTypeSymbol.getCallSignatures();
                var constructSigs = methodTypeSymbol.getConstructSignatures();
                var indexSigs = methodTypeSymbol.getIndexSignatures();
                for(var i = 0; i < callSigs.length; i++) {
                    methodTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                for(var i = 0; i < constructSigs.length; i++) {
                    methodTypeSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for(var i = 0; i < indexSigs.length; i++) {
                    methodTypeSymbol.removeIndexSignature(indexSigs[i], false);
                }
                methodSymbol.invalidate();
                methodTypeSymbol.invalidate();
                methodTypeSymbol.recomputeCallSignatures();
                methodTypeSymbol.recomputeConstructSignatures();
                methodTypeSymbol.recomputeIndexSignatures();
            }
            var sigKind = TypeScript.PullElementKind.CallSignature;
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(sigKind) : new TypeScript.PullDefinitionSignatureSymbol(sigKind);
            if (methodAST.variableArgList) {
                signature.setHasVariableParamList();
            }
            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            var typeParameterName;
            var typeParameterAST;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameterName = typeParameters[i].getName();
                typeParameterAST = this.semanticInfo.getASTForDecl(typeParameters[i]);
                typeParameter = signature.findTypeParameter(typeParameterName);
                if (!typeParameter) {
                    if (!typeParameterAST.constraint) {
                        typeParameter = this.findTypeParameterInCache(typeParameterName);
                    }
                    if (!typeParameter) {
                        typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameterName);
                        if (!typeParameterAST.constraint) {
                            this.addTypeParameterToCache(typeParameter);
                        }
                    }
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(methodDeclaration), methodTypeSymbol, signature);
            methodTypeSymbol.addSignature(signature);
            if (!isSignature) {
                var childDecls = methodDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
        };
        PullSymbolBinder.prototype.bindConstructorDeclarationToPullSymbol = function (constructorDeclaration) {
            var declKind = constructorDeclaration.getKind();
            var declFlags = constructorDeclaration.getFlags();
            var constructorAST = this.semanticInfo.getASTForDecl(constructorDeclaration);
            var constructorName = constructorDeclaration.getName();
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) != 0;
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;
            var constructorSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol = null;
            var linkKind = TypeScript.SymbolLinkKind.ConstructorMethod;
            if (constructorSymbol && (constructorSymbol.getKind() != TypeScript.PullElementKind.ConstructorMethod || (this.symbolIsRedeclaration(constructorSymbol) && !isSignature && !constructorSymbol.allDeclsHaveFlag(TypeScript.PullElementFlags.Signature)))) {
                constructorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(constructorAST.minChar, constructorAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Multiple_constructor_implementations_are_not_allowed, null)));
                constructorSymbol = null;
            }
            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.getType();
                if (this.reBindingAfterChange) {
                    var decls = constructorSymbol.getDeclarations();
                    var scriptName = constructorDeclaration.getScriptName();
                    var isGeneric = constructorTypeSymbol.isGeneric();
                    for(var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            constructorSymbol.removeDeclaration(decls[j]);
                            cleanedPreviousDecls = true;
                        }
                    }
                    decls = constructorTypeSymbol.getDeclarations();
                    for(var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            constructorTypeSymbol.removeDeclaration(decls[j]);
                            cleanedPreviousDecls = true;
                        }
                    }
                    if (isGeneric) {
                        var specializations = constructorTypeSymbol.getKnownSpecializations();
                        for(var i = 0; i < specializations.length; i++) {
                            decls = specializations[i].getDeclarations();
                            for(var j = 0; j < decls.length; j++) {
                                if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                    specializations[i].removeDeclaration(decls[j]);
                                    specializations[i].addDeclaration(constructorDeclaration);
                                    specializations[i].invalidate();
                                    cleanedPreviousDecls = true;
                                }
                            }
                        }
                    }
                    constructorSymbol.invalidate();
                    constructorTypeSymbol.invalidate();
                }
            }
            if (!constructorSymbol) {
                constructorSymbol = new TypeScript.PullSymbol(constructorName, TypeScript.PullElementKind.ConstructorMethod);
                constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();
            }
            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.setType(constructorTypeSymbol);
            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            constructorTypeSymbol.addDeclaration(constructorDeclaration);
            this.semanticInfo.setSymbolForAST(constructorAST, constructorSymbol);
            if (!isSignature) {
                this.pushParent(constructorTypeSymbol, constructorDeclaration);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var constructSigs = constructorTypeSymbol.getConstructSignatures();
                for(var i = 0; i < constructSigs.length; i++) {
                    constructorTypeSymbol.removeConstructSignature(constructSigs[i]);
                }
                constructorSymbol.invalidate();
                constructorTypeSymbol.invalidate();
                constructorTypeSymbol.recomputeConstructSignatures();
            }
            var constructSignature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
            constructSignature.setReturnType(parent);
            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);
            this.bindParameterSymbols(constructorAST, constructorTypeSymbol, constructSignature);
            if (constructorAST.variableArgList) {
                constructSignature.setHasVariableParamList();
            }
            constructorTypeSymbol.addSignature(constructSignature);
            if (!isSignature) {
                var childDecls = constructorDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
        };
        PullSymbolBinder.prototype.bindConstructSignatureDeclarationToPullSymbol = function (constructSignatureDeclaration) {
            var parent = this.getParent(true);
            var constructorAST = this.semanticInfo.getASTForDecl(constructSignatureDeclaration);
            var constructSigs = parent.getConstructSignatures();
            for(var i = 0; i < constructSigs.length; i++) {
                if (constructSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeConstructSignature(constructSigs[i], false);
                }
            }
            parent.recomputeConstructSignatures();
            var constructSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.ConstructSignature);
            if (constructorAST.variableArgList) {
                constructSignature.setHasVariableParamList();
            }
            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructSignature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    constructSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), null, constructSignature);
            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);
            parent.addConstructSignature(constructSignature);
        };
        PullSymbolBinder.prototype.bindCallSignatureDeclarationToPullSymbol = function (callSignatureDeclaration) {
            var parent = this.getParent(true);
            var callSignatureAST = this.semanticInfo.getASTForDecl(callSignatureDeclaration);
            var callSigs = parent.getCallSignatures();
            for(var i = 0; i < callSigs.length; i++) {
                if (callSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeCallSignature(callSigs[i], false);
                }
            }
            parent.recomputeCallSignatures();
            var callSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            if (callSignatureAST.variableArgList) {
                callSignature.setHasVariableParamList();
            }
            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = callSignature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    callSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(callSignatureDeclaration), null, callSignature);
            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);
            parent.addCallSignature(callSignature);
        };
        PullSymbolBinder.prototype.bindIndexSignatureDeclarationToPullSymbol = function (indexSignatureDeclaration) {
            var parent = this.getParent(true);
            var indexSigs = parent.getIndexSignatures();
            for(var i = 0; i < indexSigs.length; i++) {
                if (indexSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeIndexSignature(indexSigs[i], false);
                }
            }
            parent.recomputeIndexSignatures();
            var indexSignature = new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.IndexSignature);
            var typeParameters = indexSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = indexSignature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    indexSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), null, indexSignature);
            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);
            parent.addIndexSignature(indexSignature);
        };
        PullSymbolBinder.prototype.bindGetAccessorDeclarationToPullSymbol = function (getAccessorDeclaration) {
            var declKind = getAccessorDeclaration.getKind();
            var declFlags = getAccessorDeclaration.getFlags();
            var funcDeclAST = this.semanticInfo.getASTForDecl(getAccessorDeclaration);
            var isExported = (declFlags & TypeScript.PullElementFlags.Exported) != 0;
            var funcName = getAccessorDeclaration.getName();
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) != 0;
            var isStatic = false;
            var linkKind = TypeScript.SymbolLinkKind.PublicMember;
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Static)) {
                isStatic = true;
            }
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Private)) {
                linkKind = TypeScript.SymbolLinkKind.PrivateMember;
            }
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var hadOtherAccessor = false;
            var cleanedPreviousDecls = false;
            var accessorSymbol = null;
            var getterSymbol = null;
            var getterTypeSymbol = null;
            if (!isStatic) {
                accessorSymbol = parent.findMember(funcName, false);
            } else {
                var candidate;
                for(var m = 0; m < this.staticClassMembers.length; m++) {
                    candidate = this.staticClassMembers[m];
                    if (candidate.getName() == funcName) {
                        accessorSymbol = candidate;
                        hadOtherAccessor = accessorSymbol.isAccessor();
                        break;
                    }
                }
            }
            if (this.compilationSettings.codeGenTarget < TypeScript.LanguageVersion.EcmaScript5) {
                getAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), "Property accessors are only available when targeting ES5 or greater"));
            }
            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    getAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                        funcName
                    ])));
                    accessorSymbol = null;
                } else {
                    getterSymbol = accessorSymbol.getGetter();
                    if (getterSymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(getterSymbol))) {
                        getAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Getter__0__already_declared, [
                            funcName
                        ])));
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }
            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = getterSymbol.getType();
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && accessorSymbol) {
                var decls = accessorSymbol.getDeclarations();
                var scriptName = getAccessorDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        accessorSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                if (getterSymbol) {
                    decls = getterSymbol.getDeclarations();
                    for(var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            getterSymbol.removeDeclaration(decls[j]);
                            cleanedPreviousDecls = true;
                        }
                    }
                }
                accessorSymbol.invalidate();
            }
            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }
            if (!getterSymbol) {
                getterSymbol = new TypeScript.PullSymbol(funcName, TypeScript.PullElementKind.Function);
                getterTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                getterSymbol.setType(getterTypeSymbol);
                accessorSymbol.setGetter(getterSymbol);
            }
            getAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);
            this.semanticInfo.setSymbolForAST(funcDeclAST.name, getterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, getterSymbol);
            if (!parentHadSymbol && !hadOtherAccessor) {
                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = accessorSymbol;
                } else {
                    parent.addMember(accessorSymbol, linkKind);
                }
            }
            if (!isSignature) {
                this.pushParent(getterTypeSymbol, getAccessorDeclaration);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = getterTypeSymbol.getCallSignatures();
                for(var i = 0; i < callSigs.length; i++) {
                    getterTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                getterSymbol.invalidate();
                getterTypeSymbol.invalidate();
                getterTypeSymbol.recomputeCallSignatures();
            }
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(getAccessorDeclaration), getterTypeSymbol, signature);
            var typeParameters = getAccessorDeclaration.getTypeParameters();
            if (typeParameters.length) {
                getAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Accessor_may_not_take_type_parameters, null)));
            }
            getterTypeSymbol.addSignature(signature);
            if (!isSignature) {
                var childDecls = getAccessorDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
            getterSymbol.setIsBound(this.bindingPhase);
        };
        PullSymbolBinder.prototype.bindSetAccessorDeclarationToPullSymbol = function (setAccessorDeclaration) {
            var declKind = setAccessorDeclaration.getKind();
            var declFlags = setAccessorDeclaration.getFlags();
            var funcDeclAST = this.semanticInfo.getASTForDecl(setAccessorDeclaration);
            var isExported = (declFlags & TypeScript.PullElementFlags.Exported) != 0;
            var funcName = setAccessorDeclaration.getName();
            var isSignature = (declFlags & TypeScript.PullElementFlags.Signature) != 0;
            var isStatic = false;
            var linkKind = TypeScript.SymbolLinkKind.PublicMember;
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Static)) {
                isStatic = true;
            }
            if (TypeScript.hasFlag(declFlags, TypeScript.PullElementFlags.Private)) {
                linkKind = TypeScript.SymbolLinkKind.PrivateMember;
            }
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var hadOtherAccessor = false;
            var cleanedPreviousDecls = false;
            var accessorSymbol = null;
            var setterSymbol = null;
            var setterTypeSymbol = null;
            if (!isStatic) {
                accessorSymbol = parent.findMember(funcName, false);
            } else {
                var candidate;
                for(var m = 0; m < this.staticClassMembers.length; m++) {
                    candidate = this.staticClassMembers[m];
                    if (candidate.getName() == funcName) {
                        accessorSymbol = candidate;
                        hadOtherAccessor = accessorSymbol.isAccessor();
                        break;
                    }
                }
            }
            if (this.compilationSettings.codeGenTarget < TypeScript.LanguageVersion.EcmaScript5) {
                setAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), "Property accessors are only available when targeting ES5 or greater"));
            }
            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    setAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Duplicate_identifier__0_, [
                        funcName
                    ])));
                    accessorSymbol = null;
                } else {
                    setterSymbol = accessorSymbol.getSetter();
                    if (setterSymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(setterSymbol))) {
                        setAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Setter__0__already_declared, [
                            funcName
                        ])));
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }
            if (accessorSymbol && setterSymbol) {
                setterTypeSymbol = setterSymbol.getType();
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && accessorSymbol) {
                var decls = accessorSymbol.getDeclarations();
                var scriptName = setAccessorDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        accessorSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                if (setterSymbol) {
                    decls = setterSymbol.getDeclarations();
                    for(var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            setterSymbol.removeDeclaration(decls[j]);
                            cleanedPreviousDecls = true;
                        }
                    }
                }
                accessorSymbol.invalidate();
            }
            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }
            if (!setterSymbol) {
                setterSymbol = new TypeScript.PullSymbol(funcName, TypeScript.PullElementKind.Function);
                setterTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                setterSymbol.setType(setterTypeSymbol);
                accessorSymbol.setSetter(setterSymbol);
            }
            setAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);
            this.semanticInfo.setSymbolForAST(funcDeclAST.name, setterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, setterSymbol);
            if (!parentHadSymbol && !hadOtherAccessor) {
                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = accessorSymbol;
                } else {
                    parent.addMember(accessorSymbol, linkKind);
                }
            }
            if (!isSignature) {
                this.pushParent(setterTypeSymbol, setAccessorDeclaration);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = setterTypeSymbol.getCallSignatures();
                for(var i = 0; i < callSigs.length; i++) {
                    setterTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                setterSymbol.invalidate();
                setterTypeSymbol.invalidate();
                setterTypeSymbol.recomputeCallSignatures();
            }
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(TypeScript.PullElementKind.CallSignature) : new TypeScript.PullDefinitionSignatureSymbol(TypeScript.PullElementKind.CallSignature);
            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(setAccessorDeclaration), setterTypeSymbol, signature);
            var typeParameters = setAccessorDeclaration.getTypeParameters();
            if (typeParameters.length) {
                setAccessorDeclaration.addDiagnostic(new TypeScript.PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Accessor_may_not_take_type_parameters, null)));
            }
            setterTypeSymbol.addSignature(signature);
            if (!isSignature) {
                var childDecls = setAccessorDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
            setterSymbol.setIsBound(this.bindingPhase);
        };
        PullSymbolBinder.prototype.bindCatchBlockPullSymbols = function (catchBlockDecl) {
            var childDecls = catchBlockDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
        };
        PullSymbolBinder.prototype.bindWithBlockPullSymbols = function (withBlockDecl) {
            var childDecls = withBlockDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
        };
        PullSymbolBinder.prototype.bindDeclToPullSymbol = function (decl, rebind) {
            if (typeof rebind === "undefined") { rebind = false; }
            if (rebind) {
                this.startingDeclForRebind = TypeScript.lastBoundPullDeclId;
                this.startingSymbolForRebind = TypeScript.lastBoundPullSymbolID;
                this.reBindingAfterChange = true;
            }
            switch(decl.getKind()) {
                case TypeScript.PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for(var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;
                case TypeScript.PullElementKind.DynamicModule:
                case TypeScript.PullElementKind.Container:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Interface:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Class:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Function:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Variable:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.EnumMember:
                case TypeScript.PullElementKind.Property:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Method:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ConstructorMethod:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.CallSignature:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ConstructSignature:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.IndexSignature:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.Enum:
                    this.bindEnumDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.GetAccessor:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.SetAccessor:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ObjectType:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.FunctionType:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.ConstructorType:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.FunctionExpression:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;
                case TypeScript.PullElementKind.TypeAlias:
                    this.bindImportDeclaration(decl);
                    break;
                case TypeScript.PullElementKind.Parameter:
                    break;
                case TypeScript.PullElementKind.CatchBlock:
                    this.bindCatchBlockPullSymbols(decl);
                case TypeScript.PullElementKind.WithBlock:
                    this.bindWithBlockPullSymbols(decl);
                    break;
                default:
                    throw new Error("Unrecognized type declaration");
            }
        };
        PullSymbolBinder.prototype.bindDeclsForUnit = function (filePath, rebind) {
            if (typeof rebind === "undefined") { rebind = false; }
            this.setUnit(filePath);
            var topLevelDecls = this.semanticInfo.getTopLevelDecls();
            for(var i = 0; i < topLevelDecls.length; i++) {
                this.bindDeclToPullSymbol(topLevelDecls[i], rebind);
            }
        };
        return PullSymbolBinder;
    })();
    TypeScript.PullSymbolBinder = PullSymbolBinder;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.linkID = 0;
    var IListItem = (function () {
        function IListItem(value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
        return IListItem;
    })();
    TypeScript.IListItem = IListItem;    
    var LinkList = (function () {
        function LinkList() {
            this.head = null;
            this.last = null;
            this.length = 0;
        }
        LinkList.prototype.addItem = function (item) {
            if (!this.head) {
                this.head = new IListItem(item);
                this.last = this.head;
            } else {
                this.last.next = new IListItem(item);
                this.last.next.prev = this.last;
                this.last = this.last.next;
            }
            this.length++;
        };
        LinkList.prototype.find = function (p) {
            var node = this.head;
            var vals = [];
            while(node) {
                if (p(node.value)) {
                    vals[vals.length] = node.value;
                }
                node = node.next;
            }
            return vals;
        };
        LinkList.prototype.remove = function (p) {
            var node = this.head;
            var prev = null;
            var next = null;
            while(node) {
                if (p(node.value)) {
                    if (node == this.head) {
                        if (this.last == this.head) {
                            this.last = null;
                        }
                        this.head = this.head.next;
                        if (this.head) {
                            this.head.prev = null;
                        }
                    } else {
                        prev = node.prev;
                        next = node.next;
                        if (prev) {
                            prev.next = next;
                        }
                        if (next) {
                            next.prev = prev;
                        }
                        if (node == this.last) {
                            this.last = prev;
                        }
                    }
                    this.length--;
                }
                node = node.next;
            }
        };
        LinkList.prototype.update = function (map, context) {
            var node = this.head;
            while(node) {
                map(node.value, context);
                node = node.next;
            }
        };
        return LinkList;
    })();
    TypeScript.LinkList = LinkList;    
    var PullSymbolLink = (function () {
        function PullSymbolLink(start, end, kind) {
            this.start = start;
            this.end = end;
            this.kind = kind;
            this.id = TypeScript.linkID++;
        }
        return PullSymbolLink;
    })();
    TypeScript.PullSymbolLink = PullSymbolLink;    
    (function (GraphUpdateKind) {
        GraphUpdateKind._map = [];
        GraphUpdateKind._map[0] = "NoUpdate";
        GraphUpdateKind.NoUpdate = 0;
        GraphUpdateKind._map[1] = "SymbolRemoved";
        GraphUpdateKind.SymbolRemoved = 1;
        GraphUpdateKind._map[2] = "SymbolAdded";
        GraphUpdateKind.SymbolAdded = 2;
        GraphUpdateKind._map[3] = "TypeChanged";
        GraphUpdateKind.TypeChanged = 3;
    })(TypeScript.GraphUpdateKind || (TypeScript.GraphUpdateKind = {}));
    var GraphUpdateKind = TypeScript.GraphUpdateKind;
    var PullSymbolUpdate = (function () {
        function PullSymbolUpdate(updateKind, symbolToUpdate, updater) {
            this.updateKind = updateKind;
            this.symbolToUpdate = symbolToUpdate;
            this.updater = updater;
        }
        return PullSymbolUpdate;
    })();
    TypeScript.PullSymbolUpdate = PullSymbolUpdate;    
    TypeScript.updateVersion = 0;
    var PullSymbolGraphUpdater = (function () {
        function PullSymbolGraphUpdater(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
        }
        PullSymbolGraphUpdater.prototype.removeDecl = function (declToRemove) {
            var declSymbol = declToRemove.getSymbol();
            if (declSymbol) {
                declSymbol.removeDeclaration(declToRemove);
                var childDecls = declToRemove.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.removeDecl(childDecls[i]);
                }
                this.removeSymbol(declSymbol);
                this.semanticInfoChain.removeSymbolFromCache(declSymbol);
            }
            var valDecl = declToRemove.getValueDecl();
            if (valDecl) {
                this.removeDecl(valDecl);
            }
            TypeScript.updateVersion++;
        };
        PullSymbolGraphUpdater.prototype.addDecl = function (declToAdd) {
            var symbolToAdd = declToAdd.getSymbol();
            if (symbolToAdd) {
                this.addSymbol(symbolToAdd);
            }
            TypeScript.updateVersion++;
        };
        PullSymbolGraphUpdater.prototype.removeSymbol = function (symbolToRemove) {
            if (symbolToRemove.removeUpdateVersion == TypeScript.updateVersion) {
                return;
            }
            symbolToRemove.removeUpdateVersion = TypeScript.updateVersion;
            symbolToRemove.updateOutgoingLinks(propagateRemovalToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolRemoved, symbolToRemove, this));
            symbolToRemove.updateIncomingLinks(propagateRemovalToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolRemoved, symbolToRemove, this));
            symbolToRemove.unsetContainer();
            this.semanticInfoChain.removeSymbolFromCache(symbolToRemove);
            var container = symbolToRemove.getContainer();
            if (container) {
                container.removeMember(symbolToRemove);
                this.semanticInfoChain.removeSymbolFromCache(symbolToRemove);
            }
            if (symbolToRemove.isAccessor()) {
                var getterSymbol = (symbolToRemove).getGetter();
                var setterSymbol = (symbolToRemove).getSetter();
                if (getterSymbol) {
                    this.removeSymbol(getterSymbol);
                }
                if (setterSymbol) {
                    this.removeSymbol(setterSymbol);
                }
            }
            symbolToRemove.removeAllLinks();
        };
        PullSymbolGraphUpdater.prototype.addSymbol = function (symbolToAdd) {
            if (symbolToAdd.addUpdateVersion == TypeScript.updateVersion) {
                return;
            }
            symbolToAdd.addUpdateVersion = TypeScript.updateVersion;
            symbolToAdd.updateOutgoingLinks(propagateAdditionToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolAdded, symbolToAdd, this));
            symbolToAdd.updateIncomingLinks(propagateAdditionToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolAdded, symbolToAdd, this));
        };
        PullSymbolGraphUpdater.prototype.invalidateType = function (symbolWhoseTypeChanged) {
            if (!symbolWhoseTypeChanged) {
                return;
            }
            if (symbolWhoseTypeChanged.isPrimitive()) {
                return;
            }
            if (symbolWhoseTypeChanged.typeChangeUpdateVersion == TypeScript.updateVersion) {
                return;
            }
            symbolWhoseTypeChanged.typeChangeUpdateVersion = TypeScript.updateVersion;
            symbolWhoseTypeChanged.updateOutgoingLinks(propagateChangedTypeToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.TypeChanged, symbolWhoseTypeChanged, this));
            symbolWhoseTypeChanged.updateIncomingLinks(propagateChangedTypeToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.TypeChanged, symbolWhoseTypeChanged, this));
            if (symbolWhoseTypeChanged.getKind() == TypeScript.PullElementKind.Container) {
                var instanceSymbol = (symbolWhoseTypeChanged).getInstanceSymbol();
                this.invalidateType(instanceSymbol);
            }
            symbolWhoseTypeChanged.invalidate();
            this.invalidateUnitsForSymbol(symbolWhoseTypeChanged);
        };
        PullSymbolGraphUpdater.prototype.invalidateUnitsForSymbol = function (symbol) {
            var declarations = symbol.getDeclarations();
            for(var i = 0; i < declarations.length; i++) {
                this.semanticInfoChain.invalidateUnit(declarations[i].getScriptName());
            }
        };
        return PullSymbolGraphUpdater;
    })();
    TypeScript.PullSymbolGraphUpdater = PullSymbolGraphUpdater;    
    function propagateRemovalToOutgoingLinks(link, update) {
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.end;
        if (affectedSymbol.removeUpdateVersion == TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }
        if (link.kind == TypeScript.SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.SpecializedTo) {
            (symbolToRemove).removeSpecialization(affectedSymbol);
            update.updater.removeSymbol(affectedSymbol);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PublicMember) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PrivateMember) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ContainedBy) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Parameter) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        symbolToRemove.removeOutgoingLink(link);
    }
    TypeScript.propagateRemovalToOutgoingLinks = propagateRemovalToOutgoingLinks;
    function propagateRemovalToIncomingLinks(link, update) {
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.start;
        if (affectedSymbol.removeUpdateVersion == TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }
        if (link.kind == TypeScript.SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.SpecializedTo) {
            (affectedSymbol).removeSpecialization(symbolToRemove);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PublicMember) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PrivateMember) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ContainedBy) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Parameter) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateRemovalToIncomingLinks = propagateRemovalToIncomingLinks;
    function propagateAdditionToOutgoingLinks(link, update) {
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.end;
        if (affectedSymbol.addUpdateVersion == TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }
        if (link.kind == TypeScript.SymbolLinkKind.ContainedBy) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateAdditionToOutgoingLinks = propagateAdditionToOutgoingLinks;
    function propagateAdditionToIncomingLinks(link, update) {
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.start;
        if (affectedSymbol.addUpdateVersion == TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }
        if (link.kind == TypeScript.SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateAdditionToIncomingLinks = propagateAdditionToIncomingLinks;
    function propagateChangedTypeToOutgoingLinks(link, update) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.end;
        if (affectedSymbol.typeChangeUpdateVersion == TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }
        if (link.kind == TypeScript.SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ContainedBy) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateChangedTypeToOutgoingLinks = propagateChangedTypeToOutgoingLinks;
    function propagateChangedTypeToIncomingLinks(link, update) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.start;
        if (affectedSymbol.typeChangeUpdateVersion == TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }
        if (link.kind == TypeScript.SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == TypeScript.SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateChangedTypeToIncomingLinks = propagateChangedTypeToIncomingLinks;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullDiagnostic = (function () {
        function PullDiagnostic(start, length, fileName, message) {
            this._originalStart = start;
            this._fileName = fileName;
            this._start = start;
            this._length = length;
            this._message = message;
        }
        PullDiagnostic.prototype.fileName = function () {
            return this._fileName;
        };
        PullDiagnostic.prototype.start = function () {
            return this._start;
        };
        PullDiagnostic.prototype.length = function () {
            return this._length;
        };
        PullDiagnostic.prototype.message = function () {
            return this._message;
        };
        PullDiagnostic.prototype.adjustOffset = function (pos) {
            this._start = this._originalStart + pos;
        };
        return PullDiagnostic;
    })();
    TypeScript.PullDiagnostic = PullDiagnostic;    
    function getDiagnosticsFromEnclosingDecl(enclosingDecl, errors) {
        var declErrors = enclosingDecl.getDiagnostics();
        if (declErrors) {
            for(var i = 0; i < declErrors.length; i++) {
                errors[errors.length] = declErrors[i];
            }
        }
        var childDecls = enclosingDecl.getChildDecls();
        for(var i = 0; i < childDecls.length; i++) {
            getDiagnosticsFromEnclosingDecl(childDecls[i], errors);
        }
    }
    TypeScript.getDiagnosticsFromEnclosingDecl = getDiagnosticsFromEnclosingDecl;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullHelpers) {
        function getSignatureForFuncDecl(funcDecl, semanticInfo) {
            var funcSymbol = semanticInfo.getSymbolForAST(funcDecl);
            if (funcSymbol.isSignature()) {
                return {
                    signature: funcSymbol,
                    allSignatures: [
                        funcSymbol
                    ]
                };
            }
            var functionDecl = semanticInfo.getDeclForAST(funcDecl);
            var functionSignature = functionDecl.getSignatureSymbol();
            var funcTypeSymbol = funcSymbol.getType();
            var signatures;
            if (funcDecl.isConstructor || funcDecl.isConstructMember()) {
                signatures = funcTypeSymbol.getConstructSignatures();
            } else if (funcDecl.isIndexerMember()) {
                signatures = funcTypeSymbol.getIndexSignatures();
            } else {
                signatures = funcTypeSymbol.getCallSignatures();
            }
            return {
                signature: functionSignature,
                allSignatures: signatures
            };
        }
        PullHelpers.getSignatureForFuncDecl = getSignatureForFuncDecl;
        function getAccessorSymbol(getterOrSetter, semanticInfoChain, unitPath) {
            var getterOrSetterSymbol = semanticInfoChain.getSymbolForAST(getterOrSetter, unitPath);
            var linkKind;
            if (TypeScript.hasFlag(getterOrSetter.getFunctionFlags(), TypeScript.FunctionFlags.GetAccessor)) {
                linkKind = TypeScript.SymbolLinkKind.GetterFunction;
            } else {
                linkKind = TypeScript.SymbolLinkKind.SetterFunction;
            }
            var accessorSymbolLinks = getterOrSetterSymbol.findIncomingLinks(function (psl) {
                return psl.kind == linkKind;
            });
            if (accessorSymbolLinks.length) {
                return accessorSymbolLinks[0].start;
            }
            return null;
        }
        PullHelpers.getAccessorSymbol = getAccessorSymbol;
        function getGetterAndSetterFunction(funcDecl, semanticInfoChain, unitPath) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain, unitPath);
            var result = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = semanticInfoChain.getASTForDecl(getterDecl);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = semanticInfoChain.getASTForDecl(setterDecl);
            }
            return result;
        }
        PullHelpers.getGetterAndSetterFunction = getGetterAndSetterFunction;
    })(TypeScript.PullHelpers || (TypeScript.PullHelpers = {}));
    var PullHelpers = TypeScript.PullHelpers;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var incrementalAst = true;
    var SyntaxPositionMap = (function () {
        function SyntaxPositionMap(node) {
            this.position = 0;
            this.elementToPosition = TypeScript.Collections.createHashTable(2048, TypeScript.Collections.identityHashCode);
            this.process(node);
        }
        SyntaxPositionMap.prototype.process = function (element) {
            if (element !== null) {
                if (element.isToken()) {
                    this.elementToPosition.add(element, this.position);
                    this.position += element.fullWidth();
                } else {
                    if (element.isNode() || (element.isList() && (element).childCount() > 0) || (element.isSeparatedList() && (element).childCount() > 0)) {
                        this.elementToPosition.add(element, this.position);
                    }
                    for(var i = 0, n = element.childCount(); i < n; i++) {
                        this.process(element.childAt(i));
                    }
                }
            }
        };
        SyntaxPositionMap.create = function create(node) {
            var map = new SyntaxPositionMap(node);
            return map;
        };
        SyntaxPositionMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };
        SyntaxPositionMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };
        SyntaxPositionMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };
        SyntaxPositionMap.prototype.fullEnd = function (element) {
            return this.fullStart(element) + element.fullWidth();
        };
        return SyntaxPositionMap;
    })();
    TypeScript.SyntaxPositionMap = SyntaxPositionMap;    
    var SyntaxTreeToAstVisitor = (function () {
        function SyntaxTreeToAstVisitor(syntaxPositionMap, fileName, lineMap, compilationSettings) {
            this.syntaxPositionMap = syntaxPositionMap;
            this.fileName = fileName;
            this.lineMap = lineMap;
            this.compilationSettings = compilationSettings;
            this.position = 0;
            this.requiresExtendsBlock = false;
            this.previousTokenTrailingComments = null;
            this.isParsingAmbientModule = false;
            this.isParsingDeclareFile = TypeScript.isDTSFile(fileName);
        }
        SyntaxTreeToAstVisitor.checkPositions = false;
        SyntaxTreeToAstVisitor.visit = function visit(syntaxTree, fileName, compilationSettings) {
            var map = SyntaxTreeToAstVisitor.checkPositions ? SyntaxPositionMap.create(syntaxTree.sourceUnit()) : null;
            var visitor = new SyntaxTreeToAstVisitor(map, fileName, syntaxTree.lineMap(), compilationSettings);
            return syntaxTree.sourceUnit().accept(visitor);
        };
        SyntaxTreeToAstVisitor.prototype.assertElementAtPosition = function (element) {
            if (SyntaxTreeToAstVisitor.checkPositions) {
                TypeScript.Debug.assert(this.position === this.syntaxPositionMap.fullStart(element));
            }
        };
        SyntaxTreeToAstVisitor.prototype.movePast = function (element) {
            if (element !== null) {
                this.assertElementAtPosition(element);
                this.position += element.fullWidth();
            }
        };
        SyntaxTreeToAstVisitor.prototype.moveTo = function (element1, element2) {
            if (element2 !== null) {
                this.position += TypeScript.Syntax.childOffset(element1, element2);
            }
        };
        SyntaxTreeToAstVisitor.prototype.applyDelta = function (ast, delta) {
            var _this = this;
            if (delta === 0) {
                return;
            }
            var applyDelta = function (ast) {
                if (ast.minChar !== -1) {
                    ast.minChar += delta;
                }
                if (ast.limChar !== -1) {
                    ast.limChar += delta;
                }
            };
            var applyDeltaToComments = function (comments) {
                if (comments && comments.length > 0) {
                    for(var i = 0; i < comments.length; i++) {
                        var comment = comments[i];
                        applyDelta(comment);
                        comment.minLine = _this.lineMap.getLineNumberFromPosition(comment.minChar);
                        comment.limLine = _this.lineMap.getLineNumberFromPosition(comment.limChar);
                    }
                }
            };
            var pre = function (cur, parent, walker) {
                applyDelta(cur);
                applyDeltaToComments(cur.preComments);
                applyDeltaToComments(cur.postComments);
                return cur;
            };
            TypeScript.getAstWalkerFactory().walk(ast, pre);
        };
        SyntaxTreeToAstVisitor.prototype.setSpan = function (span, fullStart, element) {
            var desiredMinChar = fullStart + element.leadingTriviaWidth();
            var desiredLimChar = desiredMinChar + element.width();
            TypeScript.Debug.assert(!isNaN(desiredMinChar));
            TypeScript.Debug.assert(!isNaN(desiredLimChar));
            if (span.minChar !== -1) {
                TypeScript.Debug.assert(span.limChar !== -1);
                TypeScript.Debug.assert((span).nodeType != undefined);
                var delta = desiredMinChar - span.minChar;
                this.applyDelta(span, delta);
                span.limChar = desiredLimChar;
                span.trailingTriviaWidth = element.trailingTriviaWidth();
                TypeScript.Debug.assert(span.minChar === desiredMinChar);
                TypeScript.Debug.assert(span.limChar === desiredLimChar);
            } else {
                TypeScript.Debug.assert(span.limChar === -1);
                span.minChar = desiredMinChar;
                span.limChar = desiredLimChar;
                span.trailingTriviaWidth = element.trailingTriviaWidth();
            }
            TypeScript.Debug.assert(span.minChar !== -1);
            TypeScript.Debug.assert(span.limChar !== -1);
        };
        SyntaxTreeToAstVisitor.prototype.setSpan1 = function (span, fullStart, element) {
            var desiredMinChar = fullStart + element.leadingTriviaWidth();
            var desiredLimChar = desiredMinChar + element.width();
            TypeScript.Debug.assert(!isNaN(desiredMinChar));
            TypeScript.Debug.assert(!isNaN(desiredLimChar));
            span.minChar = desiredMinChar;
            span.limChar = desiredLimChar;
            span.trailingTriviaWidth = element.trailingTriviaWidth();
            TypeScript.Debug.assert(span.minChar !== -1);
            TypeScript.Debug.assert(span.limChar !== -1);
        };
        SyntaxTreeToAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            span.minChar = start;
            span.limChar = end;
            TypeScript.Debug.assert(!isNaN(span.minChar));
            TypeScript.Debug.assert(!isNaN(span.limChar));
            TypeScript.Debug.assert(span.minChar !== -1);
            TypeScript.Debug.assert(span.limChar !== -1);
        };
        SyntaxTreeToAstVisitor.prototype.identifierFromToken = function (token, isOptional, useValueText) {
            this.assertElementAtPosition(token);
            var result = null;
            if (token.fullWidth() === 0) {
                result = new TypeScript.MissingIdentifier();
            } else {
                result = new TypeScript.Identifier(token.text());
                result.text = useValueText ? token.valueText() : result.text;
            }
            if (isOptional) {
                result.setFlags(result.getFlags() | TypeScript.ASTFlags.OptionalName);
            }
            var start = this.position + token.leadingTriviaWidth();
            this.setSpanExplicit(result, start, start + token.width());
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getAST = function (element) {
            if (incrementalAst) {
                var result = (element)._ast;
                return result ? result : null;
            } else {
                return null;
            }
        };
        SyntaxTreeToAstVisitor.prototype.setAST = function (element, ast) {
            if (incrementalAst) {
                (element)._ast = ast;
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitSyntaxList = function (list) {
            var start = this.position;
            var result = this.getAST(list);
            if (result) {
                this.movePast(list);
            } else {
                result = new TypeScript.ASTList();
                for(var i = 0, n = list.childCount(); i < n; i++) {
                    result.append(list.childAt(i).accept(this));
                }
                if (n > 0) {
                    this.setAST(list, result);
                }
            }
            this.setSpan(result, start, list);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var start = this.position;
            var result = this.getAST(list);
            if (result) {
                this.movePast(list);
            } else {
                result = new TypeScript.ASTList();
                for(var i = 0, n = list.childCount(); i < n; i++) {
                    if (i % 2 === 0) {
                        result.append(list.childAt(i).accept(this));
                        this.previousTokenTrailingComments = null;
                    } else {
                        var separatorToken = list.childAt(i);
                        this.previousTokenTrailingComments = this.convertTokenTrailingComments(separatorToken, this.position + separatorToken.leadingTriviaWidth() + separatorToken.width());
                        this.movePast(separatorToken);
                    }
                }
                this.previousTokenTrailingComments = null;
                if (n > 0) {
                    this.setAST(list, result);
                }
            }
            this.setSpan(result, start, list);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.createRef = function (text, minChar) {
            var id = new TypeScript.Identifier(text);
            id.minChar = minChar;
            return id;
        };
        SyntaxTreeToAstVisitor.prototype.convertComment = function (trivia, commentStartPosition, hasTrailingNewLine) {
            var comment = new TypeScript.Comment(trivia.fullText(), trivia.kind() === TypeScript.SyntaxKind.MultiLineCommentTrivia, hasTrailingNewLine);
            comment.minChar = commentStartPosition;
            comment.limChar = commentStartPosition + trivia.fullWidth();
            comment.minLine = this.lineMap.getLineNumberFromPosition(comment.minChar);
            comment.limLine = this.lineMap.getLineNumberFromPosition(comment.limChar);
            return comment;
        };
        SyntaxTreeToAstVisitor.prototype.convertComments = function (triviaList, commentStartPosition) {
            var result = [];
            for(var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result.push(this.convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }
                commentStartPosition += trivia.fullWidth();
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.mergeComments = function (comments1, comments2) {
            if (comments1 === null) {
                return comments2;
            }
            if (comments2 === null) {
                return comments1;
            }
            return comments1.concat(comments2);
        };
        SyntaxTreeToAstVisitor.prototype.convertTokenLeadingComments = function (token, commentStartPosition) {
            if (token === null) {
                return null;
            }
            var preComments = token.hasLeadingComment() ? this.convertComments(token.leadingTrivia(), commentStartPosition) : null;
            var previousTokenTrailingComments = this.previousTokenTrailingComments;
            this.previousTokenTrailingComments = null;
            return this.mergeComments(previousTokenTrailingComments, preComments);
        };
        SyntaxTreeToAstVisitor.prototype.convertTokenTrailingComments = function (token, commentStartPosition) {
            if (token === null || !token.hasTrailingComment() || token.hasTrailingNewLine()) {
                return null;
            }
            return this.convertComments(token.trailingTrivia(), commentStartPosition);
        };
        SyntaxTreeToAstVisitor.prototype.convertNodeLeadingComments = function (node, nodeStart) {
            return this.convertTokenLeadingComments(node.firstToken(), nodeStart);
        };
        SyntaxTreeToAstVisitor.prototype.convertNodeTrailingComments = function (node, nodeStart) {
            return this.convertTokenTrailingComments(node.lastToken(), nodeStart + node.leadingTriviaWidth() + node.width());
        };
        SyntaxTreeToAstVisitor.prototype.containsToken = function (list, kind) {
            for(var i = 0, n = list.childCount(); i < n; i++) {
                if (list.childAt(i).kind() === kind) {
                    return true;
                }
            }
            return false;
        };
        SyntaxTreeToAstVisitor.prototype.visitToken = function (token) {
            this.assertElementAtPosition(token);
            var result = this.getAST(token);
            var fullStart = this.position;
            if (result) {
                this.movePast(token);
            } else {
                if (token.kind() === TypeScript.SyntaxKind.ThisKeyword) {
                    result = new TypeScript.ThisExpression();
                } else if (token.kind() === TypeScript.SyntaxKind.SuperKeyword) {
                    result = new TypeScript.SuperExpression();
                } else if (token.kind() === TypeScript.SyntaxKind.TrueKeyword) {
                    result = new TypeScript.LiteralExpression(TypeScript.NodeType.TrueLiteral);
                } else if (token.kind() === TypeScript.SyntaxKind.FalseKeyword) {
                    result = new TypeScript.LiteralExpression(TypeScript.NodeType.FalseLiteral);
                } else if (token.kind() === TypeScript.SyntaxKind.NullKeyword) {
                    result = new TypeScript.LiteralExpression(TypeScript.NodeType.NullLiteral);
                } else if (token.kind() === TypeScript.SyntaxKind.StringLiteral) {
                    result = new TypeScript.StringLiteral(token.text());
                } else if (token.kind() === TypeScript.SyntaxKind.RegularExpressionLiteral) {
                    result = new TypeScript.RegexLiteral(token.text());
                } else if (token.kind() === TypeScript.SyntaxKind.NumericLiteral) {
                    var preComments = this.convertTokenLeadingComments(token, fullStart);
                    var value = token.text().indexOf(".") > 0 ? parseFloat(token.text()) : parseInt(token.text());
                    result = new TypeScript.NumberLiteral(value, token.text());
                    result.preComments = preComments;
                } else {
                    result = this.identifierFromToken(token, false, true);
                }
                this.movePast(token);
            }
            var start = fullStart + token.leadingTriviaWidth();
            this.setAST(token, result);
            this.setSpanExplicit(result, start, start + token.width());
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.hasTopLevelImportOrExport = function (node) {
            var firstToken;
            for(var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);
                firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.kind() === TypeScript.SyntaxKind.ExportKeyword) {
                    return true;
                }
                if (moduleElement.kind() === TypeScript.SyntaxKind.ImportDeclaration) {
                    var importDecl = moduleElement;
                    if (importDecl.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference) {
                        return true;
                    }
                }
            }
            firstToken = node.firstToken();
            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();
                for(var i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);
                    if (trivia.isComment()) {
                        if (TypeScript.getImplicitImport(trivia.fullText())) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        SyntaxTreeToAstVisitor.prototype.hasUseStrictDirective = function (list) {
            for(var i = 0; i < list.childCount(); i++) {
                var item = list.childAt(i);
                if (!TypeScript.SyntaxFacts.isDirectivePrologueElement(item)) {
                    return false;
                }
                if (TypeScript.SyntaxFacts.isUseStrictDirective(item)) {
                    return true;
                }
            }
            return false;
        };
        SyntaxTreeToAstVisitor.prototype.visitSourceUnit = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var members;
            var bod = this.visitSyntaxList(node.moduleElements);
            if (this.hasUseStrictDirective(node.moduleElements)) {
                bod.setFlags(bod.getFlags() | TypeScript.ASTFlags.StrictMode);
            }
            var topLevelMod = null;
            if (this.compilationSettings.moduleGenTarget != TypeScript.ModuleGenTarget.Local && this.hasTopLevelImportOrExport(node)) {
                var correctedFileName = TypeScript.switchToForwardSlashes(this.fileName);
                var id = new TypeScript.Identifier(correctedFileName);
                topLevelMod = new TypeScript.ModuleDeclaration(id, bod, null);
                this.setSpanExplicit(topLevelMod, start, this.position);
                topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | TypeScript.ModuleFlags.IsDynamic);
                topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | TypeScript.ModuleFlags.IsWholeFile);
                topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | TypeScript.ModuleFlags.Exported);
                if (this.isParsingDeclareFile) {
                    topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | TypeScript.ModuleFlags.Ambient);
                }
                topLevelMod.prettyName = TypeScript.getPrettyName(correctedFileName);
                bod = new TypeScript.ASTList();
                this.setSpanExplicit(bod, start, this.position);
                bod.append(topLevelMod);
            }
            var result = new TypeScript.Script();
            this.setSpanExplicit(result, start, this.position);
            result.moduleElements = bod;
            result.topLevelMod = topLevelMod;
            result.isDeclareFile = this.isParsingDeclareFile;
            result.requiresExtendsBlock = this.requiresExtendsBlock;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitExternalModuleReference = function (node) {
            this.assertElementAtPosition(node);
            this.moveTo(node, node.stringLiteral);
            var result = this.identifierFromToken(node.stringLiteral, false, false);
            this.movePast(node.stringLiteral);
            this.movePast(node.closeParenToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitModuleNameModuleReference = function (node) {
            this.assertElementAtPosition(node);
            return node.moduleName.accept(this);
        };
        SyntaxTreeToAstVisitor.prototype.visitClassDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var extendsList = new TypeScript.ASTList();
                var implementsList = new TypeScript.ASTList();
                for(var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                    var heritageClause = node.heritageClauses.childAt(i);
                    if (heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ExtendsKeyword) {
                        extendsList = heritageClause.accept(this);
                    } else {
                        TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === TypeScript.SyntaxKind.ImplementsKeyword);
                        implementsList = heritageClause.accept(this);
                    }
                }
                this.movePast(node.openBraceToken);
                var members = this.visitSyntaxList(node.classElements);
                var closeBracePosition = this.position;
                this.movePast(node.closeBraceToken);
                var closeBraceSpan = new TypeScript.ASTSpan();
                this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);
                result = new TypeScript.ClassDeclaration(name, typeParameters, members, extendsList, implementsList);
                result.endingToken = closeBraceSpan;
                result.preComments = preComments;
                result.postComments = postComments;
                for(var i = 0; i < members.members.length; i++) {
                    var member = members.members[i];
                    if (member.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                        var funcDecl = member;
                        if (funcDecl.isConstructor) {
                            funcDecl.name = name;
                            funcDecl.classDecl = result;
                            result.constructorDecl = funcDecl;
                        }
                    }
                }
            }
            this.requiresExtendsBlock = this.requiresExtendsBlock || result.extendsList.members.length > 0;
            if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.ExportKeyword) || this.isParsingAmbientModule) {
                result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Exported);
            }
            if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Ambient);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var extendsList = null;
                for(var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                    var heritageClause = node.heritageClauses.childAt(i);
                    if (i === 0) {
                        extendsList = heritageClause.accept(this);
                    } else {
                        this.movePast(heritageClause);
                    }
                }
                this.movePast(node.body.openBraceToken);
                var members = this.visitSeparatedSyntaxList(node.body.typeMembers);
                this.movePast(node.body.closeBraceToken);
                result = new TypeScript.InterfaceDeclaration(name, typeParameters, members, extendsList, null);
                result.preComments = preComments;
                result.postComments = postComments;
            }
            if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.ExportKeyword) || this.isParsingAmbientModule) {
                result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Exported);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitHeritageClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                result = new TypeScript.ASTList();
                this.movePast(node.extendsOrImplementsKeyword);
                for(var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                    if (i % 2 === 1) {
                        this.movePast(node.typeNames.childAt(i));
                    } else {
                        var type = this.visitType(node.typeNames.childAt(i)).term;
                        result.append(type);
                    }
                }
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getModuleNames = function (node) {
            var result = [];
            if (node.stringLiteral !== null) {
                result.push(this.identifierFromToken(node.stringLiteral, false, false));
                this.movePast(node.stringLiteral);
            } else {
                this.getModuleNamesHelper(node.moduleName, result);
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getModuleNamesHelper = function (name, result) {
            this.assertElementAtPosition(name);
            if (name.kind() === TypeScript.SyntaxKind.QualifiedName) {
                var qualifiedName = name;
                this.getModuleNamesHelper(qualifiedName.left, result);
                this.movePast(qualifiedName.dotToken);
                result.push(this.identifierFromToken(qualifiedName.right, false, false));
                this.movePast(qualifiedName.right);
            } else {
                result.push(this.identifierFromToken(name, false, false));
                this.movePast(name);
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitModuleDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.moduleKeyword);
                this.movePast(node.moduleKeyword);
                var names = this.getModuleNames(node);
                this.movePast(node.openBraceToken);
                var svIsParsingAmbientModule = this.isParsingAmbientModule;
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword) || this.isParsingDeclareFile) {
                    this.isParsingAmbientModule = true;
                }
                var members = this.visitSyntaxList(node.moduleElements);
                this.isParsingAmbientModule = svIsParsingAmbientModule;
                var closeBracePosition = this.position;
                this.movePast(node.closeBraceToken);
                var closeBraceSpan = new TypeScript.ASTSpan();
                this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);
                for(var i = names.length - 1; i >= 0; i--) {
                    var innerName = names[i];
                    result = new TypeScript.ModuleDeclaration(innerName, members, closeBraceSpan);
                    this.setSpan(result, start, node);
                    result.preComments = preComments;
                    result.postComments = postComments;
                    preComments = null;
                    postComments = null;
                    if (i) {
                        result.setModuleFlags(result.getModuleFlags() | TypeScript.ModuleFlags.Exported);
                    } else if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.ExportKeyword) || this.isParsingAmbientModule) {
                        result.setModuleFlags(result.getModuleFlags() | TypeScript.ModuleFlags.Exported);
                    }
                    members = new TypeScript.ASTList();
                    members.append(result);
                }
            }
            if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                result.setModuleFlags(result.getModuleFlags() | TypeScript.ModuleFlags.Ambient);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.hasDotDotDotParameter = function (parameters) {
            for(var i = 0, n = parameters.nonSeparatorCount(); i < n; i++) {
                if ((parameters.nonSeparatorAt(i)).dotDotDotToken) {
                    return true;
                }
            }
            return false;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
                var block = node.block ? node.block.accept(this) : null;
                if (node.block) {
                    if (this.hasUseStrictDirective(node.block.statements)) {
                        block.setFlags(block.getFlags() | TypeScript.ASTFlags.StrictMode);
                    }
                }
                this.movePast(node.semicolonToken);
                result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                if (node.semicolonToken) {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
                }
            }
            if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.ExportKeyword) || this.isParsingAmbientModule) {
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Exported);
            }
            if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Ambient);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEnumDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);
            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false, true);
            this.movePast(node.identifier);
            this.movePast(node.openBraceToken);
            var members = new TypeScript.ASTList();
            var mapDecl = new TypeScript.VariableDeclarator(new TypeScript.Identifier("_map"));
            var declarators = new TypeScript.ASTList();
            declarators.append(mapDecl);
            var declaration = new TypeScript.VariableDeclaration(declarators);
            var statement = new TypeScript.VariableStatement(declaration);
            mapDecl.setVarFlags(mapDecl.getVarFlags() | TypeScript.VariableFlags.Exported);
            mapDecl.setVarFlags(mapDecl.getVarFlags() | TypeScript.VariableFlags.Private);
            mapDecl.setVarFlags(mapDecl.getVarFlags() | (TypeScript.VariableFlags.Property | TypeScript.VariableFlags.Public));
            mapDecl.init = new TypeScript.UnaryExpression(TypeScript.NodeType.ArrayLiteralExpression, null);
            members.append(statement);
            var lastValue = null;
            var memberNames = [];
            var memberName;
            for(var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.enumElements.childAt(i));
                } else {
                    var enumElement = node.enumElements.childAt(i);
                    var memberValue = null;
                    memberName = this.identifierFromToken(enumElement.propertyName, false, true);
                    this.movePast(enumElement.propertyName);
                    if (enumElement.equalsValueClause !== null) {
                        memberValue = enumElement.equalsValueClause.accept(this);
                        lastValue = memberValue;
                    }
                    var memberStart = this.position;
                    if (memberValue === null) {
                        if (lastValue === null) {
                            memberValue = new TypeScript.NumberLiteral(0, "0");
                            lastValue = memberValue;
                        } else {
                            var nextValue = lastValue.value + 1;
                            memberValue = new TypeScript.NumberLiteral(nextValue, nextValue.toString());
                            lastValue = memberValue;
                        }
                        var map = new TypeScript.BinaryExpression(TypeScript.NodeType.AssignmentExpression, new TypeScript.BinaryExpression(TypeScript.NodeType.ElementAccessExpression, new TypeScript.Identifier("_map"), memberValue), new TypeScript.StringLiteral('"' + memberName.actualText + '"'));
                        map.setFlags(map.getFlags() | TypeScript.ASTFlags.EnumInitializer);
                        members.append(new TypeScript.ExpressionStatement(map));
                        this.setSpanExplicit(map, memberStart, this.position);
                        this.setSpanExplicit(map.operand1, memberStart, this.position);
                        this.setSpanExplicit(map.operand2, memberStart, this.position);
                    }
                    var declarator = new TypeScript.VariableDeclarator(memberName);
                    declarator.init = memberValue;
                    declarator.typeExpr = new TypeScript.TypeReference(this.createRef(name.actualText, -1), 0);
                    declarator.setVarFlags(declarator.getVarFlags() | TypeScript.VariableFlags.Property);
                    this.setSpanExplicit(declarator, memberStart, this.position);
                    if (memberValue.nodeType === TypeScript.NodeType.NumericLiteral) {
                        declarator.setVarFlags(declarator.getVarFlags() | TypeScript.VariableFlags.Constant);
                    } else if (memberValue.nodeType === TypeScript.NodeType.LeftShiftExpression) {
                        var binop = memberValue;
                        if (binop.operand1.nodeType === TypeScript.NodeType.NumericLiteral && binop.operand2.nodeType === TypeScript.NodeType.NumericLiteral) {
                            declarator.setVarFlags(declarator.getVarFlags() | TypeScript.VariableFlags.Constant);
                        }
                    } else if (memberValue.nodeType === TypeScript.NodeType.Name) {
                        var nameNode = memberValue;
                        for(var j = 0; j < memberNames.length; j++) {
                            memberName = memberNames[j];
                            if (memberName.text === nameNode.text) {
                                declarator.setVarFlags(declarator.getVarFlags() | TypeScript.VariableFlags.Constant);
                                break;
                            }
                        }
                    }
                    declarators = new TypeScript.ASTList();
                    declarators.append(declarator);
                    declaration = new TypeScript.VariableDeclaration(declarators);
                    this.setSpanExplicit(declaration, memberStart, this.position);
                    statement = new TypeScript.VariableStatement(declaration);
                    this.setSpanExplicit(statement, memberStart, this.position);
                    members.append(statement);
                    memberNames.push(memberName);
                    declarator.setVarFlags(declarator.getVarFlags() | TypeScript.VariableFlags.Exported);
                }
            }
            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);
            var modDecl = new TypeScript.ModuleDeclaration(name, members, closeBraceSpan);
            this.setSpan(modDecl, start, node);
            this.setSpan(mapDecl, start, node);
            modDecl.preComments = preComments;
            modDecl.postComments = postComments;
            modDecl.setModuleFlags(modDecl.getModuleFlags() | TypeScript.ModuleFlags.IsEnum);
            if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.ExportKeyword) || this.isParsingAmbientModule) {
                modDecl.setModuleFlags(modDecl.getModuleFlags() | TypeScript.ModuleFlags.Exported);
            }
            return modDecl;
        };
        SyntaxTreeToAstVisitor.prototype.visitEnumElement = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };
        SyntaxTreeToAstVisitor.prototype.visitImportDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.equalsToken);
                var alias = node.moduleReference.accept(this);
                this.movePast(node.semicolonToken);
                result = new TypeScript.ImportDeclaration(name, alias);
                result.preComments = preComments;
                result.postComments = postComments;
                result.isDynamicImport = node.moduleReference.kind() === TypeScript.SyntaxKind.ExternalModuleReference;
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitExportAssignment = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.semicolonToken);
                result = new TypeScript.ExportAssignment(name);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var preComments = null;
            if (node.modifiers.childCount() > 0) {
                preComments = this.convertTokenLeadingComments(node.modifiers.firstToken(), start);
            }
            this.moveTo(node, node.variableDeclaration);
            var declaration = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);
            for(var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                var varDecl = declaration.declarators.members[i];
                if (i === 0) {
                    varDecl.preComments = this.mergeComments(preComments, varDecl.preComments);
                }
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.ExportKeyword) || this.isParsingAmbientModule) {
                    varDecl.setVarFlags(varDecl.getVarFlags() | TypeScript.VariableFlags.Exported);
                }
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.DeclareKeyword) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                    varDecl.setVarFlags(varDecl.getVarFlags() | TypeScript.VariableFlags.Ambient);
                }
            }
            var result = new TypeScript.VariableStatement(declaration);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);
            this.moveTo(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);
            for(var i = 0; i < variableDecls.members.length; i++) {
                if (i === 0) {
                    variableDecls.members[i].preComments = preComments;
                    variableDecls.members[i].postComments = postComments;
                }
            }
            var result = new TypeScript.VariableDeclaration(variableDecls);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableDeclarator = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var name = this.identifierFromToken(node.identifier, false, true);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;
            var result = new TypeScript.VariableDeclarator(name);
            this.setSpan(result, start, node);
            result.typeExpr = typeExpr;
            result.init = init;
            if (init && init.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                var funcDecl = init;
                funcDecl.hint = name.actualText;
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEqualsValueClause = function (node) {
            this.assertElementAtPosition(node);
            this.previousTokenTrailingComments = this.convertTokenTrailingComments(node.equalsToken, this.position + node.equalsToken.leadingTriviaWidth() + node.equalsToken.width());
            this.movePast(node.equalsToken);
            var result = node.value.accept(this);
            this.previousTokenTrailingComments = null;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getUnaryExpressionNodeType = function (kind) {
            switch(kind) {
                case TypeScript.SyntaxKind.PlusExpression:
                    return TypeScript.NodeType.PlusExpression;
                case TypeScript.SyntaxKind.NegateExpression:
                    return TypeScript.NodeType.NegateExpression;
                case TypeScript.SyntaxKind.BitwiseNotExpression:
                    return TypeScript.NodeType.BitwiseNotExpression;
                case TypeScript.SyntaxKind.LogicalNotExpression:
                    return TypeScript.NodeType.LogicalNotExpression;
                case TypeScript.SyntaxKind.PreIncrementExpression:
                    return TypeScript.NodeType.PreIncrementExpression;
                case TypeScript.SyntaxKind.PreDecrementExpression:
                    return TypeScript.NodeType.PreDecrementExpression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.operatorToken);
                var operand = node.operand.accept(this);
                result = new TypeScript.UnaryExpression(this.getUnaryExpressionNodeType(node.kind()), operand);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openBracketToken);
                var expressions = this.visitSeparatedSyntaxList(node.expressions);
                this.movePast(node.closeBracketToken);
                result = new TypeScript.UnaryExpression(TypeScript.NodeType.ArrayLiteralExpression, expressions);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitOmittedExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                result = new TypeScript.OmittedExpression();
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openParenToken);
                var expr = node.expression.accept(this);
                this.movePast(node.closeParenToken);
                result = new TypeScript.ParenthesizedExpression(expr);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getArrowFunctionStatements = function (body) {
            if (body.kind() === TypeScript.SyntaxKind.Block) {
                return body.accept(this);
            } else {
                var statements = new TypeScript.ASTList();
                statements.append(new TypeScript.ReturnStatement(body.accept(this)));
                var block = new TypeScript.Block(statements);
                block.closeBraceSpan = statements.members[0];
                return block;
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.equalsGreaterThanToken);
                var parameters = new TypeScript.ASTList();
                var parameter = new TypeScript.Parameter(identifier);
                this.setSpanExplicit(parameter, identifier.minChar, identifier.limChar);
                parameters.append(parameter);
                var statements = this.getArrowFunctionStatements(node.body);
                result = new TypeScript.FunctionDeclaration(null, statements, false, null, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.returnTypeAnnotation = null;
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.IsFunctionExpression);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.IsFatArrowFunction);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
                this.movePast(node.equalsGreaterThanToken);
                var block = this.getArrowFunctionStatements(node.body);
                result = new TypeScript.FunctionDeclaration(null, block, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.returnTypeAnnotation = returnType;
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.IsFunctionExpression);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.IsFatArrowFunction);
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitType = function (type) {
            this.assertElementAtPosition(type);
            var result;
            if (type.isToken()) {
                var start = this.position;
                result = new TypeScript.TypeReference(type.accept(this), 0);
                this.setSpan(result, start, type);
            } else {
                result = type.accept(this);
            }
            TypeScript.Debug.assert(result.nodeType === TypeScript.NodeType.TypeRef);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitQualifiedName = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var left = this.visitType(node.left).term;
                this.movePast(node.dotToken);
                var right = this.identifierFromToken(node.right, false, true);
                this.movePast(node.right);
                var term = new TypeScript.BinaryExpression(TypeScript.NodeType.MemberAccessExpression, left, right);
                this.setSpan(term, start, node);
                result = new TypeScript.TypeReference(term, 0);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeArgumentList = function (node) {
            this.assertElementAtPosition(node);
            var result = new TypeScript.ASTList();
            this.movePast(node.lessThanToken);
            for(var i = 0, n = node.typeArguments.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeArguments.childAt(i));
                } else {
                    result.append(this.visitType(node.typeArguments.childAt(i)));
                }
            }
            this.movePast(node.greaterThanToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructorType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.newKeyword);
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var parameters = node.parameterList.accept(this);
                this.movePast(node.equalsGreaterThanToken);
                var returnType = node.type ? this.visitType(node.type) : null;
                var funcDecl = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                this.setSpan(funcDecl, start, node);
                funcDecl.returnTypeAnnotation = returnType;
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
                funcDecl.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | TypeScript.FunctionFlags.ConstructMember);
                funcDecl.setFlags(funcDecl.getFlags() | TypeScript.ASTFlags.TypeReference);
                funcDecl.hint = "_construct";
                funcDecl.classDecl = null;
                result = new TypeScript.TypeReference(funcDecl, 0);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var parameters = node.parameterList.accept(this);
                this.movePast(node.equalsGreaterThanToken);
                var returnType = node.type ? this.visitType(node.type) : null;
                var funcDecl = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                this.setSpan(funcDecl, start, node);
                funcDecl.returnTypeAnnotation = returnType;
                funcDecl.setFlags(funcDecl.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
                funcDecl.setFlags(funcDecl.getFlags() | TypeScript.ASTFlags.TypeReference);
                funcDecl.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
                result = new TypeScript.TypeReference(funcDecl, 0);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openBraceToken);
                var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);
                this.movePast(node.closeBraceToken);
                var interfaceDecl = new TypeScript.InterfaceDeclaration(new TypeScript.Identifier("__anonymous"), null, typeMembers, null, null);
                this.setSpan(interfaceDecl, start, node);
                interfaceDecl.setFlags(interfaceDecl.getFlags() | TypeScript.ASTFlags.TypeReference);
                result = new TypeScript.TypeReference(interfaceDecl, 0);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArrayType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var underlying = this.visitType(node.type);
                this.movePast(node.openBracketToken);
                this.movePast(node.closeBracketToken);
                if (underlying.nodeType === TypeScript.NodeType.TypeRef) {
                    result = underlying;
                    result.arrayCount++;
                } else {
                    result = new TypeScript.TypeReference(underlying, 1);
                }
                result.setFlags(result.getFlags() | TypeScript.ASTFlags.TypeReference);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGenericType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var underlying = this.visitType(node.name).term;
                var typeArguments = node.typeArgumentList.accept(this);
                var genericType = new TypeScript.GenericType(underlying, typeArguments);
                this.setSpan(genericType, start, node);
                genericType.setFlags(genericType.getFlags() | TypeScript.ASTFlags.TypeReference);
                result = new TypeScript.TypeReference(genericType, 0);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeAnnotation = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.colonToken);
            return this.visitType(node.type);
        };
        SyntaxTreeToAstVisitor.prototype.visitBlock = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openBraceToken);
                var statements = this.visitSyntaxList(node.statements);
                var closeBracePosition = this.position;
                this.movePast(node.closeBraceToken);
                var closeBraceSpan = new TypeScript.ASTSpan();
                this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);
                result = new TypeScript.Block(statements);
                result.closeBraceSpan = closeBraceSpan;
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParameter = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.identifier);
                var identifier = this.identifierFromToken(node.identifier, !!node.questionToken, true);
                this.movePast(node.identifier);
                this.movePast(node.questionToken);
                var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;
                result = new TypeScript.Parameter(identifier);
                result.preComments = preComments;
                result.postComments = postComments;
                result.isOptional = !!node.questionToken;
                result.init = init;
                result.typeExpr = typeExpr;
                if (node.publicOrPrivateKeyword) {
                    result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Property);
                    if (node.publicOrPrivateKeyword.kind() === TypeScript.SyntaxKind.PublicKeyword) {
                        result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Public);
                    } else {
                        result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Private);
                    }
                }
                if (node.equalsValueClause || node.dotDotDotToken) {
                    result.setFlags(result.getFlags() | TypeScript.ASTFlags.OptionalName);
                }
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var expression = node.expression.accept(this);
                this.movePast(node.dotToken);
                var name = this.identifierFromToken(node.name, false, true);
                this.movePast(node.name);
                result = new TypeScript.BinaryExpression(TypeScript.NodeType.MemberAccessExpression, expression, name);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var operand = node.operand.accept(this);
                this.movePast(node.operatorToken);
                result = new TypeScript.UnaryExpression(node.kind() === TypeScript.SyntaxKind.PostIncrementExpression ? TypeScript.NodeType.PostIncrementExpression : TypeScript.NodeType.PostDecrementExpression, operand);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitElementAccessExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var expression = node.expression.accept(this);
                this.movePast(node.openBracketToken);
                var argumentExpression = node.argumentExpression.accept(this);
                this.movePast(node.closeBracketToken);
                result = new TypeScript.BinaryExpression(TypeScript.NodeType.ElementAccessExpression, expression, argumentExpression);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.convertArgumentListArguments = function (node) {
            if (node === null) {
                return null;
            }
            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.arguments);
            this.movePast(node.closeParenToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitInvocationExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var expression = node.expression.accept(this);
                var typeArguments = node.argumentList.typeArgumentList !== null ? node.argumentList.typeArgumentList.accept(this) : null;
                var argumentList = this.convertArgumentListArguments(node.argumentList);
                result = new TypeScript.CallExpression(TypeScript.NodeType.InvocationExpression, expression, typeArguments, argumentList);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArgumentList = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };
        SyntaxTreeToAstVisitor.prototype.getBinaryExpressionNodeType = function (node) {
            switch(node.kind()) {
                case TypeScript.SyntaxKind.CommaExpression:
                    return TypeScript.NodeType.CommaExpression;
                case TypeScript.SyntaxKind.AssignmentExpression:
                    return TypeScript.NodeType.AssignmentExpression;
                case TypeScript.SyntaxKind.AddAssignmentExpression:
                    return TypeScript.NodeType.AddAssignmentExpression;
                case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                    return TypeScript.NodeType.SubtractAssignmentExpression;
                case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                    return TypeScript.NodeType.MultiplyAssignmentExpression;
                case TypeScript.SyntaxKind.DivideAssignmentExpression:
                    return TypeScript.NodeType.DivideAssignmentExpression;
                case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                    return TypeScript.NodeType.ModuloAssignmentExpression;
                case TypeScript.SyntaxKind.AndAssignmentExpression:
                    return TypeScript.NodeType.AndAssignmentExpression;
                case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                    return TypeScript.NodeType.ExclusiveOrAssignmentExpression;
                case TypeScript.SyntaxKind.OrAssignmentExpression:
                    return TypeScript.NodeType.OrAssignmentExpression;
                case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                    return TypeScript.NodeType.LeftShiftAssignmentExpression;
                case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                    return TypeScript.NodeType.SignedRightShiftAssignmentExpression;
                case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    return TypeScript.NodeType.UnsignedRightShiftAssignmentExpression;
                case TypeScript.SyntaxKind.LogicalOrExpression:
                    return TypeScript.NodeType.LogicalOrExpression;
                case TypeScript.SyntaxKind.LogicalAndExpression:
                    return TypeScript.NodeType.LogicalAndExpression;
                case TypeScript.SyntaxKind.BitwiseOrExpression:
                    return TypeScript.NodeType.BitwiseOrExpression;
                case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                    return TypeScript.NodeType.BitwiseExclusiveOrExpression;
                case TypeScript.SyntaxKind.BitwiseAndExpression:
                    return TypeScript.NodeType.BitwiseAndExpression;
                case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                    return TypeScript.NodeType.EqualsWithTypeConversionExpression;
                case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                    return TypeScript.NodeType.NotEqualsWithTypeConversionExpression;
                case TypeScript.SyntaxKind.EqualsExpression:
                    return TypeScript.NodeType.EqualsExpression;
                case TypeScript.SyntaxKind.NotEqualsExpression:
                    return TypeScript.NodeType.NotEqualsExpression;
                case TypeScript.SyntaxKind.LessThanExpression:
                    return TypeScript.NodeType.LessThanExpression;
                case TypeScript.SyntaxKind.GreaterThanExpression:
                    return TypeScript.NodeType.GreaterThanExpression;
                case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                    return TypeScript.NodeType.LessThanOrEqualExpression;
                case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                    return TypeScript.NodeType.GreaterThanOrEqualExpression;
                case TypeScript.SyntaxKind.InstanceOfExpression:
                    return TypeScript.NodeType.InstanceOfExpression;
                case TypeScript.SyntaxKind.InExpression:
                    return TypeScript.NodeType.InExpression;
                case TypeScript.SyntaxKind.LeftShiftExpression:
                    return TypeScript.NodeType.LeftShiftExpression;
                case TypeScript.SyntaxKind.SignedRightShiftExpression:
                    return TypeScript.NodeType.SignedRightShiftExpression;
                case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                    return TypeScript.NodeType.UnsignedRightShiftExpression;
                case TypeScript.SyntaxKind.MultiplyExpression:
                    return TypeScript.NodeType.MultiplyExpression;
                case TypeScript.SyntaxKind.DivideExpression:
                    return TypeScript.NodeType.DivideExpression;
                case TypeScript.SyntaxKind.ModuloExpression:
                    return TypeScript.NodeType.ModuloExpression;
                case TypeScript.SyntaxKind.AddExpression:
                    return TypeScript.NodeType.AddExpression;
                case TypeScript.SyntaxKind.SubtractExpression:
                    return TypeScript.NodeType.SubtractExpression;
            }
            throw TypeScript.Errors.invalidOperation();
        };
        SyntaxTreeToAstVisitor.prototype.visitBinaryExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var nodeType = this.getBinaryExpressionNodeType(node);
                var left = node.left.accept(this);
                this.movePast(node.operatorToken);
                var right = node.right.accept(this);
                result = new TypeScript.BinaryExpression(nodeType, left, right);
                if (right.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    var id = left.nodeType === TypeScript.NodeType.MemberAccessExpression ? (left).operand2 : left;
                    var idHint = id.nodeType === TypeScript.NodeType.Name ? id.actualText : null;
                    var funcDecl = right;
                    funcDecl.hint = idHint;
                }
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConditionalExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var condition = node.condition.accept(this);
                this.movePast(node.questionToken);
                var whenTrue = node.whenTrue.accept(this);
                this.movePast(node.colonToken);
                var whenFalse = node.whenFalse.accept(this);
                result = new TypeScript.ConditionalExpression(condition, whenTrue, whenFalse);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                this.movePast(node.newKeyword);
                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
                result = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.returnTypeAnnotation = returnType;
                result.hint = "_construct";
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.ConstructMember);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Method);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMethodSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var name = this.identifierFromToken(node.propertyName, !!node.questionToken, true);
                this.movePast(node.propertyName);
                this.movePast(node.questionToken);
                var typeParameters = node.callSignature.typeParameterList ? node.callSignature.typeParameterList.accept(this) : null;
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
                result = new TypeScript.FunctionDeclaration(name, null, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Method);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitIndexSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                this.movePast(node.openBracketToken);
                var parameter = node.parameter.accept(this);
                this.movePast(node.closeBracketToken);
                var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                var name = new TypeScript.Identifier("__item");
                this.setSpanExplicit(name, start, start);
                var parameters = new TypeScript.ASTList();
                parameters.append(parameter);
                result = new TypeScript.FunctionDeclaration(name, null, false, null, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.variableArgList = false;
                result.returnTypeAnnotation = returnType;
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.IndexerMember);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Method);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitPropertySignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var name = this.identifierFromToken(node.propertyName, !!node.questionToken, true);
                this.movePast(node.propertyName);
                this.movePast(node.questionToken);
                var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                result = new TypeScript.VariableDeclarator(name);
                result.preComments = preComments;
                result.typeExpr = typeExpr;
                result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Property);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParameterList = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var openParenToken = node.openParenToken;
            this.previousTokenTrailingComments = this.convertTokenTrailingComments(openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());
            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCallSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var parameters = node.parameterList.accept(this);
                var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                result = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                result.hint = "_call";
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.CallMember);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Method);
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeParameterList = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.lessThanToken);
            var result = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeParameter = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var constraint = node.constraint ? node.constraint.accept(this) : null;
                result = new TypeScript.TypeParameter(identifier, constraint);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstraint = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.extendsKeyword);
            return this.visitType(node.type);
        };
        SyntaxTreeToAstVisitor.prototype.visitIfStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.condition);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                var thenBod = node.statement.accept(this);
                var elseBod = node.elseClause ? node.elseClause.accept(this) : null;
                result = new TypeScript.IfStatement(condition, thenBod, elseBod);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitElseClause = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.elseKeyword);
            return node.statement.accept(this);
        };
        SyntaxTreeToAstVisitor.prototype.visitExpressionStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                var expression = node.expression.accept(this);
                this.movePast(node.semicolonToken);
                result = new TypeScript.ExpressionStatement(expression);
                result.preComments = preComments;
                result.postComments = postComments;
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.parameterList);
                var parameters = node.parameterList.accept(this);
                var block = node.block ? node.block.accept(this) : null;
                if (node.block) {
                    if (this.hasUseStrictDirective(node.block.statements)) {
                        block.setFlags(block.getFlags() | TypeScript.ASTFlags.StrictMode);
                    }
                }
                this.movePast(node.semicolonToken);
                result = new TypeScript.FunctionDeclaration(null, block, true, null, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
                if (node.semicolonToken) {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
                }
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.ClassMethod);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);
                this.movePast(node.propertyName);
                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
                var block = node.block ? node.block.accept(this) : null;
                this.movePast(node.semicolonToken);
                result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                if (node.semicolonToken) {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Signature);
                }
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.PrivateKeyword)) {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Private);
                } else {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Public);
                }
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.StaticKeyword)) {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Static);
                }
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Method);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberAccessorDeclaration = function (node, typeAnnotation) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);
                this.movePast(node.propertyName);
                var parameters = node.parameterList.accept(this);
                var returnType = typeAnnotation ? typeAnnotation.accept(this) : null;
                var block = node.block ? node.block.accept(this) : null;
                result = new TypeScript.FunctionDeclaration(name, block, false, null, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.PrivateKeyword)) {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Private);
                } else {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Public);
                }
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.StaticKeyword)) {
                    result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Static);
                }
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.Method);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var result = this.visitMemberAccessorDeclaration(node, node.typeAnnotation);
            result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.GetAccessor);
            result.hint = "get" + result.name.actualText;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var result = this.visitMemberAccessorDeclaration(node, null);
            result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.SetAccessor);
            result.hint = "set" + result.name.actualText;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.variableDeclarator);
                this.moveTo(node.variableDeclarator, node.variableDeclarator.identifier);
                var name = this.identifierFromToken(node.variableDeclarator.identifier, false, true);
                this.movePast(node.variableDeclarator.identifier);
                var typeExpr = node.variableDeclarator.typeAnnotation ? node.variableDeclarator.typeAnnotation.accept(this) : null;
                var init = node.variableDeclarator.equalsValueClause ? node.variableDeclarator.equalsValueClause.accept(this) : null;
                this.movePast(node.semicolonToken);
                result = new TypeScript.VariableDeclarator(name);
                result.preComments = preComments;
                result.postComments = postComments;
                result.typeExpr = typeExpr;
                result.init = init;
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.StaticKeyword)) {
                    result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Static);
                }
                if (this.containsToken(node.modifiers, TypeScript.SyntaxKind.PrivateKeyword)) {
                    result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Private);
                } else {
                    result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.Public);
                }
                result.setVarFlags(result.getVarFlags() | TypeScript.VariableFlags.ClassProperty);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitThrowStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.throwKeyword);
                var expression = node.expression.accept(this);
                this.movePast(node.semicolonToken);
                result = new TypeScript.ThrowStatement(expression);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitReturnStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.returnKeyword);
                var expression = node.expression ? node.expression.accept(this) : null;
                this.movePast(node.semicolonToken);
                result = new TypeScript.ReturnStatement(expression);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.newKeyword);
                var expression = node.expression.accept(this);
                var typeArgumentList = node.argumentList === null || node.argumentList.typeArgumentList === null ? null : node.argumentList.typeArgumentList.accept(this);
                var argumentList = this.convertArgumentListArguments(node.argumentList);
                result = new TypeScript.CallExpression(TypeScript.NodeType.ObjectCreationExpression, expression, typeArgumentList, argumentList);
                if (expression.nodeType === TypeScript.NodeType.TypeRef) {
                    var typeRef = expression;
                    if (typeRef.arrayCount === 0) {
                        var term = typeRef.term;
                        if (term.nodeType === TypeScript.NodeType.MemberAccessExpression || term.nodeType === TypeScript.NodeType.Name) {
                            expression = term;
                        }
                    }
                }
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSwitchStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.switchKeyword);
                this.movePast(node.openParenToken);
                var expression = node.expression.accept(this);
                this.movePast(node.closeParenToken);
                var closeParenPosition = this.position;
                this.movePast(node.openBraceToken);
                result = new TypeScript.SwitchStatement(expression);
                result.statement.minChar = start;
                result.statement.limChar = closeParenPosition;
                result.caseList = new TypeScript.ASTList();
                for(var i = 0, n = node.switchClauses.childCount(); i < n; i++) {
                    var switchClause = node.switchClauses.childAt(i);
                    var translated = switchClause.accept(this);
                    if (switchClause.kind() === TypeScript.SyntaxKind.DefaultSwitchClause) {
                        result.defaultCase = translated;
                    }
                    result.caseList.append(translated);
                }
                this.movePast(node.closeBraceToken);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.caseKeyword);
                var expression = node.expression.accept(this);
                this.movePast(node.colonToken);
                var statements = this.visitSyntaxList(node.statements);
                result = new TypeScript.CaseClause();
                result.expr = expression;
                result.body = statements;
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.defaultKeyword);
                this.movePast(node.colonToken);
                var statements = this.visitSyntaxList(node.statements);
                result = new TypeScript.CaseClause();
                result.body = statements;
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitBreakStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.breakKeyword);
                this.movePast(node.identifier);
                this.movePast(node.semicolonToken);
                result = new TypeScript.Jump(TypeScript.NodeType.BreakStatement);
                if (node.identifier !== null) {
                    result.target = node.identifier.valueText();
                }
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitContinueStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.continueKeyword);
                this.movePast(node.identifier);
                this.movePast(node.semicolonToken);
                result = new TypeScript.Jump(TypeScript.NodeType.ContinueStatement);
                if (node.identifier !== null) {
                    result.target = node.identifier.valueText();
                }
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitForStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.forKeyword);
                this.movePast(node.openParenToken);
                var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.initializer ? node.initializer.accept(this) : null;
                this.movePast(node.firstSemicolonToken);
                var cond = node.condition ? node.condition.accept(this) : null;
                this.movePast(node.secondSemicolonToken);
                var incr = node.incrementor ? node.incrementor.accept(this) : null;
                this.movePast(node.closeParenToken);
                var body = node.statement.accept(this);
                result = new TypeScript.ForStatement(init, cond, incr, body);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitForInStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.forKeyword);
                this.movePast(node.openParenToken);
                var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.left.accept(this);
                this.movePast(node.inKeyword);
                var expression = node.expression.accept(this);
                this.movePast(node.closeParenToken);
                var body = node.statement.accept(this);
                result = new TypeScript.ForInStatement(init, expression, body);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitWhileStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.condition);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                var statement = node.statement.accept(this);
                result = new TypeScript.WhileStatement(condition, statement);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitWithStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.condition);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                var statement = node.statement.accept(this);
                result = new TypeScript.WithStatement(condition, statement);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCastExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.lessThanToken);
                var castTerm = this.visitType(node.type);
                this.movePast(node.greaterThanToken);
                var expression = node.expression.accept(this);
                result = new TypeScript.UnaryExpression(TypeScript.NodeType.CastExpression, expression);
                result.castTerm = castTerm;
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openBraceToken);
                var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);
                this.movePast(node.closeBraceToken);
                result = new TypeScript.UnaryExpression(TypeScript.NodeType.ObjectLiteralExpression, propertyAssignments);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var left = node.propertyName.accept(this);
                this.previousTokenTrailingComments = this.convertTokenTrailingComments(node.colonToken, this.position + node.colonToken.leadingTriviaWidth() + node.colonToken.width());
                this.movePast(node.colonToken);
                var right = node.expression.accept(this);
                result = new TypeScript.BinaryExpression(TypeScript.NodeType.Member, left, right);
                result.preComments = preComments;
                if (right.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    var funcDecl = right;
                    funcDecl.hint = left.text;
                }
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);
                this.movePast(node.propertyName);
                this.movePast(node.openParenToken);
                this.movePast(node.closeParenToken);
                var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                var block = node.block ? node.block.accept(this) : null;
                var funcDecl = new TypeScript.FunctionDeclaration(name, block, false, null, new TypeScript.ASTList(), TypeScript.NodeType.FunctionDeclaration);
                this.setSpan(funcDecl, start, node);
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | TypeScript.FunctionFlags.GetAccessor);
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | TypeScript.FunctionFlags.IsFunctionExpression);
                funcDecl.hint = "get" + node.propertyName.valueText();
                funcDecl.returnTypeAnnotation = returnType;
                result = new TypeScript.BinaryExpression(TypeScript.NodeType.Member, name, funcDecl);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);
                this.movePast(node.propertyName);
                this.movePast(node.openParenToken);
                var parameter = node.parameter.accept(this);
                this.movePast(node.closeParenToken);
                var parameters = new TypeScript.ASTList();
                parameters.append(parameter);
                var block = node.block ? node.block.accept(this) : null;
                var funcDecl = new TypeScript.FunctionDeclaration(name, block, false, null, parameters, TypeScript.NodeType.FunctionDeclaration);
                this.setSpan(funcDecl, start, node);
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | TypeScript.FunctionFlags.SetAccessor);
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | TypeScript.FunctionFlags.IsFunctionExpression);
                funcDecl.hint = "set" + node.propertyName.valueText();
                result = new TypeScript.BinaryExpression(TypeScript.NodeType.Member, name, funcDecl);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                this.movePast(node.functionKeyword);
                var name = node.identifier === null ? null : this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
                var block = node.block ? node.block.accept(this) : null;
                if (node.block) {
                    if (this.hasUseStrictDirective(node.block.statements)) {
                        block.setFlags(block.getFlags() | TypeScript.ASTFlags.StrictMode);
                    }
                }
                result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, TypeScript.NodeType.FunctionDeclaration);
                result.preComments = preComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                result.setFunctionFlags(result.getFunctionFlags() | TypeScript.FunctionFlags.IsFunctionExpression);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEmptyStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.semicolonToken);
                result = new TypeScript.EmptyStatement();
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTryStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.tryKeyword);
                var tryBody = node.block.accept(this);
                var catchClause = null;
                if (node.catchClause !== null) {
                    catchClause = node.catchClause.accept(this);
                }
                var finallyBody = null;
                if (node.finallyClause !== null) {
                    finallyBody = node.finallyClause.accept(this);
                }
                result = new TypeScript.TryStatement(tryBody, catchClause, finallyBody);
            }
            TypeScript.Debug.assert(result !== null);
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCatchClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.catchKeyword);
                this.movePast(node.openParenToken);
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                this.movePast(node.closeParenToken);
                var block = node.block.accept(this);
                var varDecl = new TypeScript.VariableDeclarator(identifier);
                this.setSpanExplicit(varDecl, identifier.minChar, identifier.limChar);
                varDecl.typeExpr = typeExpr;
                result = new TypeScript.CatchClause(varDecl, block);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFinallyClause = function (node) {
            this.movePast(node.finallyKeyword);
            return node.block.accept(this);
        };
        SyntaxTreeToAstVisitor.prototype.visitLabeledStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.colonToken);
                var statement = node.statement.accept(this);
                result = new TypeScript.LabeledStatement(identifier, statement);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDoStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.doKeyword);
                var statement = node.statement.accept(this);
                var whileSpan = new TypeScript.ASTSpan();
                this.setSpan1(whileSpan, this.position, node.whileKeyword);
                this.movePast(node.whileKeyword);
                this.movePast(node.openParenToken);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                this.movePast(node.semicolonToken);
                result = new TypeScript.DoStatement(statement, condition);
                result.whileSpan = whileSpan;
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeOfExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.typeOfKeyword);
                var expression = node.expression.accept(this);
                result = new TypeScript.UnaryExpression(TypeScript.NodeType.TypeOfExpression, expression);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDeleteExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.deleteKeyword);
                var expression = node.expression.accept(this);
                result = new TypeScript.UnaryExpression(TypeScript.NodeType.DeleteExpression, expression);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVoidExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.voidKeyword);
                var expression = node.expression.accept(this);
                result = new TypeScript.UnaryExpression(TypeScript.NodeType.VoidExpression, expression);
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDebuggerStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.debuggerKeyword);
                this.movePast(node.semicolonToken);
                result = new TypeScript.DebuggerStatement();
            }
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        return SyntaxTreeToAstVisitor;
    })();
    TypeScript.SyntaxTreeToAstVisitor = SyntaxTreeToAstVisitor;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {

    var Document = (function () {
        function Document(fileName, compilationSettings, scriptSnapshot, version, isOpen, syntaxTree) {
            this.fileName = fileName;
            this.compilationSettings = compilationSettings;
            this.scriptSnapshot = scriptSnapshot;
            this.version = version;
            this.isOpen = isOpen;
            this._diagnostics = null;
            this._syntaxTree = null;
            if (isOpen) {
                this._syntaxTree = syntaxTree;
            } else {
                this._diagnostics = syntaxTree.diagnostics();
            }
            this.lineMap = syntaxTree.lineMap();
            this.script = TypeScript.SyntaxTreeToAstVisitor.visit(syntaxTree, fileName, compilationSettings);
        }
        Document.prototype.diagnostics = function () {
            if (this._diagnostics === null) {
                this._diagnostics = this._syntaxTree.diagnostics();
            }
            return this._diagnostics;
        };
        Document.prototype.syntaxTree = function () {
            if (this._syntaxTree) {
                return this._syntaxTree;
            }
            return TypeScript.Parser.parse(this.fileName, TypeScript.SimpleText.fromScriptSnapshot(this.scriptSnapshot), TypeScript.isDTSFile(this.fileName), TypeScript.LanguageVersion.EcmaScript5);
        };
        Document.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange) {
            var oldScript = this.script;
            var oldSyntaxTree = this._syntaxTree;
            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            var newSyntaxTree = textChangeRange === null || oldSyntaxTree === null ? TypeScript.Parser.parse(this.fileName, text, TypeScript.isDTSFile(this.fileName)) : TypeScript.Parser.incrementalParse(oldSyntaxTree, textChangeRange, text);
            return new Document(this.fileName, this.compilationSettings, scriptSnapshot, version, isOpen, newSyntaxTree);
        };
        Document.create = function create(fileName, scriptSnapshot, version, isOpen, referencedFiles, compilationSettings) {
            var syntaxTree = TypeScript.Parser.parse(fileName, TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot), TypeScript.isDTSFile(fileName), TypeScript.LanguageVersion.EcmaScript5);
            var document = new Document(fileName, compilationSettings, scriptSnapshot, version, isOpen, syntaxTree);
            document.script.referencedFiles = referencedFiles;
            return document;
        };
        return Document;
    })();
    TypeScript.Document = Document;    
    var TypeScriptCompiler = (function () {
        function TypeScriptCompiler(logger, settings, diagnosticMessages) {
            if (typeof logger === "undefined") { logger = new TypeScript.NullLogger(); }
            if (typeof settings === "undefined") { settings = new TypeScript.CompilationSettings(); }
            if (typeof diagnosticMessages === "undefined") { diagnosticMessages = null; }
            this.logger = logger;
            this.settings = settings;
            this.diagnosticMessages = diagnosticMessages;
            this.pullTypeChecker = null;
            this.semanticInfoChain = null;
            this.fileNameToDocument = new TypeScript.StringHashTable();
            this.emitOptions = new TypeScript.EmitOptions(this.settings);
            if (this.diagnosticMessages) {
                TypeScript.diagnosticMessages = this.diagnosticMessages;
            }
        }
        TypeScriptCompiler.prototype.getDocument = function (fileName) {
            return this.fileNameToDocument.lookup(fileName);
        };
        TypeScriptCompiler.prototype.timeFunction = function (funcDescription, func) {
            return TypeScript.timeFunction(this.logger, funcDescription, func);
        };
        TypeScriptCompiler.prototype.addSourceUnit = function (fileName, scriptSnapshot, version, isOpen, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            var _this = this;
            return this.timeFunction("addSourceUnit(" + fileName + ")", function () {
                var document = Document.create(fileName, scriptSnapshot, version, isOpen, referencedFiles, _this.emitOptions.compilationSettings);
                _this.fileNameToDocument.addOrUpdate(fileName, document);
                return document;
            });
        };
        TypeScriptCompiler.prototype.updateSourceUnit = function (fileName, scriptSnapshot, version, isOpen, textChangeRange) {
            var _this = this;
            return this.timeFunction("pullUpdateUnit(" + fileName + ")", function () {
                var document = _this.getDocument(fileName);
                var updatedDocument = document.update(scriptSnapshot, version, isOpen, textChangeRange);
                _this.fileNameToDocument.addOrUpdate(fileName, updatedDocument);
                _this.pullUpdateScript(document, updatedDocument);
                return updatedDocument;
            });
        };
        TypeScriptCompiler.prototype.isDynamicModuleCompilation = function () {
            var fileNames = this.fileNameToDocument.getAllKeys();
            for(var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                var script = document.script;
                if (!script.isDeclareFile && script.topLevelMod != null) {
                    return true;
                }
            }
            return false;
        };
        TypeScriptCompiler.prototype.updateCommonDirectoryPath = function () {
            var commonComponents = [];
            var commonComponentsLength = -1;
            var fileNames = this.fileNameToDocument.getAllKeys();
            for(var i = 0, len = fileNames.length; i < len; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileNames[i]);
                var script = document.script;
                if (!script.isDeclareFile) {
                    var fileComponents = TypeScript.filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for(var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] != fileComponents[j]) {
                                commonComponentsLength = j;
                                updatedPath = true;
                                if (j === 0) {
                                    return new TypeScript.Diagnostic(0, 0, null, "Cannot find the common subdirectory path for the input files");
                                }
                                break;
                            }
                        }
                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }
            this.emitOptions.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
            if (this.emitOptions.compilationSettings.outputOption.charAt(this.emitOptions.compilationSettings.outputOption.length - 1) != "/") {
                this.emitOptions.compilationSettings.outputOption += "/";
            }
            return null;
        };
        TypeScriptCompiler.prototype.parseEmitOption = function (ioHost) {
            this.emitOptions.ioHost = ioHost;
            if (this.emitOptions.compilationSettings.outputOption === "") {
                this.emitOptions.outputMany = true;
                this.emitOptions.commonDirectoryPath = "";
                return null;
            }
            this.emitOptions.compilationSettings.outputOption = TypeScript.switchToForwardSlashes(this.emitOptions.ioHost.resolvePath(this.emitOptions.compilationSettings.outputOption));
            if (this.emitOptions.ioHost.directoryExists(this.emitOptions.compilationSettings.outputOption)) {
                this.emitOptions.outputMany = true;
            } else if (this.emitOptions.ioHost.fileExists(this.emitOptions.compilationSettings.outputOption)) {
                this.emitOptions.outputMany = false;
            } else {
                this.emitOptions.outputMany = !TypeScript.isJSFile(this.emitOptions.compilationSettings.outputOption);
            }
            if (this.isDynamicModuleCompilation() && !this.emitOptions.outputMany) {
                return new TypeScript.Diagnostic(0, 0, null, "Cannot compile dynamic modules when emitting into single file");
            }
            if (this.emitOptions.outputMany) {
                return this.updateCommonDirectoryPath();
            }
            return null;
        };
        TypeScriptCompiler.prototype.getScripts = function () {
            var result = [];
            var fileNames = this.fileNameToDocument.getAllKeys();
            for(var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                result.push(document.script);
            }
            return result;
        };
        TypeScriptCompiler.prototype.useUTF8ForFile = function (script) {
            if (this.emitOptions.outputMany) {
                return this.outputScriptToUTF8(script);
            } else {
                return this.outputScriptsToUTF8(this.getScripts());
            }
        };
        TypeScriptCompiler.mapToDTSFileName = function mapToDTSFileName(fileName, wholeFileNameReplaced) {
            return TypeScript.getDeclareFilePath(fileName);
        };
        TypeScriptCompiler.prototype.canEmitDeclarations = function (script) {
            if (!this.settings.generateDeclarationFiles) {
                return false;
            }
            if (!!script && (script.isDeclareFile || script.moduleElements === null)) {
                return false;
            }
            return true;
        };
        TypeScriptCompiler.prototype.emitDeclarations = function (document, declarationEmitter) {
            var script = document.script;
            if (this.canEmitDeclarations(script)) {
                if (!declarationEmitter) {
                    var declareFileName = this.emitOptions.mapOutputFileName(document.fileName, TypeScriptCompiler.mapToDTSFileName);
                    declarationEmitter = new TypeScript.DeclarationEmitter(declareFileName, this.useUTF8ForFile(script), this.semanticInfoChain, this.emitOptions);
                }
                declarationEmitter.fileName = document.fileName;
                declarationEmitter.emitDeclarations(script);
            }
            return declarationEmitter;
        };
        TypeScriptCompiler.prototype.emitAllDeclarations = function () {
            if (this.canEmitDeclarations()) {
                var sharedEmitter = null;
                var fileNames = this.fileNameToDocument.getAllKeys();
                for(var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];
                    try  {
                        var document = this.getDocument(fileNames[i]);
                        if (this.emitOptions.outputMany) {
                            var singleEmitter = this.emitDeclarations(document);
                            if (singleEmitter) {
                                singleEmitter.close();
                            }
                        } else {
                            sharedEmitter = this.emitDeclarations(document, sharedEmitter);
                        }
                    } catch (ex1) {
                        return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                    }
                }
                if (sharedEmitter) {
                    try  {
                        sharedEmitter.close();
                    } catch (ex2) {
                        return TypeScript.Emitter.handleEmitterError(sharedEmitter.fileName, ex2);
                    }
                }
            }
            return [];
        };
        TypeScriptCompiler.mapToFileNameExtension = function mapToFileNameExtension(extension, fileName, wholeFileNameReplaced) {
            if (wholeFileNameReplaced) {
                return fileName;
            } else {
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        };
        TypeScriptCompiler.mapToJSFileName = function mapToJSFileName(fileName, wholeFileNameReplaced) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        };
        TypeScriptCompiler.prototype.emit = function (document, inputOutputMapper, emitter) {
            var script = document.script;
            if (!script.isDeclareFile) {
                var typeScriptFileName = document.fileName;
                if (!emitter) {
                    var javaScriptFileName = this.emitOptions.mapOutputFileName(typeScriptFileName, TypeScriptCompiler.mapToJSFileName);
                    var outFile = this.createFile(javaScriptFileName, this.useUTF8ForFile(script));
                    emitter = new TypeScript.Emitter(javaScriptFileName, outFile, this.emitOptions, this.semanticInfoChain);
                    if (this.settings.mapSourceFiles) {
                        var sourceMapFileName = javaScriptFileName + TypeScript.SourceMapper.MapFileExtension;
                        emitter.setSourceMappings(new TypeScript.SourceMapper(typeScriptFileName, javaScriptFileName, sourceMapFileName, outFile, this.createFile(sourceMapFileName, false), this.settings.emitFullSourceMapPath));
                    }
                    if (inputOutputMapper) {
                        inputOutputMapper(typeScriptFileName, javaScriptFileName);
                    }
                } else if (this.settings.mapSourceFiles) {
                    emitter.setSourceMappings(new TypeScript.SourceMapper(typeScriptFileName, emitter.emittingFileName, emitter.sourceMapper.sourceMapFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.settings.emitFullSourceMapPath));
                }
                emitter.setDocument(document);
                emitter.emitJavascript(script, false);
            }
            return emitter;
        };
        TypeScriptCompiler.prototype.emitAll = function (ioHost, inputOutputMapper) {
            var optionsDiagnostic = this.parseEmitOption(ioHost);
            if (optionsDiagnostic) {
                return [
                    optionsDiagnostic
                ];
            }
            var startEmitTime = (new Date()).getTime();
            var fileNames = this.fileNameToDocument.getAllKeys();
            var sharedEmitter = null;
            for(var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileName);
                try  {
                    if (this.emitOptions.outputMany) {
                        var singleEmitter = this.emit(document, inputOutputMapper);
                        if (singleEmitter) {
                            singleEmitter.emitSourceMapsAndClose();
                        }
                    } else {
                        sharedEmitter = this.emit(document, inputOutputMapper, sharedEmitter);
                    }
                } catch (ex1) {
                    return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                }
            }
            this.logger.log("Emit: " + ((new Date()).getTime() - startEmitTime));
            if (sharedEmitter) {
                try  {
                    sharedEmitter.emitSourceMapsAndClose();
                } catch (ex2) {
                    return TypeScript.Emitter.handleEmitterError(sharedEmitter.document.fileName, ex2);
                }
            }
            return [];
        };
        TypeScriptCompiler.prototype.outputScriptToUTF8 = function (script) {
            return script.containsUnicodeChar || (this.emitOptions.compilationSettings.emitComments && script.containsUnicodeCharInComment);
        };
        TypeScriptCompiler.prototype.outputScriptsToUTF8 = function (scripts) {
            for(var i = 0, len = scripts.length; i < len; i++) {
                var script = scripts[i];
                if (this.outputScriptToUTF8(script)) {
                    return true;
                }
            }
            return false;
        };
        TypeScriptCompiler.prototype.createFile = function (fileName, useUTF8) {
            return this.emitOptions.ioHost.createFile(fileName, useUTF8);
        };
        TypeScriptCompiler.prototype.pullResolveFile = function (fileName) {
            if (!this.pullTypeChecker) {
                return false;
            }
            var unit = this.semanticInfoChain.getUnit(fileName);
            if (!unit) {
                return false;
            }
            this.pullTypeChecker.setUnit(fileName);
            this.pullTypeChecker.resolver.resolveBoundDecls(unit.getTopLevelDecls()[0], new TypeScript.PullTypeResolutionContext());
            return true;
        };
        TypeScriptCompiler.prototype.getSyntacticDiagnostics = function (fileName) {
            return this.getDocument(fileName).diagnostics();
        };
        TypeScriptCompiler.prototype.getSyntaxTree = function (fileName) {
            return this.getDocument(fileName).syntaxTree();
        };
        TypeScriptCompiler.prototype.getScript = function (fileName) {
            return this.getDocument(fileName).script;
        };
        TypeScriptCompiler.prototype.getSemanticDiagnostics = function (fileName) {
            var _this = this;
            return this.timeFunction("getSemanticDiagnostics - " + fileName + ": ", function () {
                var errors = [];
                var unit = _this.semanticInfoChain.getUnit(fileName);
                if (unit) {
                    var document = _this.getDocument(fileName);
                    var script = document.script;
                    if (script) {
                        _this.pullTypeChecker.typeCheckScript(script, fileName, _this);
                        unit.getDiagnostics(errors);
                    }
                }
                return errors;
            });
        };
        TypeScriptCompiler.prototype.pullTypeCheck = function () {
            var _this = this;
            return this.timeFunction("pullTypeCheck()", function () {
                _this.semanticInfoChain = new TypeScript.SemanticInfoChain();
                _this.pullTypeChecker = new TypeScript.PullTypeChecker(_this.settings, _this.semanticInfoChain);
                var declCollectionContext = null;
                var i, n;
                var createDeclsStartTime = new Date().getTime();
                var fileNames = _this.fileNameToDocument.getAllKeys();
                for(var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];
                    var document = _this.getDocument(fileName);
                    var semanticInfo = new TypeScript.SemanticInfo(fileName);
                    declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                    declCollectionContext.scriptName = fileName;
                    TypeScript.getAstWalkerFactory().walk(document.script, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                    semanticInfo.addTopLevelDecl(declCollectionContext.getParent());
                    _this.semanticInfoChain.addUnit(semanticInfo);
                }
                var createDeclsEndTime = new Date().getTime();
                var bindStartTime = new Date().getTime();
                var binder = new TypeScript.PullSymbolBinder(_this.settings, _this.semanticInfoChain);
                for(var i = 1; i < _this.semanticInfoChain.units.length; i++) {
                    binder.bindDeclsForUnit(_this.semanticInfoChain.units[i].getPath());
                }
                var bindEndTime = new Date().getTime();
                var findErrorsStartTime = new Date().getTime();
                for(var i = 0, n = fileNames.length; i < n; i++) {
                    fileName = fileNames[i];
                    _this.logger.log("Type checking " + fileName);
                    _this.pullTypeChecker.typeCheckScript(_this.getDocument(fileName).script, fileName, _this);
                }
                var findErrorsEndTime = new Date().getTime();
                _this.logger.log("Decl creation: " + (createDeclsEndTime - createDeclsStartTime));
                _this.logger.log("Binding: " + (bindEndTime - bindStartTime));
                _this.logger.log("    Time in findSymbol: " + TypeScript.time_in_findSymbol);
                _this.logger.log("Find errors: " + (findErrorsEndTime - findErrorsStartTime));
            });
        };
        TypeScriptCompiler.prototype.pullUpdateScript = function (oldDocument, newDocument) {
            var _this = this;
            this.timeFunction("pullUpdateScript: ", function () {
                var oldScript = oldDocument.script;
                var newScript = newDocument.script;
                var newScriptSemanticInfo = new TypeScript.SemanticInfo(oldDocument.fileName);
                var oldScriptSemanticInfo = _this.semanticInfoChain.getUnit(oldDocument.fileName);
                TypeScript.lastBoundPullDeclId = TypeScript.pullDeclID;
                TypeScript.lastBoundPullSymbolID = TypeScript.pullSymbolID;
                var declCollectionContext = new TypeScript.DeclCollectionContext(newScriptSemanticInfo);
                declCollectionContext.scriptName = oldDocument.fileName;
                TypeScript.getAstWalkerFactory().walk(newScript, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                var oldTopLevelDecl = oldScriptSemanticInfo.getTopLevelDecls()[0];
                var newTopLevelDecl = declCollectionContext.getParent();
                newScriptSemanticInfo.addTopLevelDecl(newTopLevelDecl);
                var diffStartTime = new Date().getTime();
                var diffResults = TypeScript.PullDeclDiffer.diffDecls(oldTopLevelDecl, oldScriptSemanticInfo, newTopLevelDecl, newScriptSemanticInfo);
                var diffEndTime = new Date().getTime();
                _this.logger.log("Update Script - Diff time: " + (diffEndTime - diffStartTime));
                _this.semanticInfoChain.updateUnit(oldScriptSemanticInfo, newScriptSemanticInfo);
                var innerBindStartTime = new Date().getTime();
                var topLevelDecls = newScriptSemanticInfo.getTopLevelDecls();
                _this.semanticInfoChain.update(oldDocument.fileName);
                var binder = new TypeScript.PullSymbolBinder(_this.settings, _this.semanticInfoChain);
                binder.setUnit(oldDocument.fileName);
                for(var i = 0; i < topLevelDecls.length; i++) {
                    binder.bindDeclToPullSymbol(topLevelDecls[i], true);
                }
                var innerBindEndTime = new Date().getTime();
                _this.logger.log("Update Script - Inner bind time: " + (innerBindEndTime - innerBindStartTime));
                if (diffResults.length) {
                    var graphUpdater = new TypeScript.PullSymbolGraphUpdater(_this.semanticInfoChain);
                    var diff;
                    var traceStartTime = new Date().getTime();
                    for(var i = 0; i < diffResults.length; i++) {
                        diff = diffResults[i];
                        if (diff.kind === TypeScript.PullDeclEdit.DeclRemoved) {
                            graphUpdater.removeDecl(diff.oldDecl);
                        } else if (diff.kind === TypeScript.PullDeclEdit.DeclAdded) {
                            graphUpdater.addDecl(diff.newDecl);
                            graphUpdater.invalidateType(diff.oldDecl.getSymbol());
                        } else {
                            graphUpdater.invalidateType(diff.newDecl.getSymbol());
                        }
                    }
                    var traceEndTime = new Date().getTime();
                    _this.logger.log("Update Script - Trace time: " + (traceEndTime - traceStartTime));
                    _this.logger.log("Update Script - Number of diffs: " + diffResults.length);
                }
            });
        };
        TypeScriptCompiler.prototype.getSymbolOfDeclaration = function (decl) {
            if (!decl) {
                return null;
            }
            var ast = this.pullTypeChecker.resolver.getASTForDecl(decl);
            if (!ast) {
                return null;
            }
            var enlosingDecl = this.pullTypeChecker.resolver.getEnclosingDecl(decl);
            if (ast.nodeType == TypeScript.NodeType.Member) {
                return this.getSymbolOfDeclaration(enlosingDecl);
            }
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            return this.pullTypeChecker.resolver.resolveDeclaration(ast, resolutionContext, enlosingDecl);
        };
        TypeScriptCompiler.prototype.resolvePosition = function (pos, document) {
            var declStack = [];
            var resultASTs = [];
            var script = document.script;
            var scriptName = document.fileName;
            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var lastDeclAST = null;
            var foundAST = null;
            var symbol = null;
            var candidateSignature = null;
            var callSignatures = null;
            var lambdaAST = null;
            var declarationInitASTs = [];
            var objectLitAST = null;
            var asgAST = null;
            var typeAssertionASTs = [];
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var inTypeReference = false;
            var enclosingDecl = null;
            var isConstructorCall = false;
            var pre = function (cur, parent) {
                if (TypeScript.isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {
                        var previous = resultASTs[resultASTs.length - 1];
                        if (previous === undefined || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                            var decl = semanticInfo.getDeclForAST(cur);
                            if (decl) {
                                declStack[declStack.length] = decl;
                                lastDeclAST = cur;
                            }
                            if (cur.nodeType === TypeScript.NodeType.FunctionDeclaration && TypeScript.hasFlag((cur).getFunctionFlags(), TypeScript.FunctionFlags.IsFunctionExpression)) {
                                lambdaAST = cur;
                            } else if (cur.nodeType === TypeScript.NodeType.VariableDeclarator) {
                                declarationInitASTs[declarationInitASTs.length] = cur;
                            } else if (cur.nodeType === TypeScript.NodeType.ObjectLiteralExpression) {
                                objectLitAST = cur;
                            } else if (cur.nodeType === TypeScript.NodeType.CastExpression) {
                                typeAssertionASTs[typeAssertionASTs.length] = cur;
                            } else if (cur.nodeType === TypeScript.NodeType.AssignmentExpression) {
                                asgAST = cur;
                            } else if (cur.nodeType === TypeScript.NodeType.TypeRef) {
                                inTypeReference = true;
                            }
                            resultASTs[resultASTs.length] = cur;
                        }
                    }
                }
                return cur;
            };
            TypeScript.getAstWalkerFactory().walk(script, pre);
            if (resultASTs.length) {
                this.pullTypeChecker.setUnit(scriptName);
                foundAST = resultASTs[resultASTs.length - 1];
                if (foundAST.nodeType === TypeScript.NodeType.Name && resultASTs.length > 1) {
                    var previousAST = resultASTs[resultASTs.length - 2];
                    switch(previousAST.nodeType) {
                        case TypeScript.NodeType.InterfaceDeclaration:
                        case TypeScript.NodeType.ClassDeclaration:
                        case TypeScript.NodeType.ModuleDeclaration:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                        case TypeScript.NodeType.VariableDeclarator:
                            if (foundAST === (previousAST).id) {
                                foundAST = previousAST;
                            }
                            break;
                        case TypeScript.NodeType.FunctionDeclaration:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                    }
                }
                var funcDecl = null;
                if (lastDeclAST === foundAST) {
                    symbol = declStack[declStack.length - 1].getSymbol();
                    this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, null, resolutionContext);
                    enclosingDecl = declStack[declStack.length - 1].getParentDecl();
                    if (foundAST.nodeType === TypeScript.NodeType.FunctionDeclaration) {
                        funcDecl = foundAST;
                    }
                } else {
                    for(var i = declStack.length - 1; i >= 0; i--) {
                        if (!(declStack[i].getKind() & (TypeScript.PullElementKind.Variable | TypeScript.PullElementKind.Parameter))) {
                            enclosingDecl = declStack[i];
                            break;
                        }
                    }
                    var callExpression = null;
                    if ((foundAST.nodeType == TypeScript.NodeType.SuperExpression || foundAST.nodeType == TypeScript.NodeType.ThisExpression || foundAST.nodeType == TypeScript.NodeType.Name) && resultASTs.length > 1) {
                        for(var i = resultASTs.length - 2; i >= 0; i--) {
                            if (resultASTs[i].nodeType === TypeScript.NodeType.MemberAccessExpression && (resultASTs[i]).operand2 === resultASTs[i + 1]) {
                                foundAST = resultASTs[i];
                            } else if ((resultASTs[i].nodeType === TypeScript.NodeType.InvocationExpression || resultASTs[i].nodeType === TypeScript.NodeType.ObjectCreationExpression) && (resultASTs[i]).target === resultASTs[i + 1]) {
                                callExpression = resultASTs[i];
                                break;
                            } else if (resultASTs[i].nodeType === TypeScript.NodeType.FunctionDeclaration && (resultASTs[i]).name === resultASTs[i + 1]) {
                                funcDecl = resultASTs[i];
                                break;
                            } else {
                                break;
                            }
                        }
                    }
                    if (foundAST.nodeType === TypeScript.NodeType.List) {
                        for(var i = 0; i < (foundAST).members.length; i++) {
                            if ((foundAST).members[i].minChar > pos) {
                                foundAST = (foundAST).members[i];
                                break;
                            }
                        }
                    }
                    resolutionContext.resolveAggressively = true;
                    resolutionContext.searchTypeSpace = inTypeReference;
                    var isTypedAssignment = false;
                    if (declarationInitASTs.length) {
                        var assigningAST;
                        var varSymbol;
                        for(var i = 0; i < declarationInitASTs.length; i++) {
                            assigningAST = declarationInitASTs[i];
                            isTypedAssignment = (assigningAST != null) && (assigningAST.typeExpr != null);
                            this.pullTypeChecker.resolver.resolveDeclaration(assigningAST, resolutionContext);
                            varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);
                            if (varSymbol && isTypedAssignment) {
                                var contextualType = varSymbol.getType();
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }
                            if (assigningAST.init) {
                                this.pullTypeChecker.resolver.resolveAST(assigningAST.init, isTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                    }
                    if (typeAssertionASTs.length) {
                        for(var i = 0; i < typeAssertionASTs.length; i++) {
                            this.pullTypeChecker.resolver.resolveAST(typeAssertionASTs[i], isTypedAssignment, enclosingDecl, resolutionContext);
                        }
                    }
                    if (asgAST) {
                        this.pullTypeChecker.resolver.resolveAST(asgAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }
                    if (objectLitAST) {
                        this.pullTypeChecker.resolver.resolveAST(objectLitAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }
                    if (lambdaAST) {
                        this.pullTypeChecker.resolver.resolveAST(lambdaAST, true, enclosingDecl, resolutionContext);
                        enclosingDecl = semanticInfo.getDeclForAST(lambdaAST);
                    }
                    symbol = this.pullTypeChecker.resolver.resolveAST(foundAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    if (callExpression) {
                        var isPropertyOrVar = symbol.getKind() == TypeScript.PullElementKind.Property || symbol.getKind() == TypeScript.PullElementKind.Variable;
                        var typeSymbol = symbol.getType();
                        if (isPropertyOrVar) {
                            isPropertyOrVar = (typeSymbol.getKind() != TypeScript.PullElementKind.Interface && typeSymbol.getKind() != TypeScript.PullElementKind.ObjectType) || typeSymbol.getName() == "";
                        }
                        if (!isPropertyOrVar) {
                            isConstructorCall = foundAST.nodeType == TypeScript.NodeType.SuperExpression || callExpression.nodeType === TypeScript.NodeType.ObjectCreationExpression;
                            if (foundAST.nodeType == TypeScript.NodeType.SuperExpression) {
                                if (symbol.getKind() == TypeScript.PullElementKind.Class) {
                                    callSignatures = (symbol).getConstructorMethod().getType().getConstructSignatures();
                                }
                            } else {
                                callSignatures = callExpression.nodeType === TypeScript.NodeType.InvocationExpression ? typeSymbol.getCallSignatures() : typeSymbol.getConstructSignatures();
                            }
                            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                            if (callExpression.nodeType === TypeScript.NodeType.InvocationExpression) {
                                this.pullTypeChecker.resolver.resolveCallExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            } else {
                                this.pullTypeChecker.resolver.resolveNewExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            }
                            if (callResolutionResults.candidateSignature) {
                                candidateSignature = callResolutionResults.candidateSignature;
                            }
                            if (callResolutionResults.targetSymbol && callResolutionResults.targetSymbol.getName() != "") {
                                symbol = callResolutionResults.targetSymbol;
                            }
                            foundAST = callExpression;
                        }
                    }
                }
                if (funcDecl) {
                    if (symbol && symbol.getKind() != TypeScript.PullElementKind.Property) {
                        var signatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, this.semanticInfoChain.getUnit(scriptName));
                        candidateSignature = signatureInfo.signature;
                        callSignatures = signatureInfo.allSignatures;
                    }
                } else if (!callSignatures && symbol && (symbol.getKind() === TypeScript.PullElementKind.Method || symbol.getKind() == TypeScript.PullElementKind.Function)) {
                    var typeSym = symbol.getType();
                    if (typeSym) {
                        callSignatures = typeSym.getCallSignatures();
                    }
                }
            }
            var enclosingScopeSymbol = this.getSymbolOfDeclaration(enclosingDecl);
            return {
                symbol: symbol,
                ast: foundAST,
                enclosingScopeSymbol: enclosingScopeSymbol,
                candidateSignature: candidateSignature,
                callSignatures: callSignatures,
                isConstructorCall: isConstructorCall
            };
        };
        TypeScriptCompiler.prototype.extractResolutionContextFromPath = function (path, document) {
            var script = document.script;
            var scriptName = document.fileName;
            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var enclosingDecl = null;
            var isTypedAssignment = false;
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            resolutionContext.resolveAggressively = true;
            if (path.count() === 0) {
                return null;
            }
            this.pullTypeChecker.setUnit(semanticInfo.getPath());
            for(var i = 0, n = path.count(); i < n; i++) {
                var current = path.asts[i];
                switch(current.nodeType) {
                    case TypeScript.NodeType.FunctionDeclaration:
                        if (TypeScript.hasFlag((current).getFunctionFlags(), TypeScript.FunctionFlags.IsFunctionExpression)) {
                            this.pullTypeChecker.resolver.resolveAST((current), true, enclosingDecl, resolutionContext);
                        }
                        break;
                    case TypeScript.NodeType.VariableDeclarator:
                        var assigningAST = current;
                        isTypedAssignment = (assigningAST.typeExpr != null);
                        this.pullTypeChecker.resolver.resolveDeclaration(assigningAST, resolutionContext);
                        var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);
                        if (varSymbol && isTypedAssignment) {
                            var contextualType = varSymbol.getType();
                            resolutionContext.pushContextualType(contextualType, false, null);
                        }
                        if (assigningAST.init) {
                            this.pullTypeChecker.resolver.resolveAST(assigningAST.init, isTypedAssignment, enclosingDecl, resolutionContext);
                        }
                        break;
                    case TypeScript.NodeType.InvocationExpression:
                    case TypeScript.NodeType.ObjectCreationExpression:
                        var isNew = current.nodeType === TypeScript.NodeType.ObjectCreationExpression;
                        var callExpression = current;
                        if ((i + 1 < n) && callExpression.arguments === path.asts[i + 1]) {
                            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                            if (isNew) {
                                this.pullTypeChecker.resolver.resolveNewExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            } else {
                                this.pullTypeChecker.resolver.resolveCallExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            }
                            if (callResolutionResults.actualParametersContextTypeSymbols) {
                                var argExpression = path.asts[i + 1].nodeType === TypeScript.NodeType.List ? path.asts[i + 2] : path.asts[i + 1];
                                for(var j = 0, m = callExpression.arguments.members.length; j < m; j++) {
                                    if (callExpression.arguments.members[j] === argExpression) {
                                        var callContextualType = callResolutionResults.actualParametersContextTypeSymbols[j];
                                        if (callContextualType) {
                                            resolutionContext.pushContextualType(callContextualType, false, null);
                                            break;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (isNew) {
                                this.pullTypeChecker.resolver.resolveNewExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext);
                            } else {
                                this.pullTypeChecker.resolver.resolveCallExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                        break;
                    case TypeScript.NodeType.ArrayLiteralExpression:
                        this.pullTypeChecker.resolver.resolveAST(current, isTypedAssignment, enclosingDecl, resolutionContext);
                        var currentContextualType = resolutionContext.getContextualType();
                        if (currentContextualType && currentContextualType.isArray()) {
                            resolutionContext.pushContextualType(currentContextualType.getElementType(), false, null);
                        }
                        break;
                    case TypeScript.NodeType.ObjectLiteralExpression:
                        this.pullTypeChecker.resolver.resolveAST((current), isTypedAssignment, enclosingDecl, resolutionContext);
                        break;
                    case TypeScript.NodeType.AssignmentExpression:
                        this.pullTypeChecker.resolver.resolveAST((current), isTypedAssignment, enclosingDecl, resolutionContext);
                        break;
                    case TypeScript.NodeType.CastExpression:
                        if (i + 1 < n && path.asts[i + 1] === (current).castTerm) {
                            resolutionContext.searchTypeSpace = true;
                        }
                        var typeSymbol = this.pullTypeChecker.resolver.resolveTypeAssertionExpression(current, isTypedAssignment, enclosingDecl, resolutionContext);
                        if (typeSymbol) {
                            resolutionContext.pushContextualType(typeSymbol, false, null);
                        }
                        break;
                    case TypeScript.NodeType.TypeRef:
                    case TypeScript.NodeType.TypeParameter:
                        resolutionContext.searchTypeSpace = true;
                        break;
                }
                var decl = semanticInfo.getDeclForAST(current);
                if (decl && !(decl.getKind() & (TypeScript.PullElementKind.Variable | TypeScript.PullElementKind.Parameter | TypeScript.PullElementKind.TypeParameter))) {
                    enclosingDecl = decl;
                }
            }
            if (path.isNameOfInterface() || path.isInClassImplementsList() || path.isInInterfaceExtendsList()) {
                resolutionContext.searchTypeSpace = true;
            }
            if (path.ast().nodeType === TypeScript.NodeType.Name && path.count() > 1) {
                for(var i = path.count() - 1; i >= 0; i--) {
                    if (path.asts[path.top - 1].nodeType === TypeScript.NodeType.MemberAccessExpression && (path.asts[path.top - 1]).operand2 === path.asts[path.top]) {
                        path.pop();
                    } else {
                        break;
                    }
                }
            }
            return {
                ast: path.ast(),
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                isTypedAssignment: isTypedAssignment
            };
        };
        TypeScriptCompiler.prototype.pullGetSymbolInformationFromPath = function (path, document) {
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }
            var symbol = this.pullTypeChecker.resolver.resolveAST(path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext);
            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetDeclarationSymbolInformation = function (path, document) {
            var script = document.script;
            var scriptName = document.fileName;
            var ast = path.ast();
            if (ast.nodeType !== TypeScript.NodeType.ClassDeclaration && ast.nodeType !== TypeScript.NodeType.InterfaceDeclaration && ast.nodeType !== TypeScript.NodeType.ModuleDeclaration && ast.nodeType !== TypeScript.NodeType.FunctionDeclaration && ast.nodeType !== TypeScript.NodeType.VariableDeclarator) {
                return null;
            }
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }
            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var decl = semanticInfo.getDeclForAST(ast);
            var symbol = decl.getSymbol();
            this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, null, context.resolutionContext);
            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetCallInformationFromPath = function (path, document) {
            if (path.ast().nodeType !== TypeScript.NodeType.InvocationExpression && path.ast().nodeType !== TypeScript.NodeType.ObjectCreationExpression) {
                return null;
            }
            var isNew = (path.ast().nodeType === TypeScript.NodeType.ObjectCreationExpression);
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }
            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
            if (isNew) {
                this.pullTypeChecker.resolver.resolveNewExpression(path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            } else {
                this.pullTypeChecker.resolver.resolveCallExpression(path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            }
            return {
                targetSymbol: callResolutionResults.targetSymbol,
                resolvedSignatures: callResolutionResults.resolvedSignatures,
                candidateSignature: callResolutionResults.candidateSignature,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl),
                isConstructorCall: isNew
            };
        };
        TypeScriptCompiler.prototype.pullGetVisibleMemberSymbolsFromPath = function (path, document) {
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }
            var symbols = this.pullTypeChecker.resolver.getVisibleMembersFromExpression(path.ast(), context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }
            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetVisibleSymbolsFromPath = function (path, document) {
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }
            var symbols = this.pullTypeChecker.resolver.getVisibleSymbols(context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }
            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetContextualMembersFromPath = function (path, document) {
            if (path.ast().nodeType !== TypeScript.NodeType.ObjectLiteralExpression) {
                return null;
            }
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }
            var members = this.pullTypeChecker.resolver.getVisibleContextSymbols(context.enclosingDecl, context.resolutionContext);
            return {
                symbols: members,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };
        TypeScriptCompiler.prototype.pullGetTypeInfoAtPosition = function (pos, document) {
            var _this = this;
            return this.timeFunction("pullGetTypeInfoAtPosition for pos " + pos + ":", function () {
                return _this.resolvePosition(pos, document);
            });
        };
        TypeScriptCompiler.prototype.getTopLevelDeclarations = function (scriptName) {
            this.pullResolveFile(scriptName);
            var unit = this.semanticInfoChain.getUnit(scriptName);
            if (!unit) {
                return null;
            }
            return unit.getTopLevelDecls();
        };
        TypeScriptCompiler.prototype.reportDiagnostic = function (error, textWriter) {
            if (error.fileName()) {
                var lineCol = {
                    line: -1,
                    character: -1
                };
                var lineMap = this.getDocument(error.fileName()).lineMap;
                lineMap.fillLineAndCharacterFromPosition(error.start(), lineCol);
                textWriter.Write(error.fileName() + "(" + (lineCol.line + 1) + "," + lineCol.character + "): ");
            }
            textWriter.WriteLine(error.message());
        };
        TypeScriptCompiler.prototype.reportDiagnostics = function (errors, textWriter) {
            for(var i = 0; i < errors.length; i++) {
                this.reportDiagnostic(errors[i], textWriter);
            }
        };
        return TypeScriptCompiler;
    })();
    TypeScript.TypeScriptCompiler = TypeScriptCompiler;    
})(TypeScript || (TypeScript = {}));
var Services;
(function (Services) {
    (function (EndOfLineState) {
        EndOfLineState._map = [];
        EndOfLineState._map[0] = "Start";
        EndOfLineState.Start = 0;
        EndOfLineState._map[1] = "InMultiLineCommentTrivia";
        EndOfLineState.InMultiLineCommentTrivia = 1;
        EndOfLineState._map[2] = "InSingleQuoteStringLiteral";
        EndOfLineState.InSingleQuoteStringLiteral = 2;
        EndOfLineState._map[3] = "InDoubleQuoteStringLiteral";
        EndOfLineState.InDoubleQuoteStringLiteral = 3;
    })(Services.EndOfLineState || (Services.EndOfLineState = {}));
    var EndOfLineState = Services.EndOfLineState;
    (function (TokenClass) {
        TokenClass._map = [];
        TokenClass._map[0] = "Punctuation";
        TokenClass.Punctuation = 0;
        TokenClass._map[1] = "Keyword";
        TokenClass.Keyword = 1;
        TokenClass._map[2] = "Operator";
        TokenClass.Operator = 2;
        TokenClass._map[3] = "Comment";
        TokenClass.Comment = 3;
        TokenClass._map[4] = "Whitespace";
        TokenClass.Whitespace = 4;
        TokenClass._map[5] = "Identifier";
        TokenClass.Identifier = 5;
        TokenClass._map[6] = "NumberLiteral";
        TokenClass.NumberLiteral = 6;
        TokenClass._map[7] = "StringLiteral";
        TokenClass.StringLiteral = 7;
        TokenClass._map[8] = "RegExpLiteral";
        TokenClass.RegExpLiteral = 8;
    })(Services.TokenClass || (Services.TokenClass = {}));
    var TokenClass = Services.TokenClass;
    var noRegexTable = [];
    noRegexTable[TypeScript.SyntaxKind.IdentifierName] = true;
    noRegexTable[TypeScript.SyntaxKind.StringLiteral] = true;
    noRegexTable[TypeScript.SyntaxKind.NumericLiteral] = true;
    noRegexTable[TypeScript.SyntaxKind.RegularExpressionLiteral] = true;
    noRegexTable[TypeScript.SyntaxKind.ThisKeyword] = true;
    noRegexTable[TypeScript.SyntaxKind.PlusPlusToken] = true;
    noRegexTable[TypeScript.SyntaxKind.MinusMinusToken] = true;
    noRegexTable[TypeScript.SyntaxKind.CloseParenToken] = true;
    noRegexTable[TypeScript.SyntaxKind.CloseBracketToken] = true;
    noRegexTable[TypeScript.SyntaxKind.CloseBraceToken] = true;
    noRegexTable[TypeScript.SyntaxKind.TrueKeyword] = true;
    noRegexTable[TypeScript.SyntaxKind.FalseKeyword] = true;
    var Classifier = (function () {
        function Classifier(host) {
            this.host = host;
            this.characterWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
            this.diagnostics = [];
        }
        Classifier.prototype.getClassificationsForLine = function (text, lexState) {
            var result = new ClassificationResult();
            this.scanner = new TypeScript.Scanner("", TypeScript.SimpleText.fromString(text), TypeScript.LanguageVersion.EcmaScript5, this.characterWindow);
            if (this.checkForContinuedToken(text, lexState, result)) {
                return result;
            }
            var lastTokenKind = TypeScript.SyntaxKind.None;
            while(this.scanner.absoluteIndex() < text.length) {
                this.diagnostics.length = 0;
                var token = this.scanner.scan(this.diagnostics, !noRegexTable[lastTokenKind]);
                lastTokenKind = token.tokenKind;
                this.processToken(text, token, result);
            }
            return result;
        };
        Classifier.prototype.processToken = function (text, token, result) {
            this.processTriviaList(text, token.leadingTrivia(), result);
            this.addResult(text, result, token.width(), token.tokenKind);
            this.processTriviaList(text, token.trailingTrivia(), result);
            if (this.scanner.absoluteIndex() >= text.length) {
                if (this.diagnostics.length > 0) {
                    if (this.diagnostics[this.diagnostics.length - 1].diagnosticCode() === TypeScript.DiagnosticCode._StarSlash__expected) {
                        result.finalLexState = EndOfLineState.InMultiLineCommentTrivia;
                        return;
                    }
                }
                if (token.tokenKind === TypeScript.SyntaxKind.StringLiteral) {
                    var tokenText = token.text();
                    if (tokenText.length > 0 && tokenText.charCodeAt(tokenText.length - 1) === TypeScript.CharacterCodes.backslash) {
                        var quoteChar = tokenText.charCodeAt(0);
                        result.finalLexState = quoteChar === TypeScript.CharacterCodes.doubleQuote ? EndOfLineState.InDoubleQuoteStringLiteral : EndOfLineState.InSingleQuoteStringLiteral;
                        return;
                    }
                }
            }
        };
        Classifier.prototype.processTriviaList = function (text, triviaList, result) {
            for(var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                this.addResult(text, result, trivia.fullWidth(), trivia.kind());
            }
        };
        Classifier.prototype.addResult = function (text, result, length, kind) {
            if (length > 0) {
                result.entries.push(new ClassificationInfo(length, this.classFromKind(kind)));
            }
        };
        Classifier.prototype.classFromKind = function (kind) {
            if (TypeScript.SyntaxFacts.isAnyKeyword(kind)) {
                return TokenClass.Keyword;
            } else if (TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(kind) || TypeScript.SyntaxFacts.isPrefixUnaryExpressionOperatorToken(kind)) {
                return TokenClass.Operator;
            } else if (TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
                return TokenClass.Punctuation;
            }
            switch(kind) {
                case TypeScript.SyntaxKind.WhitespaceTrivia:
                    return TokenClass.Whitespace;
                case TypeScript.SyntaxKind.MultiLineCommentTrivia:
                case TypeScript.SyntaxKind.SingleLineCommentTrivia:
                    return TokenClass.Comment;
                case TypeScript.SyntaxKind.NumericLiteral:
                    return TokenClass.NumberLiteral;
                case TypeScript.SyntaxKind.StringLiteral:
                    return TokenClass.StringLiteral;
                case TypeScript.SyntaxKind.RegularExpressionLiteral:
                    return TokenClass.RegExpLiteral;
                case TypeScript.SyntaxKind.IdentifierName:
                default:
                    return TokenClass.Identifier;
            }
        };
        Classifier.prototype.checkForContinuedToken = function (text, lexState, result) {
            if (lexState === EndOfLineState.InMultiLineCommentTrivia) {
                return this.handleMultilineComment(text, lexState, result);
            } else if (lexState === EndOfLineState.InDoubleQuoteStringLiteral || lexState === EndOfLineState.InSingleQuoteStringLiteral) {
                return this.handleMultilineString(text, lexState, result);
            } else {
                return false;
            }
        };
        Classifier.prototype.handleMultilineComment = function (text, lexState, result) {
            var index = text.indexOf("*/");
            if (index >= 0) {
                var commentEnd = index + "*/".length;
                this.scanner.setAbsoluteIndex(commentEnd);
                result.entries.push(new ClassificationInfo(commentEnd, TokenClass.Comment));
                return false;
            } else {
                result.entries.push(new ClassificationInfo(text.length, TokenClass.Comment));
                result.finalLexState = EndOfLineState.InMultiLineCommentTrivia;
                return true;
            }
        };
        Classifier.prototype.handleMultilineString = function (text, lexState, result) {
            var endChar = lexState === EndOfLineState.InDoubleQuoteStringLiteral ? TypeScript.CharacterCodes.doubleQuote : TypeScript.CharacterCodes.singleQuote;
            var seenBackslash = true;
            for(var i = 0, n = text.length; i < n; i++) {
                if (seenBackslash) {
                    seenBackslash = false;
                    continue;
                }
                var ch = text.charCodeAt(i);
                if (ch === TypeScript.CharacterCodes.backslash) {
                    seenBackslash = true;
                    continue;
                }
                if (ch === endChar) {
                    var stringEnd = i + 1;
                    this.scanner.setAbsoluteIndex(stringEnd);
                    result.entries.push(new ClassificationInfo(stringEnd, TokenClass.StringLiteral));
                    return false;
                }
            }
            this.scanner.setAbsoluteIndex(text.length);
            result.entries.push(new ClassificationInfo(text.length, TokenClass.StringLiteral));
            if (seenBackslash) {
                result.finalLexState = lexState;
            } else {
                result.finalLexState = EndOfLineState.Start;
            }
            return true;
        };
        return Classifier;
    })();
    Services.Classifier = Classifier;    
    var ClassificationResult = (function () {
        function ClassificationResult() {
            this.finalLexState = EndOfLineState.Start;
            this.entries = [];
        }
        return ClassificationResult;
    })();
    Services.ClassificationResult = ClassificationResult;    
    var ClassificationInfo = (function () {
        function ClassificationInfo(length, classification) {
            this.length = length;
            this.classification = classification;
        }
        return ClassificationInfo;
    })();
    Services.ClassificationInfo = ClassificationInfo;    
})(Services || (Services = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var TextSnapshot = (function () {
            function TextSnapshot(snapshot) {
                this.snapshot = snapshot;
                this.lines = [];
            }
            TextSnapshot.prototype.getText = function (span) {
                return this.snapshot.substr(span.start(), span.length(), false);
            };
            TextSnapshot.prototype.getLineNumberFromPosition = function (position) {
                return this.snapshot.lineMap().getLineNumberFromPosition(position);
            };
            TextSnapshot.prototype.getLineFromPosition = function (position) {
                var lineNumber = this.getLineNumberFromPosition(position);
                return this.getLineFromLineNumber(lineNumber);
            };
            TextSnapshot.prototype.getLineFromLineNumber = function (lineNumber) {
                var line = this.lines[lineNumber];
                if (line === undefined) {
                    line = this.getLineFromLineNumberWorker(lineNumber);
                    this.lines[lineNumber] = line;
                }
                return line;
            };
            TextSnapshot.prototype.getLineFromLineNumberWorker = function (lineNumber) {
                var lineMap = this.snapshot.lineMap().lineStarts();
                var lineMapIndex = lineNumber;
                if (lineMapIndex < 0 || lineMapIndex >= lineMap.length) {
                    throw new Error("invalid line number (" + lineMapIndex + ")");
                }
                var start = lineMap[lineMapIndex];
                var end;
                var endIncludingLineBreak;
                var lineBreak = "";
                if (lineMapIndex == lineMap.length) {
                    end = endIncludingLineBreak = this.snapshot.length();
                } else {
                    endIncludingLineBreak = (lineMapIndex >= lineMap.length - 1 ? this.snapshot.length() : lineMap[lineMapIndex + 1]);
                    for(var p = endIncludingLineBreak - 1; p >= start; p--) {
                        var c = this.snapshot.substr(p, 1, false);
                        if (c != "\r" && c != "\n") {
                            break;
                        }
                    }
                    end = p + 1;
                    lineBreak = this.snapshot.substr(end, endIncludingLineBreak - end, false);
                }
                var result = new Formatting.TextSnapshotLine(this, lineNumber, start, end, lineBreak);
                return result;
            };
            return TextSnapshot;
        })();
        Formatting.TextSnapshot = TextSnapshot;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var TextSnapshotLine = (function () {
            function TextSnapshotLine(_snapshot, _lineNumber, _start, _end, _lineBreak) {
                this._snapshot = _snapshot;
                this._lineNumber = _lineNumber;
                this._start = _start;
                this._end = _end;
                this._lineBreak = _lineBreak;
            }
            TextSnapshotLine.prototype.snapshot = function () {
                return this._snapshot;
            };
            TextSnapshotLine.prototype.start = function () {
                return new Formatting.SnapshotPoint(this._snapshot, this._start);
            };
            TextSnapshotLine.prototype.startPosition = function () {
                return this._start;
            };
            TextSnapshotLine.prototype.end = function () {
                return new Formatting.SnapshotPoint(this._snapshot, this._end);
            };
            TextSnapshotLine.prototype.endPosition = function () {
                return this._end;
            };
            TextSnapshotLine.prototype.endIncludingLineBreak = function () {
                return new Formatting.SnapshotPoint(this._snapshot, this._end + this._lineBreak.length);
            };
            TextSnapshotLine.prototype.endIncludingLineBreakPosition = function () {
                return this._end + this._lineBreak.length;
            };
            TextSnapshotLine.prototype.length = function () {
                return this._end - this._start;
            };
            TextSnapshotLine.prototype.lineNumber = function () {
                return this._lineNumber;
            };
            TextSnapshotLine.prototype.getText = function () {
                return this._snapshot.getText(TypeScript.TextSpan.fromBounds(this._start, this._end));
            };
            return TextSnapshotLine;
        })();
        Formatting.TextSnapshotLine = TextSnapshotLine;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var SnapshotPoint = (function () {
            function SnapshotPoint(snapshot, position) {
                this.snapshot = snapshot;
                this.position = position;
            }
            SnapshotPoint.prototype.getContainingLine = function () {
                return this.snapshot.getLineFromPosition(this.position);
            };
            SnapshotPoint.prototype.add = function (offset) {
                return new SnapshotPoint(this.snapshot, this.position + offset);
            };
            return SnapshotPoint;
        })();
        Formatting.SnapshotPoint = SnapshotPoint;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var FormattingContext = (function () {
            function FormattingContext(snapshot, formattingRequestKind) {
                this.snapshot = snapshot;
                this.formattingRequestKind = formattingRequestKind;
                this.currentTokenSpan = null;
                this.nextTokenSpan = null;
                this.contextNode = null;
                this.currentTokenParent = null;
                this.nextTokenParent = null;
                this.contextNodeAllOnSameLine = null;
                this.tokensAreOnSameLine = null;
                this.tokensAreSiblingNodesOnSameLine = null;
                TypeScript.Debug.assert(this.snapshot != null, "snapshot is null");
            }
            FormattingContext.prototype.updateContext = function (currentTokenSpan, currentTokenParent, nextTokenSpan, nextTokenParent, commonParent) {
                TypeScript.Debug.assert(currentTokenSpan != null, "currentTokenSpan is null");
                TypeScript.Debug.assert(currentTokenParent != null, "currentTokenParent is null");
                TypeScript.Debug.assert(nextTokenSpan != null, "nextTokenSpan is null");
                TypeScript.Debug.assert(nextTokenParent != null, "nextTokenParent is null");
                TypeScript.Debug.assert(commonParent != null, "commonParent is null");
                this.currentTokenSpan = currentTokenSpan;
                this.currentTokenParent = currentTokenParent;
                this.nextTokenSpan = nextTokenSpan;
                this.nextTokenParent = nextTokenParent;
                this.contextNode = commonParent;
                this.contextNodeAllOnSameLine = null;
                this.tokensAreOnSameLine = null;
                this.tokensAreSiblingNodesOnSameLine = null;
            };
            FormattingContext.prototype.ContextNodeAllOnSameLine = function () {
                if (this.contextNodeAllOnSameLine === null) {
                    var startLine = this.snapshot.getLineNumberFromPosition(this.contextNode.start());
                    var endLine = this.snapshot.getLineNumberFromPosition(this.contextNode.end());
                    this.contextNodeAllOnSameLine = (startLine == endLine);
                }
                return this.contextNodeAllOnSameLine;
            };
            FormattingContext.prototype.TokensAreOnSameLine = function () {
                if (this.tokensAreOnSameLine === null) {
                    var startLine = this.snapshot.getLineNumberFromPosition(this.currentTokenSpan.start());
                    var endLine = this.snapshot.getLineNumberFromPosition(this.nextTokenSpan.start());
                    this.tokensAreOnSameLine = (startLine == endLine);
                }
                return this.tokensAreOnSameLine;
            };
            return FormattingContext;
        })();
        Formatting.FormattingContext = FormattingContext;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var FormattingManager = (function () {
            function FormattingManager(syntaxTree, snapshot, rulesProvider, editorOptions) {
                this.syntaxTree = syntaxTree;
                this.snapshot = snapshot;
                this.rulesProvider = rulesProvider;
                this.options = new FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);
            }
            FormattingManager.prototype.formatSelection = function (minChar, limChar) {
                var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                return this.formatSpan(span, Formatting.FormattingRequestKind.FormatSelection);
            };
            FormattingManager.prototype.formatDocument = function (minChar, limChar) {
                var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                return this.formatSpan(span, Formatting.FormattingRequestKind.FormatDocument);
            };
            FormattingManager.prototype.formatOnPaste = function (minChar, limChar) {
                var span = TypeScript.TextSpan.fromBounds(minChar, limChar);
                return this.formatSpan(span, Formatting.FormattingRequestKind.FormatOnPaste);
            };
            FormattingManager.prototype.formatOnSemicolon = function (caretPosition) {
                var sourceUnit = this.syntaxTree.sourceUnit();
                var semicolonPositionedToken = sourceUnit.findToken(caretPosition - 1);
                if (semicolonPositionedToken.kind() === TypeScript.SyntaxKind.SemicolonToken) {
                    var current = semicolonPositionedToken;
                    while(current.parent() !== null && current.parent().end() === semicolonPositionedToken.end() && current.parent().kind() !== TypeScript.SyntaxKind.List) {
                        current = current.parent();
                    }
                    var span = new TypeScript.TextSpan(current.fullStart(), current.fullWidth());
                    return this.formatSpan(span, Formatting.FormattingRequestKind.FormatOnSemicolon);
                }
                return [];
            };
            FormattingManager.prototype.formatOnClosingCurlyBrace = function (caretPosition) {
                var sourceUnit = this.syntaxTree.sourceUnit();
                var closeBracePositionedToken = sourceUnit.findToken(caretPosition - 1);
                if (closeBracePositionedToken.kind() === TypeScript.SyntaxKind.CloseBraceToken) {
                    var current = closeBracePositionedToken;
                    while(current.parent() !== null && current.parent().end() === closeBracePositionedToken.end() && current.parent().kind() !== TypeScript.SyntaxKind.List) {
                        current = current.parent();
                    }
                    var span = new TypeScript.TextSpan(current.fullStart(), current.fullWidth());
                    return this.formatSpan(span, Formatting.FormattingRequestKind.FormatOnClosingCurlyBrace);
                }
                return [];
            };
            FormattingManager.prototype.formatOnEnter = function (caretPosition) {
                var lineNumber = this.snapshot.getLineNumberFromPosition(caretPosition);
                if (lineNumber > 0) {
                    var prevLine = this.snapshot.getLineFromLineNumber(lineNumber - 1);
                    var currentLine = this.snapshot.getLineFromLineNumber(lineNumber);
                    var span = TypeScript.TextSpan.fromBounds(prevLine.startPosition(), currentLine.endPosition());
                    return this.formatSpan(span, Formatting.FormattingRequestKind.FormatOnEnter);
                }
                return [];
            };
            FormattingManager.prototype.formatSpan = function (span, formattingRequestKind) {
                var startLine = this.snapshot.getLineFromPosition(span.start());
                span = TypeScript.TextSpan.fromBounds(startLine.startPosition(), span.end());
                var result = [];
                var formattingEdits = Formatting.Formatter.getEdits(span, this.syntaxTree.sourceUnit(), this.options, true, this.snapshot, this.rulesProvider, formattingRequestKind);
                formattingEdits.forEach(function (item) {
                    var edit = new Services.TextEdit(item.position, item.position + item.length, item.replaceWith);
                    result.push(edit);
                });
                return result;
            };
            return FormattingManager;
        })();
        Formatting.FormattingManager = FormattingManager;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        (function (FormattingRequestKind) {
            FormattingRequestKind._map = [];
            FormattingRequestKind._map[0] = "FormatDocument";
            FormattingRequestKind.FormatDocument = 0;
            FormattingRequestKind._map[1] = "FormatSelection";
            FormattingRequestKind.FormatSelection = 1;
            FormattingRequestKind._map[2] = "FormatOnEnter";
            FormattingRequestKind.FormatOnEnter = 2;
            FormattingRequestKind._map[3] = "FormatOnSemicolon";
            FormattingRequestKind.FormatOnSemicolon = 3;
            FormattingRequestKind._map[4] = "FormatOnClosingCurlyBrace";
            FormattingRequestKind.FormatOnClosingCurlyBrace = 4;
            FormattingRequestKind._map[5] = "FormatOnPaste";
            FormattingRequestKind.FormatOnPaste = 5;
        })(Formatting.FormattingRequestKind || (Formatting.FormattingRequestKind = {}));
        var FormattingRequestKind = Formatting.FormattingRequestKind;
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var Rule = (function () {
            function Rule(Descriptor, Operation, Flag) {
                if (typeof Flag === "undefined") { Flag = Formatting.RuleFlags.None; }
                this.Descriptor = Descriptor;
                this.Operation = Operation;
                this.Flag = Flag;
            }
            Rule.prototype.toString = function () {
                return "[desc=" + this.Descriptor + "," + "operation=" + this.Operation + "," + "flag=" + this.Flag + "]";
            };
            return Rule;
        })();
        Formatting.Rule = Rule;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        (function (RuleAction) {
            RuleAction._map = [];
            RuleAction._map[0] = "Ignore";
            RuleAction.Ignore = 0;
            RuleAction._map[1] = "Space";
            RuleAction.Space = 1;
            RuleAction._map[2] = "NewLine";
            RuleAction.NewLine = 2;
            RuleAction._map[3] = "Delete";
            RuleAction.Delete = 3;
        })(Formatting.RuleAction || (Formatting.RuleAction = {}));
        var RuleAction = Formatting.RuleAction;
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var RuleDescriptor = (function () {
            function RuleDescriptor(LeftTokenRange, RightTokenRange) {
                this.LeftTokenRange = LeftTokenRange;
                this.RightTokenRange = RightTokenRange;
            }
            RuleDescriptor.prototype.toString = function () {
                return "[leftRange=" + this.LeftTokenRange + "," + "rightRange=" + this.RightTokenRange + "]";
            };
            RuleDescriptor.create1 = function create1(left, right) {
                return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), Formatting.Shared.TokenRange.FromToken(right));
            };
            RuleDescriptor.create2 = function create2(left, right) {
                return RuleDescriptor.create4(left, Formatting.Shared.TokenRange.FromToken(right));
            };
            RuleDescriptor.create3 = function create3(left, right) {
                return RuleDescriptor.create4(Formatting.Shared.TokenRange.FromToken(left), right);
            };
            RuleDescriptor.create4 = function create4(left, right) {
                return new RuleDescriptor(left, right);
            };
            return RuleDescriptor;
        })();
        Formatting.RuleDescriptor = RuleDescriptor;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        (function (RuleFlags) {
            RuleFlags._map = [];
            RuleFlags._map[0] = "None";
            RuleFlags.None = 0;
            RuleFlags._map[1] = "CanDeleteNewLines";
            RuleFlags.CanDeleteNewLines = 1;
        })(Formatting.RuleFlags || (Formatting.RuleFlags = {}));
        var RuleFlags = Formatting.RuleFlags;
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var RuleOperation = (function () {
            function RuleOperation() {
                this.Context = null;
                this.Action = null;
            }
            RuleOperation.prototype.toString = function () {
                return "[context=" + this.Context + "," + "action=" + this.Action + "]";
            };
            RuleOperation.create1 = function create1(action) {
                return RuleOperation.create2(Formatting.RuleOperationContext.Any, action);
            };
            RuleOperation.create2 = function create2(context, action) {
                var result = new RuleOperation();
                result.Context = context;
                result.Action = action;
                return result;
            };
            return RuleOperation;
        })();
        Formatting.RuleOperation = RuleOperation;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var RuleOperationContext = (function () {
            function RuleOperationContext() {
                var funcs = [];
                for (var _i = 0; _i < (arguments.length - 0); _i++) {
                    funcs[_i] = arguments[_i + 0];
                }
                this.customContextChecks = funcs;
            }
            RuleOperationContext.Any = new RuleOperationContext();
            RuleOperationContext.prototype.IsAny = function () {
 {
                    return this == RuleOperationContext.Any;
                }
            };
            RuleOperationContext.prototype.InContext = function (context) {
                if (this.IsAny()) {
                    return true;
                }
                for(var i = 0, len = this.customContextChecks.length; i < len; i++) {
                    if (!this.customContextChecks[i](context)) {
                        return false;
                    }
                }
                return true;
            };
            return RuleOperationContext;
        })();
        Formatting.RuleOperationContext = RuleOperationContext;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var Rules = (function () {
            function Rules() {
                this.IgnoreBeforeComment = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.Comments), Formatting.RuleOperation.create1(Formatting.RuleAction.Ignore));
                this.IgnoreAfterLineComment = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.SingleLineCommentTrivia, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create1(Formatting.RuleAction.Ignore));
                this.NoSpaceBeforeSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.SemicolonToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeColon = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.ColonToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeQMark = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.QuestionToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), Formatting.RuleAction.Delete));
                this.SpaceAfterColon = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.ColonToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterQMark = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.QuestionToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterSemicolon = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.SemicolonToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.NewLineAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.CloseBraceToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineChildParentContext), Formatting.RuleAction.NewLine));
                this.SpaceAfterCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.CloseBraceToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsCodeBlockContext), Formatting.RuleAction.Space));
                this.SpaceBetweenCloseBraceAndElse = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.CloseBraceToken, TypeScript.SyntaxKind.ElseKeyword), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.SpaceBetweenCloseBraceAndWhile = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.CloseBraceToken, TypeScript.SyntaxKind.WhileKeyword), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.NoSpaceBeforeDot = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.DotToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterDot = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.DotToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.OpenBracketToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterOpenBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.OpenBracketToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.CloseBracketToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterCloseBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.CloseBracketToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.SpaceAfterOpenBrace = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.OpenBraceToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), Formatting.RuleAction.Space));
                this.SpaceBeforeCloseBrace = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.CloseBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSingleLineBlockContext), Formatting.RuleAction.Space));
                this.NoSpaceBetweenEmptyBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.OpenBraceToken, TypeScript.SyntaxKind.CloseBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsObjectContext), Formatting.RuleAction.Delete));
                this.NewLineAfterOpenBraceInBlockContext = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.OpenBraceToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), Formatting.RuleAction.NewLine));
                this.NewLineBeforeCloseBraceInFunctionOrControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.CloseBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsMultilineBlockContext), Formatting.RuleAction.NewLine));
                this.NoSpaceAfterUnaryPrefixOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.UnaryPrefixOperators, Formatting.Shared.TokenRange.UnaryPrefixExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterUnaryPreincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.PlusPlusToken, Formatting.Shared.TokenRange.UnaryPreincrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterUnaryPredecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.MinusMinusToken, Formatting.Shared.TokenRange.UnaryPredecrementExpressions), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeUnaryPostincrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostincrementExpressions, TypeScript.SyntaxKind.PlusPlusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeUnaryPostdecrementOperator = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.UnaryPostdecrementExpressions, TypeScript.SyntaxKind.MinusMinusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.SpaceAfterPostincrementWhenFollowedByAdd = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.PlusPlusToken, TypeScript.SyntaxKind.PlusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterAddWhenFollowedByUnaryPlus = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.PlusToken, TypeScript.SyntaxKind.PlusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterAddWhenFollowedByPreincrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.PlusToken, TypeScript.SyntaxKind.PlusPlusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterPostdecrementWhenFollowedBySubtract = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.MinusMinusToken, TypeScript.SyntaxKind.MinusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterSubtractWhenFollowedByUnaryMinus = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.MinusToken, TypeScript.SyntaxKind.MinusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterSubtractWhenFollowedByPredecrement = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.MinusToken, TypeScript.SyntaxKind.MinusMinusToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.NoSpaceBeforeComma = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.CommaToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.SpaceAfterCertainKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.VarKeyword, 
                    TypeScript.SyntaxKind.ThrowKeyword, 
                    TypeScript.SyntaxKind.NewKeyword, 
                    TypeScript.SyntaxKind.DeleteKeyword, 
                    TypeScript.SyntaxKind.ReturnKeyword, 
                    TypeScript.SyntaxKind.VoidKeyword, 
                    TypeScript.SyntaxKind.TypeOfKeyword
                ]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.NoSpaceBeforeOpenParenInFuncCall = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionCallOrNewContext), Formatting.RuleAction.Delete));
                this.SpaceAfterFunctionInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.FunctionKeyword, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), Formatting.RuleAction.Space));
                this.NoSpaceBeforeOpenParenInFuncDecl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsFunctionOrGetSetDeclContext), Formatting.RuleAction.Delete));
                this.SpaceBetweenStatements = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.CloseParenToken, 
                    TypeScript.SyntaxKind.DoKeyword, 
                    TypeScript.SyntaxKind.ElseKeyword, 
                    TypeScript.SyntaxKind.CaseKeyword
                ]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotForContext), Formatting.RuleAction.Space));
                this.SpaceAfterTryFinally = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.TryKeyword, 
                    TypeScript.SyntaxKind.FinallyKeyword
                ]), TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.SpaceAfterGetSetInMember = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.IdentifierName, TypeScript.SyntaxKind.IdentifierName), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsGetSetMemberContext), Formatting.RuleAction.Space));
                this.SpaceBeforeBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryKeywordOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterBinaryKeywordOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryKeywordOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.NoSpaceAfterConstructor = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.ConstructorKeyword, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterModuleImport = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.ModuleKeyword, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.SpaceAfterCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.ClassKeyword, 
                    TypeScript.SyntaxKind.DeclareKeyword, 
                    TypeScript.SyntaxKind.EnumKeyword, 
                    TypeScript.SyntaxKind.ExportKeyword, 
                    TypeScript.SyntaxKind.ExtendsKeyword, 
                    TypeScript.SyntaxKind.GetKeyword, 
                    TypeScript.SyntaxKind.ImplementsKeyword, 
                    TypeScript.SyntaxKind.ImportKeyword, 
                    TypeScript.SyntaxKind.InterfaceKeyword, 
                    TypeScript.SyntaxKind.ModuleKeyword, 
                    TypeScript.SyntaxKind.PrivateKeyword, 
                    TypeScript.SyntaxKind.PublicKeyword, 
                    TypeScript.SyntaxKind.SetKeyword, 
                    TypeScript.SyntaxKind.StaticKeyword
                ]), Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.SpaceBeforeCertainTypeScriptKeywords = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.ExtendsKeyword, 
                    TypeScript.SyntaxKind.ImplementsKeyword
                ])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.SpaceAfterModuleName = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.StringLiteral, TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsModuleDeclContext), Formatting.RuleAction.Space));
                this.SpaceAfterArrow = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.EqualsGreaterThanToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.NoSpaceAfterEllipsis = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.DotDotDotToken, TypeScript.SyntaxKind.IdentifierName), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterOptionalParameters = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.QuestionToken, Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.CloseParenToken, 
                    TypeScript.SyntaxKind.CommaToken
                ])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsNotBinaryOpContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.TypeNames, TypeScript.SyntaxKind.LessThanToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), Formatting.RuleAction.Delete));
                this.NoSpaceBetweenCloseParenAndAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.CloseParenToken, TypeScript.SyntaxKind.LessThanToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterOpenAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.LessThanToken, Formatting.Shared.TokenRange.TypeNames), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.GreaterThanToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterCloseAngularBracket = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.GreaterThanToken, Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.OpenParenToken, 
                    TypeScript.SyntaxKind.OpenBracketToken, 
                    TypeScript.SyntaxKind.GreaterThanToken, 
                    TypeScript.SyntaxKind.CommaToken
                ])), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsTypeArgumentOrParameterContext), Formatting.RuleAction.Delete));
                this.NoSpaceBetweenEmptyInterfaceBraceBrackets = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.OpenBraceToken, TypeScript.SyntaxKind.CloseBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsInterfaceContext), Formatting.RuleAction.Delete));
                this.HighPriorityCommonRules = [
                    this.IgnoreBeforeComment, 
                    this.IgnoreAfterLineComment, 
                    this.NoSpaceBeforeSemicolon, 
                    this.NoSpaceBeforeColon, 
                    this.SpaceAfterColon, 
                    this.NoSpaceBeforeQMark, 
                    this.SpaceAfterQMark, 
                    this.NewLineAfterCloseBrace, 
                    this.NoSpaceBeforeDot, 
                    this.NoSpaceAfterDot, 
                    this.NoSpaceAfterUnaryPrefixOperator, 
                    this.NoSpaceAfterUnaryPreincrementOperator, 
                    this.NoSpaceAfterUnaryPredecrementOperator, 
                    this.NoSpaceBeforeUnaryPostincrementOperator, 
                    this.NoSpaceBeforeUnaryPostdecrementOperator, 
                    this.SpaceAfterPostincrementWhenFollowedByAdd, 
                    this.SpaceAfterAddWhenFollowedByUnaryPlus, 
                    this.SpaceAfterAddWhenFollowedByPreincrement, 
                    this.SpaceAfterPostdecrementWhenFollowedBySubtract, 
                    this.SpaceAfterSubtractWhenFollowedByUnaryMinus, 
                    this.SpaceAfterSubtractWhenFollowedByPredecrement, 
                    this.SpaceAfterOpenBrace, 
                    this.SpaceBeforeCloseBrace, 
                    this.SpaceAfterCloseBrace, 
                    this.SpaceBetweenCloseBraceAndElse, 
                    this.SpaceBetweenCloseBraceAndWhile, 
                    this.NoSpaceBetweenEmptyBraceBrackets, 
                    this.NewLineBeforeCloseBraceInFunctionOrControl, 
                    this.SpaceAfterFunctionInFuncDecl, 
                    this.NewLineAfterOpenBraceInBlockContext, 
                    this.SpaceAfterGetSetInMember, 
                    this.SpaceAfterCertainKeywords, 
                    this.NoSpaceBeforeOpenParenInFuncCall, 
                    this.SpaceBeforeBinaryKeywordOperator, 
                    this.SpaceAfterBinaryKeywordOperator, 
                    this.NoSpaceAfterConstructor, 
                    this.NoSpaceAfterModuleImport, 
                    this.SpaceAfterCertainTypeScriptKeywords, 
                    this.SpaceBeforeCertainTypeScriptKeywords, 
                    this.SpaceAfterModuleName, 
                    this.SpaceAfterArrow, 
                    this.NoSpaceAfterEllipsis, 
                    this.NoSpaceAfterOptionalParameters, 
                    this.NoSpaceBetweenEmptyInterfaceBraceBrackets, 
                    this.NoSpaceBeforeOpenAngularBracket, 
                    this.NoSpaceBetweenCloseParenAndAngularBracket, 
                    this.NoSpaceAfterOpenAngularBracket, 
                    this.NoSpaceBeforeCloseAngularBracket, 
                    this.NoSpaceAfterCloseAngularBracket
                ];
                this.LowPriorityCommonRules = [
                    this.NoSpaceBeforeComma, 
                    this.NoSpaceBeforeOpenBracket, 
                    this.NoSpaceAfterOpenBracket, 
                    this.NoSpaceBeforeCloseBracket, 
                    this.NoSpaceAfterCloseBracket, 
                    this.SpaceAfterSemicolon, 
                    this.NoSpaceBeforeOpenParenInFuncDecl, 
                    this.SpaceBetweenStatements, 
                    this.SpaceAfterTryFinally
                ];
                this.SpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.CommaToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.NoSpaceAfterComma = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.CommaToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.SpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.SpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Space));
                this.NoSpaceBeforeBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.Any, Formatting.Shared.TokenRange.BinaryOperators), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterBinaryOperator = new Formatting.Rule(Formatting.RuleDescriptor.create4(Formatting.Shared.TokenRange.BinaryOperators, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsBinaryOpContext), Formatting.RuleAction.Delete));
                this.SpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), Formatting.RuleAction.Space));
                this.NoSpaceAfterKeywordInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Keywords, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext), Formatting.RuleAction.Delete));
                this.FunctionOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.Any;
                this.FunctionOpenBraceLeftTokenRange_Js = Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.CloseParenToken, 
                    TypeScript.SyntaxKind.SingleLineCommentTrivia
                ]);
                this.SpaceBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrMultilineBlockContext), Formatting.RuleAction.Space), Formatting.RuleFlags.CanDeleteNewLines);
                this.NewLineBeforeOpenBraceInFunction = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.FunctionOpenBraceLeftTokenRange, TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext, Rules.IsMultilineBlockContext), Formatting.RuleAction.NewLine), Formatting.RuleFlags.CanDeleteNewLines);
                this.TypeScriptOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.IdentifierName, 
                    TypeScript.SyntaxKind.SingleLineCommentTrivia
                ]);
                this.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrMultilineBlockContext), Formatting.RuleAction.Space), Formatting.RuleFlags.CanDeleteNewLines);
                this.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.TypeScriptOpenBraceLeftTokenRange, TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsTypeScriptDeclWithBlockContext, Rules.IsMultilineBlockContext), Formatting.RuleAction.NewLine), Formatting.RuleFlags.CanDeleteNewLines);
                this.ControlOpenBraceLeftTokenRange = Formatting.Shared.TokenRange.FromTokens([
                    TypeScript.SyntaxKind.CloseParenToken, 
                    TypeScript.SyntaxKind.SingleLineCommentTrivia, 
                    TypeScript.SyntaxKind.DoKeyword, 
                    TypeScript.SyntaxKind.TryKeyword, 
                    TypeScript.SyntaxKind.FinallyKeyword, 
                    TypeScript.SyntaxKind.ElseKeyword
                ]);
                this.SpaceBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsNotFormatOnEnter, Rules.IsSameLineTokenOrMultilineBlockContext), Formatting.RuleAction.Space), Formatting.RuleFlags.CanDeleteNewLines);
                this.NewLineBeforeOpenBraceInControl = new Formatting.Rule(Formatting.RuleDescriptor.create2(this.ControlOpenBraceLeftTokenRange, TypeScript.SyntaxKind.OpenBraceToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsControlDeclContext, Rules.IsMultilineBlockContext), Formatting.RuleAction.NewLine), Formatting.RuleFlags.CanDeleteNewLines);
                this.SpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.SemicolonToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), Formatting.RuleAction.Space));
                this.NoSpaceAfterSemicolonInFor = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.SemicolonToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext, Rules.IsForContext), Formatting.RuleAction.Delete));
                this.SpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.OpenParenToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.SpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.CloseParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Space));
                this.NoSpaceBetweenParens = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.OpenParenToken, TypeScript.SyntaxKind.CloseParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceAfterOpenParen = new Formatting.Rule(Formatting.RuleDescriptor.create3(TypeScript.SyntaxKind.OpenParenToken, Formatting.Shared.TokenRange.Any), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.NoSpaceBeforeCloseParen = new Formatting.Rule(Formatting.RuleDescriptor.create2(Formatting.Shared.TokenRange.Any, TypeScript.SyntaxKind.CloseParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsSameLineTokenContext), Formatting.RuleAction.Delete));
                this.SpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.FunctionKeyword, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), Formatting.RuleAction.Space));
                this.NoSpaceAfterAnonymousFunctionKeyword = new Formatting.Rule(Formatting.RuleDescriptor.create1(TypeScript.SyntaxKind.FunctionKeyword, TypeScript.SyntaxKind.OpenParenToken), Formatting.RuleOperation.create2(new Formatting.RuleOperationContext(Rules.IsFunctionDeclContext), Formatting.RuleAction.Delete));
            }
            Rules.prototype.getRuleName = function (rule) {
                var o = this;
                for(var name in o) {
                    if (o[name] === rule) {
                        return name;
                    }
                }
                throw new Error("Unknown rule");
            };
            Rules.IsForContext = function IsForContext(context) {
                return context.contextNode.kind() === TypeScript.SyntaxKind.ForStatement;
            };
            Rules.IsNotForContext = function IsNotForContext(context) {
                return !Rules.IsForContext(context);
            };
            Rules.IsBinaryOpContext = function IsBinaryOpContext(context) {
                switch(context.contextNode.kind()) {
                    case TypeScript.SyntaxKind.CommaExpression:
                    case TypeScript.SyntaxKind.AssignmentExpression:
                    case TypeScript.SyntaxKind.AddAssignmentExpression:
                    case TypeScript.SyntaxKind.SubtractAssignmentExpression:
                    case TypeScript.SyntaxKind.MultiplyAssignmentExpression:
                    case TypeScript.SyntaxKind.DivideAssignmentExpression:
                    case TypeScript.SyntaxKind.ModuloAssignmentExpression:
                    case TypeScript.SyntaxKind.AndAssignmentExpression:
                    case TypeScript.SyntaxKind.ExclusiveOrAssignmentExpression:
                    case TypeScript.SyntaxKind.OrAssignmentExpression:
                    case TypeScript.SyntaxKind.LeftShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.SignedRightShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    case TypeScript.SyntaxKind.ConditionalExpression:
                    case TypeScript.SyntaxKind.LogicalOrExpression:
                    case TypeScript.SyntaxKind.LogicalAndExpression:
                    case TypeScript.SyntaxKind.BitwiseOrExpression:
                    case TypeScript.SyntaxKind.BitwiseExclusiveOrExpression:
                    case TypeScript.SyntaxKind.BitwiseAndExpression:
                    case TypeScript.SyntaxKind.EqualsWithTypeConversionExpression:
                    case TypeScript.SyntaxKind.NotEqualsWithTypeConversionExpression:
                    case TypeScript.SyntaxKind.EqualsExpression:
                    case TypeScript.SyntaxKind.NotEqualsExpression:
                    case TypeScript.SyntaxKind.LessThanExpression:
                    case TypeScript.SyntaxKind.GreaterThanExpression:
                    case TypeScript.SyntaxKind.LessThanOrEqualExpression:
                    case TypeScript.SyntaxKind.GreaterThanOrEqualExpression:
                    case TypeScript.SyntaxKind.InstanceOfExpression:
                    case TypeScript.SyntaxKind.InExpression:
                    case TypeScript.SyntaxKind.LeftShiftExpression:
                    case TypeScript.SyntaxKind.SignedRightShiftExpression:
                    case TypeScript.SyntaxKind.UnsignedRightShiftExpression:
                    case TypeScript.SyntaxKind.MultiplyExpression:
                    case TypeScript.SyntaxKind.DivideExpression:
                    case TypeScript.SyntaxKind.ModuloExpression:
                    case TypeScript.SyntaxKind.AddExpression:
                    case TypeScript.SyntaxKind.SubtractExpression:
                        return true;
                    case TypeScript.SyntaxKind.ImportDeclaration:
                    case TypeScript.SyntaxKind.VariableDeclarator:
                    case TypeScript.SyntaxKind.EqualsValueClause:
                        return context.currentTokenSpan.kind() === TypeScript.SyntaxKind.EqualsToken || context.nextTokenSpan.kind() === TypeScript.SyntaxKind.EqualsToken;
                }
                return false;
            };
            Rules.IsNotBinaryOpContext = function IsNotBinaryOpContext(context) {
                return !Rules.IsBinaryOpContext(context);
            };
            Rules.IsBlockContext = function IsBlockContext(context) {
                if (Rules.IsTypeScriptDeclWithBlockContext(context)) {
                    return true;
                }
                switch(context.contextNode.kind()) {
                    case TypeScript.SyntaxKind.Block:
                    case TypeScript.SyntaxKind.SwitchStatement:
                    case TypeScript.SyntaxKind.ObjectLiteralExpression:
                        return true;
                }
                return false;
            };
            Rules.IsSingleLineBlockContext = function IsSingleLineBlockContext(context) {
                if (!Rules.IsBlockContext(context)) {
                    return false;
                }
                return context.ContextNodeAllOnSameLine();
            };
            Rules.IsMultilineBlockContext = function IsMultilineBlockContext(context) {
                if (!Rules.IsBlockContext(context)) {
                    return false;
                }
                return !context.ContextNodeAllOnSameLine();
            };
            Rules.IsFunctionDeclContext = function IsFunctionDeclContext(context) {
                switch(context.contextNode.kind()) {
                    case TypeScript.SyntaxKind.FunctionDeclaration:
                    case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                    case TypeScript.SyntaxKind.GetMemberAccessorDeclaration:
                    case TypeScript.SyntaxKind.SetMemberAccessorDeclaration:
                    case TypeScript.SyntaxKind.MethodSignature:
                    case TypeScript.SyntaxKind.CallSignature:
                    case TypeScript.SyntaxKind.FunctionExpression:
                        return true;
                }
                return false;
            };
            Rules.IsTypeScriptDeclWithBlockContext = function IsTypeScriptDeclWithBlockContext(context) {
                switch(context.contextNode.kind()) {
                    case TypeScript.SyntaxKind.ClassDeclaration:
                    case TypeScript.SyntaxKind.EnumDeclaration:
                    case TypeScript.SyntaxKind.ObjectType:
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                        return true;
                }
                return false;
            };
            Rules.IsControlDeclContext = function IsControlDeclContext(context) {
                switch(context.contextNode.kind()) {
                    case TypeScript.SyntaxKind.IfStatement:
                    case TypeScript.SyntaxKind.SwitchStatement:
                    case TypeScript.SyntaxKind.ForStatement:
                    case TypeScript.SyntaxKind.ForInStatement:
                    case TypeScript.SyntaxKind.WhileStatement:
                    case TypeScript.SyntaxKind.TryStatement:
                    case TypeScript.SyntaxKind.DoStatement:
                    case TypeScript.SyntaxKind.WithStatement:
                    case TypeScript.SyntaxKind.ElseClause:
                    case TypeScript.SyntaxKind.CatchClause:
                    case TypeScript.SyntaxKind.FinallyClause:
                        return true;
                    default:
                        return false;
                }
            };
            Rules.IsObjectContext = function IsObjectContext(context) {
                return context.contextNode.kind() === TypeScript.SyntaxKind.ObjectLiteralExpression;
            };
            Rules.IsFunctionCallContext = function IsFunctionCallContext(context) {
                return context.contextNode.kind() === TypeScript.SyntaxKind.InvocationExpression;
            };
            Rules.IsNewContext = function IsNewContext(context) {
                return context.contextNode.kind() === TypeScript.SyntaxKind.ObjectCreationExpression;
            };
            Rules.IsFunctionCallOrNewContext = function IsFunctionCallOrNewContext(context) {
                return Rules.IsFunctionCallContext(context) || Rules.IsNewContext(context);
            };
            Rules.IsSameLineTokenContext = function IsSameLineTokenContext(context) {
                return context.TokensAreOnSameLine();
            };
            Rules.IsCodeBlockContext = function IsCodeBlockContext(context) {
                switch(context.currentTokenParent.kind()) {
                    case TypeScript.SyntaxKind.ClassDeclaration:
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                    case TypeScript.SyntaxKind.EnumDeclaration:
                    case TypeScript.SyntaxKind.Block:
                    case TypeScript.SyntaxKind.SwitchStatement:
                        return true;
                }
                return false;
            };
            Rules.IsMultilineChildParentContext = function IsMultilineChildParentContext(context) {
                return false;
            };
            Rules.IsNotFormatOnEnter = function IsNotFormatOnEnter(context) {
                return context.formattingRequestKind != Formatting.FormattingRequestKind.FormatOnEnter;
            };
            Rules.IsSameLineTokenOrMultilineBlockContext = function IsSameLineTokenOrMultilineBlockContext(context) {
                return context.TokensAreOnSameLine() || Rules.IsMultilineBlockContext(context);
            };
            Rules.IsFunctionOrGetSetDeclContext = function IsFunctionOrGetSetDeclContext(context) {
                return Rules.IsFunctionDeclContext(context) || Rules.IsGetSetMemberContext(context);
            };
            Rules.IsGetSetMemberContext = function IsGetSetMemberContext(context) {
                switch(context.contextNode.kind()) {
                    case TypeScript.SyntaxKind.GetAccessorPropertyAssignment:
                    case TypeScript.SyntaxKind.GetMemberAccessorDeclaration:
                    case TypeScript.SyntaxKind.SetAccessorPropertyAssignment:
                    case TypeScript.SyntaxKind.SetMemberAccessorDeclaration:
                        return true;
                }
                return false;
            };
            Rules.IsModuleDeclContext = function IsModuleDeclContext(context) {
                return context.contextNode.kind() === TypeScript.SyntaxKind.ModuleDeclaration;
            };
            Rules.IsInterfaceContext = function IsInterfaceContext(context) {
                return context.contextNode.kind() === TypeScript.SyntaxKind.ObjectType;
            };
            Rules.IsTypeArgumentOrParameter = function IsTypeArgumentOrParameter(tokenKind, parentKind) {
                return ((tokenKind === TypeScript.SyntaxKind.LessThanToken || tokenKind === TypeScript.SyntaxKind.GreaterThanToken) && (parentKind === TypeScript.SyntaxKind.TypeParameterList || parentKind === TypeScript.SyntaxKind.TypeArgumentList));
            };
            Rules.IsTypeArgumentOrParameterContext = function IsTypeArgumentOrParameterContext(context) {
                return Rules.IsTypeArgumentOrParameter(context.currentTokenSpan.kind(), context.currentTokenParent.kind()) || Rules.IsTypeArgumentOrParameter(context.nextTokenSpan.kind(), context.nextTokenParent.kind());
            };
            return Rules;
        })();
        Formatting.Rules = Rules;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var RulesMap = (function () {
            function RulesMap() {
                this.map = [];
                this.mapRowLength = 0;
            }
            RulesMap.create = function create(rules) {
                var result = new RulesMap();
                result.Initialize(rules);
                return result;
            };
            RulesMap.prototype.Initialize = function (rules) {
                this.mapRowLength = TypeScript.SyntaxKind.LastToken + 1;
                this.map = new Array(this.mapRowLength * this.mapRowLength);
                var rulesBucketConstructionStateList = new Array(this.map.length);
                this.FillRules(rules, rulesBucketConstructionStateList);
                return this.map;
            };
            RulesMap.prototype.FillRules = function (rules, rulesBucketConstructionStateList) {
                var _this = this;
                rules.forEach(function (rule) {
                    _this.FillRule(rule, rulesBucketConstructionStateList);
                });
            };
            RulesMap.prototype.GetRuleBucketIndex = function (row, column) {
                var rulesBucketIndex = (row * this.mapRowLength) + column;
                return rulesBucketIndex;
            };
            RulesMap.prototype.FillRule = function (rule, rulesBucketConstructionStateList) {
                var _this = this;
                var specificRule = rule.Descriptor.LeftTokenRange != Formatting.Shared.TokenRange.Any && rule.Descriptor.RightTokenRange != Formatting.Shared.TokenRange.Any;
                rule.Descriptor.LeftTokenRange.GetTokens().forEach(function (left) {
                    rule.Descriptor.RightTokenRange.GetTokens().forEach(function (right) {
                        var rulesBucketIndex = _this.GetRuleBucketIndex(left, right);
                        var rulesBucket = _this.map[rulesBucketIndex];
                        if (rulesBucket == undefined) {
                            rulesBucket = _this.map[rulesBucketIndex] = new RulesBucket();
                        }
                        rulesBucket.AddRule(rule, specificRule, rulesBucketConstructionStateList, rulesBucketIndex);
                    });
                });
            };
            RulesMap.prototype.GetRule = function (context) {
                var bucketIndex = this.GetRuleBucketIndex(context.currentTokenSpan.kind(), context.nextTokenSpan.kind());
                var bucket = this.map[bucketIndex];
                if (bucket != null) {
                    for(var i = 0, len = bucket.Rules().length; i < len; i++) {
                        var rule = bucket.Rules()[i];
                        if (rule.Operation.Context.InContext(context)) {
                            return rule;
                        }
                    }
                }
                return null;
            };
            return RulesMap;
        })();
        Formatting.RulesMap = RulesMap;        
        var MaskBitSize = 5;
        var Mask = 0x1f;
        (function (RulesPosition) {
            RulesPosition._map = [];
            RulesPosition.IgnoreRulesSpecific = 0;
            RulesPosition.IgnoreRulesAny = MaskBitSize * 1;
            RulesPosition.ContextRulesSpecific = MaskBitSize * 2;
            RulesPosition.ContextRulesAny = MaskBitSize * 3;
            RulesPosition.NoContextRulesSpecific = MaskBitSize * 4;
            RulesPosition.NoContextRulesAny = MaskBitSize * 5;
        })(Formatting.RulesPosition || (Formatting.RulesPosition = {}));
        var RulesPosition = Formatting.RulesPosition;
        var RulesBucketConstructionState = (function () {
            function RulesBucketConstructionState() {
                this.rulesInsertionIndexBitmap = 0;
            }
            RulesBucketConstructionState.prototype.GetInsertionIndex = function (maskPosition) {
                var index = 0;
                var pos = 0;
                var indexBitmap = this.rulesInsertionIndexBitmap;
                while(pos <= maskPosition) {
                    index += (indexBitmap & Mask);
                    indexBitmap >>= MaskBitSize;
                    pos += MaskBitSize;
                }
                return index;
            };
            RulesBucketConstructionState.prototype.IncreaseInsertionIndex = function (maskPosition) {
                var value = (this.rulesInsertionIndexBitmap >> maskPosition) & Mask;
                value++;
                TypeScript.Debug.assert((value & Mask) == value, "Adding more rules into the sub-bucket than allowed. Maximum allowed is 32 rules.");
                var temp = this.rulesInsertionIndexBitmap & ~(Mask << maskPosition);
                temp |= value << maskPosition;
                this.rulesInsertionIndexBitmap = temp;
            };
            return RulesBucketConstructionState;
        })();
        Formatting.RulesBucketConstructionState = RulesBucketConstructionState;        
        var RulesBucket = (function () {
            function RulesBucket() {
                this.rules = [];
            }
            RulesBucket.prototype.Rules = function () {
                return this.rules;
            };
            RulesBucket.prototype.AddRule = function (rule, specificTokens, constructionState, rulesBucketIndex) {
                var position;
                if (rule.Operation.Action == Formatting.RuleAction.Ignore) {
                    position = specificTokens ? RulesPosition.IgnoreRulesSpecific : RulesPosition.IgnoreRulesAny;
                } else if (!rule.Operation.Context.IsAny()) {
                    position = specificTokens ? RulesPosition.ContextRulesSpecific : RulesPosition.ContextRulesAny;
                } else {
                    position = specificTokens ? RulesPosition.NoContextRulesSpecific : RulesPosition.NoContextRulesAny;
                }
                var state = constructionState[rulesBucketIndex];
                if (state === undefined) {
                    state = constructionState[rulesBucketIndex] = new RulesBucketConstructionState();
                }
                var index = state.GetInsertionIndex(position);
                this.rules.splice(index, 0, rule);
                state.IncreaseInsertionIndex(position);
            };
            return RulesBucket;
        })();
        Formatting.RulesBucket = RulesBucket;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var RulesProvider = (function () {
            function RulesProvider(logger) {
                this.logger = logger;
                this.globalRules = new Formatting.Rules();
            }
            RulesProvider.prototype.getRuleName = function (rule) {
                return this.globalRules.getRuleName(rule);
            };
            RulesProvider.prototype.getRuleByName = function (name) {
                return this.globalRules[name];
            };
            RulesProvider.prototype.setActiveRules = function (staticList) {
                this.activeRules = staticList;
                this.rulesMap = Formatting.RulesMap.create(this.activeRules);
            };
            RulesProvider.prototype.getActiveRules = function () {
                return this.activeRules;
            };
            RulesProvider.prototype.getRulesMap = function () {
                return this.rulesMap;
            };
            RulesProvider.prototype.ensureUptodate = function (options) {
                var _this = this;
                if (this.options == null || !Services.compareDataObjects(this.options, options)) {
                    var activeRules = TypeScript.timeFunction(this.logger, "RulesProvider: createActiveRules()", function () {
                        return _this.createActiveRules(options);
                    });
                    var rulesMap = TypeScript.timeFunction(this.logger, "RulesProvider: RulesMap.create()", function () {
                        return Formatting.RulesMap.create(activeRules);
                    });
                    this.activeRules = activeRules;
                    this.rulesMap = rulesMap;
                    this.options = options;
                }
            };
            RulesProvider.prototype.createActiveRules = function (options) {
                var rules = this.globalRules.HighPriorityCommonRules;
                if (options.InsertSpaceAfterCommaDelimiter) {
                    rules.push(this.globalRules.SpaceAfterComma);
                } else {
                    rules.push(this.globalRules.NoSpaceAfterComma);
                }
                if (options.InsertSpaceAfterFunctionKeywordForAnonymousFunctions) {
                    rules.push(this.globalRules.SpaceAfterAnonymousFunctionKeyword);
                } else {
                    rules.push(this.globalRules.NoSpaceAfterAnonymousFunctionKeyword);
                }
                if (options.InsertSpaceAfterKeywordsInControlFlowStatements) {
                    rules.push(this.globalRules.SpaceAfterKeywordInControl);
                } else {
                    rules.push(this.globalRules.NoSpaceAfterKeywordInControl);
                }
                if (options.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis) {
                    rules.push(this.globalRules.SpaceAfterOpenParen);
                    rules.push(this.globalRules.SpaceBeforeCloseParen);
                    rules.push(this.globalRules.NoSpaceBetweenParens);
                } else {
                    rules.push(this.globalRules.NoSpaceAfterOpenParen);
                    rules.push(this.globalRules.NoSpaceBeforeCloseParen);
                    rules.push(this.globalRules.NoSpaceBetweenParens);
                }
                if (options.InsertSpaceAfterSemicolonInForStatements) {
                    rules.push(this.globalRules.SpaceAfterSemicolonInFor);
                } else {
                    rules.push(this.globalRules.NoSpaceAfterSemicolonInFor);
                }
                if (options.InsertSpaceBeforeAndAfterBinaryOperators) {
                    rules.push(this.globalRules.SpaceBeforeBinaryOperator);
                    rules.push(this.globalRules.SpaceAfterBinaryOperator);
                } else {
                    rules.push(this.globalRules.NoSpaceBeforeBinaryOperator);
                    rules.push(this.globalRules.NoSpaceAfterBinaryOperator);
                }
                if (options.PlaceOpenBraceOnNewLineForControlBlocks) {
                    rules.push(this.globalRules.NewLineBeforeOpenBraceInControl);
                } else {
                    rules.push(this.globalRules.SpaceBeforeOpenBraceInControl);
                }
                if (options.PlaceOpenBraceOnNewLineForFunctions) {
                    rules.push(this.globalRules.NewLineBeforeOpenBraceInFunction);
                    rules.push(this.globalRules.NewLineBeforeOpenBraceInTypeScriptDeclWithBlock);
                } else {
                    rules.push(this.globalRules.SpaceBeforeOpenBraceInFunction);
                    rules.push(this.globalRules.SpaceBeforeOpenBraceInTypeScriptDeclWithBlock);
                }
                rules = rules.concat(this.globalRules.LowPriorityCommonRules);
                return rules;
            };
            return RulesProvider;
        })();
        Formatting.RulesProvider = RulesProvider;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var TextEditInfo = (function () {
            function TextEditInfo(position, length, replaceWith) {
                this.position = position;
                this.length = length;
                this.replaceWith = replaceWith;
            }
            TextEditInfo.prototype.toString = function () {
                return "[ position: " + this.position + ", length: " + this.length + ", replaceWith: '" + this.replaceWith + "' ]";
            };
            return TextEditInfo;
        })();
        Formatting.TextEditInfo = TextEditInfo;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        (function (Shared) {
            var TokenRangeAccess = (function () {
                function TokenRangeAccess(from, to, except) {
                    this.tokens = [];
                    for(var token = from; token <= to; token++) {
                        if (except.indexOf(token) < 0) {
                            this.tokens.push(token);
                        }
                    }
                }
                TokenRangeAccess.prototype.GetTokens = function () {
                    return this.tokens;
                };
                TokenRangeAccess.prototype.Contains = function (token) {
                    return this.tokens.indexOf(token) >= 0;
                };
                TokenRangeAccess.prototype.toString = function () {
                    return "[tokenRangeStart=" + (TypeScript.SyntaxKind)._map[this.tokens[0]] + "," + "tokenRangeEnd=" + (TypeScript.SyntaxKind)._map[this.tokens[this.tokens.length - 1]] + "]";
                };
                return TokenRangeAccess;
            })();
            Shared.TokenRangeAccess = TokenRangeAccess;            
            var TokenValuesAccess = (function () {
                function TokenValuesAccess(tks) {
                    this.tokens = tks && tks.length ? tks : [];
                }
                TokenValuesAccess.prototype.GetTokens = function () {
                    return this.tokens;
                };
                TokenValuesAccess.prototype.Contains = function (token) {
                    return this.tokens.indexOf(token) >= 0;
                };
                return TokenValuesAccess;
            })();
            Shared.TokenValuesAccess = TokenValuesAccess;            
            var TokenSingleValueAccess = (function () {
                function TokenSingleValueAccess(token) {
                    this.token = token;
                }
                TokenSingleValueAccess.prototype.GetTokens = function () {
                    return [
                        this.token
                    ];
                };
                TokenSingleValueAccess.prototype.Contains = function (tokenValue) {
                    return tokenValue == this.token;
                };
                TokenSingleValueAccess.prototype.toString = function () {
                    return "[singleTokenKind=" + (TypeScript.SyntaxKind)._map[this.token] + "]";
                };
                return TokenSingleValueAccess;
            })();
            Shared.TokenSingleValueAccess = TokenSingleValueAccess;            
            var TokenAllAccess = (function () {
                function TokenAllAccess() { }
                TokenAllAccess.prototype.GetTokens = function () {
                    var result = [];
                    for(var token = TypeScript.SyntaxKind.FirstToken; token <= TypeScript.SyntaxKind.LastToken; token++) {
                        result.push(token);
                    }
                    return result;
                };
                TokenAllAccess.prototype.Contains = function (tokenValue) {
                    return true;
                };
                TokenAllAccess.prototype.toString = function () {
                    return "[allTokens]";
                };
                return TokenAllAccess;
            })();
            Shared.TokenAllAccess = TokenAllAccess;            
            var TokenRange = (function () {
                function TokenRange(tokenAccess) {
                    this.tokenAccess = tokenAccess;
                }
                TokenRange.FromToken = function FromToken(token) {
                    return new TokenRange(new TokenSingleValueAccess(token));
                };
                TokenRange.FromTokens = function FromTokens(tokens) {
                    return new TokenRange(new TokenValuesAccess(tokens));
                };
                TokenRange.FromRange = function FromRange(f, to, except) {
                    if (typeof except === "undefined") { except = []; }
                    return new TokenRange(new TokenRangeAccess(f, to, except));
                };
                TokenRange.AllTokens = function AllTokens() {
                    return new TokenRange(new TokenAllAccess());
                };
                TokenRange.prototype.GetTokens = function () {
                    return this.tokenAccess.GetTokens();
                };
                TokenRange.prototype.Contains = function (token) {
                    return this.tokenAccess.Contains(token);
                };
                TokenRange.prototype.toString = function () {
                    return this.tokenAccess.toString();
                };
                TokenRange.Any = TokenRange.AllTokens();
                TokenRange.Keywords = TokenRange.FromRange(TypeScript.SyntaxKind.FirstKeyword, TypeScript.SyntaxKind.LastKeyword);
                TokenRange.Operators = TokenRange.FromRange(TypeScript.SyntaxKind.SemicolonToken, TypeScript.SyntaxKind.SlashEqualsToken);
                TokenRange.BinaryOperators = TokenRange.FromRange(TypeScript.SyntaxKind.CommaToken, TypeScript.SyntaxKind.SlashEqualsToken);
                TokenRange.BinaryKeywordOperators = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.InKeyword, 
                    TypeScript.SyntaxKind.InstanceOfKeyword
                ]);
                TokenRange.ReservedKeywords = TokenRange.FromRange(TypeScript.SyntaxKind.FirstFutureReservedStrictKeyword, TypeScript.SyntaxKind.LastFutureReservedStrictKeyword);
                TokenRange.UnaryPrefixOperators = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.PlusPlusToken, 
                    TypeScript.SyntaxKind.MinusMinusToken, 
                    TypeScript.SyntaxKind.TildeToken, 
                    TypeScript.SyntaxKind.ExclamationToken
                ]);
                TokenRange.UnaryPrefixExpressions = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.NumericLiteral, 
                    TypeScript.SyntaxKind.IdentifierName, 
                    TypeScript.SyntaxKind.OpenParenToken, 
                    TypeScript.SyntaxKind.OpenBracketToken, 
                    TypeScript.SyntaxKind.OpenBraceToken, 
                    TypeScript.SyntaxKind.ThisKeyword, 
                    TypeScript.SyntaxKind.NewKeyword
                ]);
                TokenRange.UnaryPreincrementExpressions = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.IdentifierName, 
                    TypeScript.SyntaxKind.OpenParenToken, 
                    TypeScript.SyntaxKind.ThisKeyword, 
                    TypeScript.SyntaxKind.NewKeyword
                ]);
                TokenRange.UnaryPostincrementExpressions = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.IdentifierName, 
                    TypeScript.SyntaxKind.CloseParenToken, 
                    TypeScript.SyntaxKind.CloseBracketToken, 
                    TypeScript.SyntaxKind.NewKeyword
                ]);
                TokenRange.UnaryPredecrementExpressions = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.IdentifierName, 
                    TypeScript.SyntaxKind.OpenParenToken, 
                    TypeScript.SyntaxKind.ThisKeyword, 
                    TypeScript.SyntaxKind.NewKeyword
                ]);
                TokenRange.UnaryPostdecrementExpressions = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.IdentifierName, 
                    TypeScript.SyntaxKind.CloseParenToken, 
                    TypeScript.SyntaxKind.CloseBracketToken, 
                    TypeScript.SyntaxKind.NewKeyword
                ]);
                TokenRange.Comments = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.SingleLineCommentTrivia, 
                    TypeScript.SyntaxKind.MultiLineCommentTrivia
                ]);
                TokenRange.TypeNames = TokenRange.FromTokens([
                    TypeScript.SyntaxKind.IdentifierName, 
                    TypeScript.SyntaxKind.NumberKeyword, 
                    TypeScript.SyntaxKind.StringKeyword, 
                    TypeScript.SyntaxKind.BooleanKeyword, 
                    TypeScript.SyntaxKind.BoolKeyword, 
                    TypeScript.SyntaxKind.VoidKeyword, 
                    TypeScript.SyntaxKind.AnyKeyword
                ]);
                return TokenRange;
            })();
            Shared.TokenRange = TokenRange;            
        })(Formatting.Shared || (Formatting.Shared = {}));
        var Shared = Formatting.Shared;
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var TokenSpan = (function (_super) {
            __extends(TokenSpan, _super);
            function TokenSpan(kind, start, length) {
                _super.call(this, start, length);
                this._kind = kind;
            }
            TokenSpan.prototype.kind = function () {
                return this._kind;
            };
            return TokenSpan;
        })(TypeScript.TextSpan);
        Formatting.TokenSpan = TokenSpan;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var IndentationNodeContext = (function () {
            function IndentationNodeContext(parent, node, fullStart, indentationLevel, childIndentationLevelDelta) {
                this.update(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
            }
            IndentationNodeContext.prototype.parent = function () {
                return this._parent;
            };
            IndentationNodeContext.prototype.node = function () {
                return this._node;
            };
            IndentationNodeContext.prototype.fullStart = function () {
                return this._fullStart;
            };
            IndentationNodeContext.prototype.fullWidth = function () {
                return this._node.fullWidth();
            };
            IndentationNodeContext.prototype.start = function () {
                return this._fullStart + this._node.leadingTriviaWidth();
            };
            IndentationNodeContext.prototype.end = function () {
                return this._fullStart + this._node.leadingTriviaWidth() + this._node.width();
            };
            IndentationNodeContext.prototype.indentationLevel = function () {
                return this._indentationLevel;
            };
            IndentationNodeContext.prototype.childIndentationLevelDelta = function () {
                return this._childIndentationLevelDelta;
            };
            IndentationNodeContext.prototype.depth = function () {
                return this._depth;
            };
            IndentationNodeContext.prototype.kind = function () {
                return this._node.kind();
            };
            IndentationNodeContext.prototype.hasSkippedOrMissingTokenChild = function () {
                if (this._hasSkippedOrMissingTokenChild === null) {
                    this._hasSkippedOrMissingTokenChild = TypeScript.Syntax.nodeHasSkippedOrMissingTokens(this._node);
                }
                return this._hasSkippedOrMissingTokenChild;
            };
            IndentationNodeContext.prototype.clone = function (pool) {
                var parent = null;
                if (this._parent) {
                    parent = this._parent.clone(pool);
                }
                return pool.getNode(parent, this._node, this._fullStart, this._indentationLevel, this._childIndentationLevelDelta);
            };
            IndentationNodeContext.prototype.update = function (parent, node, fullStart, indentationLevel, childIndentationLevelDelta) {
                this._parent = parent;
                this._node = node;
                this._fullStart = fullStart;
                this._indentationLevel = indentationLevel;
                this._childIndentationLevelDelta = childIndentationLevelDelta;
                this._hasSkippedOrMissingTokenChild = null;
                if (parent) {
                    this._depth = parent.depth() + 1;
                } else {
                    this._depth = 0;
                }
            };
            return IndentationNodeContext;
        })();
        Formatting.IndentationNodeContext = IndentationNodeContext;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var IndentationNodeContextPool = (function () {
            function IndentationNodeContextPool() {
                this.nodes = [];
            }
            IndentationNodeContextPool.prototype.getNode = function (parent, node, fullStart, indentationLevel, childIndentationLevelDelta) {
                if (this.nodes.length > 0) {
                    var cachedNode = this.nodes.pop();
                    cachedNode.update(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
                    return cachedNode;
                }
                return new Formatting.IndentationNodeContext(parent, node, fullStart, indentationLevel, childIndentationLevelDelta);
            };
            IndentationNodeContextPool.prototype.releaseNode = function (node, recursive) {
                if (typeof recursive === "undefined") { recursive = false; }
                this.nodes.push(node);
                if (recursive) {
                    var parent = node.parent();
                    if (parent) {
                        this.releaseNode(parent, recursive);
                    }
                }
            };
            return IndentationNodeContextPool;
        })();
        Formatting.IndentationNodeContextPool = IndentationNodeContextPool;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var IndentationTrackingWalker = (function (_super) {
            __extends(IndentationTrackingWalker, _super);
            function IndentationTrackingWalker(textSpan, sourceUnit, snapshot, indentFirstToken) {
                _super.call(this);
                this._position = 0;
                this._parent = null;
                this._indentationNodeContextPool = new Formatting.IndentationNodeContextPool();
                this._textSpan = textSpan;
                this._snapshot = snapshot;
                this._parent = this._indentationNodeContextPool.getNode(null, sourceUnit, 0, 0, 0);
                this._lastTriviaWasNewLine = indentFirstToken;
            }
            IndentationTrackingWalker.prototype.position = function () {
                return this._position;
            };
            IndentationTrackingWalker.prototype.parent = function () {
                return this._parent;
            };
            IndentationTrackingWalker.prototype.textSpan = function () {
                return this._textSpan;
            };
            IndentationTrackingWalker.prototype.snapshot = function () {
                return this._snapshot;
            };
            IndentationTrackingWalker.prototype.indentationNodeContextPool = function () {
                return this._indentationNodeContextPool;
            };
            IndentationTrackingWalker.prototype.forceIndentNextToken = function () {
                this._lastTriviaWasNewLine = true;
            };
            IndentationTrackingWalker.prototype.forceSkipIndentingNextToken = function () {
                this._lastTriviaWasNewLine = false;
            };
            IndentationTrackingWalker.prototype.indentToken = function (token, indentationLevel, commentIndentationLevel) {
                throw TypeScript.Errors.abstract();
            };
            IndentationTrackingWalker.prototype.visitTokenInSpan = function (token) {
                if (this._lastTriviaWasNewLine) {
                    var indentationLevel = this.getTokenIndentationLevel(token);
                    var commentIndentationLevel = this.getCommentIndentationLevel(token);
                    this.indentToken(token, indentationLevel, commentIndentationLevel);
                }
            };
            IndentationTrackingWalker.prototype.visitToken = function (token) {
                var tokenSpan = new TypeScript.TextSpan(this._position, token.fullWidth());
                if (tokenSpan.intersectsWithTextSpan(this._textSpan)) {
                    this.visitTokenInSpan(token);
                    var trivia = token.trailingTrivia();
                    this._lastTriviaWasNewLine = token.hasTrailingNewLine() && trivia.syntaxTriviaAt(trivia.count() - 1).kind() == TypeScript.SyntaxKind.NewLineTrivia;
                }
                this._position += token.fullWidth();
            };
            IndentationTrackingWalker.prototype.visitNode = function (node) {
                var nodeSpan = new TypeScript.TextSpan(this._position, node.fullWidth());
                if (nodeSpan.intersectsWithTextSpan(this._textSpan)) {
                    var indentation = this.getNodeIndentation(node);
                    var currentParent = this._parent;
                    this._parent = this._indentationNodeContextPool.getNode(currentParent, node, this._position, indentation.indentationLevel, indentation.indentationLevelDelta);
                    node.accept(this);
                    this._indentationNodeContextPool.releaseNode(this._parent);
                    this._parent = currentParent;
                } else {
                    this._position += node.fullWidth();
                }
            };
            IndentationTrackingWalker.prototype.getTokenIndentationLevel = function (token) {
                if (this._parent.node().firstToken() === token || token.kind() === TypeScript.SyntaxKind.OpenBraceToken || token.kind() === TypeScript.SyntaxKind.CloseBraceToken || token.kind() === TypeScript.SyntaxKind.OpenBracketToken || token.kind() === TypeScript.SyntaxKind.CloseBracketToken || (token.kind() === TypeScript.SyntaxKind.WhileKeyword && this._parent.node().kind() == TypeScript.SyntaxKind.DoStatement)) {
                    return this._parent.indentationLevel();
                }
                return (this._parent.indentationLevel() + this._parent.childIndentationLevelDelta());
            };
            IndentationTrackingWalker.prototype.getCommentIndentationLevel = function (token) {
                if (token.kind() === TypeScript.SyntaxKind.CloseBraceToken || token.kind() === TypeScript.SyntaxKind.CloseBracketToken) {
                    return (this._parent.indentationLevel() + this._parent.childIndentationLevelDelta());
                }
                return this._parent.indentationLevel();
            };
            IndentationTrackingWalker.prototype.getNodeIndentation = function (node) {
                var parent = this._parent.node();
                var parentIndentationLevel = this._parent.indentationLevel();
                var parentIndentationLevelDelta = this._parent.childIndentationLevelDelta();
                var indentationLevel;
                var indentationLevelDelta;
                switch(node.kind()) {
                    default:
                        indentationLevel = (parentIndentationLevel + parentIndentationLevelDelta);
                        indentationLevelDelta = 0;
                        break;
                    case TypeScript.SyntaxKind.ClassDeclaration:
                    case TypeScript.SyntaxKind.ModuleDeclaration:
                    case TypeScript.SyntaxKind.ObjectType:
                    case TypeScript.SyntaxKind.EnumDeclaration:
                    case TypeScript.SyntaxKind.SwitchStatement:
                    case TypeScript.SyntaxKind.ObjectLiteralExpression:
                    case TypeScript.SyntaxKind.ConstructorDeclaration:
                    case TypeScript.SyntaxKind.FunctionDeclaration:
                    case TypeScript.SyntaxKind.FunctionExpression:
                    case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                    case TypeScript.SyntaxKind.GetMemberAccessorDeclaration:
                    case TypeScript.SyntaxKind.SetMemberAccessorDeclaration:
                    case TypeScript.SyntaxKind.CatchClause:
                    case TypeScript.SyntaxKind.ArrayLiteralExpression:
                    case TypeScript.SyntaxKind.ArrayType:
                    case TypeScript.SyntaxKind.ElementAccessExpression:
                    case TypeScript.SyntaxKind.IndexSignature:
                    case TypeScript.SyntaxKind.ForStatement:
                    case TypeScript.SyntaxKind.ForInStatement:
                    case TypeScript.SyntaxKind.WhileStatement:
                    case TypeScript.SyntaxKind.DoStatement:
                    case TypeScript.SyntaxKind.WithStatement:
                    case TypeScript.SyntaxKind.CaseSwitchClause:
                    case TypeScript.SyntaxKind.DefaultSwitchClause:
                    case TypeScript.SyntaxKind.ReturnStatement:
                    case TypeScript.SyntaxKind.ThrowStatement:
                    case TypeScript.SyntaxKind.SimpleArrowFunctionExpression:
                    case TypeScript.SyntaxKind.ParenthesizedArrowFunctionExpression:
                    case TypeScript.SyntaxKind.VariableDeclaration:
                    case TypeScript.SyntaxKind.ExportAssignment:
                    case TypeScript.SyntaxKind.InvocationExpression:
                    case TypeScript.SyntaxKind.ObjectCreationExpression:
                    case TypeScript.SyntaxKind.CallSignature:
                    case TypeScript.SyntaxKind.ConstructSignature:
                        indentationLevel = (parentIndentationLevel + parentIndentationLevelDelta);
                        indentationLevelDelta = 1;
                        break;
                    case TypeScript.SyntaxKind.IfStatement:
                        if (parent.kind() === TypeScript.SyntaxKind.ElseClause && !(parent).elseKeyword.hasTrailingNewLine() && !(node).ifKeyword.hasLeadingNewLine()) {
                            indentationLevel = parentIndentationLevel;
                        } else {
                            indentationLevel = (parentIndentationLevel + parentIndentationLevelDelta);
                        }
                        indentationLevelDelta = 1;
                        break;
                    case TypeScript.SyntaxKind.ElseClause:
                        indentationLevel = parentIndentationLevel;
                        indentationLevelDelta = 1;
                        break;
                    case TypeScript.SyntaxKind.Block:
                        switch(parent.kind()) {
                            case TypeScript.SyntaxKind.SourceUnit:
                            case TypeScript.SyntaxKind.ModuleDeclaration:
                            case TypeScript.SyntaxKind.Block:
                            case TypeScript.SyntaxKind.CaseSwitchClause:
                            case TypeScript.SyntaxKind.DefaultSwitchClause:
                                indentationLevel = parentIndentationLevel + parentIndentationLevelDelta;
                                break;
                            default:
                                indentationLevel = parentIndentationLevel;
                                break;
                        }
                        indentationLevelDelta = 1;
                        break;
                }
                if (parent) {
                    var parentStartLine = this._snapshot.getLineNumberFromPosition(this._parent.start());
                    var currentNodeStartLine = this._snapshot.getLineNumberFromPosition(this._position + node.leadingTriviaWidth());
                    if (parentStartLine === currentNodeStartLine) {
                        indentationLevel = parentIndentationLevel;
                        indentationLevelDelta = Math.min(1, parentIndentationLevelDelta + indentationLevelDelta);
                    }
                }
                return {
                    indentationLevel: indentationLevel,
                    indentationLevelDelta: indentationLevelDelta
                };
            };
            return IndentationTrackingWalker;
        })(TypeScript.SyntaxWalker);
        Formatting.IndentationTrackingWalker = IndentationTrackingWalker;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var MultipleTokenIndenter = (function (_super) {
            __extends(MultipleTokenIndenter, _super);
            function MultipleTokenIndenter(textSpan, sourceUnit, snapshot, indentFirstToken, options) {
                _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken);
                this._edits = [];
                this.options = options;
            }
            MultipleTokenIndenter.prototype.indentToken = function (token, indentationLevel, commentIndentationLevel) {
                if (token.fullWidth() === 0) {
                    return;
                }
                if (this.parent().hasSkippedOrMissingTokenChild()) {
                    return;
                }
                var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), token.width());
                if (!this.textSpan().containsTextSpan(tokenSpan)) {
                    return;
                }
                var indentationAmount = indentationLevel * this.options.indentSpaces;
                var indentationString = TypeScript.Indentation.indentationString(indentationAmount, this.options);
                var commentIndentationAmount = commentIndentationLevel * this.options.indentSpaces;
                var commentIndentationString = TypeScript.Indentation.indentationString(commentIndentationAmount, this.options);
                this.recordIndentationEditsForToken(token, indentationString, commentIndentationString);
            };
            MultipleTokenIndenter.prototype.edits = function () {
                return this._edits;
            };
            MultipleTokenIndenter.prototype.recordEdit = function (position, length, replaceWith) {
                this._edits.push(new Formatting.TextEditInfo(position, length, replaceWith));
            };
            MultipleTokenIndenter.prototype.recordIndentationEditsForToken = function (token, indentationString, commentIndentationString) {
                var position = this.position();
                var indentNextTokenOrTrivia = true;
                var leadingWhiteSpace = "";
                var triviaList = token.leadingTrivia();
                if (triviaList) {
                    for(var i = 0, length = triviaList.count(); i < length; i++) {
                        var trivia = triviaList.syntaxTriviaAt(i);
                        switch(trivia.kind()) {
                            case TypeScript.SyntaxKind.MultiLineCommentTrivia:
                                this.recordIndentationEditsForMultiLineComment(trivia, position, commentIndentationString, leadingWhiteSpace, !indentNextTokenOrTrivia);
                                indentNextTokenOrTrivia = false;
                                leadingWhiteSpace = "";
                                break;
                            case TypeScript.SyntaxKind.SingleLineCommentTrivia:
                            case TypeScript.SyntaxKind.SkippedTextTrivia:
                                if (indentNextTokenOrTrivia) {
                                    this.recordIndentationEditsForSingleLineOrSkippedText(trivia, position, commentIndentationString);
                                    indentNextTokenOrTrivia = false;
                                }
                                break;
                            case TypeScript.SyntaxKind.WhitespaceTrivia:
                                var nextTriviaIsComment = triviaList.count() > i + 1 && triviaList.syntaxTriviaAt(i + 1).isComment();
                                if (indentNextTokenOrTrivia) {
                                    this.recordIndentationEditsForWhitespace(trivia, position, nextTriviaIsComment ? commentIndentationString : indentationString);
                                    indentNextTokenOrTrivia = false;
                                }
                                leadingWhiteSpace += trivia.fullText();
                                break;
                            case TypeScript.SyntaxKind.NewLineTrivia:
                                indentNextTokenOrTrivia = true;
                                leadingWhiteSpace = "";
                                break;
                            default:
                                throw TypeScript.Errors.invalidOperation();
                        }
                        position += trivia.fullWidth();
                    }
                }
                if (token.kind() !== TypeScript.SyntaxKind.EndOfFileToken && indentNextTokenOrTrivia) {
                    if (indentationString.length > 0) {
                        this.recordEdit(position, 0, indentationString);
                    }
                }
            };
            MultipleTokenIndenter.prototype.recordIndentationEditsForSingleLineOrSkippedText = function (trivia, fullStart, indentationString) {
                if (indentationString.length > 0) {
                    this.recordEdit(fullStart, 0, indentationString);
                }
            };
            MultipleTokenIndenter.prototype.recordIndentationEditsForWhitespace = function (trivia, fullStart, indentationString) {
                var text = trivia.fullText();
                if (indentationString === text) {
                    return;
                }
                this.recordEdit(fullStart, text.length, indentationString);
            };
            MultipleTokenIndenter.prototype.recordIndentationEditsForMultiLineComment = function (trivia, fullStart, indentationString, leadingWhiteSpace, firstLineAlreadyIndented) {
                var position = fullStart;
                var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                if (segments.length <= 1) {
                    if (!firstLineAlreadyIndented) {
                        this.recordIndentationEditsForSingleLineOrSkippedText(trivia, fullStart, indentationString);
                    }
                    return;
                }
                var whiteSpaceColumnsInFirstSegment = TypeScript.Indentation.columnForPositionInString(leadingWhiteSpace, leadingWhiteSpace.length, this.options);
                var indentationColumns = TypeScript.Indentation.columnForPositionInString(indentationString, indentationString.length, this.options);
                var startIndex = 0;
                if (firstLineAlreadyIndented) {
                    startIndex = 1;
                    position += segments[0].length;
                }
                for(var i = startIndex; i < segments.length; i++) {
                    var segment = segments[i];
                    this.recordIndentationEditsForSegment(segment, position, indentationColumns, whiteSpaceColumnsInFirstSegment);
                    position += segment.length;
                }
            };
            MultipleTokenIndenter.prototype.recordIndentationEditsForSegment = function (segment, fullStart, indentationColumns, whiteSpaceColumnsInFirstSegment) {
                var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);
                var leadingWhiteSpaceColumns = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);
                var deltaFromFirstSegment = leadingWhiteSpaceColumns - whiteSpaceColumnsInFirstSegment;
                var finalColumns = indentationColumns + deltaFromFirstSegment;
                if (finalColumns < 0) {
                    finalColumns = 0;
                }
                var indentationString = TypeScript.Indentation.indentationString(finalColumns, this.options);
                if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                    return;
                }
                if (indentationString === segment.substring(0, firstNonWhitespacePosition)) {
                    return;
                }
                this.recordEdit(fullStart, firstNonWhitespacePosition, indentationString);
            };
            return MultipleTokenIndenter;
        })(Formatting.IndentationTrackingWalker);
        Formatting.MultipleTokenIndenter = MultipleTokenIndenter;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var SingleTokenIndenter = (function (_super) {
            __extends(SingleTokenIndenter, _super);
            function SingleTokenIndenter(indentationPosition, sourceUnit, snapshot, indentFirstToken, options) {
                _super.call(this, new TypeScript.TextSpan(indentationPosition, 1), sourceUnit, snapshot, indentFirstToken);
                this.indentationAmount = null;
                this.indentationPosition = indentationPosition;
                this.options = options;
            }
            SingleTokenIndenter.getIndentationAmount = function getIndentationAmount(position, sourceUnit, snapshot, options) {
                var walker = new SingleTokenIndenter(position, sourceUnit, snapshot, true, options);
                sourceUnit.accept(walker);
                return walker.indentationAmount;
            };
            SingleTokenIndenter.prototype.indentToken = function (token, indentationLevel, commentIndentationLevel) {
                if (token.fullWidth() === 0 || (this.indentationPosition - this.position() < token.leadingTriviaWidth())) {
                    this.indentationAmount = commentIndentationLevel * this.options.indentSpaces;
                } else {
                    this.indentationAmount = indentationLevel * this.options.indentSpaces;
                }
            };
            return SingleTokenIndenter;
        })(Formatting.IndentationTrackingWalker);
        Formatting.SingleTokenIndenter = SingleTokenIndenter;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Formatting) {
        var Formatter = (function (_super) {
            __extends(Formatter, _super);
            function Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind) {
                _super.call(this, textSpan, sourceUnit, snapshot, indentFirstToken, options);
                this.previousTokenSpan = null;
                this.previousTokenParent = null;
                this.scriptHasErrors = false;
                this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                this.rulesProvider = rulesProvider;
                this.formattingRequestKind = formattingRequestKind;
                this.formattingContext = new Formatting.FormattingContext(this.snapshot(), this.formattingRequestKind);
            }
            Formatter.getEdits = function getEdits(textSpan, sourceUnit, options, indentFirstToken, snapshot, rulesProvider, formattingRequestKind) {
                var walker = new Formatter(textSpan, sourceUnit, indentFirstToken, options, snapshot, rulesProvider, formattingRequestKind);
                sourceUnit.accept(walker);
                return walker.edits();
            };
            Formatter.prototype.visitTokenInSpan = function (token) {
                if (token.fullWidth() !== 0) {
                    var tokenSpan = new TypeScript.TextSpan(this.position() + token.leadingTriviaWidth(), token.width());
                    if (this.textSpan().containsTextSpan(tokenSpan)) {
                        this.processToken(token);
                    }
                }
                _super.prototype.visitTokenInSpan.call(this, token);
            };
            Formatter.prototype.processToken = function (token) {
                var position = this.position();
                if (token.leadingTriviaWidth() !== 0) {
                    this.processTrivia(token.leadingTrivia(), position);
                    position += token.leadingTriviaWidth();
                }
                if (token.kind() !== TypeScript.SyntaxKind.EndOfFileToken) {
                    var currentTokenSpan = new Formatting.TokenSpan(token.kind(), position, token.width());
                    if (this.previousTokenSpan && !this.parent().hasSkippedOrMissingTokenChild()) {
                        this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                    }
                    this.previousTokenSpan = currentTokenSpan;
                    if (this.previousTokenParent) {
                        this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                    }
                    this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                    position += token.width();
                    if (token.trailingTriviaWidth() !== 0) {
                        this.processTrivia(token.trailingTrivia(), position);
                    }
                }
            };
            Formatter.prototype.processTrivia = function (triviaList, fullStart) {
                var position = fullStart;
                for(var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isComment() || trivia.isSkippedText()) {
                        var currentTokenSpan = new Formatting.TokenSpan(trivia.kind(), position, trivia.fullWidth());
                        if (this.previousTokenSpan && trivia.isComment()) {
                            this.formatPair(this.previousTokenSpan, this.previousTokenParent, currentTokenSpan, this.parent());
                        }
                        this.previousTokenSpan = currentTokenSpan;
                        if (this.previousTokenParent) {
                            this.indentationNodeContextPool().releaseNode(this.previousTokenParent, true);
                        }
                        this.previousTokenParent = this.parent().clone(this.indentationNodeContextPool());
                    }
                    position += trivia.fullWidth();
                }
            };
            Formatter.prototype.findCommonParents = function (parent1, parent2) {
                var shallowParent;
                var shallowParentDepth;
                var deepParent;
                var deepParentDepth;
                if (parent1.depth() < parent2.depth()) {
                    shallowParent = parent1;
                    shallowParentDepth = parent1.depth();
                    deepParent = parent2;
                    deepParentDepth = parent2.depth();
                } else {
                    shallowParent = parent2;
                    shallowParentDepth = parent2.depth();
                    deepParent = parent1;
                    deepParentDepth = parent1.depth();
                }
                TypeScript.Debug.assert(shallowParentDepth >= 0, "Expected shallowParentDepth >= 0");
                TypeScript.Debug.assert(deepParentDepth >= 0, "Expected deepParentDepth >= 0");
                TypeScript.Debug.assert(deepParentDepth >= shallowParentDepth, "Expected deepParentDepth >= shallowParentDepth");
                while(deepParentDepth > shallowParentDepth) {
                    deepParent = deepParent.parent();
                    deepParentDepth--;
                }
                TypeScript.Debug.assert(deepParentDepth === shallowParentDepth, "Expected deepParentDepth === shallowParentDepth");
                while(deepParent.node() && shallowParent.node()) {
                    if (deepParent.node() === shallowParent.node()) {
                        return deepParent;
                    }
                    deepParent = deepParent.parent();
                    shallowParent = shallowParent.parent();
                }
                throw TypeScript.Errors.invalidOperation();
            };
            Formatter.prototype.formatPair = function (t1, t1Parent, t2, t2Parent) {
                var token1Line = this.getLineNumber(t1);
                var token2Line = this.getLineNumber(t2);
                var commonParent = this.findCommonParents(t1Parent, t2Parent);
                this.formattingContext.updateContext(t1, t1Parent, t2, t2Parent, commonParent);
                var rule = this.rulesProvider.getRulesMap().GetRule(this.formattingContext);
                if (rule != null) {
                    this.RecordRuleEdits(rule, t1, t2);
                    if ((rule.Operation.Action == Formatting.RuleAction.Space || rule.Operation.Action == Formatting.RuleAction.Delete) && token1Line != token2Line) {
                        this.forceSkipIndentingNextToken();
                    }
                    if (rule.Operation.Action == Formatting.RuleAction.NewLine && token1Line == token2Line) {
                        this.forceIndentNextToken();
                    }
                }
                if (token1Line != token2Line) {
                    this.TrimWhitespaceInLineRange(t1, token1Line, token2Line - 1);
                }
            };
            Formatter.prototype.getLineNumber = function (token) {
                return this.snapshot().getLineNumberFromPosition(token.start());
            };
            Formatter.prototype.TrimWhitespaceInLineRange = function (token, startLine, endLine) {
                for(var lineNumber = startLine; lineNumber <= endLine; ++lineNumber) {
                    var line = this.snapshot().getLineFromLineNumber(lineNumber);
                    this.TrimWhitespace2(token, line);
                }
            };
            Formatter.prototype.TrimWhitespace = function (token) {
                var line = this.snapshot().getLineFromPosition(token.start());
                this.TrimWhitespace2(token, line);
            };
            Formatter.prototype.TrimWhitespace2 = function (token, line) {
                if ((token.kind() == TypeScript.SyntaxKind.MultiLineCommentTrivia || token.kind() == TypeScript.SyntaxKind.SingleLineCommentTrivia) && token.start() <= line.endPosition() && token.end() >= line.endPosition()) {
                    return;
                }
                var text = line.getText();
                var index = 0;
                for(index = text.length - 1; index >= 0; --index) {
                    if (!TypeScript.CharacterInfo.isWhitespace(text.charCodeAt(index))) {
                        break;
                    }
                }
                ++index;
                if (index < text.length) {
                    this.recordEdit(line.startPosition() + index, line.length() - index, "");
                }
            };
            Formatter.prototype.RecordRuleEdits = function (rule, t1, t2) {
                if (rule.Operation.Action == Formatting.RuleAction.Ignore) {
                    return;
                }
                var betweenSpan;
                switch(rule.Operation.Action) {
                    case Formatting.RuleAction.Delete:
 {
                            betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                            if (betweenSpan.length() > 0) {
                                this.recordEdit(betweenSpan.start(), betweenSpan.length(), "");
                                return;
                            }
                        }
                        break;
                    case Formatting.RuleAction.NewLine:
 {
                            if (rule.Flag == Formatting.RuleFlags.CanDeleteNewLines) {
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t1.start() - t1.end());
                            } else {
                                var lengthBetween;
                                if (this.getLineNumber(t1) == this.getLineNumber(t2)) {
                                    lengthBetween = t2.start() - t1.end();
                                } else {
                                    lengthBetween = this.snapshot().getLineFromPosition(t1.end()).endIncludingLineBreakPosition() - t1.end();
                                }
                                betweenSpan = new TypeScript.TextSpan(t1.end(), Math.max(0, lengthBetween));
                            }
                            var doEdit = false;
                            var betweenText = this.snapshot().getText(betweenSpan);
                            var lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter);
                            if (lineFeedLoc < 0) {
                                doEdit = true;
                            } else {
                                lineFeedLoc = betweenText.indexOf(this.options.newLineCharacter, lineFeedLoc + 1);
                                if (lineFeedLoc >= 0) {
                                    doEdit = true;
                                }
                            }
                            if (doEdit) {
                                this.recordEdit(betweenSpan.start(), betweenSpan.length(), this.options.newLineCharacter);
                                return;
                            }
                        }
                        break;
                    case Formatting.RuleAction.Space:
 {
                            if (rule.Flag == Formatting.RuleFlags.CanDeleteNewLines) {
                                betweenSpan = new TypeScript.TextSpan(t1.end(), t2.start() - t1.end());
                            } else {
                                if (this.getLineNumber(t1) == this.getLineNumber(t2)) {
                                    lengthBetween = t2.start() - t1.end();
                                } else {
                                    lengthBetween = this.snapshot().getLineFromPosition(t1.end()).endPosition() - t1.end();
                                }
                                betweenSpan = new TypeScript.TextSpan(t1.end(), Math.max(0, lengthBetween));
                            }
                            if (betweenSpan.length() > 1 || this.snapshot().getText(betweenSpan) != " ") {
                                this.recordEdit(betweenSpan.start(), betweenSpan.length(), " ");
                                return;
                            }
                        }
                        break;
                }
            };
            return Formatter;
        })(Formatting.MultipleTokenIndenter);
        Formatting.Formatter = Formatter;        
    })(TypeScript.Formatting || (TypeScript.Formatting = {}));
    var Formatting = TypeScript.Formatting;
})(TypeScript || (TypeScript = {}));
var debugObjectHost = (this);
var Services;
(function (Services) {
    var CoreServices = (function () {
        function CoreServices(host) {
            this.host = host;
        }
        CoreServices.prototype.getPreProcessedFileInfo = function (fileName, sourceText) {
            var settings = new TypeScript.CompilationSettings();
            settings.codeGenTarget = TypeScript.LanguageVersion.EcmaScript5;
            var result = TypeScript.preProcessFile(fileName, sourceText, settings);
            return result;
        };
        CoreServices.prototype.getDefaultCompilationSettings = function () {
            var settings = new TypeScript.CompilationSettings();
            settings.codeGenTarget = TypeScript.LanguageVersion.EcmaScript5;
            return settings;
        };
        CoreServices.prototype.dumpMemory = function () {
            if (!debugObjectHost || !debugObjectHost.Debug || !debugObjectHost.Debug.dumpHeap) {
                throw new Error("This version of the Javascript runtime doesn't support the 'Debug.dumpHeap()' function.");
            }
            var objects = debugObjectHost.Debug.dumpHeap(2);
            var totalSize = 0;
            for(var i = 0; i < objects.length; i++) {
                totalSize += objects[i].size;
            }
            return "There are " + objects.length + " object(s) accessible from 'global', for a total of " + totalSize + " byte(s).";
        };
        CoreServices.prototype.getMemoryInfo = function () {
            if (!debugObjectHost || !debugObjectHost.Debug || !debugObjectHost.Debug.getMemoryInfo) {
                throw new Error("This version of the Javascript runtime doesn't support the 'Debug.getMemoryInfo()' function.");
            }
            return debugObjectHost.Debug.getMemoryInfo();
        };
        CoreServices.prototype.collectGarbage = function () {
            if (!debugObjectHost || !debugObjectHost.CollectGarbage) {
                throw new Error("This version of the Javascript runtime doesn't support the 'CollectGarbage()' function.");
            }
            debugObjectHost.CollectGarbage();
        };
        return CoreServices;
    })();
    Services.CoreServices = CoreServices;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var HostCacheEntry = (function () {
        function HostCacheEntry(fileName, host, version, isOpen) {
            this.fileName = fileName;
            this.host = host;
            this.version = version;
            this.isOpen = isOpen;
            this._sourceText = null;
        }
        HostCacheEntry.prototype.getScriptSnapshot = function () {
            if (this._sourceText === null) {
                this._sourceText = this.host.getScriptSnapshot(this.fileName);
            }
            return this._sourceText;
        };
        return HostCacheEntry;
    })();
    Services.HostCacheEntry = HostCacheEntry;    
    var HostCache = (function () {
        function HostCache(host) {
            this.host = host;
            this.map = new TypeScript.StringHashTable();
            var fileNames = this.host.getScriptFileNames();
            for(var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];
                this.map.add(fileName, new HostCacheEntry(fileName, this.host, this.host.getScriptVersion(fileName), this.host.getScriptIsOpen(fileName)));
            }
        }
        HostCache.prototype.contains = function (fileName) {
            return this.map.lookup(fileName) !== null;
        };
        HostCache.prototype.getFileNames = function () {
            return this.map.getAllKeys();
        };
        HostCache.prototype.getVersion = function (fileName) {
            return this.map.lookup(fileName).version;
        };
        HostCache.prototype.isOpen = function (fileName) {
            return this.map.lookup(fileName).isOpen;
        };
        HostCache.prototype.getScriptSnapshot = function (fileName) {
            return this.map.lookup(fileName).getScriptSnapshot();
        };
        return HostCache;
    })();
    Services.HostCache = HostCache;    
    var CompilerState = (function () {
        function CompilerState(host) {
            this.host = host;
            this.compiler = null;
            this.hostCache = null;
            this.symbolTree = null;
            this._compilationSettings = null;
            this.logger = this.host;
            this.diagnostics = new Services.CompilerDiagnostics(host);
        }
        CompilerState.prototype.compilationSettings = function () {
            return this._compilationSettings;
        };
        CompilerState.prototype.onTypeCheckStarting = function () {
            this.symbolTree = new Services.SymbolTree(this);
        };
        CompilerState.prototype.getSymbolTree = function () {
            return this.symbolTree;
        };
        CompilerState.prototype.getFileNames = function () {
            return this.compiler.fileNameToDocument.getAllKeys();
        };
        CompilerState.prototype.getScript = function (fileName) {
            return this.compiler.getDocument(fileName).script;
        };
        CompilerState.prototype.getScripts = function () {
            return this.compiler.getScripts();
        };
        CompilerState.prototype.getScriptVersion = function (fileName) {
            return this.hostCache.getVersion(fileName);
        };
        CompilerState.prototype.getSemanticInfoChain = function () {
            return this.compiler.semanticInfoChain;
        };
        CompilerState.prototype.addCompilerUnit = function (compiler, fileName) {
            compiler.addSourceUnit(fileName, this.hostCache.getScriptSnapshot(fileName), this.hostCache.getVersion(fileName), this.hostCache.isOpen(fileName));
        };
        CompilerState.prototype.getHostCompilationSettings = function () {
            var settings = this.host.getCompilationSettings();
            if (settings !== null) {
                return settings;
            }
            settings = new TypeScript.CompilationSettings();
            settings.codeGenTarget = TypeScript.LanguageVersion.EcmaScript5;
            return settings;
        };
        CompilerState.prototype.createCompiler = function () {
            this.logger.log("Initializing compiler");
            this._compilationSettings = new TypeScript.CompilationSettings();
            Services.copyDataObject(this.compilationSettings(), this.getHostCompilationSettings());
            this.compiler = new TypeScript.TypeScriptCompiler(this.logger, this.compilationSettings());
            var fileNames = this.host.getScriptFileNames();
            for(var i = 0, n = fileNames.length; i < n; i++) {
                this.addCompilerUnit(this.compiler, fileNames[i]);
            }
            this.onTypeCheckStarting();
            this.compiler.pullTypeCheck();
        };
        CompilerState.prototype.minimalRefresh = function () {
            this.hostCache = new HostCache(this.host);
        };
        CompilerState.prototype.refresh = function () {
            this.hostCache = new HostCache(this.host);
            if (!this.fullRefresh()) {
                this.partialRefresh();
            }
        };
        CompilerState.prototype.fullRefresh = function () {
            if (this.compiler == null) {
                this.logger.log("Creating new compiler instance because there is no currently active instance");
                this.createCompiler();
                return true;
            }
            var fileNames = this.compiler.fileNameToDocument.getAllKeys();
            for(var unitIndex = 0, len = fileNames.length; unitIndex < len; unitIndex++) {
                var fileName = fileNames[unitIndex];
                if (!this.hostCache.contains(fileName)) {
                    this.logger.log("Creating new compiler instance because of unit is not part of program anymore: " + unitIndex + "-" + fileName);
                    this.createCompiler();
                    return true;
                }
            }
            return false;
        };
        CompilerState.prototype.partialRefresh = function () {
            this.logger.log("Updating files...");
            var fileAdded = false;
            var fileNames = this.host.getScriptFileNames();
            for(var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];
                if (this.compiler.getDocument(fileName)) {
                    this.updateCompilerUnit(this.compiler, fileName);
                } else {
                    this.addCompilerUnit(this.compiler, fileName);
                    fileAdded = true;
                }
            }
            if (fileAdded) {
                this.compiler.pullTypeCheck();
            }
        };
        CompilerState.prototype.getDocument = function (fileName) {
            return this.compiler.getDocument(fileName);
        };
        CompilerState.prototype.getSyntacticDiagnostics = function (fileName) {
            return this.compiler.getSyntacticDiagnostics(fileName);
        };
        CompilerState.prototype.getSemanticDiagnostics = function (fileName) {
            return this.compiler.getSemanticDiagnostics(fileName);
        };
        CompilerState.prototype.getScriptTextChangeRangeSinceVersion = function (fileName, lastKnownVersion) {
            var currentVersion = this.hostCache.getVersion(fileName);
            if (lastKnownVersion === currentVersion) {
                return TypeScript.TextChangeRange.unchanged;
            }
            var scriptSnapshot = this.hostCache.getScriptSnapshot(fileName);
            return scriptSnapshot.getTextChangeRangeSinceVersion(lastKnownVersion);
        };
        CompilerState.prototype.getScriptSnapshot = function (fileName) {
            return this.hostCache.getScriptSnapshot(fileName);
        };
        CompilerState.prototype.getDeclarationSymbolInformation = function (path, document) {
            return this.compiler.pullGetDeclarationSymbolInformation(path, document);
        };
        CompilerState.prototype.getSymbolInformationFromPath = function (path, document) {
            return this.compiler.pullGetSymbolInformationFromPath(path, document);
        };
        CompilerState.prototype.getCallInformationFromPath = function (path, document) {
            return this.compiler.pullGetCallInformationFromPath(path, document);
        };
        CompilerState.prototype.getVisibleMemberSymbolsFromPath = function (path, document) {
            return this.compiler.pullGetVisibleMemberSymbolsFromPath(path, document);
        };
        CompilerState.prototype.getVisibleSymbolsFromPath = function (path, document) {
            return this.compiler.pullGetVisibleSymbolsFromPath(path, document);
        };
        CompilerState.prototype.geContextualMembersFromPath = function (path, document) {
            return this.compiler.pullGetContextualMembersFromPath(path, document);
        };
        CompilerState.prototype.getTopLevelDeclarations = function (fileName) {
            return this.compiler.getTopLevelDeclarations(fileName);
        };
        CompilerState.prototype.updateCompilerUnit = function (compiler, fileName) {
            var document = this.compiler.getDocument(fileName);
            var version = this.hostCache.getVersion(fileName);
            var isOpen = this.hostCache.isOpen(fileName);
            if (document.version === version && document.isOpen === isOpen) {
                return;
            }
            var textChangeRange = this.getScriptTextChangeRangeSinceVersion(fileName, document.version);
            compiler.updateSourceUnit(fileName, this.hostCache.getScriptSnapshot(fileName), version, isOpen, textChangeRange);
        };
        CompilerState.prototype.getDocCommentsOfDecl = function (decl) {
            var ast = this.compiler.semanticInfoChain.getASTForDecl(decl);
            if (ast && (ast.nodeType != TypeScript.NodeType.ModuleDeclaration || decl.getKind() != TypeScript.PullElementKind.Variable)) {
                return ast.getDocComments();
            }
            return [];
        };
        CompilerState.prototype.getDocCommentArray = function (symbol) {
            var docComments = [];
            if (!symbol) {
                return docComments;
            }
            var decls = symbol.getDeclarations();
            for(var i = 0; i < decls.length; i++) {
                docComments = docComments.concat(this.getDocCommentsOfDecl(decls[i]));
            }
            return docComments;
        };
        CompilerState.getDefaultConstructorSymbolForDocComments = function getDefaultConstructorSymbolForDocComments(classSymbol) {
            if (classSymbol.getHasDefaultConstructor()) {
                var extendedTypes = classSymbol.getExtendedTypes();
                if (extendedTypes.length) {
                    return CompilerState.getDefaultConstructorSymbolForDocComments(extendedTypes[0]);
                }
            }
            return classSymbol.getType().getConstructSignatures()[0];
        };
        CompilerState.prototype.getDocComments = function (symbol, useConstructorAsClass) {
            if (!symbol) {
                return "";
            }
            var decls = symbol.getDeclarations();
            if (useConstructorAsClass && decls.length && decls[0].getKind() == TypeScript.PullElementKind.ConstructorMethod) {
                var classDecl = decls[0].getParentDecl();
                return TypeScript.Comment.getDocCommentText(this.getDocCommentsOfDecl(classDecl));
            }
            if (symbol.docComments === null) {
                var docComments = "";
                if (!useConstructorAsClass && symbol.getKind() == TypeScript.PullElementKind.ConstructSignature && decls.length && decls[0].getKind() == TypeScript.PullElementKind.Class) {
                    var classSymbol = (symbol).getReturnType();
                    var extendedTypes = classSymbol.getExtendedTypes();
                    if (extendedTypes.length) {
                        docComments = this.getDocComments((extendedTypes[0]).getConstructorMethod());
                    } else {
                        docComments = "";
                    }
                } else if (symbol.getKind() == TypeScript.PullElementKind.Parameter) {
                    var parameterComments = [];
                    var funcContainerList = symbol.findIncomingLinks(function (link) {
                        return link.kind == TypeScript.SymbolLinkKind.Parameter;
                    });
                    for(var i = 0; i < funcContainerList.length; i++) {
                        var funcContainer = funcContainerList[i].start;
                        var funcDocComments = this.getDocCommentArray(funcContainer);
                        var paramComment = TypeScript.Comment.getParameterDocCommentText(symbol.getName(), funcDocComments);
                        if (paramComment != "") {
                            parameterComments.push(paramComment);
                        }
                    }
                    var paramSelfComment = TypeScript.Comment.getDocCommentText(this.getDocCommentArray(symbol));
                    if (paramSelfComment != "") {
                        parameterComments.push(paramSelfComment);
                    }
                    docComments = parameterComments.join("\n");
                } else {
                    var getSymbolComments = true;
                    if (symbol.getKind() == TypeScript.PullElementKind.FunctionType) {
                        var declarationList = symbol.findIncomingLinks(function (link) {
                            return link.kind == TypeScript.SymbolLinkKind.TypedAs;
                        });
                        if (declarationList.length > 0) {
                            docComments = this.getDocComments(declarationList[0].start);
                            getSymbolComments = false;
                        }
                    }
                    if (getSymbolComments) {
                        docComments = TypeScript.Comment.getDocCommentText(this.getDocCommentArray(symbol));
                        if (docComments == "") {
                            if (symbol.getKind() == TypeScript.PullElementKind.CallSignature) {
                                var callList = symbol.findIncomingLinks(function (link) {
                                    return link.kind == TypeScript.SymbolLinkKind.CallSignature;
                                });
                                if (callList.length == 1) {
                                    var callTypeSymbol = callList[0].start;
                                    if (callTypeSymbol.getCallSignatures().length == 1) {
                                        docComments = this.getDocComments(callTypeSymbol);
                                    }
                                }
                            }
                        }
                    }
                }
                symbol.docComments = docComments;
            }
            return symbol.docComments;
        };
        return CompilerState;
    })();
    Services.CompilerState = CompilerState;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var SymbolArraySet = (function () {
        function SymbolArraySet() {
            this.rtti = SymbolArraySet.rtti_id;
            this.values = [];
        }
        SymbolArraySet.rtti_id = {
            id: "Services.SymbolArraySet"
        };
        SymbolArraySet.prototype.add = function (sym) {
            if (this.contains(sym)) {
                return false;
            }
            this.values.push(sym);
            return true;
        };
        SymbolArraySet.prototype.contains = function (sym) {
            return this.values.indexOf(sym) >= 0;
        };
        SymbolArraySet.prototype.forEach = function (callback) {
            this.values.forEach(callback);
        };
        SymbolArraySet.prototype.getAll = function () {
            return this.values;
        };
        return SymbolArraySet;
    })();    
    var SymbolSet = (function () {
        function SymbolSet() {
            this.table = new TypeScript.StringHashTable();
        }
        SymbolSet.prototype.isSymbolArraySet = function (value) {
            return value.rtti === SymbolArraySet.rtti_id;
        };
        SymbolSet.prototype.add = function (sym) {
            var key = sym.name;
            var element = this.table.lookup(key);
            if (element === null) {
                this.table.add(key, sym);
                return true;
            } else if (this.isSymbolArraySet(element)) {
                return (element).add(sym);
            } else {
                var value = element;
                if (value === sym) {
                    return false;
                }
                var arraySet = new SymbolArraySet();
                arraySet.add(value);
                arraySet.add(sym);
                this.table.addOrUpdate(key, arraySet);
                return true;
            }
        };
        SymbolSet.prototype.contains = function (sym) {
            var key = sym.name;
            var element = this.table.lookup(key);
            if (element === null) {
                return false;
            } else if (this.isSymbolArraySet(element)) {
                return (element).contains(sym);
            } else {
                var value = element;
                return (value === sym);
            }
        };
        SymbolSet.prototype.isEmpty = function () {
            return this.table.count() === 0;
        };
        SymbolSet.prototype.getAll = function () {
            var result = [];
            this.forEach(function (x) {
                result.push(x);
            });
            return result;
        };
        SymbolSet.prototype.forEach = function (callback) {
            var _this = this;
            this.table.map(function (key, element, ctx) {
                if (element === null) {
                } else if (_this.isSymbolArraySet(element)) {
                    (element).forEach(callback);
                } else {
                    callback(element);
                }
            }, null);
        };
        SymbolSet.prototype.union = function (other) {
            var _this = this;
            other.getAll().forEach(function (x) {
                _this.add(x);
            });
        };
        return SymbolSet;
    })();
    Services.SymbolSet = SymbolSet;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var SymbolTree = (function () {
        function SymbolTree(host) {
            this.host = host;
            this._allTypes = null;
        }
        SymbolTree.prototype.findBaseTypesTransitiveClosure = function (sym) {
            var closure = new Services.SymbolSet();
            var lastSet = new Services.SymbolSet();
            lastSet.add(sym);
            while(!lastSet.isEmpty()) {
                closure.union(lastSet);
                lastSet = this.findBaseTypes(closure, lastSet);
            }
            return closure;
        };
        SymbolTree.prototype.findDerivedTypesTransitiveClosure = function (sym) {
            var closure = new Services.SymbolSet();
            var lastSet = new Services.SymbolSet();
            lastSet.add(sym);
            while(!lastSet.isEmpty()) {
                closure.union(lastSet);
                lastSet = this.findDerivedTypes(closure, lastSet);
            }
            return closure;
        };
        SymbolTree.prototype.getOverride = function (container, memberSym) {
            var members = null;
            if (this.isClass(container)) {
                members = container.type.instanceType.members;
            } else if (this.isInterface(container)) {
                members = container.type.members;
            }
            if (members == null) {
                return null;
            }
            var override = members.allMembers.lookup(memberSym.name);
            if (override == null) {
                return null;
            }
            if ((this.isMethod(memberSym) === this.isMethod(override)) && (this.isField(memberSym) === this.isField(override)) && (this.isStatic(memberSym) === this.isStatic(override))) {
                return override;
            }
            return null;
        };
        SymbolTree.prototype.getAllTypes = function () {
            var _this = this;
            if (this._allTypes === null) {
                var result = new Services.SymbolSet();
                this.host.getScripts().forEach(function (script) {
                    TypeScript.walkAST(script, function (path, walker) {
                        if (path.isNameOfClass() || path.isNameOfInterface()) {
                            var sym = (path.ast()).sym;
                            if (sym != null) {
                                if (sym.kind() === TypeScript.SymbolKind.Type) {
                                    var typeSym = sym;
                                    if (_this.isClass(typeSym) || _this.isInterface(typeSym)) {
                                        result.add(typeSym);
                                    }
                                }
                            }
                        }
                        if (path.isBodyOfFunction()) {
                            walker.options.goChildren = false;
                        }
                    });
                });
                this._allTypes = result.getAll();
            }
            return this._allTypes;
        };
        SymbolTree.prototype.findBaseTypes = function (closure, lastSet) {
            var _this = this;
            var result = new Services.SymbolSet();
            var symsArray = lastSet.getAll();
            symsArray.forEach(function (sym) {
                if (sym.kind() === TypeScript.SymbolKind.Type) {
                    var type = (sym).type;
                    if (type !== null) {
                        if (type.instanceType != null) {
                            type = type.instanceType;
                        }
                        _this.addBaseTypes(closure, result, type.implementsList);
                        _this.addBaseTypes(closure, result, type.extendsList);
                    }
                }
            });
            return result;
        };
        SymbolTree.prototype.findDerivedTypes = function (alreadyFound, baseSymbols) {
            var _this = this;
            var result = new Services.SymbolSet();
            this.getAllTypes().forEach(function (candidate) {
                if (!alreadyFound.contains(candidate)) {
                    if (candidate.kind() === TypeScript.SymbolKind.Type) {
                        var type = (candidate).type;
                        if (type !== null) {
                            if (type.instanceType != null) {
                                type = type.instanceType;
                            }
                            var emptySet = new Services.SymbolSet();
                            var baseTypes = new Services.SymbolSet();
                            _this.addBaseTypes(emptySet, baseTypes, type.implementsList);
                            _this.addBaseTypes(emptySet, baseTypes, type.extendsList);
                            baseTypes.getAll().forEach(function (baseType) {
                                if (baseSymbols.contains(baseType)) {
                                    result.add(candidate);
                                }
                            });
                        }
                    }
                }
            });
            return result;
        };
        SymbolTree.prototype.addBaseTypes = function (closure, syms, bases) {
            var _this = this;
            if (bases == null) {
                return;
            }
            bases.forEach(function (base) {
                if (base.symbol !== null) {
                    if (!closure.contains(base.symbol)) {
                        if (_this.isDefinition(base.symbol)) {
                            syms.add(base.symbol);
                        }
                    }
                }
            });
        };
        SymbolTree.prototype.isDefinition = function (sym) {
            return this.isClass(sym) || this.isInterface(sym);
        };
        SymbolTree.prototype.isClass = function (sym) {
            return sym != null && sym.kind() == TypeScript.SymbolKind.Type && (sym).isClass();
        };
        SymbolTree.prototype.isInterface = function (sym) {
            return sym != null && sym.kind() == TypeScript.SymbolKind.Type && sym.declAST != null && sym.declAST.nodeType === TypeScript.NodeType.InterfaceDeclaration;
        };
        SymbolTree.prototype.isMethod = function (sym) {
            return sym != null && sym.kind() === TypeScript.SymbolKind.Type && (sym).isMethod;
        };
        SymbolTree.prototype.isField = function (sym) {
            return sym != null && sym.kind() === TypeScript.SymbolKind.Field;
        };
        SymbolTree.prototype.isStatic = function (sym) {
            return sym != null && sym.isStatic();
        };
        return SymbolTree;
    })();
    Services.SymbolTree = SymbolTree;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var OverridesCollector = (function () {
        function OverridesCollector(symbolTree) {
            this.symbolTree = symbolTree;
        }
        OverridesCollector.prototype.findMemberOverrides = function (memberSym) {
            return this.findMemberOverridesImpl(memberSym, true, true);
        };
        OverridesCollector.prototype.findImplementors = function (sym) {
            if (this.symbolTree.isClass(sym) || this.symbolTree.isInterface(sym)) {
                return this.symbolTree.findDerivedTypesTransitiveClosure(sym);
            } else if (this.symbolTree.isMethod(sym) || this.symbolTree.isField(sym)) {
                return this.findMemberOverridesImpl(sym, false, true);
            } else {
                return new Services.SymbolSet();
            }
        };
        OverridesCollector.prototype.findMemberOverridesImpl = function (memberSym, lookInBases, lookInDerived) {
            var _this = this;
            var result = new Services.SymbolSet();
            result.add(memberSym);
            if (memberSym.container === null) {
                return result;
            }
            var baseTypes = (lookInBases ? this.symbolTree.findBaseTypesTransitiveClosure(memberSym.container) : new Services.SymbolSet());
            var derivedTypes = (lookInDerived ? this.symbolTree.findDerivedTypesTransitiveClosure(memberSym.container) : new Services.SymbolSet());
            var allTypes = new Services.SymbolSet();
            allTypes.add(memberSym.container);
            allTypes.union(baseTypes);
            allTypes.union(derivedTypes);
            allTypes.getAll().forEach(function (x) {
                var override = _this.symbolTree.getOverride(x, memberSym);
                if (override !== null) {
                    result.add(override);
                }
            });
            return result;
        };
        return OverridesCollector;
    })();
    Services.OverridesCollector = OverridesCollector;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var LanguageService = (function () {
        function LanguageService(host) {
            this.host = host;
            this.currentFileName = "";
            this.currentFileVersion = -1;
            this.currentFileSyntaxTree = null;
            this.logger = this.host;
            this.compilerState = new Services.CompilerState(this.host);
        }
        LanguageService.prototype.refresh = function () {
            var _this = this;
            TypeScript.timeFunction(this.logger, "refresh()", function () {
                _this.compilerState.refresh();
            });
        };
        LanguageService.prototype.minimalRefresh = function () {
            var _this = this;
            TypeScript.timeFunction(this.logger, "minimalRefresh()", function () {
                _this.compilerState.minimalRefresh();
            });
        };
        LanguageService.prototype.getSymbolTree = function () {
            this.refresh();
            return this.compilerState.getSymbolTree();
        };
        LanguageService.prototype.getReferencesAtPosition = function (fileName, pos) {
            this.refresh();
            var result = [];
            var document = this.compilerState.getDocument(fileName);
            var script = document.script;
            var path = this.getAstPathToPosition(script, pos);
            if (path.ast() === null || path.ast().nodeType !== TypeScript.NodeType.Name) {
                this.logger.log("No name found at the given position");
                return result;
            }
            var symbolInfoAtPosition = this.compilerState.getSymbolInformationFromPath(path, document);
            if (symbolInfoAtPosition === null || symbolInfoAtPosition.symbol === null) {
                this.logger.log("No symbol found at the given position");
                return result;
            }
            var symbol = symbolInfoAtPosition.symbol;
            var fileNames = this.compilerState.getFileNames();
            for(var i = 0, len = fileNames.length; i < len; i++) {
                result = result.concat(this.getReferencesInFile(fileNames[i], symbol));
            }
            return result;
        };
        LanguageService.prototype.getOccurrencesAtPosition = function (fileName, pos) {
            this.refresh();
            var result = [];
            var document = this.compilerState.getDocument(fileName);
            var script = document.script;
            var path = this.getAstPathToPosition(script, pos);
            if (path.ast() === null || path.ast().nodeType !== TypeScript.NodeType.Name) {
                this.logger.log("No name found at the given position");
                return result;
            }
            var symbolInfoAtPosition = this.compilerState.getSymbolInformationFromPath(path, document);
            if (symbolInfoAtPosition === null || symbolInfoAtPosition.symbol === null) {
                this.logger.log("No symbol found at the given position");
                return result;
            }
            var symbol = symbolInfoAtPosition.symbol;
            return this.getReferencesInFile(fileName, symbol);
        };
        LanguageService.prototype.getImplementorsAtPosition = function (fileName, position) {
            return [];
        };
        LanguageService.prototype.getReferencesInFile = function (fileName, symbol) {
            var _this = this;
            var result = [];
            var symbolName = symbol.getName();
            var possiblePositions = this.getPossibleSymbolReferencePositions(fileName, symbol);
            if (possiblePositions && possiblePositions.length > 0) {
                var document = this.compilerState.getDocument(fileName);
                var script = document.script;
                possiblePositions.forEach(function (p) {
                    var path = _this.getAstPathToPosition(script, p);
                    if (path.ast() === null || path.ast().nodeType !== TypeScript.NodeType.Name) {
                        return;
                    }
                    var searchSymbolInfoAtPosition = _this.compilerState.getSymbolInformationFromPath(path, document);
                    if (searchSymbolInfoAtPosition !== null && searchSymbolInfoAtPosition.symbol === symbol) {
                        var isWriteAccess = false;
                        result.push(new Services.ReferenceEntry(fileName, searchSymbolInfoAtPosition.ast, isWriteAccess));
                    }
                });
            }
            return result;
        };
        LanguageService.prototype.getPossibleSymbolReferencePositions = function (fileName, symbol) {
            var positions = [];
            var sourceText = this.compilerState.getScriptSnapshot(fileName);
            var text = sourceText.getText(0, sourceText.getLength());
            var symbolName = symbol.getName();
            var position = text.indexOf(symbolName);
            while(position >= 0) {
                positions.push(position);
                position = text.indexOf(symbolName, position + symbolName.length + 1);
            }
            return positions;
        };
        LanguageService.prototype.getSignatureAtPosition = function (fileName, position) {
            this.refresh();
            var document = this.compilerState.getDocument(fileName);
            var script = document.script;
            var atEOF = (position === script.limChar);
            var path = this.getAstPathToPosition(script, position);
            if (path.count() == 0) {
                return null;
            }
            if (path.nodeType() === TypeScript.NodeType.Comment) {
                this.logger.log("position is inside a comment");
                return null;
            }
            while(path.count() >= 2) {
                if (path.isArgumentListOfCall() || path.isArgumentListOfNew()) {
                    if (atEOF || position >= path.ast().minChar) {
                        path.pop();
                    }
                    break;
                } else if (path.ast().nodeType === TypeScript.NodeType.InvocationExpression || path.ast().nodeType === TypeScript.NodeType.ObjectCreationExpression) {
                    break;
                }
                if (position > path.ast().minChar) {
                    if (path.ast().nodeType !== TypeScript.NodeType.List) {
                        break;
                    }
                }
                path.pop();
            }
            if (path.ast().nodeType !== TypeScript.NodeType.InvocationExpression && path.ast().nodeType !== TypeScript.NodeType.ObjectCreationExpression) {
                this.logger.log("No call expression for the given position");
                return null;
            }
            var callExpression = path.ast();
            var isNew = (callExpression.nodeType === TypeScript.NodeType.ObjectCreationExpression);
            var callSymbolInfo = this.compilerState.getCallInformationFromPath(path, document);
            if (!callSymbolInfo || !callSymbolInfo.targetSymbol || !callSymbolInfo.resolvedSignatures) {
                this.logger.log("Could not find symbol for call expression");
                return null;
            }
            var result = new Services.SignatureInfo();
            result.formal = this.convertSignatureSymbolToSignatureInfo(callSymbolInfo.targetSymbol, isNew, callSymbolInfo.resolvedSignatures, callSymbolInfo.enclosingScopeSymbol);
            result.actual = this.convertCallExprToActualSignatureInfo(callExpression, position, atEOF);
            result.activeFormal = (callSymbolInfo.resolvedSignatures && callSymbolInfo.candidateSignature) ? callSymbolInfo.resolvedSignatures.indexOf(callSymbolInfo.candidateSignature) : -1;
            if (result.actual === null || result.formal === null || result.activeFormal === null) {
                this.logger.log("Can't compute actual and/or formal signature of the call expression");
                return null;
            }
            return result;
        };
        LanguageService.prototype.convertSignatureSymbolToSignatureInfo = function (symbol, isNew, signatures, enclosingScopeSymbol) {
            var _this = this;
            var result = new Services.FormalSignatureInfo();
            result.isNew = isNew;
            result.name = symbol.getName();
            result.docComment = this.compilerState.getDocComments(symbol);
            result.openParen = "(";
            result.closeParen = ")";
            var hasOverloads = signatures.length > 1;
            signatures.filter(function (signature) {
                return !(hasOverloads && signature.isDefinition() && !_this.compilerState.compilationSettings().canCallDefinitionSignature);
            }).forEach(function (signature) {
                var signatureGroupInfo = new Services.FormalSignatureItemInfo();
                signatureGroupInfo.docComment = _this.compilerState.getDocComments(signature);
                signatureGroupInfo.returnType = signature.getReturnType() === null ? "any" : signature.getReturnType().getScopedNameEx(enclosingScopeSymbol).toString();
                var parameters = signature.getParameters();
                parameters.forEach(function (p, i) {
                    var signatureParameterInfo = new Services.FormalParameterInfo();
                    signatureParameterInfo.isVariable = signature.hasVariableParamList() && (i === parameters.length - 1);
                    signatureParameterInfo.isOptional = p.getIsOptional();
                    signatureParameterInfo.name = p.getName();
                    signatureParameterInfo.docComment = _this.compilerState.getDocComments(p);
                    signatureParameterInfo.type = p.getTypeName(enclosingScopeSymbol);
                    signatureGroupInfo.parameters.push(signatureParameterInfo);
                });
                result.signatureGroup.push(signatureGroupInfo);
            });
            return result;
        };
        LanguageService.prototype.convertCallExprToActualSignatureInfo = function (ast, caretPosition, atEOF) {
            if (!TypeScript.isValidAstNode(ast)) {
                return null;
            }
            if (!TypeScript.isValidAstNode(ast.arguments)) {
                return null;
            }
            var result = new Services.ActualSignatureInfo();
            result.currentParameter = -1;
            result.openParenMinChar = ast.arguments.minChar;
            result.closeParenLimChar = Math.max(ast.arguments.minChar, ast.arguments.limChar);
            ast.arguments.members.forEach(function (arg, index) {
                var parameter = new Services.ActualParameterInfo();
                parameter.minChar = arg.minChar;
                parameter.limChar = Math.max(arg.minChar, arg.limChar);
                result.parameters.push(parameter);
            });
            result.parameters.forEach(function (parameter, index) {
                var minChar = (index == 0 ? result.openParenMinChar : result.parameters[index - 1].limChar + 1);
                var limChar = (index == result.parameters.length - 1 ? result.closeParenLimChar : result.parameters[index + 1].minChar);
                if (caretPosition >= minChar && (atEOF ? caretPosition <= limChar : caretPosition < limChar)) {
                    result.currentParameter = index;
                }
            });
            return result;
        };
        LanguageService.prototype.getDefinitionAtPosition = function (fileName, position) {
            this.refresh();
            var result = null;
            var document = this.compilerState.getDocument(fileName);
            var script = document.script;
            var path = this.getAstPathToPosition(script, position);
            if (path.count() == 0) {
                return null;
            }
            var symbolInfo = this.compilerState.getSymbolInformationFromPath(path, document);
            if (symbolInfo == null || symbolInfo.symbol == null) {
                this.logger.log("No identifier at the specified location.");
                return result;
            }
            var declarations = symbolInfo.symbol.getDeclarations();
            if (declarations == null || declarations.length === 0) {
                this.logger.log("Could not find declaration for symbol.");
                return result;
            }
            var symbolName = symbolInfo.symbol.getName();
            var symbolKind = this.mapPullElementKind(symbolInfo.symbol.getKind(), symbolInfo.symbol);
            var container = symbolInfo.symbol.getContainer();
            var containerName = container ? container.getName() : "<global>";
            var containerKind = "";
            var entries = [];
            var mainEntry = 0;
            for(var i = 0, n = declarations.length; i < n; i++) {
                var declaration = declarations[i];
                var span = declaration.getSpan();
                var signature = declaration.getSignatureSymbol();
                if (signature && signature.isDefinition()) {
                    mainEntry = i;
                }
                entries.push(new Services.DefinitionInfo(declaration.getScriptName(), span.start(), span.end(), symbolKind, symbolName, containerKind, containerName, null));
            }
            result = entries[mainEntry];
            if (entries.length > 1) {
                entries.splice(mainEntry, 1);
                result.overloads = entries;
            }
            return result;
        };
        LanguageService.prototype.getNavigateToItems = function (searchValue) {
            return null;
        };
        LanguageService.prototype.getScriptLexicalStructure = function (fileName) {
            this.refresh();
            var declarations = this.compilerState.getTopLevelDeclarations(fileName);
            if (!declarations) {
                return null;
            }
            var result = [];
            this.mapPullDeclsToNavigateToItem(declarations, result);
            return result;
        };
        LanguageService.prototype.mapPullDeclsToNavigateToItem = function (declarations, result, parentSymbol, parentkindName, includeSubcontainers) {
            if (typeof includeSubcontainers === "undefined") { includeSubcontainers = true; }
            for(var i = 0, n = declarations.length; i < n; i++) {
                var declaration = declarations[i];
                var symbol = declaration.getSymbol();
                var kindName = this.mapPullElementKind(declaration.getKind(), symbol);
                var fileName = declaration.getScriptName();
                if (this.shouldIncludeDeclarationInNavigationItems(declaration, includeSubcontainers)) {
                    var item = new Services.NavigateToItem();
                    item.name = this.getNavigationItemDispalyName(declaration);
                    item.matchKind = Services.MatchKind.exact;
                    item.kind = kindName;
                    item.kindModifiers = symbol ? this.getScriptElementKindModifiers(symbol) : "";
                    item.fileName = fileName;
                    item.minChar = declaration.getSpan().start();
                    item.limChar = declaration.getSpan().end();
                    item.containerName = parentSymbol ? parentSymbol.fullName() : "";
                    item.containerKind = parentkindName || "";
                    result.push(item);
                }
                if (includeSubcontainers && this.isContainerDeclaration(declaration)) {
                    this.mapPullDeclsToNavigateToItem(declaration.getChildDecls(), result, symbol, kindName, true);
                    if (symbol) {
                        var otherDeclarations = symbol.getDeclarations();
                        if (otherDeclarations.length > 1) {
                            for(var j = 0, m = otherDeclarations.length; j < m; j++) {
                                var otherDeclaration = otherDeclarations[j];
                                if (otherDeclaration.getScriptName() === fileName) {
                                    continue;
                                }
                                this.mapPullDeclsToNavigateToItem(otherDeclaration.getChildDecls(), result, symbol, kindName, false);
                            }
                        }
                    }
                }
            }
        };
        LanguageService.prototype.isContainerDeclaration = function (declaration) {
            switch(declaration.getKind()) {
                case TypeScript.PullElementKind.Script:
                case TypeScript.PullElementKind.Container:
                case TypeScript.PullElementKind.Class:
                case TypeScript.PullElementKind.Interface:
                case TypeScript.PullElementKind.DynamicModule:
                case TypeScript.PullElementKind.Enum:
                    return true;
            }
            return false;
        };
        LanguageService.prototype.shouldIncludeDeclarationInNavigationItems = function (declaration, includeSubcontainers) {
            switch(declaration.getKind()) {
                case TypeScript.PullElementKind.Script:
                    return false;
                case TypeScript.PullElementKind.Variable:
                case TypeScript.PullElementKind.Property:
                    var symbol = declaration.getSymbol();
                    return !this.isModule(symbol) && !this.isDynamicModule(symbol) && !this.isConstructorMethod(symbol) && !this.isClass(symbol);
                case TypeScript.PullElementKind.EnumMember:
                    return declaration.getName() !== "_map";
                case TypeScript.PullElementKind.FunctionExpression:
                case TypeScript.PullElementKind.Function:
                    return declaration.getName() !== "";
            }
            if (this.isContainerDeclaration(declaration)) {
                return includeSubcontainers;
            }
            return true;
        };
        LanguageService.prototype.getNavigationItemDispalyName = function (declaration) {
            switch(declaration.getKind()) {
                case TypeScript.PullElementKind.ConstructorMethod:
                    return "constructor";
                case TypeScript.PullElementKind.CallSignature:
                    return "()";
                case TypeScript.PullElementKind.ConstructSignature:
                    return "new()";
                case TypeScript.PullElementKind.IndexSignature:
                    return "[]";
            }
            return declaration.getName();
        };
        LanguageService.prototype.getSyntacticDiagnostics = function (fileName) {
            this.compilerState.refresh();
            return this.compilerState.getSyntacticDiagnostics(fileName);
        };
        LanguageService.prototype.getSemanticDiagnostics = function (fileName) {
            this.compilerState.refresh();
            return this.compilerState.getSemanticDiagnostics(fileName);
        };
        LanguageService.prototype.getEmitOutput = function (fileName) {
            return [];
        };
        LanguageService.prototype.getAstPathToPosition = function (script, pos, useTrailingTriviaAsLimChar, options) {
            if (typeof useTrailingTriviaAsLimChar === "undefined") { useTrailingTriviaAsLimChar = true; }
            if (typeof options === "undefined") { options = TypeScript.GetAstPathOptions.Default; }
            if (this.logger.information()) {
                this.logger.log("getAstPathToPosition(" + script + ", " + pos + ")");
            }
            return TypeScript.getAstPathToPosition(script, pos, useTrailingTriviaAsLimChar, options);
        };
        LanguageService.prototype.getIdentifierPathToPosition = function (script, pos) {
            this.logger.log("getIdentifierPathToPosition(" + script + ", " + pos + ")");
            var path = this.getAstPathToPosition(script, pos, true, TypeScript.GetAstPathOptions.EdgeInclusive);
            if (path.count() == 0) {
                return null;
            }
            if (path.nodeType() !== TypeScript.NodeType.Name) {
                return null;
            }
            return path;
        };
        LanguageService.prototype.getFullNameOfSymbol = function (symbol, enclosingScopeSymbol) {
            var container = symbol.getContainer();
            if (this.isLocal(symbol) || symbol.getKind() == TypeScript.PullElementKind.Parameter) {
                return symbol.getScopedName(enclosingScopeSymbol);
            }
            if (symbol.getKind() == TypeScript.PullElementKind.Primitive) {
                return "";
            }
            return symbol.fullName(enclosingScopeSymbol);
        };
        LanguageService.prototype.getTypeInfoEligiblePath = function (fileName, position, isConstructorValidPosition) {
            this.refresh();
            var document = this.compilerState.getDocument(fileName);
            var script = document.script;
            var path = this.getAstPathToPosition(script, position, false);
            if (path.count() == 0) {
                return null;
            }
            var cur = path.ast();
            switch(cur.nodeType) {
                default:
                    return null;
                case TypeScript.NodeType.FunctionDeclaration:
                    var funcDecl = cur;
                    if (!isConstructorValidPosition || !funcDecl.isConstructor || !(position >= funcDecl.minChar && position <= funcDecl.minChar + 11)) {
                        return null;
                    }
                case TypeScript.NodeType.MemberAccessExpression:
                case TypeScript.NodeType.SuperExpression:
                case TypeScript.NodeType.StringLiteral:
                case TypeScript.NodeType.ThisExpression:
                case TypeScript.NodeType.Name:
                    return path;
            }
        };
        LanguageService.prototype.getTypeAtPosition = function (fileName, position) {
            var path = this.getTypeInfoEligiblePath(fileName, position, true);
            if (!path) {
                return null;
            }
            var document = this.compilerState.getDocument(fileName);
            var ast;
            var symbol;
            var typeSymbol;
            var enclosingScopeSymbol;
            var isCallExpression = false;
            var resolvedSignatures;
            var candidateSignature;
            var isConstructorCall;
            if (path.isNameOfClass() || path.isNameOfInterface() || path.isNameOfFunction() || path.isNameOfVariable()) {
                path.pop();
            }
            if (path.isDeclaration()) {
                var declarationInformation = this.compilerState.getDeclarationSymbolInformation(path, document);
                ast = declarationInformation.ast;
                symbol = declarationInformation.symbol;
                enclosingScopeSymbol = declarationInformation.enclosingScopeSymbol;
                if (path.ast().nodeType === TypeScript.NodeType.FunctionDeclaration) {
                    var funcDecl = (path.ast());
                    if (symbol && symbol.getKind() != TypeScript.PullElementKind.Property) {
                        var signatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, this.compilerState.getSemanticInfoChain().getUnit(fileName));
                        isCallExpression = true;
                        candidateSignature = signatureInfo.signature;
                        resolvedSignatures = signatureInfo.allSignatures;
                    }
                }
            } else if (path.isCallExpression() || path.isCallExpressionTarget()) {
                while(!path.isCallExpression()) {
                    path.pop();
                }
                var callExpressionInformation = this.compilerState.getCallInformationFromPath(path, document);
                if (!callExpressionInformation.targetSymbol) {
                    return null;
                }
                ast = callExpressionInformation.ast;
                symbol = callExpressionInformation.targetSymbol;
                enclosingScopeSymbol = callExpressionInformation.enclosingScopeSymbol;
                var isPropertyOrVar = symbol.getKind() == TypeScript.PullElementKind.Property || symbol.getKind() == TypeScript.PullElementKind.Variable;
                typeSymbol = symbol.getType();
                if (isPropertyOrVar) {
                    if (typeSymbol.getName() != "") {
                        symbol = typeSymbol;
                    }
                    isPropertyOrVar = (typeSymbol.getKind() != TypeScript.PullElementKind.Interface && typeSymbol.getKind() != TypeScript.PullElementKind.ObjectType) || typeSymbol.getName() == "";
                }
                if (!isPropertyOrVar) {
                    isCallExpression = true;
                    resolvedSignatures = callExpressionInformation.resolvedSignatures;
                    candidateSignature = callExpressionInformation.candidateSignature;
                    isConstructorCall = callExpressionInformation.isConstructorCall;
                }
            } else {
                var symbolInformation = this.compilerState.getSymbolInformationFromPath(path, document);
                if (!symbolInformation.symbol) {
                    return null;
                }
                ast = symbolInformation.ast;
                symbol = symbolInformation.symbol;
                enclosingScopeSymbol = symbolInformation.enclosingScopeSymbol;
                if (symbol.getKind() === TypeScript.PullElementKind.Method || symbol.getKind() == TypeScript.PullElementKind.Function) {
                    typeSymbol = symbol.getType();
                    if (typeSymbol) {
                        isCallExpression = true;
                        resolvedSignatures = typeSymbol.getCallSignatures();
                    }
                }
            }
            if (resolvedSignatures && (!candidateSignature || candidateSignature.isDefinition())) {
                for(var i = 0, len = resolvedSignatures.length; i < len; i++) {
                    if (len > 1 && resolvedSignatures[i].isDefinition()) {
                        continue;
                    }
                    candidateSignature = resolvedSignatures[i];
                    break;
                }
            }
            var memberName = isCallExpression ? TypeScript.PullSignatureSymbol.getSignatureTypeMemberName(candidateSignature, resolvedSignatures, enclosingScopeSymbol) : symbol.getTypeNameEx(enclosingScopeSymbol, true);
            var kind = this.mapPullElementKind(symbol.getKind(), symbol, !isCallExpression, isCallExpression, isConstructorCall);
            var docComment = this.compilerState.getDocComments(candidateSignature || symbol, !isCallExpression);
            var symbolName = this.getFullNameOfSymbol(symbol, enclosingScopeSymbol);
            var minChar = ast ? ast.minChar : -1;
            var limChar = ast ? ast.limChar : -1;
            return new Services.TypeInfo(memberName, docComment, symbolName, kind, minChar, limChar);
        };
        LanguageService.prototype.getCompletionsAtPosition = function (fileName, position, isMemberCompletion) {
            this.refresh();
            var completions = new Services.CompletionInfo();
            var document = this.compilerState.getDocument(fileName);
            var script = document.script;
            var path = this.getAstPathToPosition(script, position);
            if (this.isCompletionListBlocker(path)) {
                this.logger.log("Returning an empty list because position is inside a comment, string or regular expression");
                return null;
            }
            var isRightOfDot = false;
            if (path.count() >= 1 && path.asts[path.top].nodeType === TypeScript.NodeType.MemberAccessExpression && (path.asts[path.top]).operand1.limChar < position) {
                isRightOfDot = true;
                path.push((path.asts[path.top]).operand1);
            } else if (path.count() >= 2 && path.asts[path.top].nodeType === TypeScript.NodeType.Name && path.asts[path.top - 1].nodeType === TypeScript.NodeType.MemberAccessExpression && (path.asts[path.top - 1]).operand2 === path.asts[path.top]) {
                isRightOfDot = true;
                path.pop();
                path.push((path.asts[path.top]).operand1);
            }
            if (isRightOfDot) {
                var members = this.compilerState.getVisibleMemberSymbolsFromPath(path, document);
                if (!members) {
                    return null;
                }
                completions.isMemberCompletion = true;
                completions.entries = this.getCompletionEntriesFromSymbols(members);
            } else if (this.isInObjectExpressionContext(path)) {
                while(path.ast().nodeType !== TypeScript.NodeType.ObjectLiteralExpression) {
                    path.pop();
                }
                var contextualMembers = this.compilerState.geContextualMembersFromPath(path, document);
                if (contextualMembers && contextualMembers.symbols && contextualMembers.symbols.length > 0) {
                    var existingMembers = this.compilerState.getVisibleMemberSymbolsFromPath(path, document);
                    completions.isMemberCompletion = true;
                    completions.entries = this.getCompletionEntriesFromSymbols({
                        symbols: this.filterContextualMembersList(contextualMembers.symbols, existingMembers),
                        enclosingScopeSymbol: contextualMembers.enclosingScopeSymbol
                    });
                }
            } else if (isMemberCompletion || this.isCompletionListTriggerPoint(path)) {
                completions.isMemberCompletion = false;
                var symbols = this.compilerState.getVisibleSymbolsFromPath(path, document);
                completions.entries = this.getCompletionEntriesFromSymbols(symbols);
            }
            return completions;
        };
        LanguageService.prototype.getCompletionEntriesFromSymbols = function (symbolInfo) {
            var _this = this;
            var result = [];
            symbolInfo.symbols.forEach(function (symbol) {
                var entry = new Services.CompletionEntry();
                entry.name = symbol.getName();
                entry.type = symbol.getTypeName(symbolInfo.enclosingScopeSymbol, true);
                entry.kind = _this.mapPullElementKind(symbol.getKind(), symbol, true);
                entry.fullSymbolName = _this.getFullNameOfSymbol(symbol, symbolInfo.enclosingScopeSymbol);
                var type = symbol.getType();
                var symbolForDocComments = symbol;
                if (type && type.hasOnlyOverloadCallSignatures()) {
                    symbolForDocComments = type.getCallSignatures()[0];
                }
                entry.docComment = _this.compilerState.getDocComments(symbolForDocComments, true);
                entry.kindModifiers = _this.getScriptElementKindModifiers(symbol);
                result.push(entry);
            });
            return result;
        };
        LanguageService.prototype.filterContextualMembersList = function (contextualMemberSymbols, existingMembers) {
            if (!existingMembers || !existingMembers.symbols || existingMembers.symbols.length === 0) {
                return contextualMemberSymbols;
            }
            var existingMemberSymbols = existingMembers.symbols;
            var existingMemberNames = {};
            for(var i = 0, n = existingMemberSymbols.length; i < n; i++) {
                existingMemberNames[existingMemberSymbols[i].getName()] = true;
            }
            var filteredMembers = [];
            for(var j = 0, m = contextualMemberSymbols.length; j < m; j++) {
                var contextualMemberSymbol = contextualMemberSymbols[j];
                if (!existingMemberNames[contextualMemberSymbol.getName()]) {
                    filteredMembers.push(contextualMemberSymbol);
                }
            }
            return filteredMembers;
        };
        LanguageService.prototype.isRightOfDot = function (path, position) {
            return (path.count() >= 1 && path.asts[path.top].nodeType === TypeScript.NodeType.MemberAccessExpression && (path.asts[path.top]).operand1.limChar < position) || (path.count() >= 2 && path.asts[path.top].nodeType === TypeScript.NodeType.Name && path.asts[path.top - 1].nodeType === TypeScript.NodeType.MemberAccessExpression && (path.asts[path.top - 1]).operand2 === path.asts[path.top]);
        };
        LanguageService.prototype.isInObjectExpressionContext = function (path) {
            return (path.count() >= 0 && path.asts[path.top].nodeType === TypeScript.NodeType.ObjectLiteralExpression) || (path.count() >= 1 && path.asts[path.top].nodeType === TypeScript.NodeType.List && path.asts[path.top - 1].nodeType === TypeScript.NodeType.ObjectLiteralExpression) || (path.count() >= 3 && path.asts[path.top].nodeType === TypeScript.NodeType.Name && path.asts[path.top - 1].nodeType === TypeScript.NodeType.Member && path.asts[path.top - 2].nodeType === TypeScript.NodeType.List && path.asts[path.top - 3].nodeType === TypeScript.NodeType.ObjectLiteralExpression);
        };
        LanguageService.prototype.isCompletionListBlocker = function (path) {
            var asts = path.asts;
            var node = path.count() >= 1 && path.ast();
            if (node) {
                if (node.nodeType === TypeScript.NodeType.Comment || node.nodeType === TypeScript.NodeType.RegularExpressionLiteral || node.nodeType === TypeScript.NodeType.StringLiteral) {
                    return true;
                }
            }
            return false;
        };
        LanguageService.prototype.isCompletionListTriggerPoint = function (path) {
            if (path.isNameOfVariable() || path.isNameOfArgument() || path.isArgumentListOfFunction() || path.ast().nodeType === TypeScript.NodeType.Parameter) {
                return false;
            }
            if (path.isNameOfVariable() || path.isNameOfFunction() || path.isNameOfArgument() || path.isArgumentListOfFunction() || path.isNameOfInterface() || path.isNameOfClass() || path.isNameOfModule()) {
                return false;
            }
            return true;
        };
        LanguageService.prototype.isLocal = function (symbol) {
            var container = symbol.getContainer();
            if (container) {
                var containerKind = container.getKind();
                if (containerKind & (TypeScript.PullElementKind.SomeFunction | TypeScript.PullElementKind.FunctionType)) {
                    return true;
                }
                if (containerKind == TypeScript.PullElementKind.ConstructorType && !symbol.hasFlag(TypeScript.PullElementFlags.Static)) {
                    return true;
                }
            }
            return false;
        };
        LanguageService.prototype.isModule = function (symbol) {
            return this.isOneDeclarationOfKind(symbol, TypeScript.PullElementKind.Container);
        };
        LanguageService.prototype.isDynamicModule = function (symbol) {
            return this.isOneDeclarationOfKind(symbol, TypeScript.PullElementKind.DynamicModule);
        };
        LanguageService.prototype.isConstructorMethod = function (symbol) {
            return this.isOneDeclarationOfKind(symbol, TypeScript.PullElementKind.ConstructorMethod);
        };
        LanguageService.prototype.isClass = function (symbol) {
            return this.isOneDeclarationOfKind(symbol, TypeScript.PullElementKind.Class);
        };
        LanguageService.prototype.isOneDeclarationOfKind = function (symbol, kind) {
            var decls = symbol.getDeclarations();
            for(var i = 0; i < decls.length; i++) {
                if (decls[i].getKind() === kind) {
                    return true;
                }
            }
            return false;
        };
        LanguageService.prototype.mapPullElementKind = function (kind, symbol, useConstructorAsClass, varIsFunction, functionIsConstructor) {
            if (functionIsConstructor) {
                return Services.ScriptElementKind.constructorImplementationElement;
            }
            if (varIsFunction) {
                switch(kind) {
                    case TypeScript.PullElementKind.Container:
                    case TypeScript.PullElementKind.DynamicModule:
                    case TypeScript.PullElementKind.TypeAlias:
                    case TypeScript.PullElementKind.Interface:
                    case TypeScript.PullElementKind.Class:
                    case TypeScript.PullElementKind.Parameter:
                        return Services.ScriptElementKind.functionElement;
                    case TypeScript.PullElementKind.Variable:
                        return (symbol && this.isLocal(symbol)) ? Services.ScriptElementKind.localFunctionElement : Services.ScriptElementKind.functionElement;
                    case TypeScript.PullElementKind.Property:
                        return Services.ScriptElementKind.memberFunctionElement;
                    case TypeScript.PullElementKind.Function:
                        return (symbol && this.isLocal(symbol)) ? Services.ScriptElementKind.localFunctionElement : Services.ScriptElementKind.functionElement;
                    case TypeScript.PullElementKind.ConstructorMethod:
                        return Services.ScriptElementKind.constructorImplementationElement;
                    case TypeScript.PullElementKind.Method:
                        return Services.ScriptElementKind.memberFunctionElement;
                    case TypeScript.PullElementKind.FunctionExpression:
                        return Services.ScriptElementKind.localFunctionElement;
                    case TypeScript.PullElementKind.GetAccessor:
                        return Services.ScriptElementKind.memberGetAccessorElement;
                    case TypeScript.PullElementKind.SetAccessor:
                        return Services.ScriptElementKind.memberSetAccessorElement;
                    case TypeScript.PullElementKind.CallSignature:
                        return Services.ScriptElementKind.callSignatureElement;
                    case TypeScript.PullElementKind.ConstructSignature:
                        return Services.ScriptElementKind.constructSignatureElement;
                    case TypeScript.PullElementKind.IndexSignature:
                        return Services.ScriptElementKind.indexSignatureElement;
                    case TypeScript.PullElementKind.TypeParameter:
                        return Services.ScriptElementKind.typeParameterElement;
                }
            } else {
                switch(kind) {
                    case TypeScript.PullElementKind.Script:
                        return Services.ScriptElementKind.scriptElement;
                    case TypeScript.PullElementKind.Container:
                    case TypeScript.PullElementKind.DynamicModule:
                    case TypeScript.PullElementKind.TypeAlias:
                        return Services.ScriptElementKind.moduleElement;
                    case TypeScript.PullElementKind.Interface:
                        return Services.ScriptElementKind.interfaceElement;
                    case TypeScript.PullElementKind.Class:
                        return Services.ScriptElementKind.classElement;
                    case TypeScript.PullElementKind.Enum:
                        return Services.ScriptElementKind.enumElement;
                    case TypeScript.PullElementKind.Variable:
                        if (symbol && this.isModule(symbol)) {
                            return Services.ScriptElementKind.moduleElement;
                        }
                        return (symbol && this.isLocal(symbol)) ? Services.ScriptElementKind.localVariableElement : Services.ScriptElementKind.variableElement;
                    case TypeScript.PullElementKind.Parameter:
                        return Services.ScriptElementKind.parameterElement;
                    case TypeScript.PullElementKind.Property:
                        return Services.ScriptElementKind.memberVariableElement;
                    case TypeScript.PullElementKind.Function:
                        return (symbol && this.isLocal(symbol)) ? Services.ScriptElementKind.localFunctionElement : Services.ScriptElementKind.functionElement;
                    case TypeScript.PullElementKind.ConstructorMethod:
                        return useConstructorAsClass ? Services.ScriptElementKind.classElement : Services.ScriptElementKind.constructorImplementationElement;
                    case TypeScript.PullElementKind.Method:
                        return Services.ScriptElementKind.memberFunctionElement;
                    case TypeScript.PullElementKind.FunctionExpression:
                        return Services.ScriptElementKind.localFunctionElement;
                    case TypeScript.PullElementKind.GetAccessor:
                        return Services.ScriptElementKind.memberGetAccessorElement;
                    case TypeScript.PullElementKind.SetAccessor:
                        return Services.ScriptElementKind.memberSetAccessorElement;
                    case TypeScript.PullElementKind.CallSignature:
                        return Services.ScriptElementKind.callSignatureElement;
                    case TypeScript.PullElementKind.ConstructSignature:
                        return Services.ScriptElementKind.constructSignatureElement;
                    case TypeScript.PullElementKind.IndexSignature:
                        return Services.ScriptElementKind.indexSignatureElement;
                    case TypeScript.PullElementKind.EnumMember:
                        return Services.ScriptElementKind.memberVariableElement;
                    case TypeScript.PullElementKind.TypeParameter:
                        return Services.ScriptElementKind.typeParameterElement;
                }
            }
            return Services.ScriptElementKind.unknown;
        };
        LanguageService.prototype.getScriptElementKindModifiers = function (symbol) {
            var result = [];
            if (symbol.hasFlag(TypeScript.PullElementFlags.Exported)) {
                result.push(Services.ScriptElementKindModifier.exportedModifier);
            }
            if (symbol.hasFlag(TypeScript.PullElementFlags.Ambient)) {
                result.push(Services.ScriptElementKindModifier.ambientModifier);
            }
            if (symbol.hasFlag(TypeScript.PullElementFlags.Public)) {
                result.push(Services.ScriptElementKindModifier.publicMemberModifier);
            }
            if (symbol.hasFlag(TypeScript.PullElementFlags.Private)) {
                result.push(Services.ScriptElementKindModifier.privateMemberModifier);
            }
            if (symbol.hasFlag(TypeScript.PullElementFlags.Static)) {
                result.push(Services.ScriptElementKindModifier.staticModifier);
            }
            return result.length > 0 ? result.join(',') : Services.ScriptElementKindModifier.none;
        };
        LanguageService.prototype.getNameOrDottedNameSpan = function (fileName, startPos, endPos) {
            var path = this.getTypeInfoEligiblePath(fileName, startPos, false);
            if (!path) {
                return null;
            }
            while(path.count() > 0) {
                if (path.isMemberOfMemberAccessExpression()) {
                    path.pop();
                } else {
                    break;
                }
            }
            var cur = path.ast();
            var spanInfo = new Services.SpanInfo(cur.minChar, cur.limChar);
            return spanInfo;
        };
        LanguageService.prototype.getBreakpointInStatement = function (pos, astSpan, verifyASTPos, existingResult, forceFirstStatement, isAst) {
            if (existingResult || !astSpan || (verifyASTPos && pos > astSpan.limChar)) {
                return existingResult;
            }
            if (!isAst) {
                return astSpan;
            }
            var ast = astSpan;
            var astList = null;
            if (ast.nodeType == TypeScript.NodeType.Block) {
                var block = ast;
                astList = block.statements;
            } else if (ast.nodeType == TypeScript.NodeType.List) {
                astList = ast;
            } else {
                return ast;
            }
            if (astList.members.length > 0) {
                var lastAST = astList.members[astList.members.length - 1];
                if (!forceFirstStatement && pos > lastAST.limChar) {
                    return lastAST;
                } else {
                    return astList.members[0];
                }
            }
            return null;
        };
        LanguageService.prototype.getBreakpointStatementAtPosition = function (fileName, pos) {
            this.refresh();
            var document = this.compilerState.getDocument(fileName);
            var script = document.script;
            var containerASTs = [];
            var lineMap = document.lineMap;
            var lineCol = {
                line: -1,
                character: -1
            };
            lineMap.fillLineAndCharacterFromPosition(pos, lineCol);
            var pre = function (cur, parent, walker) {
                if (TypeScript.isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {
                        switch(cur.nodeType) {
                            case TypeScript.NodeType.ModuleDeclaration:
                            case TypeScript.NodeType.ClassDeclaration:
                            case TypeScript.NodeType.FunctionDeclaration:
                            case TypeScript.NodeType.BreakStatement:
                            case TypeScript.NodeType.ContinueStatement:
                                containerASTs.push(cur);
                                break;
                            case TypeScript.NodeType.Script:
                            case TypeScript.NodeType.List:
                            case TypeScript.NodeType.NumericLiteral:
                            case TypeScript.NodeType.RegularExpressionLiteral:
                            case TypeScript.NodeType.StringLiteral:
                            case TypeScript.NodeType.ArrayLiteralExpression:
                            case TypeScript.NodeType.ObjectLiteralExpression:
                            case TypeScript.NodeType.CastExpression:
                            case TypeScript.NodeType.PlusExpression:
                            case TypeScript.NodeType.NegateExpression:
                            case TypeScript.NodeType.BitwiseNotExpression:
                            case TypeScript.NodeType.LogicalNotExpression:
                            case TypeScript.NodeType.Block:
                            case TypeScript.NodeType.ExpressionStatement:
                                break;
                            case TypeScript.NodeType.TypeRef:
                                walker.options.goChildren = false;
                                break;
                            default:
                                if (cur.isStatementOrExpression() && (!cur.isExpression() || containerASTs.length == 0 || (!containerASTs[containerASTs.length - 1].isExpression() && (containerASTs[containerASTs.length - 1].nodeType != TypeScript.NodeType.VariableDeclarator && containerASTs[containerASTs.length - 1].nodeType != TypeScript.NodeType.Parameter) || containerASTs[containerASTs.length - 1].nodeType == TypeScript.NodeType.ConditionalExpression))) {
                                    containerASTs.push(cur);
                                }
                                break;
                        }
                    } else {
                        walker.options.goChildren = false;
                    }
                }
                return cur;
            };
            TypeScript.getAstWalkerFactory().walk(script, pre);
            if (containerASTs.length == 0) {
                return null;
            }
            var resultAST = null;
            var cur = containerASTs[containerASTs.length - 1];
            var customSpan = null;
            switch(cur.nodeType) {
                case TypeScript.NodeType.ModuleDeclaration:
                    var moduleDecl = cur;
                    if (containerASTs.length > 1) {
                        resultAST = moduleDecl;
                    } else {
                        resultAST = this.getBreakpointInStatement(pos, moduleDecl.members, false, null, false, true);
                    }
                    customSpan = moduleDecl.endingToken;
                    break;
                case TypeScript.NodeType.FunctionDeclaration:
                    var funcDecl = cur;
                    if (containerASTs.length > 1) {
                        resultAST = funcDecl;
                    } else {
                        resultAST = this.getBreakpointInStatement(pos, funcDecl.block, false, null, false, true);
                    }
                    customSpan = funcDecl.block ? funcDecl.block.closeBraceSpan : null;
                    break;
                case TypeScript.NodeType.ClassDeclaration:
                    var classDecl = cur;
                    if (containerASTs.length > 1) {
                        resultAST = classDecl;
                    } else {
                        resultAST = this.getBreakpointInStatement(pos, classDecl.members, false, null, false, true);
                    }
                    customSpan = classDecl.endingToken;
                    break;
                case TypeScript.NodeType.VariableDeclarator:
                    var varDecl = cur;
                    if (varDecl.init) {
                        resultAST = varDecl;
                        if (containerASTs.length > 1 && containerASTs[containerASTs.length - 2].nodeType == TypeScript.NodeType.VariableStatement) {
                            var varStatement = containerASTs[containerASTs.length - 2];
                            if (varStatement.declaration.declarators.members.length && varStatement.declaration.declarators.members[0] == resultAST) {
                                resultAST = varStatement;
                            }
                        }
                    }
                    break;
                case TypeScript.NodeType.IfStatement:
                    var ifStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, ifStatement.statement, true, resultAST, false, false);
                    resultAST = this.getBreakpointInStatement(pos, ifStatement.thenBod, true, resultAST, false, true);
                    resultAST = this.getBreakpointInStatement(pos, ifStatement.elseBod, false, resultAST, false, true);
                    break;
                case TypeScript.NodeType.ForInStatement:
                    var forInStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, forInStatement.statement, true, resultAST, false, false);
                    resultAST = this.getBreakpointInStatement(pos, forInStatement.body, false, resultAST, false, true);
                    break;
                case TypeScript.NodeType.ForStatement:
                    var forStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, forStatement.init, true, null, false, true);
                    resultAST = this.getBreakpointInStatement(pos, forStatement.cond, true, resultAST, false, true);
                    resultAST = this.getBreakpointInStatement(pos, forStatement.incr, true, resultAST, false, true);
                    resultAST = this.getBreakpointInStatement(pos, forStatement.body, false, resultAST, false, true);
                    break;
                case TypeScript.NodeType.WhileStatement:
                    var whileStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, whileStatement.cond, true, null, false, true);
                    resultAST = this.getBreakpointInStatement(pos, whileStatement.body, false, resultAST, false, true);
                    break;
                case TypeScript.NodeType.DoStatement:
                    var doWhileStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, doWhileStatement.body, true, null, false, true);
                    resultAST = this.getBreakpointInStatement(pos, doWhileStatement.cond, false, resultAST, false, true);
                    break;
                case TypeScript.NodeType.SwitchStatement:
                    var switchStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, switchStatement.statement, true, resultAST, false, false);
                    var caseListCount = switchStatement.caseList.members.length;
                    if (caseListCount > 0) {
                        var lastCase = switchStatement.caseList.members[caseListCount - 1];
                        var caseToUse;
                        if (pos >= lastCase.limChar) {
                            caseToUse = lastCase;
                            resultAST = this.getBreakpointInStatement(pos, caseToUse.body.members[0], false, resultAST, false, true);
                        } else {
                            caseToUse = switchStatement.caseList.members[0];
                            resultAST = this.getBreakpointInStatement(pos, caseToUse.body.members[0], false, resultAST, true, true);
                        }
                    }
                    break;
                case TypeScript.NodeType.CaseClause:
                    var caseStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, caseStatement.body.members[0], false, null, false, true);
                    break;
                case TypeScript.NodeType.WithStatement:
                    var withStatement = cur;
                    resultAST = this.getBreakpointInStatement(pos, withStatement.body, false, null, false, true);
                    break;
                case TypeScript.NodeType.TryStatement:
                    var tryNode = cur;
                    resultAST = this.getBreakpointInStatement(pos, tryNode.tryBody, true, null, false, false);
                    resultAST = this.getBreakpointInStatement(pos, tryNode.catchClause, true, resultAST, false, false);
                    resultAST = this.getBreakpointInStatement(pos, tryNode.finallyBody, false, resultAST, false, true);
                    break;
                case TypeScript.NodeType.CatchClause:
                    var catchNode = cur;
                    resultAST = this.getBreakpointInStatement(pos, catchNode.statement, true, null, false, false);
                    resultAST = this.getBreakpointInStatement(pos, catchNode.body, false, resultAST, false, true);
                    break;
                default:
                    resultAST = cur;
                    break;
            }
            if (TypeScript.isValidAstNode(customSpan) && pos >= customSpan.minChar && pos <= customSpan.limChar) {
                resultAST = customSpan;
            }
            if (resultAST) {
                var result = new Services.SpanInfo(resultAST.minChar, resultAST.limChar);
                return result;
            }
            return null;
        };
        LanguageService.prototype.getFormattingEditsForRange = function (fileName, minChar, limChar, options) {
            this.minimalRefresh();
            var manager = this.getFormattingManager(fileName, options);
            return manager.formatSelection(minChar, limChar);
        };
        LanguageService.prototype.getFormattingEditsForDocument = function (fileName, minChar, limChar, options) {
            this.minimalRefresh();
            var manager = this.getFormattingManager(fileName, options);
            return manager.formatDocument(minChar, limChar);
        };
        LanguageService.prototype.getFormattingEditsOnPaste = function (fileName, minChar, limChar, options) {
            this.minimalRefresh();
            var manager = this.getFormattingManager(fileName, options);
            return manager.formatOnPaste(minChar, limChar);
        };
        LanguageService.prototype.getFormattingEditsAfterKeystroke = function (fileName, position, key, options) {
            this.minimalRefresh();
            var manager = this.getFormattingManager(fileName, options);
            if (key === "}") {
                return manager.formatOnClosingCurlyBrace(position);
            } else if (key === ";") {
                return manager.formatOnSemicolon(position);
            } else if (key === "\n") {
                return manager.formatOnEnter(position);
            }
            return [];
        };
        LanguageService.prototype.getFormattingManager = function (fileName, options) {
            if (this.formattingRulesProvider == null) {
                this.formattingRulesProvider = new TypeScript.Formatting.RulesProvider(this.logger);
            }
            this.formattingRulesProvider.ensureUptodate(options);
            var syntaxTree = this.getSyntaxTree(fileName);
            var scriptSnapshot = this.compilerState.getScriptSnapshot(fileName);
            var scriptText = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            var textSnapshot = new TypeScript.Formatting.TextSnapshot(scriptText);
            var manager = new TypeScript.Formatting.FormattingManager(syntaxTree, textSnapshot, this.formattingRulesProvider, options);
            return manager;
        };
        LanguageService.prototype.getOutliningRegions = function (fileName) {
            this.minimalRefresh();
            var syntaxTree = this.getSyntaxTree(fileName);
            return Services.OutliningElementsCollector.collectElements(syntaxTree.sourceUnit());
        };
        LanguageService.prototype.getSmartIndentAtLineNumber = function (fileName, position, editorOptions) {
            this.minimalRefresh();
            var syntaxTree = this.getSyntaxTree(fileName);
            var scriptSnapshot = this.compilerState.getScriptSnapshot(fileName);
            var scriptText = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            var textSnapshot = new TypeScript.Formatting.TextSnapshot(scriptText);
            var options = new FormattingOptions(!editorOptions.ConvertTabsToSpaces, editorOptions.TabSize, editorOptions.IndentSize, editorOptions.NewLineCharacter);
            return TypeScript.Formatting.SingleTokenIndenter.getIndentationAmount(position, syntaxTree.sourceUnit(), textSnapshot, options);
        };
        LanguageService.prototype.getBraceMatchingAtPosition = function (fileName, position) {
            this.minimalRefresh();
            var syntaxTree = this.getSyntaxTree(fileName);
            return Services.BraceMatcher.getMatchSpans(syntaxTree, position);
        };
        LanguageService.prototype.getSyntaxTree = function (fileName) {
            var version = this.compilerState.getScriptVersion(fileName);
            var syntaxTree = null;
            if (this.currentFileSyntaxTree === null || this.currentFileName !== fileName) {
                syntaxTree = this.createSyntaxTree(fileName);
            } else if (version == null) {
                syntaxTree = this.createSyntaxTree(fileName);
            } else if (this.currentFileVersion !== version) {
                syntaxTree = this.updateSyntaxTree(fileName, this.currentFileSyntaxTree, this.currentFileVersion);
            }
            if (syntaxTree !== null) {
                this.currentFileVersion = version;
                this.currentFileName = fileName;
                this.currentFileSyntaxTree = syntaxTree;
            }
            return this.currentFileSyntaxTree;
        };
        LanguageService.prototype.createSyntaxTree = function (fileName) {
            var scriptSnapshot = this.compilerState.getScriptSnapshot(fileName);
            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);
            var syntaxTree = TypeScript.Parser.parse(fileName, text, TypeScript.isDTSFile(fileName));
            return syntaxTree;
        };
        LanguageService.prototype.updateSyntaxTree = function (fileName, previousSyntaxTree, previousFileVersion) {
            var editRange = this.compilerState.getScriptTextChangeRangeSinceVersion(fileName, previousFileVersion);
            if (editRange === null) {
                return previousSyntaxTree;
            }
            var newScriptSnapshot = this.compilerState.getScriptSnapshot(fileName);
            var newSegmentedScriptSnapshot = TypeScript.SimpleText.fromScriptSnapshot(newScriptSnapshot);
            var nextSyntaxTree = TypeScript.Parser.incrementalParse(previousSyntaxTree, editRange, newSegmentedScriptSnapshot);
            return nextSyntaxTree;
        };
        return LanguageService;
    })();
    Services.LanguageService = LanguageService;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var ShimBase = (function () {
        function ShimBase(factory) {
            this.factory = factory;
            factory.registerShim(this);
        }
        ShimBase.prototype.dispose = function (dummy) {
            this.factory.unregisterShim(this);
        };
        return ShimBase;
    })();
    Services.ShimBase = ShimBase;    
    var ScriptSnapshotShimAdapter = (function () {
        function ScriptSnapshotShimAdapter(scriptSnapshotShim) {
            this.scriptSnapshotShim = scriptSnapshotShim;
            this.lineStartPositions = null;
        }
        ScriptSnapshotShimAdapter.prototype.getText = function (start, end) {
            return this.scriptSnapshotShim.getText(start, end);
        };
        ScriptSnapshotShimAdapter.prototype.getLength = function () {
            return this.scriptSnapshotShim.getLength();
        };
        ScriptSnapshotShimAdapter.prototype.getLineStartPositions = function () {
            if (this.lineStartPositions === null) {
                this.lineStartPositions = JSON.parse(this.scriptSnapshotShim.getLineStartPositions());
            }
            return this.lineStartPositions;
        };
        ScriptSnapshotShimAdapter.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
            var encoded = this.scriptSnapshotShim.getTextChangeRangeSinceVersion(scriptVersion);
            if (encoded === null) {
                return null;
            }
            var decoded = JSON.parse(encoded);
            return new TypeScript.TextChangeRange(new TypeScript.TextSpan(decoded.span.start, decoded.span.length), decoded.newLength);
        };
        return ScriptSnapshotShimAdapter;
    })();    
    var LanguageServiceShimHostAdapter = (function () {
        function LanguageServiceShimHostAdapter(shimHost) {
            this.shimHost = shimHost;
        }
        LanguageServiceShimHostAdapter.prototype.information = function () {
            return this.shimHost.information();
        };
        LanguageServiceShimHostAdapter.prototype.debug = function () {
            return this.shimHost.debug();
        };
        LanguageServiceShimHostAdapter.prototype.warning = function () {
            return this.shimHost.warning();
        };
        LanguageServiceShimHostAdapter.prototype.error = function () {
            return this.shimHost.error();
        };
        LanguageServiceShimHostAdapter.prototype.fatal = function () {
            return this.shimHost.fatal();
        };
        LanguageServiceShimHostAdapter.prototype.log = function (s) {
            this.shimHost.log(s);
        };
        LanguageServiceShimHostAdapter.prototype.getCompilationSettings = function () {
            var settingsJson = this.shimHost.getCompilationSettings();
            if (settingsJson == null || settingsJson == "") {
                return null;
            }
            var settings = JSON.parse(settingsJson);
            return settings;
        };
        LanguageServiceShimHostAdapter.prototype.getScriptFileNames = function () {
            var encoded = this.shimHost.getScriptFileNames();
            return JSON.parse(encoded);
        };
        LanguageServiceShimHostAdapter.prototype.getScriptSnapshot = function (fileName) {
            return new ScriptSnapshotShimAdapter(this.shimHost.getScriptSnapshot(fileName));
        };
        LanguageServiceShimHostAdapter.prototype.getScriptVersion = function (fileName) {
            return this.shimHost.getScriptVersion(fileName);
        };
        LanguageServiceShimHostAdapter.prototype.getScriptIsOpen = function (fileName) {
            return this.shimHost.getScriptIsOpen(fileName);
        };
        LanguageServiceShimHostAdapter.prototype.getDiagnosticsObject = function () {
            return this.shimHost.getDiagnosticsObject();
        };
        return LanguageServiceShimHostAdapter;
    })();
    Services.LanguageServiceShimHostAdapter = LanguageServiceShimHostAdapter;    
    function simpleForwardCall(logger, actionDescription, action) {
        logger.log(actionDescription);
        var start = Date.now();
        var result = action();
        var end = Date.now();
        logger.log(actionDescription + " completed in " + (end - start) + " msec");
        if (typeof (result) === "string") {
            var str = result;
            logger.log("  result.length=" + str.length + ", result=\"" + TypeScript.stringToLiteral(str, 128) + (str.length > 128 ? "..." : "") + "\"");
        }
        return result;
    }
    Services.simpleForwardCall = simpleForwardCall;
    function forwardJSONCall(logger, actionDescription, action) {
        try  {
            var result = simpleForwardCall(logger, actionDescription, action);
            return JSON.stringify({
                result: result
            });
        } catch (err) {
            Services.logInternalError(logger, err);
            return JSON.stringify({
                error: err
            });
        }
    }
    Services.forwardJSONCall = forwardJSONCall;
    var LanguageServiceShim = (function (_super) {
        __extends(LanguageServiceShim, _super);
        function LanguageServiceShim(factory, host, languageService) {
            _super.call(this, factory);
            this.host = host;
            this.languageService = languageService;
            this.logger = this.host;
        }
        LanguageServiceShim.prototype.forwardJSONCall = function (actionDescription, action) {
            return Services.forwardJSONCall(this.logger, actionDescription, action);
        };
        LanguageServiceShim.prototype.dispose = function (dummy) {
            this.logger.log("dispose()");
            this.languageService = null;
            this.logger = null;
            _super.prototype.dispose.call(this, dummy);
        };
        LanguageServiceShim.prototype.refresh = function (throwOnError) {
            var _this = this;
            this.forwardJSONCall("refresh(" + throwOnError + ")", function () {
                _this.languageService.refresh();
                return null;
            });
        };
        LanguageServiceShim.realizeDiagnostic = function realizeDiagnostic(diagnostic) {
            return {
                message: diagnostic.message(),
                start: diagnostic.start(),
                length: diagnostic.length()
            };
        };
        LanguageServiceShim.prototype.getSyntacticDiagnostics = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getSyntacticDiagnostics(\"" + fileName + "\")", function () {
                var errors = _this.languageService.getSyntacticDiagnostics(fileName);
                return errors.map(LanguageServiceShim.realizeDiagnostic);
            });
        };
        LanguageServiceShim.prototype.getSemanticDiagnostics = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getSemanticDiagnostics(\"" + fileName + "\")", function () {
                var errors = _this.languageService.getSemanticDiagnostics(fileName);
                return errors.map(LanguageServiceShim.realizeDiagnostic);
            });
        };
        LanguageServiceShim.prototype.getTypeAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getTypeAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var typeInfo = _this.languageService.getTypeAtPosition(fileName, pos);
                return typeInfo;
            });
        };
        LanguageServiceShim.prototype.getNameOrDottedNameSpan = function (fileName, startPos, endPos) {
            var _this = this;
            return this.forwardJSONCall("getNameOrDottedNameSpan(\"" + fileName + "\", " + startPos + ", " + endPos + ")", function () {
                var spanInfo = _this.languageService.getNameOrDottedNameSpan(fileName, startPos, endPos);
                return spanInfo;
            });
        };
        LanguageServiceShim.prototype.getBreakpointStatementAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getBreakpointStatementAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var spanInfo = _this.languageService.getBreakpointStatementAtPosition(fileName, pos);
                return spanInfo;
            });
        };
        LanguageServiceShim.prototype.getSignatureAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getSignatureAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var signatureInfo = _this.languageService.getSignatureAtPosition(fileName, pos);
                return signatureInfo;
            });
        };
        LanguageServiceShim.prototype.getDefinitionAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getDefinitionAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var definition = _this.languageService.getDefinitionAtPosition(fileName, pos);
                if (definition === null) {
                    return null;
                }
                return {
                    fileName: definition.fileName,
                    minChar: definition.minChar,
                    limChar: definition.limChar,
                    kind: definition.kind,
                    name: definition.name,
                    containerKind: definition.containerKind,
                    containerName: definition.containerName
                };
            });
        };
        LanguageServiceShim.prototype.getBraceMatchingAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getBraceMatchingAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var textRanges = _this.languageService.getBraceMatchingAtPosition(fileName, pos);
                return textRanges;
            });
        };
        LanguageServiceShim.prototype.getSmartIndentAtLineNumber = function (fileName, position, options) {
            var _this = this;
            return this.forwardJSONCall("getSmartIndentAtLineNumber(\"" + fileName + "\", " + position + ")", function () {
                var localOptions = JSON.parse(options);
                var columnOffset = _this.languageService.getSmartIndentAtLineNumber(fileName, position, localOptions);
                return {
                    value: columnOffset
                };
            });
        };
        LanguageServiceShim.prototype.getReferencesAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getReferencesAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var entries = _this.languageService.getReferencesAtPosition(fileName, pos);
                return _this._referencesToResult(entries);
            });
        };
        LanguageServiceShim.prototype.getOccurrencesAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getOccurrencesAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var entries = _this.languageService.getOccurrencesAtPosition(fileName, pos);
                return _this._referencesToResult(entries);
            });
        };
        LanguageServiceShim.prototype.getImplementorsAtPosition = function (fileName, pos) {
            var _this = this;
            return this.forwardJSONCall("getImplementorsAtPosition(\"" + fileName + "\", " + pos + ")", function () {
                var entries = _this.languageService.getImplementorsAtPosition(fileName, pos);
                return _this._referencesToResult(entries);
            });
        };
        LanguageServiceShim.prototype._referencesToResult = function (entries) {
            var result = [];
            for(var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                result.push({
                    fileName: entry.fileName,
                    minChar: entry.ast.minChar,
                    limChar: entry.ast.limChar,
                    isWriteAccess: entry.isWriteAccess
                });
            }
            return result;
        };
        LanguageServiceShim.prototype.getCompletionsAtPosition = function (fileName, pos, isMemberCompletion) {
            var _this = this;
            return this.forwardJSONCall("getCompletionsAtPosition(\"" + fileName + "\", " + pos + ", " + isMemberCompletion + ")", function () {
                var completion = _this.languageService.getCompletionsAtPosition(fileName, pos, isMemberCompletion);
                return completion;
            });
        };
        LanguageServiceShim.prototype.getFormattingEditsForRange = function (fileName, minChar, limChar, options) {
            var _this = this;
            return this.forwardJSONCall("getFormattingEditsForRange(\"" + fileName + "\", " + minChar + ", " + limChar + ")", function () {
                var localOptions = JSON.parse(options);
                var edits = _this.languageService.getFormattingEditsForRange(fileName, minChar, limChar, localOptions);
                return edits;
            });
        };
        LanguageServiceShim.prototype.getFormattingEditsForDocument = function (fileName, minChar, limChar, options) {
            var _this = this;
            return this.forwardJSONCall("getFormattingEditsForDocument(\"" + fileName + "\", " + minChar + ", " + limChar + ")", function () {
                var localOptions = JSON.parse(options);
                var edits = _this.languageService.getFormattingEditsForDocument(fileName, minChar, limChar, localOptions);
                return edits;
            });
        };
        LanguageServiceShim.prototype.getFormattingEditsOnPaste = function (fileName, minChar, limChar, options) {
            var _this = this;
            return this.forwardJSONCall("getFormattingEditsOnPaste(\"" + fileName + "\", " + minChar + ", " + limChar + ")", function () {
                var localOptions = JSON.parse(options);
                var edits = _this.languageService.getFormattingEditsOnPaste(fileName, minChar, limChar, localOptions);
                return edits;
            });
        };
        LanguageServiceShim.prototype.getFormattingEditsAfterKeystroke = function (fileName, position, key, options) {
            var _this = this;
            return this.forwardJSONCall("getFormattingEditsAfterKeystroke(\"" + fileName + "\", " + position + ", \"" + key + "\")", function () {
                var localOptions = JSON.parse(options);
                var edits = _this.languageService.getFormattingEditsAfterKeystroke(fileName, position, key, localOptions);
                return edits;
            });
        };
        LanguageServiceShim.prototype.getNavigateToItems = function (searchValue) {
            var _this = this;
            return this.forwardJSONCall("getNavigateToItems(\"" + searchValue + "\")", function () {
                var items = _this.languageService.getNavigateToItems(searchValue);
                var result = _this._navigateToItemsToString(items);
                return result;
            });
        };
        LanguageServiceShim.prototype.getScriptLexicalStructure = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getScriptLexicalStructure(\"" + fileName + "\")", function () {
                var items = _this.languageService.getScriptLexicalStructure(fileName);
                var result = _this._navigateToItemsToString(items);
                return result;
            });
        };
        LanguageServiceShim.prototype.getOutliningRegions = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getOutliningRegions(\"" + fileName + "\")", function () {
                var items = _this.languageService.getOutliningRegions(fileName);
                return items;
            });
        };
        LanguageServiceShim.prototype.getEmitOutput = function (fileName) {
            var _this = this;
            return this.forwardJSONCall("getEmitOutput(\"" + fileName + "\")", function () {
                var output = _this.languageService.getEmitOutput(fileName);
                return output;
            });
        };
        LanguageServiceShim.prototype._navigateToItemsToString = function (items) {
            var result = [];
            for(var i = 0; i < items.length; i++) {
                var item = items[i];
                result.push({
                    name: item.name,
                    kind: item.kind,
                    kindModifiers: item.kindModifiers,
                    containerName: item.containerName,
                    containerKind: item.containerKind,
                    matchKind: item.matchKind,
                    fileName: item.fileName,
                    minChar: item.minChar,
                    limChar: item.limChar
                });
            }
            return result;
        };
        return LanguageServiceShim;
    })(ShimBase);
    Services.LanguageServiceShim = LanguageServiceShim;    
    var ClassifierShim = (function (_super) {
        __extends(ClassifierShim, _super);
        function ClassifierShim(factory, host) {
            _super.call(this, factory);
            this.host = host;
            this.classifier = new Services.Classifier(this.host);
        }
        ClassifierShim.prototype.getClassificationsForLine = function (text, lexState) {
            var classification = this.classifier.getClassificationsForLine(text, lexState);
            var items = classification.entries;
            var result = "";
            for(var i = 0; i < items.length; i++) {
                result += items[i].length + "\n";
                result += items[i].classification + "\n";
            }
            result += classification.finalLexState;
            return result;
        };
        return ClassifierShim;
    })(ShimBase);
    Services.ClassifierShim = ClassifierShim;    
    var CoreServicesShim = (function (_super) {
        __extends(CoreServicesShim, _super);
        function CoreServicesShim(factory, host) {
            _super.call(this, factory);
            this.host = host;
            this.logger = this.host.logger;
            this.services = new Services.CoreServices(this.host);
        }
        CoreServicesShim.prototype.forwardJSONCall = function (actionDescription, action) {
            return Services.forwardJSONCall(this.logger, actionDescription, action);
        };
        CoreServicesShim.prototype.getPreProcessedFileInfo = function (fileName, sourceText) {
            var _this = this;
            return this.forwardJSONCall("getPreProcessedFileInfo(\"" + fileName + "\")", function () {
                var result = _this.services.getPreProcessedFileInfo(fileName, sourceText);
                return result;
            });
        };
        CoreServicesShim.prototype.getDefaultCompilationSettings = function () {
            var _this = this;
            return this.forwardJSONCall("getDefaultCompilationSettings()", function () {
                var result = _this.services.getDefaultCompilationSettings();
                return result;
            });
        };
        CoreServicesShim.prototype.dumpMemory = function (dummy) {
            var _this = this;
            return this.forwardJSONCall("dumpMemory()", function () {
                return _this.services.dumpMemory();
            });
        };
        CoreServicesShim.prototype.getMemoryInfo = function (dummy) {
            var _this = this;
            return this.forwardJSONCall("getMemoryInfo()", function () {
                var result = _this.services.getMemoryInfo();
                return result;
            });
        };
        return CoreServicesShim;
    })(ShimBase);
    Services.CoreServicesShim = CoreServicesShim;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var OutliningElementsCollector = (function (_super) {
        __extends(OutliningElementsCollector, _super);
        function OutliningElementsCollector() {
            _super.call(this, OutliningElementsCollector.MaximumDepth);
            this.elements = [];
        }
        OutliningElementsCollector.MaximumDepth = 10;
        OutliningElementsCollector.prototype.visitClassDeclaration = function (node) {
            this.addOutlineRange(node, node.openBraceToken, node.closeBraceToken);
            _super.prototype.visitClassDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitInterfaceDeclaration = function (node) {
            this.addOutlineRange(node, node.body, node.body);
            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitModuleDeclaration = function (node) {
            this.addOutlineRange(node, node.openBraceToken, node.closeBraceToken);
            _super.prototype.visitModuleDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitEnumDeclaration = function (node) {
            this.addOutlineRange(node, node.openBraceToken, node.closeBraceToken);
            _super.prototype.visitEnumDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitFunctionDeclaration = function (node) {
            this.addOutlineRange(node, node.block, node.block);
            _super.prototype.visitFunctionDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitFunctionExpression = function (node) {
            this.addOutlineRange(node, node.block, node.block);
            _super.prototype.visitFunctionExpression.call(this, node);
        };
        OutliningElementsCollector.prototype.visitConstructorDeclaration = function (node) {
            this.addOutlineRange(node, node.block, node.block);
            _super.prototype.visitConstructorDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitMemberFunctionDeclaration = function (node) {
            this.addOutlineRange(node, node.block, node.block);
            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.addOutlineRange(node, node.block, node.block);
            _super.prototype.visitGetMemberAccessorDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.addOutlineRange(node, node.block, node.block);
            _super.prototype.visitSetMemberAccessorDeclaration.call(this, node);
        };
        OutliningElementsCollector.prototype.addOutlineRange = function (node, startElement, endElement) {
            if (startElement && endElement) {
                var start = this.position() + TypeScript.Syntax.childOffset(node, startElement);
                var end = this.position() + TypeScript.Syntax.childOffset(node, endElement) + endElement.leadingTriviaWidth() + endElement.width();
                this.elements.push(TypeScript.TextSpan.fromBounds(start, end));
            }
        };
        OutliningElementsCollector.collectElements = function collectElements(node) {
            var collector = new OutliningElementsCollector();
            node.accept(collector);
            return collector.elements;
        };
        return OutliningElementsCollector;
    })(TypeScript.DepthLimitedWalker);
    Services.OutliningElementsCollector = OutliningElementsCollector;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var BraceMatcher = (function () {
        function BraceMatcher() { }
        BraceMatcher.getMatchSpans = function getMatchSpans(syntaxTree, position) {
            var result = [];
            var currentToken = syntaxTree.sourceUnit().findToken(position);
            BraceMatcher.getMatchingCloseBrace(currentToken, position, result);
            BraceMatcher.getMatchingOpenBrace(currentToken, position, result);
            return result;
        };
        BraceMatcher.getMatchingCloseBrace = function getMatchingCloseBrace(currentToken, position, result) {
            if (currentToken.start() === position) {
                var closingBraceKind = BraceMatcher.getMatchingCloseBraceTokenKind(currentToken);
                if (closingBraceKind !== null) {
                    var parentElement = currentToken.parentElement();
                    var currentPosition = currentToken.parent().fullStart();
                    for(var i = 0, n = parentElement.childCount(); i < n; i++) {
                        var element = parentElement.childAt(i);
                        if (element !== null && element.fullWidth() > 0) {
                            if (element.kind() === closingBraceKind) {
                                var range1 = new TypeScript.TextSpan(position, currentToken.token().width());
                                var range2 = new TypeScript.TextSpan(currentPosition + element.leadingTriviaWidth(), element.width());
                                result.push(range1, range2);
                                break;
                            }
                            currentPosition += element.fullWidth();
                        }
                    }
                }
            }
        };
        BraceMatcher.getMatchingOpenBrace = function getMatchingOpenBrace(currentToken, position, result) {
            if (currentToken.fullStart() === position) {
                currentToken = currentToken.previousToken();
            }
            if (currentToken !== null && currentToken.start() === (position - 1)) {
                var openBraceKind = BraceMatcher.getMatchingOpenBraceTokenKind(currentToken);
                if (openBraceKind !== null) {
                    var parentElement = currentToken.parentElement();
                    var currentPosition = currentToken.parent().fullStart() + parentElement.fullWidth();
                    for(var i = parentElement.childCount() - 1; i >= 0; i--) {
                        var element = parentElement.childAt(i);
                        if (element !== null && element.fullWidth() > 0) {
                            if (element.kind() === openBraceKind) {
                                var range1 = new TypeScript.TextSpan(position - 1, currentToken.token().width());
                                var range2 = new TypeScript.TextSpan(currentPosition - element.trailingTriviaWidth() - element.width(), element.width());
                                result.push(range1, range2);
                                break;
                            }
                            currentPosition -= element.fullWidth();
                        }
                    }
                }
            }
        };
        BraceMatcher.getMatchingCloseBraceTokenKind = function getMatchingCloseBraceTokenKind(positionedElement) {
            var element = positionedElement !== null && positionedElement.element();
            switch(element.kind()) {
                case TypeScript.SyntaxKind.OpenBraceToken:
                    return TypeScript.SyntaxKind.CloseBraceToken;
                case TypeScript.SyntaxKind.OpenParenToken:
                    return TypeScript.SyntaxKind.CloseParenToken;
                case TypeScript.SyntaxKind.OpenBracketToken:
                    return TypeScript.SyntaxKind.CloseBracketToken;
                case TypeScript.SyntaxKind.LessThanToken:
                    return TypeScript.SyntaxUtilities.isAngleBracket(positionedElement) ? TypeScript.SyntaxKind.GreaterThanToken : null;
            }
            return null;
        };
        BraceMatcher.getMatchingOpenBraceTokenKind = function getMatchingOpenBraceTokenKind(positionedElement) {
            var element = positionedElement !== null && positionedElement.element();
            switch(element.kind()) {
                case TypeScript.SyntaxKind.CloseBraceToken:
                    return TypeScript.SyntaxKind.OpenBraceToken;
                case TypeScript.SyntaxKind.CloseParenToken:
                    return TypeScript.SyntaxKind.OpenParenToken;
                case TypeScript.SyntaxKind.CloseBracketToken:
                    return TypeScript.SyntaxKind.OpenBracketToken;
                case TypeScript.SyntaxKind.GreaterThanToken:
                    return TypeScript.SyntaxUtilities.isAngleBracket(positionedElement) ? TypeScript.SyntaxKind.LessThanToken : null;
            }
            return null;
        };
        return BraceMatcher;
    })();
    Services.BraceMatcher = BraceMatcher;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var Indenter = (function () {
        function Indenter() { }
        Indenter.getIndentation = function getIndentation(node, soruceText, position, editorOptions) {
            var indentation = 0;
            var currentToken = node.findToken(position);
            var currentNode = currentToken;
            if (currentToken.token().kind() === TypeScript.SyntaxKind.EndOfFileToken) {
                currentNode = currentToken.previousToken();
            } else if (Indenter.belongsToBracket(soruceText, currentToken, position)) {
                currentNode = currentToken.parent();
            }
            if (currentNode === null) {
                return indentation;
            }
            if (currentNode.kind() === TypeScript.SyntaxKind.StringLiteral || currentNode.kind() === TypeScript.SyntaxKind.RegularExpressionLiteral) {
                return indentation;
            }
            var currentElement = currentNode.element();
            var parent = currentNode.parent();
            while(parent !== null) {
                if (parent.fullStart() !== currentNode.fullStart()) {
                    if (Indenter.isInContainerNode(parent.element(), currentElement)) {
                        indentation += editorOptions.IndentSize;
                    } else {
                        var listIndentation = Indenter.getCustomListIndentation(parent.element(), currentElement);
                        if (listIndentation !== -1) {
                            return indentation + listIndentation;
                        }
                    }
                }
                currentNode = parent;
                currentElement = parent.element();
                parent = parent.parent();
            }
            return indentation;
        };
        Indenter.belongsToBracket = function belongsToBracket(sourceText, token, position) {
            switch(token.token().kind()) {
                case TypeScript.SyntaxKind.OpenBraceToken:
                case TypeScript.SyntaxKind.CloseBraceToken:
                case TypeScript.SyntaxKind.OpenParenToken:
                case TypeScript.SyntaxKind.CloseParenToken:
                case TypeScript.SyntaxKind.OpenBracketToken:
                case TypeScript.SyntaxKind.CloseBracketToken:
                    if (position < token.start()) {
                        var text = sourceText.getText(position, token.start());
                        for(var i = 0; i < text.length; i++) {
                            if (TypeScript.CharacterInfo.isLineTerminator(text.charCodeAt(i))) {
                                return false;
                            }
                        }
                    }
                    return true;
            }
            return false;
        };
        Indenter.isInContainerNode = function isInContainerNode(parent, element) {
            switch(parent.kind()) {
                case TypeScript.SyntaxKind.ClassDeclaration:
                case TypeScript.SyntaxKind.ModuleDeclaration:
                case TypeScript.SyntaxKind.EnumDeclaration:
                case TypeScript.SyntaxKind.ImportDeclaration:
                case TypeScript.SyntaxKind.Block:
                case TypeScript.SyntaxKind.SwitchStatement:
                case TypeScript.SyntaxKind.CaseSwitchClause:
                case TypeScript.SyntaxKind.DefaultSwitchClause:
                    return true;
                case TypeScript.SyntaxKind.ObjectType:
                    return true;
                case TypeScript.SyntaxKind.InterfaceDeclaration:
                    return element.kind() !== TypeScript.SyntaxKind.ObjectType;
                case TypeScript.SyntaxKind.FunctionDeclaration:
                case TypeScript.SyntaxKind.MemberFunctionDeclaration:
                case TypeScript.SyntaxKind.GetMemberAccessorDeclaration:
                case TypeScript.SyntaxKind.SetMemberAccessorDeclaration:
                case TypeScript.SyntaxKind.GetAccessorPropertyAssignment:
                case TypeScript.SyntaxKind.SetAccessorPropertyAssignment:
                case TypeScript.SyntaxKind.FunctionExpression:
                case TypeScript.SyntaxKind.CatchClause:
                case TypeScript.SyntaxKind.FinallyClause:
                case TypeScript.SyntaxKind.FunctionDeclaration:
                case TypeScript.SyntaxKind.ConstructorDeclaration:
                case TypeScript.SyntaxKind.ForStatement:
                case TypeScript.SyntaxKind.ForInStatement:
                case TypeScript.SyntaxKind.WhileStatement:
                case TypeScript.SyntaxKind.DoStatement:
                case TypeScript.SyntaxKind.WithStatement:
                case TypeScript.SyntaxKind.IfStatement:
                case TypeScript.SyntaxKind.ElseClause:
                    return element.kind() !== TypeScript.SyntaxKind.Block;
                case TypeScript.SyntaxKind.TryStatement:
                    return false;
                default:
                    return parent.isNode() && (parent).isStatement();
            }
        };
        Indenter.getCustomListIndentation = function getCustomListIndentation(list, element) {
            switch(list.kind()) {
                case TypeScript.SyntaxKind.SeparatedList:
                    for(var i = 0, n = list.childCount(); i < n; i++) {
                        var child = list.childAt(i);
                        if (child !== null && child === element) {
                            return Indenter.getListItemIndentation(list, i - 1);
                        }
                    }
                    break;
                case TypeScript.SyntaxKind.ArgumentList:
                    var argumentList = list;
                    var arguments = argumentList.arguments;
                    if (arguments !== null && argumentList.closeParenToken === element) {
                        return Indenter.getListItemIndentation(arguments, arguments.childCount() - 1);
                    }
                    break;
                case TypeScript.SyntaxKind.ParameterList:
                    var parameterList = list;
                    var parameters = parameterList.parameters;
                    if (parameters !== null && parameterList.closeParenToken === element) {
                        return Indenter.getListItemIndentation(parameters, parameters.childCount() - 1);
                    }
                    break;
                case TypeScript.SyntaxKind.TypeArgumentList:
                    var typeArgumentList = list;
                    var typeArguments = typeArgumentList.typeArguments;
                    if (typeArguments !== null && typeArgumentList.greaterThanToken === element) {
                        return Indenter.getListItemIndentation(typeArguments, typeArguments.childCount() - 1);
                    }
                    break;
                case TypeScript.SyntaxKind.TypeParameterList:
                    var typeParameterList = list;
                    var typeParameters = typeParameterList.typeParameters;
                    if (typeParameters !== null && typeParameterList.greaterThanToken === element) {
                        return Indenter.getListItemIndentation(typeParameters, typeParameters.childCount() - 1);
                    }
                    break;
            }
            return -1;
        };
        Indenter.getListItemIndentation = function getListItemIndentation(list, elementIndex) {
            for(var i = elementIndex; i > 0; i--) {
                var child = list.childAt(i);
                var previousChild = list.childAt(i - 1);
                if ((child !== null && child.leadingTrivia().hasNewLine()) || (previousChild !== null && previousChild.trailingTrivia().hasNewLine())) {
                    return child.leadingTriviaWidth();
                }
            }
            return -1;
        };
        return Indenter;
    })();
    Services.Indenter = Indenter;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    function copyDataObject(dst, src) {
        for(var e in dst) {
            if (typeof dst[e] == "object") {
                copyDataObject(dst[e], src[e]);
            } else if (typeof dst[e] != "function") {
                dst[e] = src[e];
            }
        }
        return dst;
    }
    Services.copyDataObject = copyDataObject;
    function compareDataObjects(dst, src) {
        for(var e in dst) {
            if (typeof dst[e] == "object") {
                if (!compareDataObjects(dst[e], src[e])) {
                    return false;
                }
            } else if (typeof dst[e] != "function") {
                if (dst[e] !== src[e]) {
                    return false;
                }
            }
        }
        return true;
    }
    Services.compareDataObjects = compareDataObjects;
    var TypeScriptServicesFactory = (function () {
        function TypeScriptServicesFactory() {
            this._shims = [];
        }
        TypeScriptServicesFactory.prototype.createPullLanguageService = function (host) {
            try  {
                return new Services.LanguageService(host);
            } catch (err) {
                Services.logInternalError(host, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.createLanguageServiceShim = function (host) {
            try  {
                var hostAdapter = new Services.LanguageServiceShimHostAdapter(host);
                var pullLanguageService = this.createPullLanguageService(hostAdapter);
                return new Services.LanguageServiceShim(this, host, pullLanguageService);
            } catch (err) {
                Services.logInternalError(host, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.createClassifier = function (host) {
            try  {
                return new Services.Classifier(host);
            } catch (err) {
                Services.logInternalError(host, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.createClassifierShim = function (host) {
            try  {
                return new Services.ClassifierShim(this, host);
            } catch (err) {
                Services.logInternalError(host, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.createCoreServices = function (host) {
            try  {
                return new Services.CoreServices(host);
            } catch (err) {
                Services.logInternalError(host.logger, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.createCoreServicesShim = function (host) {
            try  {
                return new Services.CoreServicesShim(this, host);
            } catch (err) {
                Services.logInternalError(host.logger, err);
                throw err;
            }
        };
        TypeScriptServicesFactory.prototype.close = function () {
            this._shims = [];
        };
        TypeScriptServicesFactory.prototype.registerShim = function (shim) {
            this._shims.push(shim);
        };
        TypeScriptServicesFactory.prototype.unregisterShim = function (shim) {
            for(var i = 0, n = this._shims.length; i < n; i++) {
                if (this._shims[i] === shim) {
                    delete this._shims[i];
                    return;
                }
            }
            throw TypeScript.Errors.invalidOperation();
        };
        return TypeScriptServicesFactory;
    })();
    Services.TypeScriptServicesFactory = TypeScriptServicesFactory;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    var CompilerDiagnostics = (function () {
        function CompilerDiagnostics(host) {
            this.host = host;
            this.openEditTag = "<Edit>";
            this.closeEditTag = "<Edit/>";
        }
        CompilerDiagnostics.prototype.isLoggingEdits = function () {
            return (this.host.getDiagnosticsObject() !== null);
        };
        return CompilerDiagnostics;
    })();
    Services.CompilerDiagnostics = CompilerDiagnostics;    
    var DiagnosticService = (function () {
        function DiagnosticService(internal, host) {
            this.internal = internal;
            this.diagnostics = host.getDiagnosticsObject();
        }
        DiagnosticService.prototype.writeFile = function (content) {
            this.diagnostics.log(content);
        };
        DiagnosticService.prototype.refresh = function () {
            this.writeFile("refresh: " + "\n");
            this.internal.refresh();
        };
        DiagnosticService.prototype.getSyntacticDiagnostics = function (fileName) {
            var args = "fileName: " + this.stringify(fileName);
            var result = this.internal.getSyntacticDiagnostics(fileName);
            this.writeFile("getSyntacticDiagnostics: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getSemanticDiagnostics = function (fileName) {
            var args = "fileName: " + this.stringify(fileName);
            var result = this.internal.getSemanticDiagnostics(fileName);
            this.writeFile("getSemanticDiagnostics: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getCompletionsAtPosition = function (fileName, pos, isMemberCompletion) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos) + " isMemberCompletion: " + this.stringify(isMemberCompletion);
            var result = this.internal.getCompletionsAtPosition(fileName, pos, isMemberCompletion);
            this.writeFile("getCompletionsAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getTypeAtPosition = function (fileName, pos) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos);
            var result = this.internal.getTypeAtPosition(fileName, pos);
            this.writeFile("getTypeAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getNameOrDottedNameSpan = function (fileName, startPos, endPos) {
            var args = "fileName: " + this.stringify(fileName) + " startPos: " + this.stringify(startPos) + " endPos: " + this.stringify(endPos);
            var result = this.internal.getNameOrDottedNameSpan(fileName, startPos, endPos);
            this.writeFile("getNameOrDottedNameSpan: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getBreakpointStatementAtPosition = function (fileName, pos) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos);
            var result = this.internal.getBreakpointStatementAtPosition(fileName, pos);
            this.writeFile("getBreakpointStatementAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getSignatureAtPosition = function (fileName, pos) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos);
            var result = this.internal.getSignatureAtPosition(fileName, pos);
            this.writeFile("getSignatureAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getDefinitionAtPosition = function (fileName, pos) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos);
            var result = this.internal.getDefinitionAtPosition(fileName, pos);
            this.writeFile("getDefinitionAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getReferencesAtPosition = function (fileName, pos) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos);
            var result = this.internal.getReferencesAtPosition(fileName, pos);
            this.writeFile("getReferencesAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getOccurrencesAtPosition = function (fileName, pos) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos);
            var result = this.internal.getOccurrencesAtPosition(fileName, pos);
            this.writeFile("getOccurrencesAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getImplementorsAtPosition = function (fileName, pos) {
            var args = "fileName: " + this.stringify(fileName) + " pos: " + this.stringify(pos);
            var result = this.internal.getImplementorsAtPosition(fileName, pos);
            this.writeFile("getImplementorsAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getNavigateToItems = function (searchValue) {
            var args = "searchValue: " + this.stringify(searchValue);
            var result = this.internal.getNavigateToItems(searchValue);
            this.writeFile("getNavigateToItems: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getScriptLexicalStructure = function (fileName) {
            var args = "fileName: " + this.stringify(fileName);
            var result = this.internal.getScriptLexicalStructure(fileName);
            this.writeFile("getScriptLexicalStructure: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getOutliningRegions = function (fileName) {
            var args = "fileName: " + this.stringify(fileName);
            var result = this.internal.getOutliningRegions(fileName);
            this.writeFile("getOutliningRegions: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getFormattingEditsForRange = function (fileName, minChar, limChar, options) {
            var args = "fileName: " + this.stringify(fileName) + " minChar: " + this.stringify(minChar) + " limChar: " + this.stringify(limChar) + " options: " + this.stringify(options);
            var result = this.internal.getFormattingEditsForRange(fileName, minChar, limChar, options);
            this.writeFile("getFormattingEditsForRange: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getFormattingEditsForDocument = function (fileName, minChar, limChar, options) {
            var args = "fileName: " + this.stringify(fileName) + " minChar: " + this.stringify(minChar) + " limChar: " + this.stringify(limChar) + " options: " + this.stringify(options);
            var result = this.internal.getFormattingEditsForDocument(fileName, minChar, limChar, options);
            this.writeFile("getFormattingEditsForDocument: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getFormattingEditsOnPaste = function (fileName, minChar, limChar, options) {
            var args = "fileName: " + this.stringify(fileName) + " minChar: " + this.stringify(minChar) + " limChar: " + this.stringify(limChar) + " options: " + this.stringify(options);
            var result = this.internal.getFormattingEditsOnPaste(fileName, minChar, limChar, options);
            this.writeFile("getFormattingEditsOnPaste: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getFormattingEditsAfterKeystroke = function (fileName, position, key, options) {
            var args = "fileName: " + this.stringify(fileName) + " position: " + this.stringify(position) + " key: " + this.stringify(key) + " options: " + this.stringify(options);
            var result = this.internal.getFormattingEditsAfterKeystroke(fileName, position, key, options);
            this.writeFile("getFormattingEditsAfterKeystroke: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getBraceMatchingAtPosition = function (fileName, position) {
            var args = "fileName: " + this.stringify(fileName) + " position: " + this.stringify(position);
            var result = this.internal.getBraceMatchingAtPosition(fileName, position);
            this.writeFile("getBraceMatchingAtPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getSmartIndentAtLineNumber = function (fileName, position, options) {
            var args = "fileName: " + this.stringify(fileName) + " position: " + this.stringify(position) + " options: " + this.stringify(options);
            var result = this.internal.getSmartIndentAtLineNumber(fileName, position, options);
            this.writeFile("getSmartIndentAtLineNumber: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getAstPathToPosition = function (script, pos, useTrailingTriviaAsLimChar, options) {
            var args = "script: " + this.stringify(script) + " pos: " + this.stringify(pos) + " options: " + this.stringify(options);
            var result = this.internal.getAstPathToPosition(script, pos, useTrailingTriviaAsLimChar, options);
            this.writeFile("getAstPathToPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getIdentifierPathToPosition = function (script, pos) {
            var args = "script: " + this.stringify(script) + " pos: " + this.stringify(pos);
            var result = this.internal.getIdentifierPathToPosition(script, pos);
            this.writeFile("getIdentifierPathToPosition: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getSymbolTree = function () {
            var result = this.internal.getSymbolTree();
            this.writeFile("getSymbolTree: " + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.getEmitOutput = function (fileName) {
            var args = "fileName: " + this.stringify(fileName);
            var result = this.internal.getEmitOutput(fileName);
            this.writeFile("getEmitOutput: " + args + " result: " + this.stringify(result) + "\n");
            return result;
        };
        DiagnosticService.prototype.stringify = function (object) {
            var returnString = "";
            if (typeof object === 'string') {
                returnString = "\"" + object.toString().replace("\n", "\\n") + "\"";
            } else if (typeof object === 'number') {
                returnString = object.toString();
            } else if (typeof object === 'boolean') {
                returnString = object;
            } else if (typeof object !== 'function') {
                var properties = [];
                for(var key in object) {
                    if (object.hasOwnProperty(key) && typeof object[key] !== 'function') {
                        properties.push(key);
                    }
                }
                for(var i = 0; i < properties.length; i++) {
                    key = properties[i];
                    properties[i] = (typeof object[key] !== 'undefined' ? key + ": " + this.stringify(object[key]) : this.stringify(key));
                }
                returnString = "{ " + properties.toString() + " }";
            }
            return returnString;
        };
        return DiagnosticService;
    })();
    Services.DiagnosticService = DiagnosticService;    
})(Services || (Services = {}));
var Services;
(function (Services) {
    function logInternalError(logger, err) {
        logger.log("*INTERNAL ERROR* - Exception in typescript services: " + err.message);
    }
    Services.logInternalError = logInternalError;
    var ReferenceEntry = (function () {
        function ReferenceEntry(fileName, ast, isWriteAccess) {
            this.fileName = fileName;
            this.ast = ast;
            this.isWriteAccess = isWriteAccess;
        }
        ReferenceEntry.prototype.getHashCode = function () {
            return TypeScript.combineHashes(TypeScript.Hash.computeSimple31BitStringHashCode(this.fileName), TypeScript.combineHashes(TypeScript.numberHashFn(this.ast.minChar), TypeScript.numberHashFn(this.ast.limChar)));
        };
        ReferenceEntry.prototype.equals = function (other) {
            if (other === null || other === undefined) {
                return false;
            }
            return (this.fileName === other.fileName) && (this.ast.minChar === other.ast.minChar) && (this.ast.limChar === other.ast.limChar);
        };
        return ReferenceEntry;
    })();
    Services.ReferenceEntry = ReferenceEntry;    
    var NavigateToItem = (function () {
        function NavigateToItem() {
            this.name = "";
            this.kind = "";
            this.kindModifiers = "";
            this.matchKind = "";
            this.fileName = "";
            this.minChar = -1;
            this.limChar = -1;
            this.containerName = "";
            this.containerKind = "";
        }
        return NavigateToItem;
    })();
    Services.NavigateToItem = NavigateToItem;    
    var NavigateToContext = (function () {
        function NavigateToContext() {
            this.options = new TypeScript.AstWalkOptions();
            this.fileName = "";
            this.containerSymbols = [];
            this.containerKinds = [];
            this.containerASTs = [];
            this.path = new TypeScript.AstPath();
            this.result = [];
        }
        return NavigateToContext;
    })();
    Services.NavigateToContext = NavigateToContext;    
    var TextEdit = (function () {
        function TextEdit(minChar, limChar, text) {
            this.minChar = minChar;
            this.limChar = limChar;
            this.text = text;
        }
        TextEdit.createInsert = function createInsert(pos, text) {
            return new TextEdit(pos, pos, text);
        };
        TextEdit.createDelete = function createDelete(minChar, limChar) {
            return new TextEdit(minChar, limChar, "");
        };
        TextEdit.createReplace = function createReplace(minChar, limChar, text) {
            return new TextEdit(minChar, limChar, text);
        };
        return TextEdit;
    })();
    Services.TextEdit = TextEdit;    
    var EditorOptions = (function () {
        function EditorOptions() {
            this.IndentSize = 4;
            this.TabSize = 4;
            this.NewLineCharacter = "\r\n";
            this.ConvertTabsToSpaces = true;
        }
        return EditorOptions;
    })();
    Services.EditorOptions = EditorOptions;    
    var FormatCodeOptions = (function (_super) {
        __extends(FormatCodeOptions, _super);
        function FormatCodeOptions() {
            _super.apply(this, arguments);

            this.InsertSpaceAfterCommaDelimiter = true;
            this.InsertSpaceAfterSemicolonInForStatements = true;
            this.InsertSpaceBeforeAndAfterBinaryOperators = true;
            this.InsertSpaceAfterKeywordsInControlFlowStatements = true;
            this.InsertSpaceAfterFunctionKeywordForAnonymousFunctions = false;
            this.InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis = false;
            this.PlaceOpenBraceOnNewLineForFunctions = false;
            this.PlaceOpenBraceOnNewLineForControlBlocks = false;
        }
        return FormatCodeOptions;
    })(EditorOptions);
    Services.FormatCodeOptions = FormatCodeOptions;    
    var DefinitionInfo = (function () {
        function DefinitionInfo(fileName, minChar, limChar, kind, name, containerKind, containerName, overloads) {
            this.fileName = fileName;
            this.minChar = minChar;
            this.limChar = limChar;
            this.kind = kind;
            this.name = name;
            this.containerKind = containerKind;
            this.containerName = containerName;
            this.overloads = overloads;
        }
        return DefinitionInfo;
    })();
    Services.DefinitionInfo = DefinitionInfo;    
    var TypeInfo = (function () {
        function TypeInfo(memberName, docComment, fullSymbolName, kind, minChar, limChar) {
            this.memberName = memberName;
            this.docComment = docComment;
            this.fullSymbolName = fullSymbolName;
            this.kind = kind;
            this.minChar = minChar;
            this.limChar = limChar;
        }
        return TypeInfo;
    })();
    Services.TypeInfo = TypeInfo;    
    var SpanInfo = (function () {
        function SpanInfo(minChar, limChar, text) {
            if (typeof text === "undefined") { text = null; }
            this.minChar = minChar;
            this.limChar = limChar;
            this.text = text;
        }
        return SpanInfo;
    })();
    Services.SpanInfo = SpanInfo;    
    var SignatureInfo = (function () {
        function SignatureInfo() { }
        return SignatureInfo;
    })();
    Services.SignatureInfo = SignatureInfo;    
    var FormalSignatureInfo = (function () {
        function FormalSignatureInfo() {
            this.signatureGroup = [];
        }
        return FormalSignatureInfo;
    })();
    Services.FormalSignatureInfo = FormalSignatureInfo;    
    var FormalSignatureItemInfo = (function () {
        function FormalSignatureItemInfo() {
            this.parameters = [];
        }
        return FormalSignatureItemInfo;
    })();
    Services.FormalSignatureItemInfo = FormalSignatureItemInfo;    
    var FormalParameterInfo = (function () {
        function FormalParameterInfo() { }
        return FormalParameterInfo;
    })();
    Services.FormalParameterInfo = FormalParameterInfo;    
    var ActualSignatureInfo = (function () {
        function ActualSignatureInfo() {
            this.parameters = [];
        }
        return ActualSignatureInfo;
    })();
    Services.ActualSignatureInfo = ActualSignatureInfo;    
    var ActualParameterInfo = (function () {
        function ActualParameterInfo() { }
        return ActualParameterInfo;
    })();
    Services.ActualParameterInfo = ActualParameterInfo;    
    var CompletionInfo = (function () {
        function CompletionInfo() {
            this.maybeInaccurate = false;
            this.isMemberCompletion = false;
            this.entries = [];
        }
        return CompletionInfo;
    })();
    Services.CompletionInfo = CompletionInfo;    
    var CompletionEntry = (function () {
        function CompletionEntry() {
            this.name = "";
            this.type = "";
            this.kind = "";
            this.kindModifiers = "";
            this.fullSymbolName = "";
            this.docComment = "";
        }
        return CompletionEntry;
    })();
    Services.CompletionEntry = CompletionEntry;    
    var ScriptElementKind = (function () {
        function ScriptElementKind() { }
        ScriptElementKind.unknown = "";
        ScriptElementKind.keyword = "keyword";
        ScriptElementKind.scriptElement = "script";
        ScriptElementKind.moduleElement = "module";
        ScriptElementKind.classElement = "class";
        ScriptElementKind.interfaceElement = "interface";
        ScriptElementKind.enumElement = "enum";
        ScriptElementKind.variableElement = "var";
        ScriptElementKind.localVariableElement = "local var";
        ScriptElementKind.functionElement = "function";
        ScriptElementKind.localFunctionElement = "local function";
        ScriptElementKind.memberFunctionElement = "method";
        ScriptElementKind.memberGetAccessorElement = "getter";
        ScriptElementKind.memberSetAccessorElement = "setter";
        ScriptElementKind.memberVariableElement = "property";
        ScriptElementKind.constructorImplementationElement = "constructor";
        ScriptElementKind.callSignatureElement = "call";
        ScriptElementKind.indexSignatureElement = "index";
        ScriptElementKind.constructSignatureElement = "construct";
        ScriptElementKind.parameterElement = "parameter";
        ScriptElementKind.typeParameterElement = "type parameter";
        return ScriptElementKind;
    })();
    Services.ScriptElementKind = ScriptElementKind;    
    var ScriptElementKindModifier = (function () {
        function ScriptElementKindModifier() { }
        ScriptElementKindModifier.none = "";
        ScriptElementKindModifier.publicMemberModifier = "public";
        ScriptElementKindModifier.privateMemberModifier = "private";
        ScriptElementKindModifier.exportedModifier = "export";
        ScriptElementKindModifier.ambientModifier = "declare";
        ScriptElementKindModifier.staticModifier = "static";
        return ScriptElementKindModifier;
    })();
    Services.ScriptElementKindModifier = ScriptElementKindModifier;    
    var MatchKind = (function () {
        function MatchKind() { }
        MatchKind.none = null;
        MatchKind.exact = "exact";
        MatchKind.subString = "substring";
        MatchKind.prefix = "prefix";
        return MatchKind;
    })();
    Services.MatchKind = MatchKind;    
    var ScriptSyntaxASTState = (function () {
        function ScriptSyntaxASTState() {
            this.version = -1;
            this.fileName = null;
        }
        return ScriptSyntaxASTState;
    })();
    Services.ScriptSyntaxASTState = ScriptSyntaxASTState;    
})(Services || (Services = {}));
